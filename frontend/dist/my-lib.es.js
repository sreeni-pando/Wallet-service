var V_ = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var Cre = V_((Wn, Un) => {
  function Wr(e, t) {
    const n = /* @__PURE__ */ Object.create(null), o = e.split(",");
    for (let r = 0; r < o.length; r++)
      n[o[r]] = !0;
    return t ? (r) => !!n[r.toLowerCase()] : (r) => !!n[r];
  }
  const B_ = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", F_ = /* @__PURE__ */ Wr(B_);
  function Ab(e) {
    return !!e || e === "";
  }
  function Ke(e) {
    if (De(e)) {
      const t = {};
      for (let n = 0; n < e.length; n++) {
        const o = e[n], r = et(o) ? K_(o) : Ke(o);
        if (r)
          for (const s in r)
            t[s] = r[s];
      }
      return t;
    } else {
      if (et(e))
        return e;
      if (rt(e))
        return e;
    }
  }
  const H_ = /;(?![^(]*\))/g, z_ = /:(.+)/;
  function K_(e) {
    const t = {};
    return e.split(H_).forEach((n) => {
      if (n) {
        const o = n.split(z_);
        o.length > 1 && (t[o[0].trim()] = o[1].trim());
      }
    }), t;
  }
  function $(e) {
    let t = "";
    if (et(e))
      t = e;
    else if (De(e))
      for (let n = 0; n < e.length; n++) {
        const o = $(e[n]);
        o && (t += o + " ");
      }
    else if (rt(e))
      for (const n in e)
        e[n] && (t += n + " ");
    return t.trim();
  }
  function mo(e) {
    if (!e)
      return null;
    let { class: t, style: n } = e;
    return t && !et(t) && (e.class = $(t)), n && (e.style = Ke(n)), e;
  }
  const j_ = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", W_ = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", U_ = /* @__PURE__ */ Wr(j_), q_ = /* @__PURE__ */ Wr(W_);
  function Y_(e, t) {
    if (e.length !== t.length)
      return !1;
    let n = !0;
    for (let o = 0; n && o < e.length; o++)
      n = gl(e[o], t[o]);
    return n;
  }
  function gl(e, t) {
    if (e === t)
      return !0;
    let n = Ns(e), o = Ns(t);
    if (n || o)
      return n && o ? e.getTime() === t.getTime() : !1;
    if (n = ka(e), o = ka(t), n || o)
      return e === t;
    if (n = De(e), o = De(t), n || o)
      return n && o ? Y_(e, t) : !1;
    if (n = rt(e), o = rt(t), n || o) {
      if (!n || !o)
        return !1;
      const r = Object.keys(e).length, s = Object.keys(t).length;
      if (r !== s)
        return !1;
      for (const l in e) {
        const a = e.hasOwnProperty(l), u = t.hasOwnProperty(l);
        if (a && !u || !a && u || !gl(e[l], t[l]))
          return !1;
      }
    }
    return String(e) === String(t);
  }
  function Rb(e, t) {
    return e.findIndex((n) => gl(n, t));
  }
  const Ne = (e) => et(e) ? e : e == null ? "" : De(e) || rt(e) && (e.toString === Lb || !Ge(e.toString)) ? JSON.stringify(e, xb, 2) : String(e), xb = (e, t) => t && t.__v_isRef ? xb(e, t.value) : gs(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce((n, [o, r]) => (n[`${o} =>`] = r, n), {})
  } : hc(t) ? {
    [`Set(${t.size})`]: [...t.values()]
  } : rt(t) && !De(t) && !Vb(t) ? String(t) : t, Lt = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, ll = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [], Nt = () => {
  }, Db = () => !1, G_ = /^on[^a-z]/, ui = (e) => G_.test(e), Du = (e) => e.startsWith("onUpdate:"), Zt = Object.assign, Lp = (e, t) => {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1);
  }, X_ = Object.prototype.hasOwnProperty, ht = (e, t) => X_.call(e, t), De = Array.isArray, gs = (e) => ci(e) === "[object Map]", hc = (e) => ci(e) === "[object Set]", Ns = (e) => ci(e) === "[object Date]", Ge = (e) => typeof e == "function", et = (e) => typeof e == "string", ka = (e) => typeof e == "symbol", rt = (e) => e !== null && typeof e == "object", yl = (e) => rt(e) && Ge(e.then) && Ge(e.catch), Lb = Object.prototype.toString, ci = (e) => Lb.call(e), al = (e) => ci(e).slice(8, -1), Vb = (e) => ci(e) === "[object Object]", Vp = (e) => et(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, tu = /* @__PURE__ */ Wr(
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  ), J_ = /* @__PURE__ */ Wr("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"), vc = (e) => {
    const t = /* @__PURE__ */ Object.create(null);
    return (n) => t[n] || (t[n] = e(n));
  }, Z_ = /-(\w)/g, ro = vc((e) => e.replace(Z_, (t, n) => n ? n.toUpperCase() : "")), Q_ = /\B([A-Z])/g, Do = vc((e) => e.replace(Q_, "-$1").toLowerCase()), xr = vc((e) => e.charAt(0).toUpperCase() + e.slice(1)), _r = vc((e) => e ? `on${xr(e)}` : ""), $a = (e, t) => !Object.is(e, t), Ys = (e, t) => {
    for (let n = 0; n < e.length; n++)
      e[n](t);
  }, Lu = (e, t, n) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      value: n
    });
  }, Vu = (e) => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t;
  };
  let Rv;
  const Bb = () => Rv || (Rv = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
  function Bu(e, ...t) {
    console.warn(`[Vue warn] ${e}`, ...t);
  }
  let zn;
  class Fb {
    constructor(t = !1) {
      this.detached = t, this.active = !0, this.effects = [], this.cleanups = [], this.parent = zn, !t && zn && (this.index = (zn.scopes || (zn.scopes = [])).push(this) - 1);
    }
    run(t) {
      if (this.active) {
        const n = zn;
        try {
          return zn = this, t();
        } finally {
          zn = n;
        }
      } else
        process.env.NODE_ENV !== "production" && Bu("cannot run an inactive effect scope.");
    }
    on() {
      zn = this;
    }
    off() {
      zn = this.parent;
    }
    stop(t) {
      if (this.active) {
        let n, o;
        for (n = 0, o = this.effects.length; n < o; n++)
          this.effects[n].stop();
        for (n = 0, o = this.cleanups.length; n < o; n++)
          this.cleanups[n]();
        if (this.scopes)
          for (n = 0, o = this.scopes.length; n < o; n++)
            this.scopes[n].stop(!0);
        if (!this.detached && this.parent && !t) {
          const r = this.parent.scopes.pop();
          r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index);
        }
        this.parent = void 0, this.active = !1;
      }
    }
  }
  function e2(e) {
    return new Fb(e);
  }
  function t2(e, t = zn) {
    t && t.active && t.effects.push(e);
  }
  function n2() {
    return zn;
  }
  function Hb(e) {
    zn ? zn.cleanups.push(e) : process.env.NODE_ENV !== "production" && Bu("onScopeDispose() is called when there is no active effect scope to be associated with.");
  }
  const Na = (e) => {
    const t = new Set(e);
    return t.w = 0, t.n = 0, t;
  }, zb = (e) => (e.w & Dr) > 0, Kb = (e) => (e.n & Dr) > 0, o2 = ({ deps: e }) => {
    if (e.length)
      for (let t = 0; t < e.length; t++)
        e[t].w |= Dr;
  }, r2 = (e) => {
    const { deps: t } = e;
    if (t.length) {
      let n = 0;
      for (let o = 0; o < t.length; o++) {
        const r = t[o];
        zb(r) && !Kb(r) ? r.delete(e) : t[n++] = r, r.w &= ~Dr, r.n &= ~Dr;
      }
      t.length = n;
    }
  }, tf = /* @__PURE__ */ new WeakMap();
  let la = 0, Dr = 1;
  const nf = 30;
  let _n;
  const ys = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : ""), of = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
  class Bp {
    constructor(t, n = null, o) {
      this.fn = t, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, t2(this, o);
    }
    run() {
      if (!this.active)
        return this.fn();
      let t = _n, n = Pr;
      for (; t; ) {
        if (t === this)
          return;
        t = t.parent;
      }
      try {
        return this.parent = _n, _n = this, Pr = !0, Dr = 1 << ++la, la <= nf ? o2(this) : xv(this), this.fn();
      } finally {
        la <= nf && r2(this), Dr = 1 << --la, _n = this.parent, Pr = n, this.parent = void 0, this.deferStop && this.stop();
      }
    }
    stop() {
      _n === this ? this.deferStop = !0 : this.active && (xv(this), this.onStop && this.onStop(), this.active = !1);
    }
  }
  function xv(e) {
    const { deps: t } = e;
    if (t.length) {
      for (let n = 0; n < t.length; n++)
        t[n].delete(e);
      t.length = 0;
    }
  }
  let Pr = !0;
  const jb = [];
  function Rs() {
    jb.push(Pr), Pr = !1;
  }
  function xs() {
    const e = jb.pop();
    Pr = e === void 0 ? !0 : e;
  }
  function Bn(e, t, n) {
    if (Pr && _n) {
      let o = tf.get(e);
      o || tf.set(e, o = /* @__PURE__ */ new Map());
      let r = o.get(n);
      r || o.set(n, r = Na());
      const s = process.env.NODE_ENV !== "production" ? { effect: _n, target: e, type: t, key: n } : void 0;
      rf(r, s);
    }
  }
  function rf(e, t) {
    let n = !1;
    la <= nf ? Kb(e) || (e.n |= Dr, n = !zb(e)) : n = !e.has(_n), n && (e.add(_n), _n.deps.push(e), process.env.NODE_ENV !== "production" && _n.onTrack && _n.onTrack(Object.assign({ effect: _n }, t)));
  }
  function sr(e, t, n, o, r, s) {
    const l = tf.get(e);
    if (!l)
      return;
    let a = [];
    if (t === "clear")
      a = [...l.values()];
    else if (n === "length" && De(e))
      l.forEach((c, f) => {
        (f === "length" || f >= o) && a.push(c);
      });
    else
      switch (n !== void 0 && a.push(l.get(n)), t) {
        case "add":
          De(e) ? Vp(n) && a.push(l.get("length")) : (a.push(l.get(ys)), gs(e) && a.push(l.get(of)));
          break;
        case "delete":
          De(e) || (a.push(l.get(ys)), gs(e) && a.push(l.get(of)));
          break;
        case "set":
          gs(e) && a.push(l.get(ys));
          break;
      }
    const u = process.env.NODE_ENV !== "production" ? { target: e, type: t, key: n, newValue: o, oldValue: r, oldTarget: s } : void 0;
    if (a.length === 1)
      a[0] && (process.env.NODE_ENV !== "production" ? el(a[0], u) : el(a[0]));
    else {
      const c = [];
      for (const f of a)
        f && c.push(...f);
      process.env.NODE_ENV !== "production" ? el(Na(c), u) : el(Na(c));
    }
  }
  function el(e, t) {
    const n = De(e) ? e : [...e];
    for (const o of n)
      o.computed && Dv(o, t);
    for (const o of n)
      o.computed || Dv(o, t);
  }
  function Dv(e, t) {
    (e !== _n || e.allowRecurse) && (process.env.NODE_ENV !== "production" && e.onTrigger && e.onTrigger(Zt({ effect: e }, t)), e.scheduler ? e.scheduler() : e.run());
  }
  const s2 = /* @__PURE__ */ Wr("__proto__,__v_isRef,__isVue"), Wb = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(ka)
  ), l2 = /* @__PURE__ */ mc(), a2 = /* @__PURE__ */ mc(!1, !0), i2 = /* @__PURE__ */ mc(!0), u2 = /* @__PURE__ */ mc(!0, !0), Lv = /* @__PURE__ */ c2();
  function c2() {
    const e = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach((t) => {
      e[t] = function(...n) {
        const o = Ct(this);
        for (let s = 0, l = this.length; s < l; s++)
          Bn(o, "get", s + "");
        const r = o[t](...n);
        return r === -1 || r === !1 ? o[t](...n.map(Ct)) : r;
      };
    }), ["push", "pop", "shift", "unshift", "splice"].forEach((t) => {
      e[t] = function(...n) {
        Rs();
        const o = Ct(this)[t].apply(this, n);
        return xs(), o;
      };
    }), e;
  }
  function mc(e = !1, t = !1) {
    return function(o, r, s) {
      if (r === "__v_isReactive")
        return !e;
      if (r === "__v_isReadonly")
        return e;
      if (r === "__v_isShallow")
        return t;
      if (r === "__v_raw" && s === (e ? t ? Qb : Zb : t ? Jb : Xb).get(o))
        return o;
      const l = De(o);
      if (!e && l && ht(Lv, r))
        return Reflect.get(Lv, r, s);
      const a = Reflect.get(o, r, s);
      return (ka(r) ? Wb.has(r) : s2(r)) || (e || Bn(o, "get", r), t) ? a : Pt(a) ? l && Vp(r) ? a : a.value : rt(a) ? e ? Fl(a) : Tt(a) : a;
    };
  }
  const d2 = /* @__PURE__ */ Ub(), f2 = /* @__PURE__ */ Ub(!0);
  function Ub(e = !1) {
    return function(n, o, r, s) {
      let l = n[o];
      if (Lr(l) && Pt(l) && !Pt(r))
        return !1;
      if (!e && (!Fu(r) && !Lr(r) && (l = Ct(l), r = Ct(r)), !De(n) && Pt(l) && !Pt(r)))
        return l.value = r, !0;
      const a = De(n) && Vp(o) ? Number(o) < n.length : ht(n, o), u = Reflect.set(n, o, r, s);
      return n === Ct(s) && (a ? $a(r, l) && sr(n, "set", o, r, l) : sr(n, "add", o, r)), u;
    };
  }
  function p2(e, t) {
    const n = ht(e, t), o = e[t], r = Reflect.deleteProperty(e, t);
    return r && n && sr(e, "delete", t, void 0, o), r;
  }
  function h2(e, t) {
    const n = Reflect.has(e, t);
    return (!ka(t) || !Wb.has(t)) && Bn(e, "has", t), n;
  }
  function v2(e) {
    return Bn(e, "iterate", De(e) ? "length" : ys), Reflect.ownKeys(e);
  }
  const qb = {
    get: l2,
    set: d2,
    deleteProperty: p2,
    has: h2,
    ownKeys: v2
  }, Yb = {
    get: i2,
    set(e, t) {
      return process.env.NODE_ENV !== "production" && Bu(`Set operation on key "${String(t)}" failed: target is readonly.`, e), !0;
    },
    deleteProperty(e, t) {
      return process.env.NODE_ENV !== "production" && Bu(`Delete operation on key "${String(t)}" failed: target is readonly.`, e), !0;
    }
  }, m2 = /* @__PURE__ */ Zt({}, qb, {
    get: a2,
    set: f2
  }), g2 = /* @__PURE__ */ Zt({}, Yb, {
    get: u2
  }), Fp = (e) => e, gc = (e) => Reflect.getPrototypeOf(e);
  function Ii(e, t, n = !1, o = !1) {
    e = e.__v_raw;
    const r = Ct(e), s = Ct(t);
    n || (t !== s && Bn(r, "get", t), Bn(r, "get", s));
    const { has: l } = gc(r), a = o ? Fp : n ? Hp : Ta;
    if (l.call(r, t))
      return a(e.get(t));
    if (l.call(r, s))
      return a(e.get(s));
    e !== r && e.get(t);
  }
  function Pi(e, t = !1) {
    const n = this.__v_raw, o = Ct(n), r = Ct(e);
    return t || (e !== r && Bn(o, "has", e), Bn(o, "has", r)), e === r ? n.has(e) : n.has(e) || n.has(r);
  }
  function Ai(e, t = !1) {
    return e = e.__v_raw, !t && Bn(Ct(e), "iterate", ys), Reflect.get(e, "size", e);
  }
  function Vv(e) {
    e = Ct(e);
    const t = Ct(this);
    return gc(t).has.call(t, e) || (t.add(e), sr(t, "add", e, e)), this;
  }
  function Bv(e, t) {
    t = Ct(t);
    const n = Ct(this), { has: o, get: r } = gc(n);
    let s = o.call(n, e);
    s ? process.env.NODE_ENV !== "production" && Gb(n, o, e) : (e = Ct(e), s = o.call(n, e));
    const l = r.call(n, e);
    return n.set(e, t), s ? $a(t, l) && sr(n, "set", e, t, l) : sr(n, "add", e, t), this;
  }
  function Fv(e) {
    const t = Ct(this), { has: n, get: o } = gc(t);
    let r = n.call(t, e);
    r ? process.env.NODE_ENV !== "production" && Gb(t, n, e) : (e = Ct(e), r = n.call(t, e));
    const s = o ? o.call(t, e) : void 0, l = t.delete(e);
    return r && sr(t, "delete", e, void 0, s), l;
  }
  function Hv() {
    const e = Ct(this), t = e.size !== 0, n = process.env.NODE_ENV !== "production" ? gs(e) ? new Map(e) : new Set(e) : void 0, o = e.clear();
    return t && sr(e, "clear", void 0, void 0, n), o;
  }
  function Ri(e, t) {
    return function(o, r) {
      const s = this, l = s.__v_raw, a = Ct(l), u = t ? Fp : e ? Hp : Ta;
      return !e && Bn(a, "iterate", ys), l.forEach((c, f) => o.call(r, u(c), u(f), s));
    };
  }
  function xi(e, t, n) {
    return function(...o) {
      const r = this.__v_raw, s = Ct(r), l = gs(s), a = e === "entries" || e === Symbol.iterator && l, u = e === "keys" && l, c = r[e](...o), f = n ? Fp : t ? Hp : Ta;
      return !t && Bn(s, "iterate", u ? of : ys), {
        next() {
          const { value: d, done: p } = c.next();
          return p ? { value: d, done: p } : {
            value: a ? [f(d[0]), f(d[1])] : f(d),
            done: p
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function vr(e) {
    return function(...t) {
      if (process.env.NODE_ENV !== "production") {
        const n = t[0] ? `on key "${t[0]}" ` : "";
        console.warn(`${xr(e)} operation ${n}failed: target is readonly.`, Ct(this));
      }
      return e === "delete" ? !1 : this;
    };
  }
  function y2() {
    const e = {
      get(s) {
        return Ii(this, s);
      },
      get size() {
        return Ai(this);
      },
      has: Pi,
      add: Vv,
      set: Bv,
      delete: Fv,
      clear: Hv,
      forEach: Ri(!1, !1)
    }, t = {
      get(s) {
        return Ii(this, s, !1, !0);
      },
      get size() {
        return Ai(this);
      },
      has: Pi,
      add: Vv,
      set: Bv,
      delete: Fv,
      clear: Hv,
      forEach: Ri(!1, !0)
    }, n = {
      get(s) {
        return Ii(this, s, !0);
      },
      get size() {
        return Ai(this, !0);
      },
      has(s) {
        return Pi.call(this, s, !0);
      },
      add: vr("add"),
      set: vr("set"),
      delete: vr("delete"),
      clear: vr("clear"),
      forEach: Ri(!0, !1)
    }, o = {
      get(s) {
        return Ii(this, s, !0, !0);
      },
      get size() {
        return Ai(this, !0);
      },
      has(s) {
        return Pi.call(this, s, !0);
      },
      add: vr("add"),
      set: vr("set"),
      delete: vr("delete"),
      clear: vr("clear"),
      forEach: Ri(!0, !0)
    };
    return ["keys", "values", "entries", Symbol.iterator].forEach((s) => {
      e[s] = xi(s, !1, !1), n[s] = xi(s, !0, !1), t[s] = xi(s, !1, !0), o[s] = xi(s, !0, !0);
    }), [
      e,
      n,
      t,
      o
    ];
  }
  const [b2, w2, C2, E2] = /* @__PURE__ */ y2();
  function yc(e, t) {
    const n = t ? e ? E2 : C2 : e ? w2 : b2;
    return (o, r, s) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? o : Reflect.get(ht(n, r) && r in o ? n : o, r, s);
  }
  const S2 = {
    get: /* @__PURE__ */ yc(!1, !1)
  }, _2 = {
    get: /* @__PURE__ */ yc(!1, !0)
  }, k2 = {
    get: /* @__PURE__ */ yc(!0, !1)
  }, $2 = {
    get: /* @__PURE__ */ yc(!0, !0)
  };
  function Gb(e, t, n) {
    const o = Ct(n);
    if (o !== n && t.call(e, o)) {
      const r = al(e);
      console.warn(`Reactive ${r} contains both the raw and reactive versions of the same object${r === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  const Xb = /* @__PURE__ */ new WeakMap(), Jb = /* @__PURE__ */ new WeakMap(), Zb = /* @__PURE__ */ new WeakMap(), Qb = /* @__PURE__ */ new WeakMap();
  function N2(e) {
    switch (e) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function T2(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : N2(al(e));
  }
  function Tt(e) {
    return Lr(e) ? e : bc(e, !1, qb, S2, Xb);
  }
  function e0(e) {
    return bc(e, !1, m2, _2, Jb);
  }
  function Fl(e) {
    return bc(e, !0, Yb, k2, Zb);
  }
  function tl(e) {
    return bc(e, !0, g2, $2, Qb);
  }
  function bc(e, t, n, o, r) {
    if (!rt(e))
      return process.env.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(e)}`), e;
    if (e.__v_raw && !(t && e.__v_isReactive))
      return e;
    const s = r.get(e);
    if (s)
      return s;
    const l = T2(e);
    if (l === 0)
      return e;
    const a = new Proxy(e, l === 2 ? o : n);
    return r.set(e, a), a;
  }
  function bs(e) {
    return Lr(e) ? bs(e.__v_raw) : !!(e && e.__v_isReactive);
  }
  function Lr(e) {
    return !!(e && e.__v_isReadonly);
  }
  function Fu(e) {
    return !!(e && e.__v_isShallow);
  }
  function Hu(e) {
    return bs(e) || Lr(e);
  }
  function Ct(e) {
    const t = e && e.__v_raw;
    return t ? Ct(t) : e;
  }
  function ws(e) {
    return Lu(e, "__v_skip", !0), e;
  }
  const Ta = (e) => rt(e) ? Tt(e) : e, Hp = (e) => rt(e) ? Fl(e) : e;
  function t0(e) {
    Pr && _n && (e = Ct(e), process.env.NODE_ENV !== "production" ? rf(e.dep || (e.dep = Na()), {
      target: e,
      type: "get",
      key: "value"
    }) : rf(e.dep || (e.dep = Na())));
  }
  function zp(e, t) {
    e = Ct(e), e.dep && (process.env.NODE_ENV !== "production" ? el(e.dep, {
      target: e,
      type: "set",
      key: "value",
      newValue: t
    }) : el(e.dep));
  }
  function Pt(e) {
    return !!(e && e.__v_isRef === !0);
  }
  function I(e) {
    return n0(e, !1);
  }
  function xt(e) {
    return n0(e, !0);
  }
  function n0(e, t) {
    return Pt(e) ? e : new O2(e, t);
  }
  class O2 {
    constructor(t, n) {
      this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? t : Ct(t), this._value = n ? t : Ta(t);
    }
    get value() {
      return t0(this), this._value;
    }
    set value(t) {
      const n = this.__v_isShallow || Fu(t) || Lr(t);
      t = n ? t : Ct(t), $a(t, this._rawValue) && (this._rawValue = t, this._value = n ? t : Ta(t), zp(this, t));
    }
  }
  function Yl(e) {
    zp(e, process.env.NODE_ENV !== "production" ? e.value : void 0);
  }
  function i(e) {
    return Pt(e) ? e.value : e;
  }
  const M2 = {
    get: (e, t, n) => i(Reflect.get(e, t, n)),
    set: (e, t, n, o) => {
      const r = e[t];
      return Pt(r) && !Pt(n) ? (r.value = n, !0) : Reflect.set(e, t, n, o);
    }
  };
  function o0(e) {
    return bs(e) ? e : new Proxy(e, M2);
  }
  function rn(e) {
    process.env.NODE_ENV !== "production" && !Hu(e) && console.warn("toRefs() expects a reactive object but received a plain one.");
    const t = De(e) ? new Array(e.length) : {};
    for (const n in e)
      t[n] = Ht(e, n);
    return t;
  }
  class I2 {
    constructor(t, n, o) {
      this._object = t, this._key = n, this._defaultValue = o, this.__v_isRef = !0;
    }
    get value() {
      const t = this._object[this._key];
      return t === void 0 ? this._defaultValue : t;
    }
    set value(t) {
      this._object[this._key] = t;
    }
  }
  function Ht(e, t, n) {
    const o = e[t];
    return Pt(o) ? o : new I2(e, t, n);
  }
  var r0;
  class P2 {
    constructor(t, n, o, r) {
      this._setter = n, this.dep = void 0, this.__v_isRef = !0, this[r0] = !1, this._dirty = !0, this.effect = new Bp(t, () => {
        this._dirty || (this._dirty = !0, zp(this));
      }), this.effect.computed = this, this.effect.active = this._cacheable = !r, this.__v_isReadonly = o;
    }
    get value() {
      const t = Ct(this);
      return t0(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value;
    }
    set value(t) {
      this._setter(t);
    }
  }
  r0 = "__v_isReadonly";
  function s0(e, t, n = !1) {
    let o, r;
    const s = Ge(e);
    s ? (o = e, r = process.env.NODE_ENV !== "production" ? () => {
      console.warn("Write operation failed: computed value is readonly");
    } : Nt) : (o = e.get, r = e.set);
    const l = new P2(o, r, s || !r, n);
    return process.env.NODE_ENV !== "production" && t && !n && (l.effect.onTrack = t.onTrack, l.effect.onTrigger = t.onTrigger), l;
  }
  const Cs = [];
  function nu(e) {
    Cs.push(e);
  }
  function ou() {
    Cs.pop();
  }
  function Ue(e, ...t) {
    Rs();
    const n = Cs.length ? Cs[Cs.length - 1].component : null, o = n && n.appContext.config.warnHandler, r = A2();
    if (o)
      nr(o, n, 11, [
        e + t.join(""),
        n && n.proxy,
        r.map(({ vnode: s }) => `at <${Oc(n, s.type)}>`).join(`
`),
        r
      ]);
    else {
      const s = [`[Vue warn]: ${e}`, ...t];
      r.length && s.push(`
`, ...R2(r)), console.warn(...s);
    }
    xs();
  }
  function A2() {
    let e = Cs[Cs.length - 1];
    if (!e)
      return [];
    const t = [];
    for (; e; ) {
      const n = t[0];
      n && n.vnode === e ? n.recurseCount++ : t.push({
        vnode: e,
        recurseCount: 0
      });
      const o = e.component && e.component.parent;
      e = o && o.vnode;
    }
    return t;
  }
  function R2(e) {
    const t = [];
    return e.forEach((n, o) => {
      t.push(...o === 0 ? [] : [`
`], ...x2(n));
    }), t;
  }
  function x2({ vnode: e, recurseCount: t }) {
    const n = t > 0 ? `... (${t} recursive calls)` : "", o = e.component ? e.component.parent == null : !1, r = ` at <${Oc(e.component, e.type, o)}`, s = ">" + n;
    return e.props ? [r, ...D2(e.props), s] : [r + s];
  }
  function D2(e) {
    const t = [], n = Object.keys(e);
    return n.slice(0, 3).forEach((o) => {
      t.push(...l0(o, e[o]));
    }), n.length > 3 && t.push(" ..."), t;
  }
  function l0(e, t, n) {
    return et(t) ? (t = JSON.stringify(t), n ? t : [`${e}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? n ? t : [`${e}=${t}`] : Pt(t) ? (t = l0(e, Ct(t.value), !0), n ? t : [`${e}=Ref<`, t, ">"]) : Ge(t) ? [`${e}=fn${t.name ? `<${t.name}>` : ""}`] : (t = Ct(t), n ? t : [`${e}=`, t]);
  }
  const Kp = {
    sp: "serverPrefetch hook",
    bc: "beforeCreate hook",
    c: "created hook",
    bm: "beforeMount hook",
    m: "mounted hook",
    bu: "beforeUpdate hook",
    u: "updated",
    bum: "beforeUnmount hook",
    um: "unmounted hook",
    a: "activated hook",
    da: "deactivated hook",
    ec: "errorCaptured hook",
    rtc: "renderTracked hook",
    rtg: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
  };
  function nr(e, t, n, o) {
    let r;
    try {
      r = o ? e(...o) : e();
    } catch (s) {
      wc(s, t, n);
    }
    return r;
  }
  function to(e, t, n, o) {
    if (Ge(e)) {
      const s = nr(e, t, n, o);
      return s && yl(s) && s.catch((l) => {
        wc(l, t, n);
      }), s;
    }
    const r = [];
    for (let s = 0; s < e.length; s++)
      r.push(to(e[s], t, n, o));
    return r;
  }
  function wc(e, t, n, o = !0) {
    const r = t ? t.vnode : null;
    if (t) {
      let s = t.parent;
      const l = t.proxy, a = process.env.NODE_ENV !== "production" ? Kp[n] : n;
      for (; s; ) {
        const c = s.ec;
        if (c) {
          for (let f = 0; f < c.length; f++)
            if (c[f](e, l, a) === !1)
              return;
        }
        s = s.parent;
      }
      const u = t.appContext.config.errorHandler;
      if (u) {
        nr(u, null, 10, [e, l, a]);
        return;
      }
    }
    L2(e, n, r, o);
  }
  function L2(e, t, n, o = !0) {
    if (process.env.NODE_ENV !== "production") {
      const r = Kp[t];
      if (n && nu(n), Ue(`Unhandled error${r ? ` during execution of ${r}` : ""}`), n && ou(), o)
        throw e;
      console.error(e);
    } else
      console.error(e);
  }
  let Oa = !1, sf = !1;
  const bn = [];
  let Mo = 0;
  const il = [];
  let Oo = null, kr = 0;
  const a0 = /* @__PURE__ */ Promise.resolve();
  let jp = null;
  const V2 = 100;
  function Fe(e) {
    const t = jp || a0;
    return e ? t.then(this ? e.bind(this) : e) : t;
  }
  function B2(e) {
    let t = Mo + 1, n = bn.length;
    for (; t < n; ) {
      const o = t + n >>> 1;
      Ma(bn[o]) < e ? t = o + 1 : n = o;
    }
    return t;
  }
  function Cc(e) {
    (!bn.length || !bn.includes(e, Oa && e.allowRecurse ? Mo + 1 : Mo)) && (e.id == null ? bn.push(e) : bn.splice(B2(e.id), 0, e), i0());
  }
  function i0() {
    !Oa && !sf && (sf = !0, jp = a0.then(d0));
  }
  function F2(e) {
    const t = bn.indexOf(e);
    t > Mo && bn.splice(t, 1);
  }
  function u0(e) {
    De(e) ? il.push(...e) : (!Oo || !Oo.includes(e, e.allowRecurse ? kr + 1 : kr)) && il.push(e), i0();
  }
  function zv(e, t = Oa ? Mo + 1 : 0) {
    for (process.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()); t < bn.length; t++) {
      const n = bn[t];
      if (n && n.pre) {
        if (process.env.NODE_ENV !== "production" && Wp(e, n))
          continue;
        bn.splice(t, 1), t--, n();
      }
    }
  }
  function c0(e) {
    if (il.length) {
      const t = [...new Set(il)];
      if (il.length = 0, Oo) {
        Oo.push(...t);
        return;
      }
      for (Oo = t, process.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()), Oo.sort((n, o) => Ma(n) - Ma(o)), kr = 0; kr < Oo.length; kr++)
        process.env.NODE_ENV !== "production" && Wp(e, Oo[kr]) || Oo[kr]();
      Oo = null, kr = 0;
    }
  }
  const Ma = (e) => e.id == null ? 1 / 0 : e.id, H2 = (e, t) => {
    const n = Ma(e) - Ma(t);
    if (n === 0) {
      if (e.pre && !t.pre)
        return -1;
      if (t.pre && !e.pre)
        return 1;
    }
    return n;
  };
  function d0(e) {
    sf = !1, Oa = !0, process.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()), bn.sort(H2);
    const t = process.env.NODE_ENV !== "production" ? (n) => Wp(e, n) : Nt;
    try {
      for (Mo = 0; Mo < bn.length; Mo++) {
        const n = bn[Mo];
        if (n && n.active !== !1) {
          if (process.env.NODE_ENV !== "production" && t(n))
            continue;
          nr(n, null, 14);
        }
      }
    } finally {
      Mo = 0, bn.length = 0, c0(e), Oa = !1, jp = null, (bn.length || il.length) && d0(e);
    }
  }
  function Wp(e, t) {
    if (!e.has(t))
      e.set(t, 1);
    else {
      const n = e.get(t);
      if (n > V2) {
        const o = t.ownerInstance, r = o && eh(o.type);
        return Ue(`Maximum recursive updates exceeded${r ? ` in component <${r}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`), !0;
      } else
        e.set(t, n + 1);
    }
  }
  let Ar = !1;
  const Gs = /* @__PURE__ */ new Set();
  process.env.NODE_ENV !== "production" && (Bb().__VUE_HMR_RUNTIME__ = {
    createRecord: pd(f0),
    rerender: pd(j2),
    reload: pd(W2)
  });
  const Ts = /* @__PURE__ */ new Map();
  function z2(e) {
    const t = e.type.__hmrId;
    let n = Ts.get(t);
    n || (f0(t, e.type), n = Ts.get(t)), n.instances.add(e);
  }
  function K2(e) {
    Ts.get(e.type.__hmrId).instances.delete(e);
  }
  function f0(e, t) {
    return Ts.has(e) ? !1 : (Ts.set(e, {
      initialDef: ca(t),
      instances: /* @__PURE__ */ new Set()
    }), !0);
  }
  function ca(e) {
    return W0(e) ? e.__vccOpts : e;
  }
  function j2(e, t) {
    const n = Ts.get(e);
    !n || (n.initialDef.render = t, [...n.instances].forEach((o) => {
      t && (o.render = t, ca(o.type).render = t), o.renderCache = [], Ar = !0, o.update(), Ar = !1;
    }));
  }
  function W2(e, t) {
    const n = Ts.get(e);
    if (!n)
      return;
    t = ca(t), Kv(n.initialDef, t);
    const o = [...n.instances];
    for (const r of o) {
      const s = ca(r.type);
      Gs.has(s) || (s !== n.initialDef && Kv(s, t), Gs.add(s)), r.appContext.optionsCache.delete(r.type), r.ceReload ? (Gs.add(s), r.ceReload(t.styles), Gs.delete(s)) : r.parent ? (Cc(r.parent.update), r.parent.type.__asyncLoader && r.parent.ceReload && r.parent.ceReload(t.styles)) : r.appContext.reload ? r.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
    u0(() => {
      for (const r of o)
        Gs.delete(ca(r.type));
    });
  }
  function Kv(e, t) {
    Zt(e, t);
    for (const n in e)
      n !== "__file" && !(n in t) && delete e[n];
  }
  function pd(e) {
    return (t, n) => {
      try {
        return e(t, n);
      } catch (o) {
        console.error(o), console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.");
      }
    };
  }
  let Io, aa = [], lf = !1;
  function di(e, ...t) {
    Io ? Io.emit(e, ...t) : lf || aa.push({ event: e, args: t });
  }
  function p0(e, t) {
    var n, o;
    Io = e, Io ? (Io.enabled = !0, aa.forEach(({ event: r, args: s }) => Io.emit(r, ...s)), aa = []) : typeof window < "u" && window.HTMLElement && !(!((o = (n = window.navigator) === null || n === void 0 ? void 0 : n.userAgent) === null || o === void 0) && o.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((s) => {
      p0(s, t);
    }), setTimeout(() => {
      Io || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, lf = !0, aa = []);
    }, 3e3)) : (lf = !0, aa = []);
  }
  function U2(e, t) {
    di("app:init", e, t, {
      Fragment: ze,
      Text: Hl,
      Comment: en,
      Static: ru
    });
  }
  function q2(e) {
    di("app:unmount", e);
  }
  const Y2 = /* @__PURE__ */ Up("component:added"), h0 = /* @__PURE__ */ Up("component:updated"), G2 = /* @__PURE__ */ Up("component:removed"), X2 = (e) => {
    Io && typeof Io.cleanupBuffer == "function" && !Io.cleanupBuffer(e) && G2(e);
  };
  function Up(e) {
    return (t) => {
      di(e, t.appContext.app, t.uid, t.parent ? t.parent.uid : void 0, t);
    };
  }
  const J2 = /* @__PURE__ */ v0("perf:start"), Z2 = /* @__PURE__ */ v0("perf:end");
  function v0(e) {
    return (t, n, o) => {
      di(e, t.appContext.app, t.uid, t, n, o);
    };
  }
  function Q2(e, t, n) {
    di("component:emit", e.appContext.app, e, t, n);
  }
  function ek(e, t, ...n) {
    if (e.isUnmounted)
      return;
    const o = e.vnode.props || Lt;
    if (process.env.NODE_ENV !== "production") {
      const { emitsOptions: f, propsOptions: [d] } = e;
      if (f)
        if (!(t in f))
          (!d || !(_r(t) in d)) && Ue(`Component emitted event "${t}" but it is neither declared in the emits option nor as an "${_r(t)}" prop.`);
        else {
          const p = f[t];
          Ge(p) && (p(...n) || Ue(`Invalid event arguments: event validation failed for event "${t}".`));
        }
    }
    let r = n;
    const s = t.startsWith("update:"), l = s && t.slice(7);
    if (l && l in o) {
      const f = `${l === "modelValue" ? "model" : l}Modifiers`, { number: d, trim: p } = o[f] || Lt;
      p && (r = n.map((h) => h.trim())), d && (r = n.map(Vu));
    }
    if (process.env.NODE_ENV !== "production" && Q2(e, t, r), process.env.NODE_ENV !== "production") {
      const f = t.toLowerCase();
      f !== t && o[_r(f)] && Ue(`Event "${f}" is emitted in component ${Oc(e, e.type)} but the handler is registered for "${t}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Do(t)}" instead of "${t}".`);
    }
    let a, u = o[a = _r(t)] || o[a = _r(ro(t))];
    !u && s && (u = o[a = _r(Do(t))]), u && to(u, e, 6, r);
    const c = o[a + "Once"];
    if (c) {
      if (!e.emitted)
        e.emitted = {};
      else if (e.emitted[a])
        return;
      e.emitted[a] = !0, to(c, e, 6, r);
    }
  }
  function m0(e, t, n = !1) {
    const o = t.emitsCache, r = o.get(e);
    if (r !== void 0)
      return r;
    const s = e.emits;
    let l = {}, a = !1;
    if (!Ge(e)) {
      const u = (c) => {
        const f = m0(c, t, !0);
        f && (a = !0, Zt(l, f));
      };
      !n && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u);
    }
    return !s && !a ? (rt(e) && o.set(e, null), null) : (De(s) ? s.forEach((u) => l[u] = null) : Zt(l, s), rt(e) && o.set(e, l), l);
  }
  function Ec(e, t) {
    return !e || !ui(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), ht(e, t[0].toLowerCase() + t.slice(1)) || ht(e, Do(t)) || ht(e, t));
  }
  let fn = null, Sc = null;
  function zu(e) {
    const t = fn;
    return fn = e, Sc = e && e.type.__scopeId || null, t;
  }
  function tk(e) {
    Sc = e;
  }
  function nk() {
    Sc = null;
  }
  function X(e, t = fn, n) {
    if (!t || e._n)
      return e;
    const o = (...r) => {
      o._d && om(-1);
      const s = zu(t);
      let l;
      try {
        l = e(...r);
      } finally {
        zu(s), o._d && om(1);
      }
      return process.env.NODE_ENV !== "production" && h0(t), l;
    };
    return o._n = !0, o._c = !0, o._d = !0, o;
  }
  let af = !1;
  function Ku() {
    af = !0;
  }
  function hd(e) {
    const { type: t, vnode: n, proxy: o, withProxy: r, props: s, propsOptions: [l], slots: a, attrs: u, emit: c, render: f, renderCache: d, data: p, setupState: h, ctx: m, inheritAttrs: v } = e;
    let g, y;
    const w = zu(e);
    process.env.NODE_ENV !== "production" && (af = !1);
    try {
      if (n.shapeFlag & 4) {
        const _ = r || o;
        g = ho(f.call(_, _, d, s, h, p, m)), y = u;
      } else {
        const _ = t;
        process.env.NODE_ENV !== "production" && u === s && Ku(), g = ho(_.length > 1 ? _(s, process.env.NODE_ENV !== "production" ? {
          get attrs() {
            return Ku(), u;
          },
          slots: a,
          emit: c
        } : { attrs: u, slots: a, emit: c }) : _(s, null)), y = t.props ? u : rk(u);
      }
    } catch (_) {
      pa.length = 0, wc(_, e, 1), g = K(en);
    }
    let b = g, C;
    if (process.env.NODE_ENV !== "production" && g.patchFlag > 0 && g.patchFlag & 2048 && ([b, C] = ok(g)), y && v !== !1) {
      const _ = Object.keys(y), { shapeFlag: k } = b;
      if (_.length) {
        if (k & 7)
          l && _.some(Du) && (y = sk(y, l)), b = Eo(b, y);
        else if (process.env.NODE_ENV !== "production" && !af && b.type !== en) {
          const O = Object.keys(u), T = [], P = [];
          for (let A = 0, L = O.length; A < L; A++) {
            const D = O[A];
            ui(D) ? Du(D) || T.push(D[2].toLowerCase() + D.slice(3)) : P.push(D);
          }
          P.length && Ue(`Extraneous non-props attributes (${P.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`), T.length && Ue(`Extraneous non-emits event listeners (${T.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
        }
      }
    }
    return n.dirs && (process.env.NODE_ENV !== "production" && !jv(b) && Ue("Runtime directive used on component with non-element root node. The directives will not function as intended."), b = Eo(b), b.dirs = b.dirs ? b.dirs.concat(n.dirs) : n.dirs), n.transition && (process.env.NODE_ENV !== "production" && !jv(b) && Ue("Component inside <Transition> renders non-element root node that cannot be animated."), b.transition = n.transition), process.env.NODE_ENV !== "production" && C ? C(b) : g = b, zu(w), g;
  }
  const ok = (e) => {
    const t = e.children, n = e.dynamicChildren, o = g0(t);
    if (!o)
      return [e, void 0];
    const r = t.indexOf(o), s = n ? n.indexOf(o) : -1, l = (a) => {
      t[r] = a, n && (s > -1 ? n[s] = a : a.patchFlag > 0 && (e.dynamicChildren = [...n, a]));
    };
    return [ho(o), l];
  };
  function g0(e) {
    let t;
    for (let n = 0; n < e.length; n++) {
      const o = e[n];
      if (Bt(o)) {
        if (o.type !== en || o.children === "v-if") {
          if (t)
            return;
          t = o;
        }
      } else
        return;
    }
    return t;
  }
  const rk = (e) => {
    let t;
    for (const n in e)
      (n === "class" || n === "style" || ui(n)) && ((t || (t = {}))[n] = e[n]);
    return t;
  }, sk = (e, t) => {
    const n = {};
    for (const o in e)
      (!Du(o) || !(o.slice(9) in t)) && (n[o] = e[o]);
    return n;
  }, jv = (e) => e.shapeFlag & 7 || e.type === en;
  function lk(e, t, n) {
    const { props: o, children: r, component: s } = e, { props: l, children: a, patchFlag: u } = t, c = s.emitsOptions;
    if (process.env.NODE_ENV !== "production" && (r || a) && Ar || t.dirs || t.transition)
      return !0;
    if (n && u >= 0) {
      if (u & 1024)
        return !0;
      if (u & 16)
        return o ? Wv(o, l, c) : !!l;
      if (u & 8) {
        const f = t.dynamicProps;
        for (let d = 0; d < f.length; d++) {
          const p = f[d];
          if (l[p] !== o[p] && !Ec(c, p))
            return !0;
        }
      }
    } else
      return (r || a) && (!a || !a.$stable) ? !0 : o === l ? !1 : o ? l ? Wv(o, l, c) : !0 : !!l;
    return !1;
  }
  function Wv(e, t, n) {
    const o = Object.keys(t);
    if (o.length !== Object.keys(e).length)
      return !0;
    for (let r = 0; r < o.length; r++) {
      const s = o[r];
      if (t[s] !== e[s] && !Ec(n, s))
        return !0;
    }
    return !1;
  }
  function ak({ vnode: e, parent: t }, n) {
    for (; t && t.subTree === e; )
      (e = t.vnode).el = n, t = t.parent;
  }
  const ik = (e) => e.__isSuspense;
  function uk(e, t) {
    t && t.pendingBranch ? De(e) ? t.effects.push(...e) : t.effects.push(e) : u0(e);
  }
  function pt(e, t) {
    if (!an)
      process.env.NODE_ENV !== "production" && Ue("provide() can only be used inside setup().");
    else {
      let n = an.provides;
      const o = an.parent && an.parent.provides;
      o === n && (n = an.provides = Object.create(o)), n[e] = t;
    }
  }
  function Be(e, t, n = !1) {
    const o = an || fn;
    if (o) {
      const r = o.parent == null ? o.vnode.appContext && o.vnode.appContext.provides : o.parent.provides;
      if (r && e in r)
        return r[e];
      if (arguments.length > 1)
        return n && Ge(t) ? t.call(o.proxy) : t;
      process.env.NODE_ENV !== "production" && Ue(`injection "${String(e)}" not found.`);
    } else
      process.env.NODE_ENV !== "production" && Ue("inject() can only be used inside setup() or functional components.");
  }
  function xn(e, t) {
    return qp(e, null, t);
  }
  const Uv = {};
  function me(e, t, n) {
    return process.env.NODE_ENV !== "production" && !Ge(t) && Ue("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."), qp(e, t, n);
  }
  function qp(e, t, { immediate: n, deep: o, flush: r, onTrack: s, onTrigger: l } = Lt) {
    process.env.NODE_ENV !== "production" && !t && (n !== void 0 && Ue('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'), o !== void 0 && Ue('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'));
    const a = (w) => {
      Ue("Invalid watch source: ", w, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.");
    }, u = an;
    let c, f = !1, d = !1;
    if (Pt(e) ? (c = () => e.value, f = Fu(e)) : bs(e) ? (c = () => e, o = !0) : De(e) ? (d = !0, f = e.some((w) => bs(w) || Fu(w)), c = () => e.map((w) => {
      if (Pt(w))
        return w.value;
      if (bs(w))
        return cs(w);
      if (Ge(w))
        return nr(w, u, 2);
      process.env.NODE_ENV !== "production" && a(w);
    })) : Ge(e) ? t ? c = () => nr(e, u, 2) : c = () => {
      if (!(u && u.isUnmounted))
        return p && p(), to(e, u, 3, [h]);
    } : (c = Nt, process.env.NODE_ENV !== "production" && a(e)), t && o) {
      const w = c;
      c = () => cs(w());
    }
    let p, h = (w) => {
      p = y.onStop = () => {
        nr(w, u, 4);
      };
    };
    if (xa)
      return h = Nt, t ? n && to(t, u, 3, [
        c(),
        d ? [] : void 0,
        h
      ]) : c(), Nt;
    let m = d ? [] : Uv;
    const v = () => {
      if (!!y.active)
        if (t) {
          const w = y.run();
          (o || f || (d ? w.some((b, C) => $a(b, m[C])) : $a(w, m))) && (p && p(), to(t, u, 3, [
            w,
            m === Uv ? void 0 : m,
            h
          ]), m = w);
        } else
          y.run();
    };
    v.allowRecurse = !!t;
    let g;
    r === "sync" ? g = v : r === "post" ? g = () => Rn(v, u && u.suspense) : (v.pre = !0, u && (v.id = u.uid), g = () => Cc(v));
    const y = new Bp(c, g);
    return process.env.NODE_ENV !== "production" && (y.onTrack = s, y.onTrigger = l), t ? n ? v() : m = y.run() : r === "post" ? Rn(y.run.bind(y), u && u.suspense) : y.run(), () => {
      y.stop(), u && u.scope && Lp(u.scope.effects, y);
    };
  }
  function ck(e, t, n) {
    const o = this.proxy, r = et(e) ? e.includes(".") ? y0(o, e) : () => o[e] : e.bind(o, o);
    let s;
    Ge(t) ? s = t : (s = t.handler, n = t);
    const l = an;
    wl(this);
    const a = qp(r, s.bind(o), n);
    return l ? wl(l) : Es(), a;
  }
  function y0(e, t) {
    const n = t.split(".");
    return () => {
      let o = e;
      for (let r = 0; r < n.length && o; r++)
        o = o[n[r]];
      return o;
    };
  }
  function cs(e, t) {
    if (!rt(e) || e.__v_skip || (t = t || /* @__PURE__ */ new Set(), t.has(e)))
      return e;
    if (t.add(e), Pt(e))
      cs(e.value, t);
    else if (De(e))
      for (let n = 0; n < e.length; n++)
        cs(e[n], t);
    else if (hc(e) || gs(e))
      e.forEach((n) => {
        cs(n, t);
      });
    else if (Vb(e))
      for (const n in e)
        cs(e[n], t);
    return e;
  }
  function b0() {
    const e = {
      isMounted: !1,
      isLeaving: !1,
      isUnmounting: !1,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    return st(() => {
      e.isMounted = !0;
    }), zt(() => {
      e.isUnmounting = !0;
    }), e;
  }
  const Jn = [Function, Array], dk = {
    name: "BaseTransition",
    props: {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      onBeforeEnter: Jn,
      onEnter: Jn,
      onAfterEnter: Jn,
      onEnterCancelled: Jn,
      onBeforeLeave: Jn,
      onLeave: Jn,
      onAfterLeave: Jn,
      onLeaveCancelled: Jn,
      onBeforeAppear: Jn,
      onAppear: Jn,
      onAfterAppear: Jn,
      onAppearCancelled: Jn
    },
    setup(e, { slots: t }) {
      const n = it(), o = b0();
      let r;
      return () => {
        const s = t.default && Yp(t.default(), !0);
        if (!s || !s.length)
          return;
        let l = s[0];
        if (s.length > 1) {
          let v = !1;
          for (const g of s)
            if (g.type !== en) {
              if (process.env.NODE_ENV !== "production" && v) {
                Ue("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
                break;
              }
              if (l = g, v = !0, process.env.NODE_ENV === "production")
                break;
            }
        }
        const a = Ct(e), { mode: u } = a;
        if (process.env.NODE_ENV !== "production" && u && u !== "in-out" && u !== "out-in" && u !== "default" && Ue(`invalid <transition> mode: ${u}`), o.isLeaving)
          return vd(l);
        const c = qv(l);
        if (!c)
          return vd(l);
        const f = Ia(c, a, o, n);
        Pa(c, f);
        const d = n.subTree, p = d && qv(d);
        let h = !1;
        const { getTransitionKey: m } = c.type;
        if (m) {
          const v = m();
          r === void 0 ? r = v : v !== r && (r = v, h = !0);
        }
        if (p && p.type !== en && (!ls(c, p) || h)) {
          const v = Ia(p, a, o, n);
          if (Pa(p, v), u === "out-in")
            return o.isLeaving = !0, v.afterLeave = () => {
              o.isLeaving = !1, n.update();
            }, vd(l);
          u === "in-out" && c.type !== en && (v.delayLeave = (g, y, w) => {
            const b = C0(o, p);
            b[String(p.key)] = p, g._leaveCb = () => {
              y(), g._leaveCb = void 0, delete f.delayedLeave;
            }, f.delayedLeave = w;
          });
        }
        return l;
      };
    }
  }, w0 = dk;
  function C0(e, t) {
    const { leavingVNodes: n } = e;
    let o = n.get(t.type);
    return o || (o = /* @__PURE__ */ Object.create(null), n.set(t.type, o)), o;
  }
  function Ia(e, t, n, o) {
    const { appear: r, mode: s, persisted: l = !1, onBeforeEnter: a, onEnter: u, onAfterEnter: c, onEnterCancelled: f, onBeforeLeave: d, onLeave: p, onAfterLeave: h, onLeaveCancelled: m, onBeforeAppear: v, onAppear: g, onAfterAppear: y, onAppearCancelled: w } = t, b = String(e.key), C = C0(n, e), _ = (T, P) => {
      T && to(T, o, 9, P);
    }, k = (T, P) => {
      const A = P[1];
      _(T, P), De(T) ? T.every((L) => L.length <= 1) && A() : T.length <= 1 && A();
    }, O = {
      mode: s,
      persisted: l,
      beforeEnter(T) {
        let P = a;
        if (!n.isMounted)
          if (r)
            P = v || a;
          else
            return;
        T._leaveCb && T._leaveCb(!0);
        const A = C[b];
        A && ls(e, A) && A.el._leaveCb && A.el._leaveCb(), _(P, [T]);
      },
      enter(T) {
        let P = u, A = c, L = f;
        if (!n.isMounted)
          if (r)
            P = g || u, A = y || c, L = w || f;
          else
            return;
        let D = !1;
        const B = T._enterCb = (F) => {
          D || (D = !0, F ? _(L, [T]) : _(A, [T]), O.delayedLeave && O.delayedLeave(), T._enterCb = void 0);
        };
        P ? k(P, [T, B]) : B();
      },
      leave(T, P) {
        const A = String(e.key);
        if (T._enterCb && T._enterCb(!0), n.isUnmounting)
          return P();
        _(d, [T]);
        let L = !1;
        const D = T._leaveCb = (B) => {
          L || (L = !0, P(), B ? _(m, [T]) : _(h, [T]), T._leaveCb = void 0, C[A] === e && delete C[A]);
        };
        C[A] = e, p ? k(p, [T, D]) : D();
      },
      clone(T) {
        return Ia(T, t, n, o);
      }
    };
    return O;
  }
  function vd(e) {
    if (fi(e))
      return e = Eo(e), e.children = null, e;
  }
  function qv(e) {
    return fi(e) ? e.children ? e.children[0] : void 0 : e;
  }
  function Pa(e, t) {
    e.shapeFlag & 6 && e.component ? Pa(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
  }
  function Yp(e, t = !1, n) {
    let o = [], r = 0;
    for (let s = 0; s < e.length; s++) {
      let l = e[s];
      const a = n == null ? l.key : String(n) + String(l.key != null ? l.key : s);
      l.type === ze ? (l.patchFlag & 128 && r++, o = o.concat(Yp(l.children, t, a))) : (t || l.type !== en) && o.push(a != null ? Eo(l, { key: a }) : l);
    }
    if (r > 1)
      for (let s = 0; s < o.length; s++)
        o[s].patchFlag = -2;
    return o;
  }
  function G(e) {
    return Ge(e) ? { setup: e, name: e.name } : e;
  }
  const da = (e) => !!e.type.__asyncLoader, fi = (e) => e.type.__isKeepAlive;
  function fk(e, t) {
    S0(e, "a", t);
  }
  function E0(e, t) {
    S0(e, "da", t);
  }
  function S0(e, t, n = an) {
    const o = e.__wdc || (e.__wdc = () => {
      let r = n;
      for (; r; ) {
        if (r.isDeactivated)
          return;
        r = r.parent;
      }
      return e();
    });
    if (_c(t, o, n), n) {
      let r = n.parent;
      for (; r && r.parent; )
        fi(r.parent.vnode) && pk(o, t, n, r), r = r.parent;
    }
  }
  function pk(e, t, n, o) {
    const r = _c(t, e, o, !0);
    Ur(() => {
      Lp(o[t], r);
    }, n);
  }
  function _c(e, t, n = an, o = !1) {
    if (n) {
      const r = n[e] || (n[e] = []), s = t.__weh || (t.__weh = (...l) => {
        if (n.isUnmounted)
          return;
        Rs(), wl(n);
        const a = to(t, n, e, l);
        return Es(), xs(), a;
      });
      return o ? r.unshift(s) : r.push(s), s;
    } else if (process.env.NODE_ENV !== "production") {
      const r = _r(Kp[e].replace(/ hook$/, ""));
      Ue(`${r} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
    }
  }
  const ur = (e) => (t, n = an) => (!xa || e === "sp") && _c(e, (...o) => t(...o), n), kc = ur("bm"), st = ur("m"), _0 = ur("bu"), cr = ur("u"), zt = ur("bum"), Ur = ur("um"), hk = ur("sp"), vk = ur("rtg"), mk = ur("rtc");
  function gk(e, t = an) {
    _c("ec", e, t);
  }
  function k0(e) {
    J_(e) && Ue("Do not use built-in directive ids as custom directive id: " + e);
  }
  function ot(e, t) {
    const n = fn;
    if (n === null)
      return process.env.NODE_ENV !== "production" && Ue("withDirectives can only be used inside render functions."), e;
    const o = Tc(n) || n.proxy, r = e.dirs || (e.dirs = []);
    for (let s = 0; s < t.length; s++) {
      let [l, a, u, c = Lt] = t[s];
      Ge(l) && (l = {
        mounted: l,
        updated: l
      }), l.deep && cs(a), r.push({
        dir: l,
        instance: o,
        value: a,
        oldValue: void 0,
        arg: u,
        modifiers: c
      });
    }
    return e;
  }
  function Qr(e, t, n, o) {
    const r = e.dirs, s = t && t.dirs;
    for (let l = 0; l < r.length; l++) {
      const a = r[l];
      s && (a.oldValue = s[l].value);
      let u = a.dir[o];
      u && (Rs(), to(u, n, 8, [
        e.el,
        a,
        e,
        t
      ]), xs());
    }
  }
  const ju = "components", yk = "directives";
  function Qe(e, t) {
    return Gp(ju, e, !0, t) || e;
  }
  const $0 = Symbol();
  function vt(e) {
    return et(e) ? Gp(ju, e, !1) || e : e || $0;
  }
  function Aa(e) {
    return Gp(yk, e);
  }
  function Gp(e, t, n = !0, o = !1) {
    const r = fn || an;
    if (r) {
      const s = r.type;
      if (e === ju) {
        const a = eh(s, !1);
        if (a && (a === t || a === ro(t) || a === xr(ro(t))))
          return s;
      }
      const l = Yv(r[e] || s[e], t) || Yv(r.appContext[e], t);
      if (!l && o)
        return s;
      if (process.env.NODE_ENV !== "production" && n && !l) {
        const a = e === ju ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
        Ue(`Failed to resolve ${e.slice(0, -1)}: ${t}${a}`);
      }
      return l;
    } else
      process.env.NODE_ENV !== "production" && Ue(`resolve${xr(e.slice(0, -1))} can only be used in render() or setup().`);
  }
  function Yv(e, t) {
    return e && (e[t] || e[ro(t)] || e[xr(ro(t))]);
  }
  function gt(e, t, n, o) {
    let r;
    const s = n && n[o];
    if (De(e) || et(e)) {
      r = new Array(e.length);
      for (let l = 0, a = e.length; l < a; l++)
        r[l] = t(e[l], l, void 0, s && s[l]);
    } else if (typeof e == "number") {
      process.env.NODE_ENV !== "production" && !Number.isInteger(e) && Ue(`The v-for range expect an integer value but got ${e}.`), r = new Array(e);
      for (let l = 0; l < e; l++)
        r[l] = t(l + 1, l, void 0, s && s[l]);
    } else if (rt(e))
      if (e[Symbol.iterator])
        r = Array.from(e, (l, a) => t(l, a, void 0, s && s[a]));
      else {
        const l = Object.keys(e);
        r = new Array(l.length);
        for (let a = 0, u = l.length; a < u; a++) {
          const c = l[a];
          r[a] = t(e[c], c, a, s && s[a]);
        }
      }
    else
      r = [];
    return n && (n[o] = r), r;
  }
  function lr(e, t) {
    for (let n = 0; n < t.length; n++) {
      const o = t[n];
      if (De(o))
        for (let r = 0; r < o.length; r++)
          e[o[r].name] = o[r].fn;
      else
        o && (e[o.name] = o.key ? (...r) => {
          const s = o.fn(...r);
          return s && (s.key = o.key), s;
        } : o.fn);
    }
    return e;
  }
  function he(e, t, n = {}, o, r) {
    if (fn.isCE || fn.parent && da(fn.parent) && fn.parent.isCE)
      return K("slot", t === "default" ? null : { name: t }, o && o());
    let s = e[t];
    process.env.NODE_ENV !== "production" && s && s.length > 1 && (Ue("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."), s = () => []), s && s._c && (s._d = !1), S();
    const l = s && N0(s(n)), a = ie(ze, {
      key: n.key || l && l.key || `_${t}`
    }, l || (o ? o() : []), l && e._ === 1 ? 64 : -2);
    return !r && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), s && s._c && (s._d = !0), a;
  }
  function N0(e) {
    return e.some((t) => Bt(t) ? !(t.type === en || t.type === ze && !N0(t.children)) : !0) ? e : null;
  }
  function bk(e, t) {
    const n = {};
    if (process.env.NODE_ENV !== "production" && !rt(e))
      return Ue("v-on with no argument expects an object value."), n;
    for (const o in e)
      n[t && /[A-Z]/.test(o) ? `on:${o}` : _r(o)] = e[o];
    return n;
  }
  const uf = (e) => e ? H0(e) ? Tc(e) || e.proxy : uf(e.parent) : null, bl = /* @__PURE__ */ Zt(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => process.env.NODE_ENV !== "production" ? tl(e.props) : e.props,
    $attrs: (e) => process.env.NODE_ENV !== "production" ? tl(e.attrs) : e.attrs,
    $slots: (e) => process.env.NODE_ENV !== "production" ? tl(e.slots) : e.slots,
    $refs: (e) => process.env.NODE_ENV !== "production" ? tl(e.refs) : e.refs,
    $parent: (e) => uf(e.parent),
    $root: (e) => uf(e.root),
    $emit: (e) => e.emit,
    $options: (e) => Jp(e),
    $forceUpdate: (e) => e.f || (e.f = () => Cc(e.update)),
    $nextTick: (e) => e.n || (e.n = Fe.bind(e.proxy)),
    $watch: (e) => ck.bind(e)
  }), Xp = (e) => e === "_" || e === "$", T0 = {
    get({ _: e }, t) {
      const { ctx: n, setupState: o, data: r, props: s, accessCache: l, type: a, appContext: u } = e;
      if (process.env.NODE_ENV !== "production" && t === "__isVue")
        return !0;
      if (process.env.NODE_ENV !== "production" && o !== Lt && o.__isScriptSetup && ht(o, t))
        return o[t];
      let c;
      if (t[0] !== "$") {
        const h = l[t];
        if (h !== void 0)
          switch (h) {
            case 1:
              return o[t];
            case 2:
              return r[t];
            case 4:
              return n[t];
            case 3:
              return s[t];
          }
        else {
          if (o !== Lt && ht(o, t))
            return l[t] = 1, o[t];
          if (r !== Lt && ht(r, t))
            return l[t] = 2, r[t];
          if ((c = e.propsOptions[0]) && ht(c, t))
            return l[t] = 3, s[t];
          if (n !== Lt && ht(n, t))
            return l[t] = 4, n[t];
          cf && (l[t] = 0);
        }
      }
      const f = bl[t];
      let d, p;
      if (f)
        return t === "$attrs" && (Bn(e, "get", t), process.env.NODE_ENV !== "production" && Ku()), f(e);
      if ((d = a.__cssModules) && (d = d[t]))
        return d;
      if (n !== Lt && ht(n, t))
        return l[t] = 4, n[t];
      if (p = u.config.globalProperties, ht(p, t))
        return p[t];
      process.env.NODE_ENV !== "production" && fn && (!et(t) || t.indexOf("__v") !== 0) && (r !== Lt && Xp(t[0]) && ht(r, t) ? Ue(`Property ${JSON.stringify(t)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`) : e === fn && Ue(`Property ${JSON.stringify(t)} was accessed during render but is not defined on instance.`));
    },
    set({ _: e }, t, n) {
      const { data: o, setupState: r, ctx: s } = e;
      return r !== Lt && ht(r, t) ? (r[t] = n, !0) : o !== Lt && ht(o, t) ? (o[t] = n, !0) : ht(e.props, t) ? (process.env.NODE_ENV !== "production" && Ue(`Attempting to mutate prop "${t}". Props are readonly.`, e), !1) : t[0] === "$" && t.slice(1) in e ? (process.env.NODE_ENV !== "production" && Ue(`Attempting to mutate public property "${t}". Properties starting with $ are reserved and readonly.`, e), !1) : (process.env.NODE_ENV !== "production" && t in e.appContext.config.globalProperties ? Object.defineProperty(s, t, {
        enumerable: !0,
        configurable: !0,
        value: n
      }) : s[t] = n, !0);
    },
    has({ _: { data: e, setupState: t, accessCache: n, ctx: o, appContext: r, propsOptions: s } }, l) {
      let a;
      return !!n[l] || e !== Lt && ht(e, l) || t !== Lt && ht(t, l) || (a = s[0]) && ht(a, l) || ht(o, l) || ht(bl, l) || ht(r.config.globalProperties, l);
    },
    defineProperty(e, t, n) {
      return n.get != null ? e._.accessCache[t] = 0 : ht(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n);
    }
  };
  process.env.NODE_ENV !== "production" && (T0.ownKeys = (e) => (Ue("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."), Reflect.ownKeys(e)));
  function wk(e) {
    const t = {};
    return Object.defineProperty(t, "_", {
      configurable: !0,
      enumerable: !1,
      get: () => e
    }), Object.keys(bl).forEach((n) => {
      Object.defineProperty(t, n, {
        configurable: !0,
        enumerable: !1,
        get: () => bl[n](e),
        set: Nt
      });
    }), t;
  }
  function Ck(e) {
    const { ctx: t, propsOptions: [n] } = e;
    n && Object.keys(n).forEach((o) => {
      Object.defineProperty(t, o, {
        enumerable: !0,
        configurable: !0,
        get: () => e.props[o],
        set: Nt
      });
    });
  }
  function Ek(e) {
    const { ctx: t, setupState: n } = e;
    Object.keys(Ct(n)).forEach((o) => {
      if (!n.__isScriptSetup) {
        if (Xp(o[0])) {
          Ue(`setup() return property ${JSON.stringify(o)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
          return;
        }
        Object.defineProperty(t, o, {
          enumerable: !0,
          configurable: !0,
          get: () => n[o],
          set: Nt
        });
      }
    });
  }
  function Sk() {
    const e = /* @__PURE__ */ Object.create(null);
    return (t, n) => {
      e[n] ? Ue(`${t} property "${n}" is already defined in ${e[n]}.`) : e[n] = t;
    };
  }
  let cf = !0;
  function _k(e) {
    const t = Jp(e), n = e.proxy, o = e.ctx;
    cf = !1, t.beforeCreate && Gv(t.beforeCreate, e, "bc");
    const {
      data: r,
      computed: s,
      methods: l,
      watch: a,
      provide: u,
      inject: c,
      created: f,
      beforeMount: d,
      mounted: p,
      beforeUpdate: h,
      updated: m,
      activated: v,
      deactivated: g,
      beforeDestroy: y,
      beforeUnmount: w,
      destroyed: b,
      unmounted: C,
      render: _,
      renderTracked: k,
      renderTriggered: O,
      errorCaptured: T,
      serverPrefetch: P,
      expose: A,
      inheritAttrs: L,
      components: D,
      directives: B,
      filters: F
    } = t, W = process.env.NODE_ENV !== "production" ? Sk() : null;
    if (process.env.NODE_ENV !== "production") {
      const [N] = e.propsOptions;
      if (N)
        for (const R in N)
          W("Props", R);
    }
    if (c && kk(c, o, W, e.appContext.config.unwrapInjectedRef), l)
      for (const N in l) {
        const R = l[N];
        Ge(R) ? (process.env.NODE_ENV !== "production" ? Object.defineProperty(o, N, {
          value: R.bind(n),
          configurable: !0,
          enumerable: !0,
          writable: !0
        }) : o[N] = R.bind(n), process.env.NODE_ENV !== "production" && W("Methods", N)) : process.env.NODE_ENV !== "production" && Ue(`Method "${N}" has type "${typeof R}" in the component definition. Did you reference the function correctly?`);
      }
    if (r) {
      process.env.NODE_ENV !== "production" && !Ge(r) && Ue("The data option must be a function. Plain object usage is no longer supported.");
      const N = r.call(n, n);
      if (process.env.NODE_ENV !== "production" && yl(N) && Ue("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."), !rt(N))
        process.env.NODE_ENV !== "production" && Ue("data() should return an object.");
      else if (e.data = Tt(N), process.env.NODE_ENV !== "production")
        for (const R in N)
          W("Data", R), Xp(R[0]) || Object.defineProperty(o, R, {
            configurable: !0,
            enumerable: !0,
            get: () => N[R],
            set: Nt
          });
    }
    if (cf = !0, s)
      for (const N in s) {
        const R = s[N], M = Ge(R) ? R.bind(n, n) : Ge(R.get) ? R.get.bind(n, n) : Nt;
        process.env.NODE_ENV !== "production" && M === Nt && Ue(`Computed property "${N}" has no getter.`);
        const j = !Ge(R) && Ge(R.set) ? R.set.bind(n) : process.env.NODE_ENV !== "production" ? () => {
          Ue(`Write operation failed: computed property "${N}" is readonly.`);
        } : Nt, te = E({
          get: M,
          set: j
        });
        Object.defineProperty(o, N, {
          enumerable: !0,
          configurable: !0,
          get: () => te.value,
          set: (U) => te.value = U
        }), process.env.NODE_ENV !== "production" && W("Computed", N);
      }
    if (a)
      for (const N in a)
        O0(a[N], o, n, N);
    if (u) {
      const N = Ge(u) ? u.call(n) : u;
      Reflect.ownKeys(N).forEach((R) => {
        pt(R, N[R]);
      });
    }
    f && Gv(f, e, "c");
    function x(N, R) {
      De(R) ? R.forEach((M) => N(M.bind(n))) : R && N(R.bind(n));
    }
    if (x(kc, d), x(st, p), x(_0, h), x(cr, m), x(fk, v), x(E0, g), x(gk, T), x(mk, k), x(vk, O), x(zt, w), x(Ur, C), x(hk, P), De(A))
      if (A.length) {
        const N = e.exposed || (e.exposed = {});
        A.forEach((R) => {
          Object.defineProperty(N, R, {
            get: () => n[R],
            set: (M) => n[R] = M
          });
        });
      } else
        e.exposed || (e.exposed = {});
    _ && e.render === Nt && (e.render = _), L != null && (e.inheritAttrs = L), D && (e.components = D), B && (e.directives = B);
  }
  function kk(e, t, n = Nt, o = !1) {
    De(e) && (e = df(e));
    for (const r in e) {
      const s = e[r];
      let l;
      rt(s) ? "default" in s ? l = Be(s.from || r, s.default, !0) : l = Be(s.from || r) : l = Be(s), Pt(l) ? o ? Object.defineProperty(t, r, {
        enumerable: !0,
        configurable: !0,
        get: () => l.value,
        set: (a) => l.value = a
      }) : (process.env.NODE_ENV !== "production" && Ue(`injected property "${r}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`), t[r] = l) : t[r] = l, process.env.NODE_ENV !== "production" && n("Inject", r);
    }
  }
  function Gv(e, t, n) {
    to(De(e) ? e.map((o) => o.bind(t.proxy)) : e.bind(t.proxy), t, n);
  }
  function O0(e, t, n, o) {
    const r = o.includes(".") ? y0(n, o) : () => n[o];
    if (et(e)) {
      const s = t[e];
      Ge(s) ? me(r, s) : process.env.NODE_ENV !== "production" && Ue(`Invalid watch handler specified by key "${e}"`, s);
    } else if (Ge(e))
      me(r, e.bind(n));
    else if (rt(e))
      if (De(e))
        e.forEach((s) => O0(s, t, n, o));
      else {
        const s = Ge(e.handler) ? e.handler.bind(n) : t[e.handler];
        Ge(s) ? me(r, s, e) : process.env.NODE_ENV !== "production" && Ue(`Invalid watch handler specified by key "${e.handler}"`, s);
      }
    else
      process.env.NODE_ENV !== "production" && Ue(`Invalid watch option: "${o}"`, e);
  }
  function Jp(e) {
    const t = e.type, { mixins: n, extends: o } = t, { mixins: r, optionsCache: s, config: { optionMergeStrategies: l } } = e.appContext, a = s.get(t);
    let u;
    return a ? u = a : !r.length && !n && !o ? u = t : (u = {}, r.length && r.forEach((c) => Wu(u, c, l, !0)), Wu(u, t, l)), rt(t) && s.set(t, u), u;
  }
  function Wu(e, t, n, o = !1) {
    const { mixins: r, extends: s } = t;
    s && Wu(e, s, n, !0), r && r.forEach((l) => Wu(e, l, n, !0));
    for (const l in t)
      if (o && l === "expose")
        process.env.NODE_ENV !== "production" && Ue('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');
      else {
        const a = $k[l] || n && n[l];
        e[l] = a ? a(e[l], t[l]) : t[l];
      }
    return e;
  }
  const $k = {
    data: Xv,
    props: rs,
    emits: rs,
    methods: rs,
    computed: rs,
    beforeCreate: Sn,
    created: Sn,
    beforeMount: Sn,
    mounted: Sn,
    beforeUpdate: Sn,
    updated: Sn,
    beforeDestroy: Sn,
    beforeUnmount: Sn,
    destroyed: Sn,
    unmounted: Sn,
    activated: Sn,
    deactivated: Sn,
    errorCaptured: Sn,
    serverPrefetch: Sn,
    components: rs,
    directives: rs,
    watch: Tk,
    provide: Xv,
    inject: Nk
  };
  function Xv(e, t) {
    return t ? e ? function() {
      return Zt(Ge(e) ? e.call(this, this) : e, Ge(t) ? t.call(this, this) : t);
    } : t : e;
  }
  function Nk(e, t) {
    return rs(df(e), df(t));
  }
  function df(e) {
    if (De(e)) {
      const t = {};
      for (let n = 0; n < e.length; n++)
        t[e[n]] = e[n];
      return t;
    }
    return e;
  }
  function Sn(e, t) {
    return e ? [...new Set([].concat(e, t))] : t;
  }
  function rs(e, t) {
    return e ? Zt(Zt(/* @__PURE__ */ Object.create(null), e), t) : t;
  }
  function Tk(e, t) {
    if (!e)
      return t;
    if (!t)
      return e;
    const n = Zt(/* @__PURE__ */ Object.create(null), e);
    for (const o in t)
      n[o] = Sn(e[o], t[o]);
    return n;
  }
  function Ok(e, t, n, o = !1) {
    const r = {}, s = {};
    Lu(s, $c, 1), e.propsDefaults = /* @__PURE__ */ Object.create(null), M0(e, t, r, s);
    for (const l in e.propsOptions[0])
      l in r || (r[l] = void 0);
    process.env.NODE_ENV !== "production" && P0(t || {}, r, e), n ? e.props = o ? r : e0(r) : e.type.props ? e.props = r : e.props = s, e.attrs = s;
  }
  function Mk(e) {
    for (; e; ) {
      if (e.type.__hmrId)
        return !0;
      e = e.parent;
    }
  }
  function Ik(e, t, n, o) {
    const { props: r, attrs: s, vnode: { patchFlag: l } } = e, a = Ct(r), [u] = e.propsOptions;
    let c = !1;
    if (!(process.env.NODE_ENV !== "production" && Mk(e)) && (o || l > 0) && !(l & 16)) {
      if (l & 8) {
        const f = e.vnode.dynamicProps;
        for (let d = 0; d < f.length; d++) {
          let p = f[d];
          if (Ec(e.emitsOptions, p))
            continue;
          const h = t[p];
          if (u)
            if (ht(s, p))
              h !== s[p] && (s[p] = h, c = !0);
            else {
              const m = ro(p);
              r[m] = ff(u, a, m, h, e, !1);
            }
          else
            h !== s[p] && (s[p] = h, c = !0);
        }
      }
    } else {
      M0(e, t, r, s) && (c = !0);
      let f;
      for (const d in a)
        (!t || !ht(t, d) && ((f = Do(d)) === d || !ht(t, f))) && (u ? n && (n[d] !== void 0 || n[f] !== void 0) && (r[d] = ff(u, a, d, void 0, e, !0)) : delete r[d]);
      if (s !== a)
        for (const d in s)
          (!t || !ht(t, d) && !0) && (delete s[d], c = !0);
    }
    c && sr(e, "set", "$attrs"), process.env.NODE_ENV !== "production" && P0(t || {}, r, e);
  }
  function M0(e, t, n, o) {
    const [r, s] = e.propsOptions;
    let l = !1, a;
    if (t)
      for (let u in t) {
        if (tu(u))
          continue;
        const c = t[u];
        let f;
        r && ht(r, f = ro(u)) ? !s || !s.includes(f) ? n[f] = c : (a || (a = {}))[f] = c : Ec(e.emitsOptions, u) || (!(u in o) || c !== o[u]) && (o[u] = c, l = !0);
      }
    if (s) {
      const u = Ct(n), c = a || Lt;
      for (let f = 0; f < s.length; f++) {
        const d = s[f];
        n[d] = ff(r, u, d, c[d], e, !ht(c, d));
      }
    }
    return l;
  }
  function ff(e, t, n, o, r, s) {
    const l = e[n];
    if (l != null) {
      const a = ht(l, "default");
      if (a && o === void 0) {
        const u = l.default;
        if (l.type !== Function && Ge(u)) {
          const { propsDefaults: c } = r;
          n in c ? o = c[n] : (wl(r), o = c[n] = u.call(null, t), Es());
        } else
          o = u;
      }
      l[0] && (s && !a ? o = !1 : l[1] && (o === "" || o === Do(n)) && (o = !0));
    }
    return o;
  }
  function I0(e, t, n = !1) {
    const o = t.propsCache, r = o.get(e);
    if (r)
      return r;
    const s = e.props, l = {}, a = [];
    let u = !1;
    if (!Ge(e)) {
      const f = (d) => {
        u = !0;
        const [p, h] = I0(d, t, !0);
        Zt(l, p), h && a.push(...h);
      };
      !n && t.mixins.length && t.mixins.forEach(f), e.extends && f(e.extends), e.mixins && e.mixins.forEach(f);
    }
    if (!s && !u)
      return rt(e) && o.set(e, ll), ll;
    if (De(s))
      for (let f = 0; f < s.length; f++) {
        process.env.NODE_ENV !== "production" && !et(s[f]) && Ue("props must be strings when using array syntax.", s[f]);
        const d = ro(s[f]);
        Jv(d) && (l[d] = Lt);
      }
    else if (s) {
      process.env.NODE_ENV !== "production" && !rt(s) && Ue("invalid props options", s);
      for (const f in s) {
        const d = ro(f);
        if (Jv(d)) {
          const p = s[f], h = l[d] = De(p) || Ge(p) ? { type: p } : p;
          if (h) {
            const m = Qv(Boolean, h.type), v = Qv(String, h.type);
            h[0] = m > -1, h[1] = v < 0 || m < v, (m > -1 || ht(h, "default")) && a.push(d);
          }
        }
      }
    }
    const c = [l, a];
    return rt(e) && o.set(e, c), c;
  }
  function Jv(e) {
    return e[0] !== "$" ? !0 : (process.env.NODE_ENV !== "production" && Ue(`Invalid prop name: "${e}" is a reserved property.`), !1);
  }
  function pf(e) {
    const t = e && e.toString().match(/^\s*function (\w+)/);
    return t ? t[1] : e === null ? "null" : "";
  }
  function Zv(e, t) {
    return pf(e) === pf(t);
  }
  function Qv(e, t) {
    return De(t) ? t.findIndex((n) => Zv(n, e)) : Ge(t) && Zv(t, e) ? 0 : -1;
  }
  function P0(e, t, n) {
    const o = Ct(t), r = n.propsOptions[0];
    for (const s in r) {
      let l = r[s];
      l != null && Pk(s, o[s], l, !ht(e, s) && !ht(e, Do(s)));
    }
  }
  function Pk(e, t, n, o) {
    const { type: r, required: s, validator: l } = n;
    if (s && o) {
      Ue('Missing required prop: "' + e + '"');
      return;
    }
    if (!(t == null && !n.required)) {
      if (r != null && r !== !0) {
        let a = !1;
        const u = De(r) ? r : [r], c = [];
        for (let f = 0; f < u.length && !a; f++) {
          const { valid: d, expectedType: p } = Rk(t, u[f]);
          c.push(p || ""), a = d;
        }
        if (!a) {
          Ue(xk(e, t, c));
          return;
        }
      }
      l && !l(t) && Ue('Invalid prop: custom validator check failed for prop "' + e + '".');
    }
  }
  const Ak = /* @__PURE__ */ Wr("String,Number,Boolean,Function,Symbol,BigInt");
  function Rk(e, t) {
    let n;
    const o = pf(t);
    if (Ak(o)) {
      const r = typeof e;
      n = r === o.toLowerCase(), !n && r === "object" && (n = e instanceof t);
    } else
      o === "Object" ? n = rt(e) : o === "Array" ? n = De(e) : o === "null" ? n = e === null : n = e instanceof t;
    return {
      valid: n,
      expectedType: o
    };
  }
  function xk(e, t, n) {
    let o = `Invalid prop: type check failed for prop "${e}". Expected ${n.map(xr).join(" | ")}`;
    const r = n[0], s = al(t), l = em(t, r), a = em(t, s);
    return n.length === 1 && tm(r) && !Dk(r, s) && (o += ` with value ${l}`), o += `, got ${s} `, tm(s) && (o += `with value ${a}.`), o;
  }
  function em(e, t) {
    return t === "String" ? `"${e}"` : t === "Number" ? `${Number(e)}` : `${e}`;
  }
  function tm(e) {
    return ["string", "number", "boolean"].some((n) => e.toLowerCase() === n);
  }
  function Dk(...e) {
    return e.some((t) => t.toLowerCase() === "boolean");
  }
  const A0 = (e) => e[0] === "_" || e === "$stable", Zp = (e) => De(e) ? e.map(ho) : [ho(e)], Lk = (e, t, n) => {
    if (t._n)
      return t;
    const o = X((...r) => (process.env.NODE_ENV !== "production" && an && Ue(`Slot "${e}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`), Zp(t(...r))), n);
    return o._c = !1, o;
  }, R0 = (e, t, n) => {
    const o = e._ctx;
    for (const r in e) {
      if (A0(r))
        continue;
      const s = e[r];
      if (Ge(s))
        t[r] = Lk(r, s, o);
      else if (s != null) {
        process.env.NODE_ENV !== "production" && Ue(`Non-function value encountered for slot "${r}". Prefer function slots for better performance.`);
        const l = Zp(s);
        t[r] = () => l;
      }
    }
  }, x0 = (e, t) => {
    process.env.NODE_ENV !== "production" && !fi(e.vnode) && Ue("Non-function value encountered for default slot. Prefer function slots for better performance.");
    const n = Zp(t);
    e.slots.default = () => n;
  }, Vk = (e, t) => {
    if (e.vnode.shapeFlag & 32) {
      const n = t._;
      n ? (e.slots = Ct(t), Lu(t, "_", n)) : R0(t, e.slots = {});
    } else
      e.slots = {}, t && x0(e, t);
    Lu(e.slots, $c, 1);
  }, Bk = (e, t, n) => {
    const { vnode: o, slots: r } = e;
    let s = !0, l = Lt;
    if (o.shapeFlag & 32) {
      const a = t._;
      a ? process.env.NODE_ENV !== "production" && Ar ? Zt(r, t) : n && a === 1 ? s = !1 : (Zt(r, t), !n && a === 1 && delete r._) : (s = !t.$stable, R0(t, r)), l = t;
    } else
      t && (x0(e, t), l = { default: 1 });
    if (s)
      for (const a in r)
        !A0(a) && !(a in l) && delete r[a];
  };
  function D0() {
    return {
      app: null,
      config: {
        isNativeTag: Db,
        performance: !1,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let Fk = 0;
  function Hk(e, t) {
    return function(o, r = null) {
      Ge(o) || (o = Object.assign({}, o)), r != null && !rt(r) && (process.env.NODE_ENV !== "production" && Ue("root props passed to app.mount() must be an object."), r = null);
      const s = D0(), l = /* @__PURE__ */ new Set();
      let a = !1;
      const u = s.app = {
        _uid: Fk++,
        _component: o,
        _props: r,
        _container: null,
        _context: s,
        _instance: null,
        version: lm,
        get config() {
          return s.config;
        },
        set config(c) {
          process.env.NODE_ENV !== "production" && Ue("app.config cannot be replaced. Modify individual options instead.");
        },
        use(c, ...f) {
          return l.has(c) ? process.env.NODE_ENV !== "production" && Ue("Plugin has already been applied to target app.") : c && Ge(c.install) ? (l.add(c), c.install(u, ...f)) : Ge(c) ? (l.add(c), c(u, ...f)) : process.env.NODE_ENV !== "production" && Ue('A plugin must either be a function or an object with an "install" function.'), u;
        },
        mixin(c) {
          return s.mixins.includes(c) ? process.env.NODE_ENV !== "production" && Ue("Mixin has already been applied to target app" + (c.name ? `: ${c.name}` : "")) : s.mixins.push(c), u;
        },
        component(c, f) {
          return process.env.NODE_ENV !== "production" && mf(c, s.config), f ? (process.env.NODE_ENV !== "production" && s.components[c] && Ue(`Component "${c}" has already been registered in target app.`), s.components[c] = f, u) : s.components[c];
        },
        directive(c, f) {
          return process.env.NODE_ENV !== "production" && k0(c), f ? (process.env.NODE_ENV !== "production" && s.directives[c] && Ue(`Directive "${c}" has already been registered in target app.`), s.directives[c] = f, u) : s.directives[c];
        },
        mount(c, f, d) {
          if (a)
            process.env.NODE_ENV !== "production" && Ue("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`");
          else {
            process.env.NODE_ENV !== "production" && c.__vue_app__ && Ue("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.");
            const p = K(o, r);
            return p.appContext = s, process.env.NODE_ENV !== "production" && (s.reload = () => {
              e(Eo(p), c, d);
            }), f && t ? t(p, c) : e(p, c, d), a = !0, u._container = c, c.__vue_app__ = u, process.env.NODE_ENV !== "production" && (u._instance = p.component, U2(u, lm)), Tc(p.component) || p.component.proxy;
          }
        },
        unmount() {
          a ? (e(null, u._container), process.env.NODE_ENV !== "production" && (u._instance = null, q2(u)), delete u._container.__vue_app__) : process.env.NODE_ENV !== "production" && Ue("Cannot unmount an app that is not mounted.");
        },
        provide(c, f) {
          return process.env.NODE_ENV !== "production" && c in s.provides && Ue(`App already provides property with key "${String(c)}". It will be overwritten with the new value.`), s.provides[c] = f, u;
        }
      };
      return u;
    };
  }
  function hf(e, t, n, o, r = !1) {
    if (De(e)) {
      e.forEach((p, h) => hf(p, t && (De(t) ? t[h] : t), n, o, r));
      return;
    }
    if (da(o) && !r)
      return;
    const s = o.shapeFlag & 4 ? Tc(o.component) || o.component.proxy : o.el, l = r ? null : s, { i: a, r: u } = e;
    if (process.env.NODE_ENV !== "production" && !a) {
      Ue("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");
      return;
    }
    const c = t && t.r, f = a.refs === Lt ? a.refs = {} : a.refs, d = a.setupState;
    if (c != null && c !== u && (et(c) ? (f[c] = null, ht(d, c) && (d[c] = null)) : Pt(c) && (c.value = null)), Ge(u))
      nr(u, a, 12, [l, f]);
    else {
      const p = et(u), h = Pt(u);
      if (p || h) {
        const m = () => {
          if (e.f) {
            const v = p ? ht(d, u) ? d[u] : f[u] : u.value;
            r ? De(v) && Lp(v, s) : De(v) ? v.includes(s) || v.push(s) : p ? (f[u] = [s], ht(d, u) && (d[u] = f[u])) : (u.value = [s], e.k && (f[e.k] = u.value));
          } else
            p ? (f[u] = l, ht(d, u) && (d[u] = l)) : h ? (u.value = l, e.k && (f[e.k] = l)) : process.env.NODE_ENV !== "production" && Ue("Invalid template ref type:", u, `(${typeof u})`);
        };
        l ? (m.id = -1, Rn(m, n)) : m();
      } else
        process.env.NODE_ENV !== "production" && Ue("Invalid template ref type:", u, `(${typeof u})`);
    }
  }
  let Gl, Tr;
  function qo(e, t) {
    e.appContext.config.performance && Uu() && Tr.mark(`vue-${t}-${e.uid}`), process.env.NODE_ENV !== "production" && J2(e, t, Uu() ? Tr.now() : Date.now());
  }
  function Yo(e, t) {
    if (e.appContext.config.performance && Uu()) {
      const n = `vue-${t}-${e.uid}`, o = n + ":end";
      Tr.mark(o), Tr.measure(`<${Oc(e, e.type)}> ${t}`, n, o), Tr.clearMarks(n), Tr.clearMarks(o);
    }
    process.env.NODE_ENV !== "production" && Z2(e, t, Uu() ? Tr.now() : Date.now());
  }
  function Uu() {
    return Gl !== void 0 || (typeof window < "u" && window.performance ? (Gl = !0, Tr = window.performance) : Gl = !1), Gl;
  }
  function zk() {
    const e = [];
    if (process.env.NODE_ENV !== "production" && e.length) {
      const t = e.length > 1;
      console.warn(`Feature flag${t ? "s" : ""} ${e.join(", ")} ${t ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
    }
  }
  const Rn = uk;
  function Kk(e) {
    return jk(e);
  }
  function jk(e, t) {
    zk();
    const n = Bb();
    n.__VUE__ = !0, process.env.NODE_ENV !== "production" && p0(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);
    const { insert: o, remove: r, patchProp: s, createElement: l, createText: a, createComment: u, setText: c, setElementText: f, parentNode: d, nextSibling: p, setScopeId: h = Nt, insertStaticContent: m } = e, v = (z, Q, de, Oe = null, ae = null, Ee = null, we = !1, Se = null, _e = process.env.NODE_ENV !== "production" && Ar ? !1 : !!Q.dynamicChildren) => {
      if (z === Q)
        return;
      z && !ls(z, Q) && (Oe = Y(z), Z(z, ae, Ee, !0), z = null), Q.patchFlag === -2 && (_e = !1, Q.dynamicChildren = null);
      const { type: ke, ref: Re, shapeFlag: fe } = Q;
      switch (ke) {
        case Hl:
          g(z, Q, de, Oe);
          break;
        case en:
          y(z, Q, de, Oe);
          break;
        case ru:
          z == null ? w(Q, de, Oe, we) : process.env.NODE_ENV !== "production" && b(z, Q, de, we);
          break;
        case ze:
          B(z, Q, de, Oe, ae, Ee, we, Se, _e);
          break;
        default:
          fe & 1 ? k(z, Q, de, Oe, ae, Ee, we, Se, _e) : fe & 6 ? F(z, Q, de, Oe, ae, Ee, we, Se, _e) : fe & 64 || fe & 128 ? ke.process(z, Q, de, Oe, ae, Ee, we, Se, _e, ce) : process.env.NODE_ENV !== "production" && Ue("Invalid VNode type:", ke, `(${typeof ke})`);
      }
      Re != null && ae && hf(Re, z && z.ref, Ee, Q || z, !Q);
    }, g = (z, Q, de, Oe) => {
      if (z == null)
        o(Q.el = a(Q.children), de, Oe);
      else {
        const ae = Q.el = z.el;
        Q.children !== z.children && c(ae, Q.children);
      }
    }, y = (z, Q, de, Oe) => {
      z == null ? o(Q.el = u(Q.children || ""), de, Oe) : Q.el = z.el;
    }, w = (z, Q, de, Oe) => {
      [z.el, z.anchor] = m(z.children, Q, de, Oe, z.el, z.anchor);
    }, b = (z, Q, de, Oe) => {
      if (Q.children !== z.children) {
        const ae = p(z.anchor);
        _(z), [Q.el, Q.anchor] = m(Q.children, de, ae, Oe);
      } else
        Q.el = z.el, Q.anchor = z.anchor;
    }, C = ({ el: z, anchor: Q }, de, Oe) => {
      let ae;
      for (; z && z !== Q; )
        ae = p(z), o(z, de, Oe), z = ae;
      o(Q, de, Oe);
    }, _ = ({ el: z, anchor: Q }) => {
      let de;
      for (; z && z !== Q; )
        de = p(z), r(z), z = de;
      r(Q);
    }, k = (z, Q, de, Oe, ae, Ee, we, Se, _e) => {
      we = we || Q.type === "svg", z == null ? O(Q, de, Oe, ae, Ee, we, Se, _e) : A(z, Q, ae, Ee, we, Se, _e);
    }, O = (z, Q, de, Oe, ae, Ee, we, Se) => {
      let _e, ke;
      const { type: Re, props: fe, shapeFlag: Ae, transition: qe, dirs: tt } = z;
      if (_e = z.el = l(z.type, Ee, fe && fe.is, fe), Ae & 8 ? f(_e, z.children) : Ae & 16 && P(z.children, _e, null, Oe, ae, Ee && Re !== "foreignObject", we, Se), tt && Qr(z, null, Oe, "created"), fe) {
        for (const ye in fe)
          ye !== "value" && !tu(ye) && s(_e, ye, null, fe[ye], Ee, z.children, Oe, ae, ne);
        "value" in fe && s(_e, "value", null, fe.value), (ke = fe.onVnodeBeforeMount) && To(ke, Oe, z);
      }
      T(_e, z, z.scopeId, we, Oe), process.env.NODE_ENV !== "production" && (Object.defineProperty(_e, "__vnode", {
        value: z,
        enumerable: !1
      }), Object.defineProperty(_e, "__vueParentComponent", {
        value: Oe,
        enumerable: !1
      })), tt && Qr(z, null, Oe, "beforeMount");
      const Je = (!ae || ae && !ae.pendingBranch) && qe && !qe.persisted;
      Je && qe.beforeEnter(_e), o(_e, Q, de), ((ke = fe && fe.onVnodeMounted) || Je || tt) && Rn(() => {
        ke && To(ke, Oe, z), Je && qe.enter(_e), tt && Qr(z, null, Oe, "mounted");
      }, ae);
    }, T = (z, Q, de, Oe, ae) => {
      if (de && h(z, de), Oe)
        for (let Ee = 0; Ee < Oe.length; Ee++)
          h(z, Oe[Ee]);
      if (ae) {
        let Ee = ae.subTree;
        if (process.env.NODE_ENV !== "production" && Ee.patchFlag > 0 && Ee.patchFlag & 2048 && (Ee = g0(Ee.children) || Ee), Q === Ee) {
          const we = ae.vnode;
          T(z, we, we.scopeId, we.slotScopeIds, ae.parent);
        }
      }
    }, P = (z, Q, de, Oe, ae, Ee, we, Se, _e = 0) => {
      for (let ke = _e; ke < z.length; ke++) {
        const Re = z[ke] = Se ? $r(z[ke]) : ho(z[ke]);
        v(null, Re, Q, de, Oe, ae, Ee, we, Se);
      }
    }, A = (z, Q, de, Oe, ae, Ee, we) => {
      const Se = Q.el = z.el;
      let { patchFlag: _e, dynamicChildren: ke, dirs: Re } = Q;
      _e |= z.patchFlag & 16;
      const fe = z.props || Lt, Ae = Q.props || Lt;
      let qe;
      de && es(de, !1), (qe = Ae.onVnodeBeforeUpdate) && To(qe, de, Q, z), Re && Qr(Q, z, de, "beforeUpdate"), de && es(de, !0), process.env.NODE_ENV !== "production" && Ar && (_e = 0, we = !1, ke = null);
      const tt = ae && Q.type !== "foreignObject";
      if (ke ? (L(z.dynamicChildren, ke, Se, de, Oe, tt, Ee), process.env.NODE_ENV !== "production" && de && de.type.__hmrId && fa(z, Q)) : we || M(z, Q, Se, null, de, Oe, tt, Ee, !1), _e > 0) {
        if (_e & 16)
          D(Se, Q, fe, Ae, de, Oe, ae);
        else if (_e & 2 && fe.class !== Ae.class && s(Se, "class", null, Ae.class, ae), _e & 4 && s(Se, "style", fe.style, Ae.style, ae), _e & 8) {
          const Je = Q.dynamicProps;
          for (let ye = 0; ye < Je.length; ye++) {
            const Ce = Je[ye], ue = fe[Ce], q = Ae[Ce];
            (q !== ue || Ce === "value") && s(Se, Ce, ue, q, ae, z.children, de, Oe, ne);
          }
        }
        _e & 1 && z.children !== Q.children && f(Se, Q.children);
      } else
        !we && ke == null && D(Se, Q, fe, Ae, de, Oe, ae);
      ((qe = Ae.onVnodeUpdated) || Re) && Rn(() => {
        qe && To(qe, de, Q, z), Re && Qr(Q, z, de, "updated");
      }, Oe);
    }, L = (z, Q, de, Oe, ae, Ee, we) => {
      for (let Se = 0; Se < Q.length; Se++) {
        const _e = z[Se], ke = Q[Se], Re = _e.el && (_e.type === ze || !ls(_e, ke) || _e.shapeFlag & 70) ? d(_e.el) : de;
        v(_e, ke, Re, null, Oe, ae, Ee, we, !0);
      }
    }, D = (z, Q, de, Oe, ae, Ee, we) => {
      if (de !== Oe) {
        if (de !== Lt)
          for (const Se in de)
            !tu(Se) && !(Se in Oe) && s(z, Se, de[Se], null, we, Q.children, ae, Ee, ne);
        for (const Se in Oe) {
          if (tu(Se))
            continue;
          const _e = Oe[Se], ke = de[Se];
          _e !== ke && Se !== "value" && s(z, Se, ke, _e, we, Q.children, ae, Ee, ne);
        }
        "value" in Oe && s(z, "value", de.value, Oe.value);
      }
    }, B = (z, Q, de, Oe, ae, Ee, we, Se, _e) => {
      const ke = Q.el = z ? z.el : a(""), Re = Q.anchor = z ? z.anchor : a("");
      let { patchFlag: fe, dynamicChildren: Ae, slotScopeIds: qe } = Q;
      process.env.NODE_ENV !== "production" && (Ar || fe & 2048) && (fe = 0, _e = !1, Ae = null), qe && (Se = Se ? Se.concat(qe) : qe), z == null ? (o(ke, de, Oe), o(Re, de, Oe), P(Q.children, de, Re, ae, Ee, we, Se, _e)) : fe > 0 && fe & 64 && Ae && z.dynamicChildren ? (L(z.dynamicChildren, Ae, de, ae, Ee, we, Se), process.env.NODE_ENV !== "production" && ae && ae.type.__hmrId ? fa(z, Q) : (Q.key != null || ae && Q === ae.subTree) && fa(z, Q, !0)) : M(z, Q, de, Re, ae, Ee, we, Se, _e);
    }, F = (z, Q, de, Oe, ae, Ee, we, Se, _e) => {
      Q.slotScopeIds = Se, z == null ? Q.shapeFlag & 512 ? ae.ctx.activate(Q, de, Oe, we, _e) : W(Q, de, Oe, ae, Ee, we, _e) : x(z, Q, _e);
    }, W = (z, Q, de, Oe, ae, Ee, we) => {
      const Se = z.component = Qk(z, Oe, ae);
      if (process.env.NODE_ENV !== "production" && Se.type.__hmrId && z2(Se), process.env.NODE_ENV !== "production" && (nu(z), qo(Se, "mount")), fi(z) && (Se.ctx.renderer = ce), process.env.NODE_ENV !== "production" && qo(Se, "init"), t$(Se), process.env.NODE_ENV !== "production" && Yo(Se, "init"), Se.asyncDep) {
        if (ae && ae.registerDep(Se, N), !z.el) {
          const _e = Se.subTree = K(en);
          y(null, _e, Q, de);
        }
        return;
      }
      N(Se, z, Q, de, ae, Ee, we), process.env.NODE_ENV !== "production" && (ou(), Yo(Se, "mount"));
    }, x = (z, Q, de) => {
      const Oe = Q.component = z.component;
      if (lk(z, Q, de))
        if (Oe.asyncDep && !Oe.asyncResolved) {
          process.env.NODE_ENV !== "production" && nu(Q), R(Oe, Q, de), process.env.NODE_ENV !== "production" && ou();
          return;
        } else
          Oe.next = Q, F2(Oe.update), Oe.update();
      else
        Q.el = z.el, Oe.vnode = Q;
    }, N = (z, Q, de, Oe, ae, Ee, we) => {
      const Se = () => {
        if (z.isMounted) {
          let { next: Re, bu: fe, u: Ae, parent: qe, vnode: tt } = z, Je = Re, ye;
          process.env.NODE_ENV !== "production" && nu(Re || z.vnode), es(z, !1), Re ? (Re.el = tt.el, R(z, Re, we)) : Re = tt, fe && Ys(fe), (ye = Re.props && Re.props.onVnodeBeforeUpdate) && To(ye, qe, Re, tt), es(z, !0), process.env.NODE_ENV !== "production" && qo(z, "render");
          const Ce = hd(z);
          process.env.NODE_ENV !== "production" && Yo(z, "render");
          const ue = z.subTree;
          z.subTree = Ce, process.env.NODE_ENV !== "production" && qo(z, "patch"), v(
            ue,
            Ce,
            d(ue.el),
            Y(ue),
            z,
            ae,
            Ee
          ), process.env.NODE_ENV !== "production" && Yo(z, "patch"), Re.el = Ce.el, Je === null && ak(z, Ce.el), Ae && Rn(Ae, ae), (ye = Re.props && Re.props.onVnodeUpdated) && Rn(() => To(ye, qe, Re, tt), ae), process.env.NODE_ENV !== "production" && h0(z), process.env.NODE_ENV !== "production" && ou();
        } else {
          let Re;
          const { el: fe, props: Ae } = Q, { bm: qe, m: tt, parent: Je } = z, ye = da(Q);
          if (es(z, !1), qe && Ys(qe), !ye && (Re = Ae && Ae.onVnodeBeforeMount) && To(Re, Je, Q), es(z, !0), fe && Pe) {
            const Ce = () => {
              process.env.NODE_ENV !== "production" && qo(z, "render"), z.subTree = hd(z), process.env.NODE_ENV !== "production" && Yo(z, "render"), process.env.NODE_ENV !== "production" && qo(z, "hydrate"), Pe(fe, z.subTree, z, ae, null), process.env.NODE_ENV !== "production" && Yo(z, "hydrate");
            };
            ye ? Q.type.__asyncLoader().then(
              () => !z.isUnmounted && Ce()
            ) : Ce();
          } else {
            process.env.NODE_ENV !== "production" && qo(z, "render");
            const Ce = z.subTree = hd(z);
            process.env.NODE_ENV !== "production" && Yo(z, "render"), process.env.NODE_ENV !== "production" && qo(z, "patch"), v(null, Ce, de, Oe, z, ae, Ee), process.env.NODE_ENV !== "production" && Yo(z, "patch"), Q.el = Ce.el;
          }
          if (tt && Rn(tt, ae), !ye && (Re = Ae && Ae.onVnodeMounted)) {
            const Ce = Q;
            Rn(() => To(Re, Je, Ce), ae);
          }
          (Q.shapeFlag & 256 || Je && da(Je.vnode) && Je.vnode.shapeFlag & 256) && z.a && Rn(z.a, ae), z.isMounted = !0, process.env.NODE_ENV !== "production" && Y2(z), Q = de = Oe = null;
        }
      }, _e = z.effect = new Bp(
        Se,
        () => Cc(ke),
        z.scope
      ), ke = z.update = () => _e.run();
      ke.id = z.uid, es(z, !0), process.env.NODE_ENV !== "production" && (_e.onTrack = z.rtc ? (Re) => Ys(z.rtc, Re) : void 0, _e.onTrigger = z.rtg ? (Re) => Ys(z.rtg, Re) : void 0, ke.ownerInstance = z), ke();
    }, R = (z, Q, de) => {
      Q.component = z;
      const Oe = z.vnode.props;
      z.vnode = Q, z.next = null, Ik(z, Q.props, Oe, de), Bk(z, Q.children, de), Rs(), zv(), xs();
    }, M = (z, Q, de, Oe, ae, Ee, we, Se, _e = !1) => {
      const ke = z && z.children, Re = z ? z.shapeFlag : 0, fe = Q.children, { patchFlag: Ae, shapeFlag: qe } = Q;
      if (Ae > 0) {
        if (Ae & 128) {
          te(ke, fe, de, Oe, ae, Ee, we, Se, _e);
          return;
        } else if (Ae & 256) {
          j(ke, fe, de, Oe, ae, Ee, we, Se, _e);
          return;
        }
      }
      qe & 8 ? (Re & 16 && ne(ke, ae, Ee), fe !== ke && f(de, fe)) : Re & 16 ? qe & 16 ? te(ke, fe, de, Oe, ae, Ee, we, Se, _e) : ne(ke, ae, Ee, !0) : (Re & 8 && f(de, ""), qe & 16 && P(fe, de, Oe, ae, Ee, we, Se, _e));
    }, j = (z, Q, de, Oe, ae, Ee, we, Se, _e) => {
      z = z || ll, Q = Q || ll;
      const ke = z.length, Re = Q.length, fe = Math.min(ke, Re);
      let Ae;
      for (Ae = 0; Ae < fe; Ae++) {
        const qe = Q[Ae] = _e ? $r(Q[Ae]) : ho(Q[Ae]);
        v(z[Ae], qe, de, null, ae, Ee, we, Se, _e);
      }
      ke > Re ? ne(z, ae, Ee, !0, !1, fe) : P(Q, de, Oe, ae, Ee, we, Se, _e, fe);
    }, te = (z, Q, de, Oe, ae, Ee, we, Se, _e) => {
      let ke = 0;
      const Re = Q.length;
      let fe = z.length - 1, Ae = Re - 1;
      for (; ke <= fe && ke <= Ae; ) {
        const qe = z[ke], tt = Q[ke] = _e ? $r(Q[ke]) : ho(Q[ke]);
        if (ls(qe, tt))
          v(qe, tt, de, null, ae, Ee, we, Se, _e);
        else
          break;
        ke++;
      }
      for (; ke <= fe && ke <= Ae; ) {
        const qe = z[fe], tt = Q[Ae] = _e ? $r(Q[Ae]) : ho(Q[Ae]);
        if (ls(qe, tt))
          v(qe, tt, de, null, ae, Ee, we, Se, _e);
        else
          break;
        fe--, Ae--;
      }
      if (ke > fe) {
        if (ke <= Ae) {
          const qe = Ae + 1, tt = qe < Re ? Q[qe].el : Oe;
          for (; ke <= Ae; )
            v(null, Q[ke] = _e ? $r(Q[ke]) : ho(Q[ke]), de, tt, ae, Ee, we, Se, _e), ke++;
        }
      } else if (ke > Ae)
        for (; ke <= fe; )
          Z(z[ke], ae, Ee, !0), ke++;
      else {
        const qe = ke, tt = ke, Je = /* @__PURE__ */ new Map();
        for (ke = tt; ke <= Ae; ke++) {
          const nt = Q[ke] = _e ? $r(Q[ke]) : ho(Q[ke]);
          nt.key != null && (process.env.NODE_ENV !== "production" && Je.has(nt.key) && Ue("Duplicate keys found during update:", JSON.stringify(nt.key), "Make sure keys are unique."), Je.set(nt.key, ke));
        }
        let ye, Ce = 0;
        const ue = Ae - tt + 1;
        let q = !1, oe = 0;
        const be = new Array(ue);
        for (ke = 0; ke < ue; ke++)
          be[ke] = 0;
        for (ke = qe; ke <= fe; ke++) {
          const nt = z[ke];
          if (Ce >= ue) {
            Z(nt, ae, Ee, !0);
            continue;
          }
          let ve;
          if (nt.key != null)
            ve = Je.get(nt.key);
          else
            for (ye = tt; ye <= Ae; ye++)
              if (be[ye - tt] === 0 && ls(nt, Q[ye])) {
                ve = ye;
                break;
              }
          ve === void 0 ? Z(nt, ae, Ee, !0) : (be[ve - tt] = ke + 1, ve >= oe ? oe = ve : q = !0, v(nt, Q[ve], de, null, ae, Ee, we, Se, _e), Ce++);
        }
        const xe = q ? Wk(be) : ll;
        for (ye = xe.length - 1, ke = ue - 1; ke >= 0; ke--) {
          const nt = tt + ke, ve = Q[nt], Le = nt + 1 < Re ? Q[nt + 1].el : Oe;
          be[ke] === 0 ? v(null, ve, de, Le, ae, Ee, we, Se, _e) : q && (ye < 0 || ke !== xe[ye] ? U(ve, de, Le, 2) : ye--);
        }
      }
    }, U = (z, Q, de, Oe, ae = null) => {
      const { el: Ee, type: we, transition: Se, children: _e, shapeFlag: ke } = z;
      if (ke & 6) {
        U(z.component.subTree, Q, de, Oe);
        return;
      }
      if (ke & 128) {
        z.suspense.move(Q, de, Oe);
        return;
      }
      if (ke & 64) {
        we.move(z, Q, de, ce);
        return;
      }
      if (we === ze) {
        o(Ee, Q, de);
        for (let fe = 0; fe < _e.length; fe++)
          U(_e[fe], Q, de, Oe);
        o(z.anchor, Q, de);
        return;
      }
      if (we === ru) {
        C(z, Q, de);
        return;
      }
      if (Oe !== 2 && ke & 1 && Se)
        if (Oe === 0)
          Se.beforeEnter(Ee), o(Ee, Q, de), Rn(() => Se.enter(Ee), ae);
        else {
          const { leave: fe, delayLeave: Ae, afterLeave: qe } = Se, tt = () => o(Ee, Q, de), Je = () => {
            fe(Ee, () => {
              tt(), qe && qe();
            });
          };
          Ae ? Ae(Ee, tt, Je) : Je();
        }
      else
        o(Ee, Q, de);
    }, Z = (z, Q, de, Oe = !1, ae = !1) => {
      const { type: Ee, props: we, ref: Se, children: _e, dynamicChildren: ke, shapeFlag: Re, patchFlag: fe, dirs: Ae } = z;
      if (Se != null && hf(Se, null, de, z, !0), Re & 256) {
        Q.ctx.deactivate(z);
        return;
      }
      const qe = Re & 1 && Ae, tt = !da(z);
      let Je;
      if (tt && (Je = we && we.onVnodeBeforeUnmount) && To(Je, Q, z), Re & 6)
        ee(z.component, de, Oe);
      else {
        if (Re & 128) {
          z.suspense.unmount(de, Oe);
          return;
        }
        qe && Qr(z, null, Q, "beforeUnmount"), Re & 64 ? z.type.remove(z, Q, de, ae, ce, Oe) : ke && (Ee !== ze || fe > 0 && fe & 64) ? ne(ke, Q, de, !1, !0) : (Ee === ze && fe & 384 || !ae && Re & 16) && ne(_e, Q, de), Oe && pe(z);
      }
      (tt && (Je = we && we.onVnodeUnmounted) || qe) && Rn(() => {
        Je && To(Je, Q, z), qe && Qr(z, null, Q, "unmounted");
      }, de);
    }, pe = (z) => {
      const { type: Q, el: de, anchor: Oe, transition: ae } = z;
      if (Q === ze) {
        process.env.NODE_ENV !== "production" && z.patchFlag > 0 && z.patchFlag & 2048 && ae && !ae.persisted ? z.children.forEach((we) => {
          we.type === en ? r(we.el) : pe(we);
        }) : J(de, Oe);
        return;
      }
      if (Q === ru) {
        _(z);
        return;
      }
      const Ee = () => {
        r(de), ae && !ae.persisted && ae.afterLeave && ae.afterLeave();
      };
      if (z.shapeFlag & 1 && ae && !ae.persisted) {
        const { leave: we, delayLeave: Se } = ae, _e = () => we(de, Ee);
        Se ? Se(z.el, Ee, _e) : _e();
      } else
        Ee();
    }, J = (z, Q) => {
      let de;
      for (; z !== Q; )
        de = p(z), r(z), z = de;
      r(Q);
    }, ee = (z, Q, de) => {
      process.env.NODE_ENV !== "production" && z.type.__hmrId && K2(z);
      const { bum: Oe, scope: ae, update: Ee, subTree: we, um: Se } = z;
      Oe && Ys(Oe), ae.stop(), Ee && (Ee.active = !1, Z(we, z, Q, de)), Se && Rn(Se, Q), Rn(() => {
        z.isUnmounted = !0;
      }, Q), Q && Q.pendingBranch && !Q.isUnmounted && z.asyncDep && !z.asyncResolved && z.suspenseId === Q.pendingId && (Q.deps--, Q.deps === 0 && Q.resolve()), process.env.NODE_ENV !== "production" && X2(z);
    }, ne = (z, Q, de, Oe = !1, ae = !1, Ee = 0) => {
      for (let we = Ee; we < z.length; we++)
        Z(z[we], Q, de, Oe, ae);
    }, Y = (z) => z.shapeFlag & 6 ? Y(z.component.subTree) : z.shapeFlag & 128 ? z.suspense.next() : p(z.anchor || z.el), re = (z, Q, de) => {
      z == null ? Q._vnode && Z(Q._vnode, null, null, !0) : v(Q._vnode || null, z, Q, null, null, null, de), zv(), c0(), Q._vnode = z;
    }, ce = {
      p: v,
      um: Z,
      m: U,
      r: pe,
      mt: W,
      mc: P,
      pc: M,
      pbc: L,
      n: Y,
      o: e
    };
    let Te, Pe;
    return t && ([Te, Pe] = t(ce)), {
      render: re,
      hydrate: Te,
      createApp: Hk(re, Te)
    };
  }
  function es({ effect: e, update: t }, n) {
    e.allowRecurse = t.allowRecurse = n;
  }
  function fa(e, t, n = !1) {
    const o = e.children, r = t.children;
    if (De(o) && De(r))
      for (let s = 0; s < o.length; s++) {
        const l = o[s];
        let a = r[s];
        a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = r[s] = $r(r[s]), a.el = l.el), n || fa(l, a)), process.env.NODE_ENV !== "production" && a.type === en && !a.el && (a.el = l.el);
      }
  }
  function Wk(e) {
    const t = e.slice(), n = [0];
    let o, r, s, l, a;
    const u = e.length;
    for (o = 0; o < u; o++) {
      const c = e[o];
      if (c !== 0) {
        if (r = n[n.length - 1], e[r] < c) {
          t[o] = r, n.push(o);
          continue;
        }
        for (s = 0, l = n.length - 1; s < l; )
          a = s + l >> 1, e[n[a]] < c ? s = a + 1 : l = a;
        c < e[n[s]] && (s > 0 && (t[o] = n[s - 1]), n[s] = o);
      }
    }
    for (s = n.length, l = n[s - 1]; s-- > 0; )
      n[s] = l, l = t[l];
    return n;
  }
  const Uk = (e) => e.__isTeleport, ul = (e) => e && (e.disabled || e.disabled === ""), nm = (e) => typeof SVGElement < "u" && e instanceof SVGElement, vf = (e, t) => {
    const n = e && e.to;
    if (et(n))
      if (t) {
        const o = t(n);
        return o || process.env.NODE_ENV !== "production" && Ue(`Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`), o;
      } else
        return process.env.NODE_ENV !== "production" && Ue("Current renderer does not support string target for Teleports. (missing querySelector renderer option)"), null;
    else
      return process.env.NODE_ENV !== "production" && !n && !ul(e) && Ue(`Invalid Teleport target: ${n}`), n;
  }, qk = {
    __isTeleport: !0,
    process(e, t, n, o, r, s, l, a, u, c) {
      const { mc: f, pc: d, pbc: p, o: { insert: h, querySelector: m, createText: v, createComment: g } } = c, y = ul(t.props);
      let { shapeFlag: w, children: b, dynamicChildren: C } = t;
      if (process.env.NODE_ENV !== "production" && Ar && (u = !1, C = null), e == null) {
        const _ = t.el = process.env.NODE_ENV !== "production" ? g("teleport start") : v(""), k = t.anchor = process.env.NODE_ENV !== "production" ? g("teleport end") : v("");
        h(_, n, o), h(k, n, o);
        const O = t.target = vf(t.props, m), T = t.targetAnchor = v("");
        O ? (h(T, O), l = l || nm(O)) : process.env.NODE_ENV !== "production" && !y && Ue("Invalid Teleport target on mount:", O, `(${typeof O})`);
        const P = (A, L) => {
          w & 16 && f(b, A, L, r, s, l, a, u);
        };
        y ? P(n, k) : O && P(O, T);
      } else {
        t.el = e.el;
        const _ = t.anchor = e.anchor, k = t.target = e.target, O = t.targetAnchor = e.targetAnchor, T = ul(e.props), P = T ? n : k, A = T ? _ : O;
        if (l = l || nm(k), C ? (p(e.dynamicChildren, C, P, r, s, l, a), fa(e, t, !0)) : u || d(e, t, P, A, r, s, l, a, !1), y)
          T || Di(t, n, _, c, 1);
        else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
          const L = t.target = vf(t.props, m);
          L ? Di(t, L, null, c, 0) : process.env.NODE_ENV !== "production" && Ue("Invalid Teleport target on update:", k, `(${typeof k})`);
        } else
          T && Di(t, k, O, c, 1);
      }
    },
    remove(e, t, n, o, { um: r, o: { remove: s } }, l) {
      const { shapeFlag: a, children: u, anchor: c, targetAnchor: f, target: d, props: p } = e;
      if (d && s(f), (l || !ul(p)) && (s(c), a & 16))
        for (let h = 0; h < u.length; h++) {
          const m = u[h];
          r(m, t, n, !0, !!m.dynamicChildren);
        }
    },
    move: Di,
    hydrate: Yk
  };
  function Di(e, t, n, { o: { insert: o }, m: r }, s = 2) {
    s === 0 && o(e.targetAnchor, t, n);
    const { el: l, anchor: a, shapeFlag: u, children: c, props: f } = e, d = s === 2;
    if (d && o(l, t, n), (!d || ul(f)) && u & 16)
      for (let p = 0; p < c.length; p++)
        r(c[p], t, n, 2);
    d && o(a, t, n);
  }
  function Yk(e, t, n, o, r, s, { o: { nextSibling: l, parentNode: a, querySelector: u } }, c) {
    const f = t.target = vf(t.props, u);
    if (f) {
      const d = f._lpa || f.firstChild;
      if (t.shapeFlag & 16)
        if (ul(t.props))
          t.anchor = c(l(e), t, a(e), n, o, r, s), t.targetAnchor = d;
        else {
          t.anchor = l(e);
          let p = d;
          for (; p; )
            if (p = l(p), p && p.nodeType === 8 && p.data === "teleport anchor") {
              t.targetAnchor = p, f._lpa = t.targetAnchor && l(t.targetAnchor);
              break;
            }
          c(d, t, f, n, o, r, s);
        }
    }
    return t.anchor && l(t.anchor);
  }
  const pi = qk, ze = Symbol(process.env.NODE_ENV !== "production" ? "Fragment" : void 0), Hl = Symbol(process.env.NODE_ENV !== "production" ? "Text" : void 0), en = Symbol(process.env.NODE_ENV !== "production" ? "Comment" : void 0), ru = Symbol(process.env.NODE_ENV !== "production" ? "Static" : void 0), pa = [];
  let go = null;
  function S(e = !1) {
    pa.push(go = e ? null : []);
  }
  function Gk() {
    pa.pop(), go = pa[pa.length - 1] || null;
  }
  let Ra = 1;
  function om(e) {
    Ra += e;
  }
  function L0(e) {
    return e.dynamicChildren = Ra > 0 ? go || ll : null, Gk(), Ra > 0 && go && go.push(e), e;
  }
  function V(e, t, n, o, r, s) {
    return L0(H(e, t, n, o, r, s, !0));
  }
  function ie(e, t, n, o, r) {
    return L0(K(e, t, n, o, r, !0));
  }
  function Bt(e) {
    return e ? e.__v_isVNode === !0 : !1;
  }
  function ls(e, t) {
    return process.env.NODE_ENV !== "production" && t.shapeFlag & 6 && Gs.has(t.type) ? !1 : e.type === t.type && e.key === t.key;
  }
  const Xk = (...e) => B0(...e), $c = "__vInternal", V0 = ({ key: e }) => e != null ? e : null, su = ({ ref: e, ref_key: t, ref_for: n }) => e != null ? et(e) || Pt(e) || Ge(e) ? { i: fn, r: e, k: t, f: !!n } : e : null;
  function H(e, t = null, n = null, o = 0, r = null, s = e === ze ? 0 : 1, l = !1, a = !1) {
    const u = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e,
      props: t,
      key: t && V0(t),
      ref: t && su(t),
      scopeId: Sc,
      slotScopeIds: null,
      children: n,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag: s,
      patchFlag: o,
      dynamicProps: r,
      dynamicChildren: null,
      appContext: null
    };
    return a ? (Qp(u, n), s & 128 && e.normalize(u)) : n && (u.shapeFlag |= et(n) ? 8 : 16), process.env.NODE_ENV !== "production" && u.key !== u.key && Ue("VNode created with invalid key (NaN). VNode type:", u.type), Ra > 0 && !l && go && (u.patchFlag > 0 || s & 6) && u.patchFlag !== 32 && go.push(u), u;
  }
  const K = process.env.NODE_ENV !== "production" ? Xk : B0;
  function B0(e, t = null, n = null, o = 0, r = null, s = !1) {
    if ((!e || e === $0) && (process.env.NODE_ENV !== "production" && !e && Ue(`Invalid vnode type when creating vnode: ${e}.`), e = en), Bt(e)) {
      const a = Eo(e, t, !0);
      return n && Qp(a, n), Ra > 0 && !s && go && (a.shapeFlag & 6 ? go[go.indexOf(e)] = a : go.push(a)), a.patchFlag |= -2, a;
    }
    if (W0(e) && (e = e.__vccOpts), t) {
      t = Nc(t);
      let { class: a, style: u } = t;
      a && !et(a) && (t.class = $(a)), rt(u) && (Hu(u) && !De(u) && (u = Zt({}, u)), t.style = Ke(u));
    }
    const l = et(e) ? 1 : ik(e) ? 128 : Uk(e) ? 64 : rt(e) ? 4 : Ge(e) ? 2 : 0;
    return process.env.NODE_ENV !== "production" && l & 4 && Hu(e) && (e = Ct(e), Ue("Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", `
Component that was made reactive: `, e)), H(e, t, n, o, r, l, s, !0);
  }
  function Nc(e) {
    return e ? Hu(e) || $c in e ? Zt({}, e) : e : null;
  }
  function Eo(e, t, n = !1) {
    const { props: o, ref: r, patchFlag: s, children: l } = e, a = t ? ft(o || {}, t) : o;
    return {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e.type,
      props: a,
      key: a && V0(a),
      ref: t && t.ref ? n && r ? De(r) ? r.concat(su(t)) : [r, su(t)] : su(t) : r,
      scopeId: e.scopeId,
      slotScopeIds: e.slotScopeIds,
      children: process.env.NODE_ENV !== "production" && s === -1 && De(l) ? l.map(F0) : l,
      target: e.target,
      targetAnchor: e.targetAnchor,
      staticCount: e.staticCount,
      shapeFlag: e.shapeFlag,
      patchFlag: t && e.type !== ze ? s === -1 ? 16 : s | 16 : s,
      dynamicProps: e.dynamicProps,
      dynamicChildren: e.dynamicChildren,
      appContext: e.appContext,
      dirs: e.dirs,
      transition: e.transition,
      component: e.component,
      suspense: e.suspense,
      ssContent: e.ssContent && Eo(e.ssContent),
      ssFallback: e.ssFallback && Eo(e.ssFallback),
      el: e.el,
      anchor: e.anchor
    };
  }
  function F0(e) {
    const t = Eo(e);
    return De(e.children) && (t.children = e.children.map(F0)), t;
  }
  function wt(e = " ", t = 0) {
    return K(Hl, null, e, t);
  }
  function se(e = "", t = !1) {
    return t ? (S(), ie(en, null, e)) : K(en, null, e);
  }
  function ho(e) {
    return e == null || typeof e == "boolean" ? K(en) : De(e) ? K(
      ze,
      null,
      e.slice()
    ) : typeof e == "object" ? $r(e) : K(Hl, null, String(e));
  }
  function $r(e) {
    return e.el === null && e.patchFlag !== -1 || e.memo ? e : Eo(e);
  }
  function Qp(e, t) {
    let n = 0;
    const { shapeFlag: o } = e;
    if (t == null)
      t = null;
    else if (De(t))
      n = 16;
    else if (typeof t == "object")
      if (o & 65) {
        const r = t.default;
        r && (r._c && (r._d = !1), Qp(e, r()), r._c && (r._d = !0));
        return;
      } else {
        n = 32;
        const r = t._;
        !r && !($c in t) ? t._ctx = fn : r === 3 && fn && (fn.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
      }
    else
      Ge(t) ? (t = { default: t, _ctx: fn }, n = 32) : (t = String(t), o & 64 ? (n = 16, t = [wt(t)]) : n = 8);
    e.children = t, e.shapeFlag |= n;
  }
  function ft(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const o = e[n];
      for (const r in o)
        if (r === "class")
          t.class !== o.class && (t.class = $([t.class, o.class]));
        else if (r === "style")
          t.style = Ke([t.style, o.style]);
        else if (ui(r)) {
          const s = t[r], l = o[r];
          l && s !== l && !(De(s) && s.includes(l)) && (t[r] = s ? [].concat(s, l) : l);
        } else
          r !== "" && (t[r] = o[r]);
    }
    return t;
  }
  function To(e, t, n, o = null) {
    to(e, t, 7, [
      n,
      o
    ]);
  }
  const Jk = D0();
  let Zk = 0;
  function Qk(e, t, n) {
    const o = e.type, r = (t ? t.appContext : e.appContext) || Jk, s = {
      uid: Zk++,
      vnode: e,
      type: o,
      parent: t,
      appContext: r,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      scope: new Fb(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: t ? t.provides : Object.create(r.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: I0(o, r),
      emitsOptions: m0(o, r),
      emit: null,
      emitted: null,
      propsDefaults: Lt,
      inheritAttrs: o.inheritAttrs,
      ctx: Lt,
      data: Lt,
      props: Lt,
      attrs: Lt,
      slots: Lt,
      refs: Lt,
      setupState: Lt,
      setupContext: null,
      suspense: n,
      suspenseId: n ? n.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    return process.env.NODE_ENV !== "production" ? s.ctx = wk(s) : s.ctx = { _: s }, s.root = t ? t.root : s, s.emit = ek.bind(null, s), e.ce && e.ce(s), s;
  }
  let an = null;
  const it = () => an || fn, wl = (e) => {
    an = e, e.scope.on();
  }, Es = () => {
    an && an.scope.off(), an = null;
  }, e$ = /* @__PURE__ */ Wr("slot,component");
  function mf(e, t) {
    const n = t.isNativeTag || Db;
    (e$(e) || n(e)) && Ue("Do not use built-in or reserved HTML elements as component id: " + e);
  }
  function H0(e) {
    return e.vnode.shapeFlag & 4;
  }
  let xa = !1;
  function t$(e, t = !1) {
    xa = t;
    const { props: n, children: o } = e.vnode, r = H0(e);
    Ok(e, n, r, t), Vk(e, o);
    const s = r ? n$(e, t) : void 0;
    return xa = !1, s;
  }
  function n$(e, t) {
    var n;
    const o = e.type;
    if (process.env.NODE_ENV !== "production") {
      if (o.name && mf(o.name, e.appContext.config), o.components) {
        const s = Object.keys(o.components);
        for (let l = 0; l < s.length; l++)
          mf(s[l], e.appContext.config);
      }
      if (o.directives) {
        const s = Object.keys(o.directives);
        for (let l = 0; l < s.length; l++)
          k0(s[l]);
      }
      o.compilerOptions && z0() && Ue('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.');
    }
    e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = ws(new Proxy(e.ctx, T0)), process.env.NODE_ENV !== "production" && Ck(e);
    const { setup: r } = o;
    if (r) {
      const s = e.setupContext = r.length > 1 ? j0(e) : null;
      wl(e), Rs();
      const l = nr(r, e, 0, [process.env.NODE_ENV !== "production" ? tl(e.props) : e.props, s]);
      if (xs(), Es(), yl(l)) {
        if (l.then(Es, Es), t)
          return l.then((a) => {
            rm(e, a, t);
          }).catch((a) => {
            wc(a, e, 0);
          });
        if (e.asyncDep = l, process.env.NODE_ENV !== "production" && !e.suspense) {
          const a = (n = o.name) !== null && n !== void 0 ? n : "Anonymous";
          Ue(`Component <${a}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
        }
      } else
        rm(e, l, t);
    } else
      K0(e, t);
  }
  function rm(e, t, n) {
    Ge(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : rt(t) ? (process.env.NODE_ENV !== "production" && Bt(t) && Ue("setup() should not return VNodes directly - return a render function instead."), process.env.NODE_ENV !== "production" && (e.devtoolsRawSetupState = t), e.setupState = o0(t), process.env.NODE_ENV !== "production" && Ek(e)) : process.env.NODE_ENV !== "production" && t !== void 0 && Ue(`setup() should return an object. Received: ${t === null ? "null" : typeof t}`), K0(e, n);
  }
  let gf;
  const z0 = () => !gf;
  function K0(e, t, n) {
    const o = e.type;
    if (!e.render) {
      if (!t && gf && !o.render) {
        const r = o.template || Jp(e).template;
        if (r) {
          process.env.NODE_ENV !== "production" && qo(e, "compile");
          const { isCustomElement: s, compilerOptions: l } = e.appContext.config, { delimiters: a, compilerOptions: u } = o, c = Zt(Zt({
            isCustomElement: s,
            delimiters: a
          }, l), u);
          o.render = gf(r, c), process.env.NODE_ENV !== "production" && Yo(e, "compile");
        }
      }
      e.render = o.render || Nt;
    }
    wl(e), Rs(), _k(e), xs(), Es(), process.env.NODE_ENV !== "production" && !o.render && e.render === Nt && !t && (o.template ? Ue('Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".') : Ue("Component is missing template or render function."));
  }
  function sm(e) {
    return new Proxy(e.attrs, process.env.NODE_ENV !== "production" ? {
      get(t, n) {
        return Ku(), Bn(e, "get", "$attrs"), t[n];
      },
      set() {
        return Ue("setupContext.attrs is readonly."), !1;
      },
      deleteProperty() {
        return Ue("setupContext.attrs is readonly."), !1;
      }
    } : {
      get(t, n) {
        return Bn(e, "get", "$attrs"), t[n];
      }
    });
  }
  function j0(e) {
    const t = (o) => {
      process.env.NODE_ENV !== "production" && e.exposed && Ue("expose() should be called only once per setup()."), e.exposed = o || {};
    };
    let n;
    return process.env.NODE_ENV !== "production" ? Object.freeze({
      get attrs() {
        return n || (n = sm(e));
      },
      get slots() {
        return tl(e.slots);
      },
      get emit() {
        return (o, ...r) => e.emit(o, ...r);
      },
      expose: t
    }) : {
      get attrs() {
        return n || (n = sm(e));
      },
      slots: e.slots,
      emit: e.emit,
      expose: t
    };
  }
  function Tc(e) {
    if (e.exposed)
      return e.exposeProxy || (e.exposeProxy = new Proxy(o0(ws(e.exposed)), {
        get(t, n) {
          if (n in t)
            return t[n];
          if (n in bl)
            return bl[n](e);
        }
      }));
  }
  const o$ = /(?:^|[-_])(\w)/g, r$ = (e) => e.replace(o$, (t) => t.toUpperCase()).replace(/[-_]/g, "");
  function eh(e, t = !0) {
    return Ge(e) ? e.displayName || e.name : e.name || t && e.__name;
  }
  function Oc(e, t, n = !1) {
    let o = eh(t);
    if (!o && t.__file) {
      const r = t.__file.match(/([^/\\]+)\.\w+$/);
      r && (o = r[1]);
    }
    if (!o && e && e.parent) {
      const r = (s) => {
        for (const l in s)
          if (s[l] === t)
            return l;
      };
      o = r(e.components || e.parent.type.components) || r(e.appContext.components);
    }
    return o ? r$(o) : n ? "App" : "Anonymous";
  }
  function W0(e) {
    return Ge(e) && "__vccOpts" in e;
  }
  const E = (e, t) => s0(e, t, xa);
  function hn() {
    return U0().slots;
  }
  function zl() {
    return U0().attrs;
  }
  function U0() {
    const e = it();
    return process.env.NODE_ENV !== "production" && !e && Ue("useContext() called without active instance."), e.setupContext || (e.setupContext = j0(e));
  }
  function je(e, t, n) {
    const o = arguments.length;
    return o === 2 ? rt(t) && !De(t) ? Bt(t) ? K(e, null, [t]) : K(e, t) : K(e, null, t) : (o > 3 ? n = Array.prototype.slice.call(arguments, 2) : o === 3 && Bt(n) && (n = [n]), K(e, t, n));
  }
  Symbol(process.env.NODE_ENV !== "production" ? "ssrContext" : "");
  function md(e) {
    return !!(e && e.__v_isShallow);
  }
  function s$() {
    if (process.env.NODE_ENV === "production" || typeof window > "u")
      return;
    const e = { style: "color:#3ba776" }, t = { style: "color:#0b1bc9" }, n = { style: "color:#b62e24" }, o = { style: "color:#9d288c" }, r = {
      header(d) {
        return rt(d) ? d.__isVue ? ["div", e, "VueInstance"] : Pt(d) ? [
          "div",
          {},
          ["span", e, f(d)],
          "<",
          a(d.value),
          ">"
        ] : bs(d) ? [
          "div",
          {},
          ["span", e, md(d) ? "ShallowReactive" : "Reactive"],
          "<",
          a(d),
          `>${Lr(d) ? " (readonly)" : ""}`
        ] : Lr(d) ? [
          "div",
          {},
          ["span", e, md(d) ? "ShallowReadonly" : "Readonly"],
          "<",
          a(d),
          ">"
        ] : null : null;
      },
      hasBody(d) {
        return d && d.__isVue;
      },
      body(d) {
        if (d && d.__isVue)
          return [
            "div",
            {},
            ...s(d.$)
          ];
      }
    };
    function s(d) {
      const p = [];
      d.type.props && d.props && p.push(l("props", Ct(d.props))), d.setupState !== Lt && p.push(l("setup", d.setupState)), d.data !== Lt && p.push(l("data", Ct(d.data)));
      const h = u(d, "computed");
      h && p.push(l("computed", h));
      const m = u(d, "inject");
      return m && p.push(l("injected", m)), p.push([
        "div",
        {},
        [
          "span",
          {
            style: o.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: d }]
      ]), p;
    }
    function l(d, p) {
      return p = Zt({}, p), Object.keys(p).length ? [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          d
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(p).map((h) => [
            "div",
            {},
            ["span", o, h + ": "],
            a(p[h], !1)
          ])
        ]
      ] : ["span", {}];
    }
    function a(d, p = !0) {
      return typeof d == "number" ? ["span", t, d] : typeof d == "string" ? ["span", n, JSON.stringify(d)] : typeof d == "boolean" ? ["span", o, d] : rt(d) ? ["object", { object: p ? Ct(d) : d }] : ["span", n, String(d)];
    }
    function u(d, p) {
      const h = d.type;
      if (Ge(h))
        return;
      const m = {};
      for (const v in d.ctx)
        c(h, v, p) && (m[v] = d.ctx[v]);
      return m;
    }
    function c(d, p, h) {
      const m = d[h];
      if (De(m) && m.includes(p) || rt(m) && p in m || d.extends && c(d.extends, p, h) || d.mixins && d.mixins.some((v) => c(v, p, h)))
        return !0;
    }
    function f(d) {
      return md(d) ? "ShallowRef" : d.effect ? "ComputedRef" : "Ref";
    }
    window.devtoolsFormatters ? window.devtoolsFormatters.push(r) : window.devtoolsFormatters = [r];
  }
  const lm = "3.2.41", l$ = "http://www.w3.org/2000/svg", as = typeof document < "u" ? document : null, am = as && /* @__PURE__ */ as.createElement("template"), a$ = {
    insert: (e, t, n) => {
      t.insertBefore(e, n || null);
    },
    remove: (e) => {
      const t = e.parentNode;
      t && t.removeChild(e);
    },
    createElement: (e, t, n, o) => {
      const r = t ? as.createElementNS(l$, e) : as.createElement(e, n ? { is: n } : void 0);
      return e === "select" && o && o.multiple != null && r.setAttribute("multiple", o.multiple), r;
    },
    createText: (e) => as.createTextNode(e),
    createComment: (e) => as.createComment(e),
    setText: (e, t) => {
      e.nodeValue = t;
    },
    setElementText: (e, t) => {
      e.textContent = t;
    },
    parentNode: (e) => e.parentNode,
    nextSibling: (e) => e.nextSibling,
    querySelector: (e) => as.querySelector(e),
    setScopeId(e, t) {
      e.setAttribute(t, "");
    },
    insertStaticContent(e, t, n, o, r, s) {
      const l = n ? n.previousSibling : t.lastChild;
      if (r && (r === s || r.nextSibling))
        for (; t.insertBefore(r.cloneNode(!0), n), !(r === s || !(r = r.nextSibling)); )
          ;
      else {
        am.innerHTML = o ? `<svg>${e}</svg>` : e;
        const a = am.content;
        if (o) {
          const u = a.firstChild;
          for (; u.firstChild; )
            a.appendChild(u.firstChild);
          a.removeChild(u);
        }
        t.insertBefore(a, n);
      }
      return [
        l ? l.nextSibling : t.firstChild,
        n ? n.previousSibling : t.lastChild
      ];
    }
  };
  function i$(e, t, n) {
    const o = e._vtc;
    o && (t = (t ? [t, ...o] : [...o]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t;
  }
  function u$(e, t, n) {
    const o = e.style, r = et(n);
    if (n && !r) {
      for (const s in n)
        yf(o, s, n[s]);
      if (t && !et(t))
        for (const s in t)
          n[s] == null && yf(o, s, "");
    } else {
      const s = o.display;
      r ? t !== n && (o.cssText = n) : t && e.removeAttribute("style"), "_vod" in e && (o.display = s);
    }
  }
  const im = /\s*!important$/;
  function yf(e, t, n) {
    if (De(n))
      n.forEach((o) => yf(e, t, o));
    else if (n == null && (n = ""), t.startsWith("--"))
      e.setProperty(t, n);
    else {
      const o = c$(e, t);
      im.test(n) ? e.setProperty(Do(o), n.replace(im, ""), "important") : e[o] = n;
    }
  }
  const um = ["Webkit", "Moz", "ms"], gd = {};
  function c$(e, t) {
    const n = gd[t];
    if (n)
      return n;
    let o = ro(t);
    if (o !== "filter" && o in e)
      return gd[t] = o;
    o = xr(o);
    for (let r = 0; r < um.length; r++) {
      const s = um[r] + o;
      if (s in e)
        return gd[t] = s;
    }
    return t;
  }
  const cm = "http://www.w3.org/1999/xlink";
  function d$(e, t, n, o, r) {
    if (o && t.startsWith("xlink:"))
      n == null ? e.removeAttributeNS(cm, t.slice(6, t.length)) : e.setAttributeNS(cm, t, n);
    else {
      const s = F_(t);
      n == null || s && !Ab(n) ? e.removeAttribute(t) : e.setAttribute(t, s ? "" : n);
    }
  }
  function f$(e, t, n, o, r, s, l) {
    if (t === "innerHTML" || t === "textContent") {
      o && l(o, r, s), e[t] = n == null ? "" : n;
      return;
    }
    if (t === "value" && e.tagName !== "PROGRESS" && !e.tagName.includes("-")) {
      e._value = n;
      const u = n == null ? "" : n;
      (e.value !== u || e.tagName === "OPTION") && (e.value = u), n == null && e.removeAttribute(t);
      return;
    }
    let a = !1;
    if (n === "" || n == null) {
      const u = typeof e[t];
      u === "boolean" ? n = Ab(n) : n == null && u === "string" ? (n = "", a = !0) : u === "number" && (n = 0, a = !0);
    }
    try {
      e[t] = n;
    } catch (u) {
      process.env.NODE_ENV !== "production" && !a && Ue(`Failed setting prop "${t}" on <${e.tagName.toLowerCase()}>: value ${n} is invalid.`, u);
    }
    a && e.removeAttribute(t);
  }
  function Or(e, t, n, o) {
    e.addEventListener(t, n, o);
  }
  function p$(e, t, n, o) {
    e.removeEventListener(t, n, o);
  }
  function h$(e, t, n, o, r = null) {
    const s = e._vei || (e._vei = {}), l = s[t];
    if (o && l)
      l.value = o;
    else {
      const [a, u] = v$(t);
      if (o) {
        const c = s[t] = y$(o, r);
        Or(e, a, c, u);
      } else
        l && (p$(e, a, l, u), s[t] = void 0);
    }
  }
  const dm = /(?:Once|Passive|Capture)$/;
  function v$(e) {
    let t;
    if (dm.test(e)) {
      t = {};
      let o;
      for (; o = e.match(dm); )
        e = e.slice(0, e.length - o[0].length), t[o[0].toLowerCase()] = !0;
    }
    return [e[2] === ":" ? e.slice(3) : Do(e.slice(2)), t];
  }
  let yd = 0;
  const m$ = /* @__PURE__ */ Promise.resolve(), g$ = () => yd || (m$.then(() => yd = 0), yd = Date.now());
  function y$(e, t) {
    const n = (o) => {
      if (!o._vts)
        o._vts = Date.now();
      else if (o._vts <= n.attached)
        return;
      to(b$(o, n.value), t, 5, [o]);
    };
    return n.value = e, n.attached = g$(), n;
  }
  function b$(e, t) {
    if (De(t)) {
      const n = e.stopImmediatePropagation;
      return e.stopImmediatePropagation = () => {
        n.call(e), e._stopped = !0;
      }, t.map((o) => (r) => !r._stopped && o && o(r));
    } else
      return t;
  }
  const fm = /^on[a-z]/, w$ = (e, t, n, o, r = !1, s, l, a, u) => {
    t === "class" ? i$(e, o, r) : t === "style" ? u$(e, n, o) : ui(t) ? Du(t) || h$(e, t, n, o, l) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : C$(e, t, o, r)) ? f$(e, t, o, s, l, a, u) : (t === "true-value" ? e._trueValue = o : t === "false-value" && (e._falseValue = o), d$(e, t, o, r));
  };
  function C$(e, t, n, o) {
    return o ? !!(t === "innerHTML" || t === "textContent" || t in e && fm.test(t) && Ge(n)) : t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || fm.test(t) && et(n) ? !1 : t in e;
  }
  const mr = "transition", Xl = "animation", Qt = (e, { slots: t }) => je(w0, Y0(e), t);
  Qt.displayName = "Transition";
  const q0 = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  }, E$ = Qt.props = /* @__PURE__ */ Zt({}, w0.props, q0), ts = (e, t = []) => {
    De(e) ? e.forEach((n) => n(...t)) : e && e(...t);
  }, pm = (e) => e ? De(e) ? e.some((t) => t.length > 1) : e.length > 1 : !1;
  function Y0(e) {
    const t = {};
    for (const D in e)
      D in q0 || (t[D] = e[D]);
    if (e.css === !1)
      return t;
    const { name: n = "v", type: o, duration: r, enterFromClass: s = `${n}-enter-from`, enterActiveClass: l = `${n}-enter-active`, enterToClass: a = `${n}-enter-to`, appearFromClass: u = s, appearActiveClass: c = l, appearToClass: f = a, leaveFromClass: d = `${n}-leave-from`, leaveActiveClass: p = `${n}-leave-active`, leaveToClass: h = `${n}-leave-to` } = e, m = S$(r), v = m && m[0], g = m && m[1], { onBeforeEnter: y, onEnter: w, onEnterCancelled: b, onLeave: C, onLeaveCancelled: _, onBeforeAppear: k = y, onAppear: O = w, onAppearCancelled: T = b } = t, P = (D, B, F) => {
      wr(D, B ? f : a), wr(D, B ? c : l), F && F();
    }, A = (D, B) => {
      D._isLeaving = !1, wr(D, d), wr(D, h), wr(D, p), B && B();
    }, L = (D) => (B, F) => {
      const W = D ? O : w, x = () => P(B, D, F);
      ts(W, [B, x]), hm(() => {
        wr(B, D ? u : s), Go(B, D ? f : a), pm(W) || vm(B, o, v, x);
      });
    };
    return Zt(t, {
      onBeforeEnter(D) {
        ts(y, [D]), Go(D, s), Go(D, l);
      },
      onBeforeAppear(D) {
        ts(k, [D]), Go(D, u), Go(D, c);
      },
      onEnter: L(!1),
      onAppear: L(!0),
      onLeave(D, B) {
        D._isLeaving = !0;
        const F = () => A(D, B);
        Go(D, d), X0(), Go(D, p), hm(() => {
          !D._isLeaving || (wr(D, d), Go(D, h), pm(C) || vm(D, o, g, F));
        }), ts(C, [D, F]);
      },
      onEnterCancelled(D) {
        P(D, !1), ts(b, [D]);
      },
      onAppearCancelled(D) {
        P(D, !0), ts(T, [D]);
      },
      onLeaveCancelled(D) {
        A(D), ts(_, [D]);
      }
    });
  }
  function S$(e) {
    if (e == null)
      return null;
    if (rt(e))
      return [bd(e.enter), bd(e.leave)];
    {
      const t = bd(e);
      return [t, t];
    }
  }
  function bd(e) {
    const t = Vu(e);
    return process.env.NODE_ENV !== "production" && _$(t), t;
  }
  function _$(e) {
    typeof e != "number" ? Ue(`<transition> explicit duration is not a valid number - got ${JSON.stringify(e)}.`) : isNaN(e) && Ue("<transition> explicit duration is NaN - the duration expression might be incorrect.");
  }
  function Go(e, t) {
    t.split(/\s+/).forEach((n) => n && e.classList.add(n)), (e._vtc || (e._vtc = /* @__PURE__ */ new Set())).add(t);
  }
  function wr(e, t) {
    t.split(/\s+/).forEach((o) => o && e.classList.remove(o));
    const { _vtc: n } = e;
    n && (n.delete(t), n.size || (e._vtc = void 0));
  }
  function hm(e) {
    requestAnimationFrame(() => {
      requestAnimationFrame(e);
    });
  }
  let k$ = 0;
  function vm(e, t, n, o) {
    const r = e._endId = ++k$, s = () => {
      r === e._endId && o();
    };
    if (n)
      return setTimeout(s, n);
    const { type: l, timeout: a, propCount: u } = G0(e, t);
    if (!l)
      return o();
    const c = l + "end";
    let f = 0;
    const d = () => {
      e.removeEventListener(c, p), s();
    }, p = (h) => {
      h.target === e && ++f >= u && d();
    };
    setTimeout(() => {
      f < u && d();
    }, a + 1), e.addEventListener(c, p);
  }
  function G0(e, t) {
    const n = window.getComputedStyle(e), o = (m) => (n[m] || "").split(", "), r = o(mr + "Delay"), s = o(mr + "Duration"), l = mm(r, s), a = o(Xl + "Delay"), u = o(Xl + "Duration"), c = mm(a, u);
    let f = null, d = 0, p = 0;
    t === mr ? l > 0 && (f = mr, d = l, p = s.length) : t === Xl ? c > 0 && (f = Xl, d = c, p = u.length) : (d = Math.max(l, c), f = d > 0 ? l > c ? mr : Xl : null, p = f ? f === mr ? s.length : u.length : 0);
    const h = f === mr && /\b(transform|all)(,|$)/.test(n[mr + "Property"]);
    return {
      type: f,
      timeout: d,
      propCount: p,
      hasTransform: h
    };
  }
  function mm(e, t) {
    for (; e.length < t.length; )
      e = e.concat(e);
    return Math.max(...t.map((n, o) => gm(n) + gm(e[o])));
  }
  function gm(e) {
    return Number(e.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function X0() {
    return document.body.offsetHeight;
  }
  const J0 = /* @__PURE__ */ new WeakMap(), Z0 = /* @__PURE__ */ new WeakMap(), $$ = {
    name: "TransitionGroup",
    props: /* @__PURE__ */ Zt({}, E$, {
      tag: String,
      moveClass: String
    }),
    setup(e, { slots: t }) {
      const n = it(), o = b0();
      let r, s;
      return cr(() => {
        if (!r.length)
          return;
        const l = e.moveClass || `${e.name || "v"}-move`;
        if (!M$(r[0].el, n.vnode.el, l))
          return;
        r.forEach(N$), r.forEach(T$);
        const a = r.filter(O$);
        X0(), a.forEach((u) => {
          const c = u.el, f = c.style;
          Go(c, l), f.transform = f.webkitTransform = f.transitionDuration = "";
          const d = c._moveCb = (p) => {
            p && p.target !== c || (!p || /transform$/.test(p.propertyName)) && (c.removeEventListener("transitionend", d), c._moveCb = null, wr(c, l));
          };
          c.addEventListener("transitionend", d);
        });
      }), () => {
        const l = Ct(e), a = Y0(l);
        let u = l.tag || ze;
        r = s, s = t.default ? Yp(t.default()) : [];
        for (let c = 0; c < s.length; c++) {
          const f = s[c];
          f.key != null ? Pa(f, Ia(f, a, o, n)) : process.env.NODE_ENV !== "production" && Ue("<TransitionGroup> children must be keyed.");
        }
        if (r)
          for (let c = 0; c < r.length; c++) {
            const f = r[c];
            Pa(f, Ia(f, a, o, n)), J0.set(f, f.el.getBoundingClientRect());
          }
        return K(u, null, s);
      };
    }
  }, Q0 = $$;
  function N$(e) {
    const t = e.el;
    t._moveCb && t._moveCb(), t._enterCb && t._enterCb();
  }
  function T$(e) {
    Z0.set(e, e.el.getBoundingClientRect());
  }
  function O$(e) {
    const t = J0.get(e), n = Z0.get(e), o = t.left - n.left, r = t.top - n.top;
    if (o || r) {
      const s = e.el.style;
      return s.transform = s.webkitTransform = `translate(${o}px,${r}px)`, s.transitionDuration = "0s", e;
    }
  }
  function M$(e, t, n) {
    const o = e.cloneNode();
    e._vtc && e._vtc.forEach((l) => {
      l.split(/\s+/).forEach((a) => a && o.classList.remove(a));
    }), n.split(/\s+/).forEach((l) => l && o.classList.add(l)), o.style.display = "none";
    const r = t.nodeType === 1 ? t : t.parentNode;
    r.appendChild(o);
    const { hasTransform: s } = G0(o);
    return r.removeChild(o), s;
  }
  const Cl = (e) => {
    const t = e.props["onUpdate:modelValue"] || !1;
    return De(t) ? (n) => Ys(t, n) : t;
  };
  function I$(e) {
    e.target.composing = !0;
  }
  function ym(e) {
    const t = e.target;
    t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")));
  }
  const th = {
    created(e, { modifiers: { lazy: t, trim: n, number: o } }, r) {
      e._assign = Cl(r);
      const s = o || r.props && r.props.type === "number";
      Or(e, t ? "change" : "input", (l) => {
        if (l.target.composing)
          return;
        let a = e.value;
        n && (a = a.trim()), s && (a = Vu(a)), e._assign(a);
      }), n && Or(e, "change", () => {
        e.value = e.value.trim();
      }), t || (Or(e, "compositionstart", I$), Or(e, "compositionend", ym), Or(e, "change", ym));
    },
    mounted(e, { value: t }) {
      e.value = t == null ? "" : t;
    },
    beforeUpdate(e, { value: t, modifiers: { lazy: n, trim: o, number: r } }, s) {
      if (e._assign = Cl(s), e.composing || document.activeElement === e && e.type !== "range" && (n || o && e.value.trim() === t || (r || e.type === "number") && Vu(e.value) === t))
        return;
      const l = t == null ? "" : t;
      e.value !== l && (e.value = l);
    }
  }, qu = {
    deep: !0,
    created(e, t, n) {
      e._assign = Cl(n), Or(e, "change", () => {
        const o = e._modelValue, r = t1(e), s = e.checked, l = e._assign;
        if (De(o)) {
          const a = Rb(o, r), u = a !== -1;
          if (s && !u)
            l(o.concat(r));
          else if (!s && u) {
            const c = [...o];
            c.splice(a, 1), l(c);
          }
        } else if (hc(o)) {
          const a = new Set(o);
          s ? a.add(r) : a.delete(r), l(a);
        } else
          l(n1(e, s));
      });
    },
    mounted: bm,
    beforeUpdate(e, t, n) {
      e._assign = Cl(n), bm(e, t, n);
    }
  };
  function bm(e, { value: t, oldValue: n }, o) {
    e._modelValue = t, De(t) ? e.checked = Rb(t, o.props.value) > -1 : hc(t) ? e.checked = t.has(o.props.value) : t !== n && (e.checked = gl(t, n1(e, !0)));
  }
  const e1 = {
    created(e, { value: t }, n) {
      e.checked = gl(t, n.props.value), e._assign = Cl(n), Or(e, "change", () => {
        e._assign(t1(e));
      });
    },
    beforeUpdate(e, { value: t, oldValue: n }, o) {
      e._assign = Cl(o), t !== n && (e.checked = gl(t, o.props.value));
    }
  };
  function t1(e) {
    return "_value" in e ? e._value : e.value;
  }
  function n1(e, t) {
    const n = t ? "_trueValue" : "_falseValue";
    return n in e ? e[n] : t;
  }
  const P$ = ["ctrl", "shift", "alt", "meta"], A$ = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => "button" in e && e.button !== 0,
    middle: (e) => "button" in e && e.button !== 1,
    right: (e) => "button" in e && e.button !== 2,
    exact: (e, t) => P$.some((n) => e[`${n}Key`] && !t.includes(n))
  }, Ze = (e, t) => (n, ...o) => {
    for (let r = 0; r < t.length; r++) {
      const s = A$[t[r]];
      if (s && s(n, t))
        return;
    }
    return e(n, ...o);
  }, R$ = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  }, Et = (e, t) => (n) => {
    if (!("key" in n))
      return;
    const o = Do(n.key);
    if (t.some((r) => r === o || R$[r] === o))
      return e(n);
  }, $t = {
    beforeMount(e, { value: t }, { transition: n }) {
      e._vod = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : Jl(e, t);
    },
    mounted(e, { value: t }, { transition: n }) {
      n && t && n.enter(e);
    },
    updated(e, { value: t, oldValue: n }, { transition: o }) {
      !t != !n && (o ? t ? (o.beforeEnter(e), Jl(e, !0), o.enter(e)) : o.leave(e, () => {
        Jl(e, !1);
      }) : Jl(e, t));
    },
    beforeUnmount(e, { value: t }) {
      Jl(e, t);
    }
  };
  function Jl(e, t) {
    e.style.display = t ? e._vod : "none";
  }
  const x$ = /* @__PURE__ */ Zt({ patchProp: w$ }, a$);
  let wm;
  function o1() {
    return wm || (wm = Kk(x$));
  }
  const El = (...e) => {
    o1().render(...e);
  }, r1 = (...e) => {
    const t = o1().createApp(...e);
    process.env.NODE_ENV !== "production" && (D$(t), L$(t));
    const { mount: n } = t;
    return t.mount = (o) => {
      const r = V$(o);
      if (!r)
        return;
      const s = t._component;
      !Ge(s) && !s.render && !s.template && (s.template = r.innerHTML), r.innerHTML = "";
      const l = n(r, !1, r instanceof SVGElement);
      return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), l;
    }, t;
  };
  function D$(e) {
    Object.defineProperty(e.config, "isNativeTag", {
      value: (t) => U_(t) || q_(t),
      writable: !1
    });
  }
  function L$(e) {
    if (z0()) {
      const t = e.config.isCustomElement;
      Object.defineProperty(e.config, "isCustomElement", {
        get() {
          return t;
        },
        set() {
          Ue("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.");
        }
      });
      const n = e.config.compilerOptions, o = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom';
      Object.defineProperty(e.config, "compilerOptions", {
        get() {
          return Ue(o), n;
        },
        set() {
          Ue(o);
        }
      });
    }
  }
  function V$(e) {
    if (et(e)) {
      const t = document.querySelector(e);
      return process.env.NODE_ENV !== "production" && !t && Ue(`Failed to mount app: mount target selector "${e}" returned null.`), t;
    }
    return process.env.NODE_ENV !== "production" && window.ShadowRoot && e instanceof window.ShadowRoot && e.mode === "closed" && Ue('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'), e;
  }
  function B$() {
    s$();
  }
  process.env.NODE_ENV !== "production" && B$();
  const Mc = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [o, r] of t)
      n[o] = r;
    return n;
  }, F$ = {
    name: "HelloWorld",
    props: {
      msg: String
    }
  }, H$ = (e) => (tk("data-v-48d7c773"), e = e(), nk(), e), z$ = { class: "hello" }, K$ = /* @__PURE__ */ H$(() => /* @__PURE__ */ H("p", null, null, -1));
  function j$(e, t, n, o, r, s) {
    return S(), V("div", z$, [
      H("h1", null, Ne(n.msg), 1),
      K$
    ]);
  }
  const W$ = /* @__PURE__ */ Mc(F$, [["render", j$], ["__scopeId", "data-v-48d7c773"]]), U$ = {
    name: "App",
    components: {
      HelloWorld: W$
    },
    data() {
      return {
        showWallet: !0
      };
    },
    computed: {},
    created() {
      this.$route.path.includes("wallet") && (this.showWallet = !1);
    }
  };
  function q$(e, t, n, o, r, s) {
    const l = Qe("HelloWorld"), a = Qe("router-view");
    return S(), V(ze, null, [
      K(l, { msg: "Welcome to Wallet Application" }),
      K(a)
    ], 64);
  }
  const Y$ = /* @__PURE__ */ Mc(U$, [["render", q$]]), G$ = 'a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])', X$ = (e) => process.env.NODE_ENV === "test" ? !0 : getComputedStyle(e).position === "fixed" ? !1 : e.offsetParent !== null, Cm = (e) => Array.from(e.querySelectorAll(G$)).filter((t) => J$(t) && X$(t)), J$ = (e) => {
    if (e.tabIndex > 0 || e.tabIndex === 0 && e.getAttribute("tabIndex") !== null)
      return !0;
    if (e.disabled)
      return !1;
    switch (e.nodeName) {
      case "A":
        return !!e.href && e.rel !== "ignore";
      case "INPUT":
        return !(e.type === "hidden" || e.type === "file");
      case "BUTTON":
      case "SELECT":
      case "TEXTAREA":
        return !0;
      default:
        return !1;
    }
  }, lu = function(e, t, ...n) {
    let o;
    t.includes("mouse") || t.includes("click") ? o = "MouseEvents" : t.includes("key") ? o = "KeyboardEvent" : o = "HTMLEvents";
    const r = document.createEvent(o);
    return r.initEvent(t, ...n), e.dispatchEvent(r), e;
  }, s1 = (e) => !e.getAttribute("aria-owns"), l1 = (e, t, n) => {
    const { parentNode: o } = e;
    if (!o)
      return null;
    const r = o.querySelectorAll(n), s = Array.prototype.indexOf.call(r, e);
    return r[s + t] || null;
  }, au = (e) => {
    !e || (e.focus(), !s1(e) && e.click());
  }, qt = (e, t, { checkForDefaultPrevented: n = !0 } = {}) => (r) => {
    const s = e == null ? void 0 : e(r);
    if (n === !1 || !s)
      return t == null ? void 0 : t(r);
  }, Em = (e) => (t) => t.pointerType === "mouse" ? e(t) : void 0;
  var Z$ = Object.defineProperty, Q$ = Object.defineProperties, eN = Object.getOwnPropertyDescriptors, Sm = Object.getOwnPropertySymbols, tN = Object.prototype.hasOwnProperty, nN = Object.prototype.propertyIsEnumerable, _m = (e, t, n) => t in e ? Z$(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, oN = (e, t) => {
    for (var n in t || (t = {}))
      tN.call(t, n) && _m(e, n, t[n]);
    if (Sm)
      for (var n of Sm(t))
        nN.call(t, n) && _m(e, n, t[n]);
    return e;
  }, rN = (e, t) => Q$(e, eN(t));
  function km(e, t) {
    var n;
    const o = xt();
    return xn(() => {
      o.value = e();
    }, rN(oN({}, t), {
      flush: (n = t == null ? void 0 : t.flush) != null ? n : "sync"
    })), Fl(o);
  }
  var $m;
  const bt = typeof window < "u", sN = (e) => typeof e < "u", tn = (e) => typeof e == "boolean", lN = (e) => typeof e == "function", Xe = (e) => typeof e == "number", aN = (e) => typeof e == "string", Sl = () => {
  }, a1 = bt && (($m = window == null ? void 0 : window.navigator) == null ? void 0 : $m.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
  function Vr(e) {
    return typeof e == "function" ? e() : i(e);
  }
  function i1(e, t) {
    function n(...o) {
      return new Promise((r, s) => {
        Promise.resolve(e(() => t.apply(this, o), { fn: t, thisArg: this, args: o })).then(r).catch(s);
      });
    }
    return n;
  }
  function iN(e, t = {}) {
    let n, o, r = Sl;
    const s = (a) => {
      clearTimeout(a), r(), r = Sl;
    };
    return (a) => {
      const u = Vr(e), c = Vr(t.maxWait);
      return n && s(n), u <= 0 || c !== void 0 && c <= 0 ? (o && (s(o), o = null), Promise.resolve(a())) : new Promise((f, d) => {
        r = t.rejectOnCancel ? d : f, c && !o && (o = setTimeout(() => {
          n && s(n), o = null, f(a());
        }, c)), n = setTimeout(() => {
          o && s(o), o = null, f(a());
        }, u);
      });
    };
  }
  function uN(e, t = !0, n = !0, o = !1) {
    let r = 0, s, l = !0, a = Sl, u;
    const c = () => {
      s && (clearTimeout(s), s = void 0, a(), a = Sl);
    };
    return (d) => {
      const p = Vr(e), h = Date.now() - r, m = () => u = d();
      return c(), p <= 0 ? (r = Date.now(), m()) : (h > p && (n || !l) ? (r = Date.now(), m()) : t && (u = new Promise((v, g) => {
        a = o ? g : v, s = setTimeout(() => {
          r = Date.now(), l = !0, v(m()), c();
        }, Math.max(0, p - h));
      })), !n && !s && (s = setTimeout(() => l = !0, p)), l = !1, u);
    };
  }
  function cN(e) {
    return e;
  }
  function Ic(e) {
    return n2() ? (Hb(e), !0) : !1;
  }
  function dN(e, t = 200, n = {}) {
    return i1(iN(t, n), e);
  }
  function fN(e, t = 200, n = {}) {
    const o = I(e.value), r = dN(() => {
      o.value = e.value;
    }, t, n);
    return me(e, () => r()), o;
  }
  function u1(e, t = 200, n = !1, o = !0, r = !1) {
    return i1(uN(t, n, o, r), e);
  }
  function nh(e, t = !0) {
    it() ? st(e) : t ? e() : Fe(e);
  }
  function Os(e, t, n = {}) {
    const {
      immediate: o = !0
    } = n, r = I(!1);
    let s = null;
    function l() {
      s && (clearTimeout(s), s = null);
    }
    function a() {
      r.value = !1, l();
    }
    function u(...c) {
      l(), r.value = !0, s = setTimeout(() => {
        r.value = !1, s = null, e(...c);
      }, Vr(t));
    }
    return o && (r.value = !0, bt && u()), Ic(a), {
      isPending: Fl(r),
      start: u,
      stop: a
    };
  }
  function Kn(e) {
    var t;
    const n = Vr(e);
    return (t = n == null ? void 0 : n.$el) != null ? t : n;
  }
  const Kl = bt ? window : void 0, pN = bt ? window.document : void 0;
  function Wt(...e) {
    let t, n, o, r;
    if (aN(e[0]) || Array.isArray(e[0]) ? ([n, o, r] = e, t = Kl) : [t, n, o, r] = e, !t)
      return Sl;
    Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o]);
    const s = [], l = () => {
      s.forEach((f) => f()), s.length = 0;
    }, a = (f, d, p, h) => (f.addEventListener(d, p, h), () => f.removeEventListener(d, p, h)), u = me(() => [Kn(t), Vr(r)], ([f, d]) => {
      l(), f && s.push(...n.flatMap((p) => o.map((h) => a(f, p, h, d))));
    }, { immediate: !0, flush: "post" }), c = () => {
      u(), l();
    };
    return Ic(c), c;
  }
  let Nm = !1;
  function oh(e, t, n = {}) {
    const { window: o = Kl, ignore: r = [], capture: s = !0, detectIframe: l = !1 } = n;
    if (!o)
      return;
    a1 && !Nm && (Nm = !0, Array.from(o.document.body.children).forEach((p) => p.addEventListener("click", Sl)));
    let a = !0;
    const u = (p) => r.some((h) => {
      if (typeof h == "string")
        return Array.from(o.document.querySelectorAll(h)).some((m) => m === p.target || p.composedPath().includes(m));
      {
        const m = Kn(h);
        return m && (p.target === m || p.composedPath().includes(m));
      }
    }), f = [
      Wt(o, "click", (p) => {
        const h = Kn(e);
        if (!(!h || h === p.target || p.composedPath().includes(h))) {
          if (p.detail === 0 && (a = !u(p)), !a) {
            a = !0;
            return;
          }
          t(p);
        }
      }, { passive: !0, capture: s }),
      Wt(o, "pointerdown", (p) => {
        const h = Kn(e);
        h && (a = !p.composedPath().includes(h) && !u(p));
      }, { passive: !0 }),
      l && Wt(o, "blur", (p) => {
        var h;
        const m = Kn(e);
        ((h = o.document.activeElement) == null ? void 0 : h.tagName) === "IFRAME" && !(m != null && m.contains(o.document.activeElement)) && t(p);
      })
    ].filter(Boolean);
    return () => f.forEach((p) => p());
  }
  function hN(e, t = !1) {
    const n = I(), o = () => n.value = Boolean(e());
    return o(), nh(o, t), n;
  }
  function vN(e) {
    return JSON.parse(JSON.stringify(e));
  }
  const bf = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, wf = "__vueuse_ssr_handlers__";
  bf[wf] = bf[wf] || {};
  bf[wf];
  function mN(e, t, { window: n = Kl, initialValue: o = "" } = {}) {
    const r = I(o), s = E(() => {
      var l;
      return Kn(t) || ((l = n == null ? void 0 : n.document) == null ? void 0 : l.documentElement);
    });
    return me([s, () => Vr(e)], ([l, a]) => {
      var u;
      if (l && n) {
        const c = (u = n.getComputedStyle(l).getPropertyValue(a)) == null ? void 0 : u.trim();
        r.value = c || o;
      }
    }, { immediate: !0 }), me(r, (l) => {
      var a;
      (a = s.value) != null && a.style && s.value.style.setProperty(Vr(e), l);
    }), r;
  }
  function gN({ document: e = pN } = {}) {
    if (!e)
      return I("visible");
    const t = I(e.visibilityState);
    return Wt(e, "visibilitychange", () => {
      t.value = e.visibilityState;
    }), t;
  }
  var Tm = Object.getOwnPropertySymbols, yN = Object.prototype.hasOwnProperty, bN = Object.prototype.propertyIsEnumerable, wN = (e, t) => {
    var n = {};
    for (var o in e)
      yN.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
    if (e != null && Tm)
      for (var o of Tm(e))
        t.indexOf(o) < 0 && bN.call(e, o) && (n[o] = e[o]);
    return n;
  };
  function Cn(e, t, n = {}) {
    const o = n, { window: r = Kl } = o, s = wN(o, ["window"]);
    let l;
    const a = hN(() => r && "ResizeObserver" in r), u = () => {
      l && (l.disconnect(), l = void 0);
    }, c = me(() => Kn(e), (d) => {
      u(), a.value && r && d && (l = new ResizeObserver(t), l.observe(d, s));
    }, { immediate: !0, flush: "post" }), f = () => {
      u(), c();
    };
    return Ic(f), {
      isSupported: a,
      stop: f
    };
  }
  function Om(e, t = {}) {
    const {
      reset: n = !0,
      windowResize: o = !0,
      windowScroll: r = !0,
      immediate: s = !0
    } = t, l = I(0), a = I(0), u = I(0), c = I(0), f = I(0), d = I(0), p = I(0), h = I(0);
    function m() {
      const v = Kn(e);
      if (!v) {
        n && (l.value = 0, a.value = 0, u.value = 0, c.value = 0, f.value = 0, d.value = 0, p.value = 0, h.value = 0);
        return;
      }
      const g = v.getBoundingClientRect();
      l.value = g.height, a.value = g.bottom, u.value = g.left, c.value = g.right, f.value = g.top, d.value = g.width, p.value = g.x, h.value = g.y;
    }
    return Cn(e, m), me(() => Kn(e), (v) => !v && m()), r && Wt("scroll", m, { capture: !0, passive: !0 }), o && Wt("resize", m, { passive: !0 }), nh(() => {
      s && m();
    }), {
      height: l,
      bottom: a,
      left: u,
      right: c,
      top: f,
      width: d,
      x: p,
      y: h,
      update: m
    };
  }
  var Mm;
  (function(e) {
    e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE";
  })(Mm || (Mm = {}));
  var CN = Object.defineProperty, Im = Object.getOwnPropertySymbols, EN = Object.prototype.hasOwnProperty, SN = Object.prototype.propertyIsEnumerable, Pm = (e, t, n) => t in e ? CN(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, _N = (e, t) => {
    for (var n in t || (t = {}))
      EN.call(t, n) && Pm(e, n, t[n]);
    if (Im)
      for (var n of Im(t))
        SN.call(t, n) && Pm(e, n, t[n]);
    return e;
  };
  const kN = {
    easeInSine: [0.12, 0, 0.39, 0],
    easeOutSine: [0.61, 1, 0.88, 1],
    easeInOutSine: [0.37, 0, 0.63, 1],
    easeInQuad: [0.11, 0, 0.5, 0],
    easeOutQuad: [0.5, 1, 0.89, 1],
    easeInOutQuad: [0.45, 0, 0.55, 1],
    easeInCubic: [0.32, 0, 0.67, 0],
    easeOutCubic: [0.33, 1, 0.68, 1],
    easeInOutCubic: [0.65, 0, 0.35, 1],
    easeInQuart: [0.5, 0, 0.75, 0],
    easeOutQuart: [0.25, 1, 0.5, 1],
    easeInOutQuart: [0.76, 0, 0.24, 1],
    easeInQuint: [0.64, 0, 0.78, 0],
    easeOutQuint: [0.22, 1, 0.36, 1],
    easeInOutQuint: [0.83, 0, 0.17, 1],
    easeInExpo: [0.7, 0, 0.84, 0],
    easeOutExpo: [0.16, 1, 0.3, 1],
    easeInOutExpo: [0.87, 0, 0.13, 1],
    easeInCirc: [0.55, 0, 1, 0.45],
    easeOutCirc: [0, 0.55, 0.45, 1],
    easeInOutCirc: [0.85, 0, 0.15, 1],
    easeInBack: [0.36, 0, 0.66, -0.56],
    easeOutBack: [0.34, 1.56, 0.64, 1],
    easeInOutBack: [0.68, -0.6, 0.32, 1.6]
  };
  _N({
    linear: cN
  }, kN);
  function $N(e, t, n, o = {}) {
    var r, s, l;
    const {
      clone: a = !1,
      passive: u = !1,
      eventName: c,
      deep: f = !1,
      defaultValue: d
    } = o, p = it(), h = n || (p == null ? void 0 : p.emit) || ((r = p == null ? void 0 : p.$emit) == null ? void 0 : r.bind(p)) || ((l = (s = p == null ? void 0 : p.proxy) == null ? void 0 : s.$emit) == null ? void 0 : l.bind(p == null ? void 0 : p.proxy));
    let m = c;
    t || (t = "modelValue"), m = c || m || `update:${t.toString()}`;
    const v = (y) => a ? lN(a) ? a(y) : vN(y) : y, g = () => sN(e[t]) ? v(e[t]) : d;
    if (u) {
      const y = g(), w = I(y);
      return me(() => e[t], (b) => w.value = v(b)), me(w, (b) => {
        (b !== e[t] || f) && h(m, b);
      }, { deep: f }), w;
    } else
      return E({
        get() {
          return g();
        },
        set(y) {
          h(m, y);
        }
      });
  }
  function NN({ window: e = Kl } = {}) {
    if (!e)
      return I(!1);
    const t = I(e.document.hasFocus());
    return Wt(e, "blur", () => {
      t.value = !1;
    }), Wt(e, "focus", () => {
      t.value = !0;
    }), t;
  }
  function TN(e = {}) {
    const {
      window: t = Kl,
      initialWidth: n = 1 / 0,
      initialHeight: o = 1 / 0,
      listenOrientation: r = !0,
      includeScrollbar: s = !0
    } = e, l = I(n), a = I(o), u = () => {
      t && (s ? (l.value = t.innerWidth, a.value = t.innerHeight) : (l.value = t.document.documentElement.clientWidth, a.value = t.document.documentElement.clientHeight));
    };
    return u(), nh(u), Wt("resize", u, { passive: !0 }), r && Wt("orientationchange", u, { passive: !0 }), { width: l, height: a };
  }
  const ON = (e, t) => {
    if (!bt || !e || !t)
      return !1;
    const n = e.getBoundingClientRect();
    let o;
    return t instanceof Element ? o = t.getBoundingClientRect() : o = {
      top: 0,
      right: window.innerWidth,
      bottom: window.innerHeight,
      left: 0
    }, n.top < o.bottom && n.bottom > o.top && n.right > o.left && n.left < o.right;
  }, Am = (e) => {
    let t = 0, n = e;
    for (; n; )
      t += n.offsetTop, n = n.offsetParent;
    return t;
  }, MN = (e, t) => Math.abs(Am(e) - Am(t)), rh = (e) => {
    let t, n;
    return e.type === "touchend" ? (n = e.changedTouches[0].clientY, t = e.changedTouches[0].clientX) : e.type.startsWith("touch") ? (n = e.touches[0].clientY, t = e.touches[0].clientX) : (n = e.clientY, t = e.clientX), {
      clientX: t,
      clientY: n
    };
  };
  var IN = typeof global == "object" && global && global.Object === Object && global;
  const c1 = IN;
  var PN = typeof self == "object" && self && self.Object === Object && self, AN = c1 || PN || Function("return this")();
  const ko = AN;
  var RN = ko.Symbol;
  const so = RN;
  var d1 = Object.prototype, xN = d1.hasOwnProperty, DN = d1.toString, Zl = so ? so.toStringTag : void 0;
  function LN(e) {
    var t = xN.call(e, Zl), n = e[Zl];
    try {
      e[Zl] = void 0;
      var o = !0;
    } catch {
    }
    var r = DN.call(e);
    return o && (t ? e[Zl] = n : delete e[Zl]), r;
  }
  var VN = Object.prototype, BN = VN.toString;
  function FN(e) {
    return BN.call(e);
  }
  var HN = "[object Null]", zN = "[object Undefined]", Rm = so ? so.toStringTag : void 0;
  function Ds(e) {
    return e == null ? e === void 0 ? zN : HN : Rm && Rm in Object(e) ? LN(e) : FN(e);
  }
  function Lo(e) {
    return e != null && typeof e == "object";
  }
  var KN = "[object Symbol]";
  function Pc(e) {
    return typeof e == "symbol" || Lo(e) && Ds(e) == KN;
  }
  function f1(e, t) {
    for (var n = -1, o = e == null ? 0 : e.length, r = Array(o); ++n < o; )
      r[n] = t(e[n], n, e);
    return r;
  }
  var jN = Array.isArray;
  const Nn = jN;
  var WN = 1 / 0, xm = so ? so.prototype : void 0, Dm = xm ? xm.toString : void 0;
  function p1(e) {
    if (typeof e == "string")
      return e;
    if (Nn(e))
      return f1(e, p1) + "";
    if (Pc(e))
      return Dm ? Dm.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -WN ? "-0" : t;
  }
  var UN = /\s/;
  function qN(e) {
    for (var t = e.length; t-- && UN.test(e.charAt(t)); )
      ;
    return t;
  }
  var YN = /^\s+/;
  function GN(e) {
    return e && e.slice(0, qN(e) + 1).replace(YN, "");
  }
  function Tn(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  var Lm = 0 / 0, XN = /^[-+]0x[0-9a-f]+$/i, JN = /^0b[01]+$/i, ZN = /^0o[0-7]+$/i, QN = parseInt;
  function Vm(e) {
    if (typeof e == "number")
      return e;
    if (Pc(e))
      return Lm;
    if (Tn(e)) {
      var t = typeof e.valueOf == "function" ? e.valueOf() : e;
      e = Tn(t) ? t + "" : t;
    }
    if (typeof e != "string")
      return e === 0 ? e : +e;
    e = GN(e);
    var n = JN.test(e);
    return n || ZN.test(e) ? QN(e.slice(2), n ? 2 : 8) : XN.test(e) ? Lm : +e;
  }
  function sh(e) {
    return e;
  }
  var eT = "[object AsyncFunction]", tT = "[object Function]", nT = "[object GeneratorFunction]", oT = "[object Proxy]";
  function lh(e) {
    if (!Tn(e))
      return !1;
    var t = Ds(e);
    return t == tT || t == nT || t == eT || t == oT;
  }
  var rT = ko["__core-js_shared__"];
  const wd = rT;
  var Bm = function() {
    var e = /[^.]+$/.exec(wd && wd.keys && wd.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : "";
  }();
  function sT(e) {
    return !!Bm && Bm in e;
  }
  var lT = Function.prototype, aT = lT.toString;
  function Ls(e) {
    if (e != null) {
      try {
        return aT.call(e);
      } catch {
      }
      try {
        return e + "";
      } catch {
      }
    }
    return "";
  }
  var iT = /[\\^$.*+?()[\]{}|]/g, uT = /^\[object .+?Constructor\]$/, cT = Function.prototype, dT = Object.prototype, fT = cT.toString, pT = dT.hasOwnProperty, hT = RegExp(
    "^" + fT.call(pT).replace(iT, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function vT(e) {
    if (!Tn(e) || sT(e))
      return !1;
    var t = lh(e) ? hT : uT;
    return t.test(Ls(e));
  }
  function mT(e, t) {
    return e == null ? void 0 : e[t];
  }
  function Vs(e, t) {
    var n = mT(e, t);
    return vT(n) ? n : void 0;
  }
  var gT = Vs(ko, "WeakMap");
  const Cf = gT;
  var Fm = Object.create, yT = function() {
    function e() {
    }
    return function(t) {
      if (!Tn(t))
        return {};
      if (Fm)
        return Fm(t);
      e.prototype = t;
      var n = new e();
      return e.prototype = void 0, n;
    };
  }();
  const bT = yT;
  function wT(e, t, n) {
    switch (n.length) {
      case 0:
        return e.call(t);
      case 1:
        return e.call(t, n[0]);
      case 2:
        return e.call(t, n[0], n[1]);
      case 3:
        return e.call(t, n[0], n[1], n[2]);
    }
    return e.apply(t, n);
  }
  function CT() {
  }
  function h1(e, t) {
    var n = -1, o = e.length;
    for (t || (t = Array(o)); ++n < o; )
      t[n] = e[n];
    return t;
  }
  var ET = 800, ST = 16, _T = Date.now;
  function kT(e) {
    var t = 0, n = 0;
    return function() {
      var o = _T(), r = ST - (o - n);
      if (n = o, r > 0) {
        if (++t >= ET)
          return arguments[0];
      } else
        t = 0;
      return e.apply(void 0, arguments);
    };
  }
  function $T(e) {
    return function() {
      return e;
    };
  }
  var NT = function() {
    try {
      var e = Vs(Object, "defineProperty");
      return e({}, "", {}), e;
    } catch {
    }
  }();
  const Yu = NT;
  var TT = Yu ? function(e, t) {
    return Yu(e, "toString", {
      configurable: !0,
      enumerable: !1,
      value: $T(t),
      writable: !0
    });
  } : sh;
  const OT = TT;
  var MT = kT(OT);
  const v1 = MT;
  function IT(e, t) {
    for (var n = -1, o = e == null ? 0 : e.length; ++n < o && t(e[n], n, e) !== !1; )
      ;
    return e;
  }
  function PT(e, t, n, o) {
    for (var r = e.length, s = n + (o ? 1 : -1); o ? s-- : ++s < r; )
      if (t(e[s], s, e))
        return s;
    return -1;
  }
  function AT(e) {
    return e !== e;
  }
  function RT(e, t, n) {
    for (var o = n - 1, r = e.length; ++o < r; )
      if (e[o] === t)
        return o;
    return -1;
  }
  function xT(e, t, n) {
    return t === t ? RT(e, t, n) : PT(e, AT, n);
  }
  function DT(e, t) {
    var n = e == null ? 0 : e.length;
    return !!n && xT(e, t, 0) > -1;
  }
  var LT = 9007199254740991, VT = /^(?:0|[1-9]\d*)$/;
  function Ac(e, t) {
    var n = typeof e;
    return t = t == null ? LT : t, !!t && (n == "number" || n != "symbol" && VT.test(e)) && e > -1 && e % 1 == 0 && e < t;
  }
  function ah(e, t, n) {
    t == "__proto__" && Yu ? Yu(e, t, {
      configurable: !0,
      enumerable: !0,
      value: n,
      writable: !0
    }) : e[t] = n;
  }
  function hi(e, t) {
    return e === t || e !== e && t !== t;
  }
  var BT = Object.prototype, FT = BT.hasOwnProperty;
  function ih(e, t, n) {
    var o = e[t];
    (!(FT.call(e, t) && hi(o, n)) || n === void 0 && !(t in e)) && ah(e, t, n);
  }
  function vi(e, t, n, o) {
    var r = !n;
    n || (n = {});
    for (var s = -1, l = t.length; ++s < l; ) {
      var a = t[s], u = o ? o(n[a], e[a], a, n, e) : void 0;
      u === void 0 && (u = e[a]), r ? ah(n, a, u) : ih(n, a, u);
    }
    return n;
  }
  var Hm = Math.max;
  function m1(e, t, n) {
    return t = Hm(t === void 0 ? e.length - 1 : t, 0), function() {
      for (var o = arguments, r = -1, s = Hm(o.length - t, 0), l = Array(s); ++r < s; )
        l[r] = o[t + r];
      r = -1;
      for (var a = Array(t + 1); ++r < t; )
        a[r] = o[r];
      return a[t] = n(l), wT(e, this, a);
    };
  }
  function g1(e, t) {
    return v1(m1(e, t, sh), e + "");
  }
  var HT = 9007199254740991;
  function uh(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= HT;
  }
  function jl(e) {
    return e != null && uh(e.length) && !lh(e);
  }
  function zT(e, t, n) {
    if (!Tn(n))
      return !1;
    var o = typeof t;
    return (o == "number" ? jl(n) && Ac(t, n.length) : o == "string" && t in n) ? hi(n[t], e) : !1;
  }
  function KT(e) {
    return g1(function(t, n) {
      var o = -1, r = n.length, s = r > 1 ? n[r - 1] : void 0, l = r > 2 ? n[2] : void 0;
      for (s = e.length > 3 && typeof s == "function" ? (r--, s) : void 0, l && zT(n[0], n[1], l) && (s = r < 3 ? void 0 : s, r = 1), t = Object(t); ++o < r; ) {
        var a = n[o];
        a && e(t, a, o, s);
      }
      return t;
    });
  }
  var jT = Object.prototype;
  function ch(e) {
    var t = e && e.constructor, n = typeof t == "function" && t.prototype || jT;
    return e === n;
  }
  function WT(e, t) {
    for (var n = -1, o = Array(e); ++n < e; )
      o[n] = t(n);
    return o;
  }
  var UT = "[object Arguments]";
  function zm(e) {
    return Lo(e) && Ds(e) == UT;
  }
  var y1 = Object.prototype, qT = y1.hasOwnProperty, YT = y1.propertyIsEnumerable, GT = zm(function() {
    return arguments;
  }()) ? zm : function(e) {
    return Lo(e) && qT.call(e, "callee") && !YT.call(e, "callee");
  };
  const Da = GT;
  function XT() {
    return !1;
  }
  var b1 = typeof Wn == "object" && Wn && !Wn.nodeType && Wn, Km = b1 && typeof Un == "object" && Un && !Un.nodeType && Un, JT = Km && Km.exports === b1, jm = JT ? ko.Buffer : void 0, ZT = jm ? jm.isBuffer : void 0, QT = ZT || XT;
  const La = QT;
  var eO = "[object Arguments]", tO = "[object Array]", nO = "[object Boolean]", oO = "[object Date]", rO = "[object Error]", sO = "[object Function]", lO = "[object Map]", aO = "[object Number]", iO = "[object Object]", uO = "[object RegExp]", cO = "[object Set]", dO = "[object String]", fO = "[object WeakMap]", pO = "[object ArrayBuffer]", hO = "[object DataView]", vO = "[object Float32Array]", mO = "[object Float64Array]", gO = "[object Int8Array]", yO = "[object Int16Array]", bO = "[object Int32Array]", wO = "[object Uint8Array]", CO = "[object Uint8ClampedArray]", EO = "[object Uint16Array]", SO = "[object Uint32Array]", Xt = {};
  Xt[vO] = Xt[mO] = Xt[gO] = Xt[yO] = Xt[bO] = Xt[wO] = Xt[CO] = Xt[EO] = Xt[SO] = !0;
  Xt[eO] = Xt[tO] = Xt[pO] = Xt[nO] = Xt[hO] = Xt[oO] = Xt[rO] = Xt[sO] = Xt[lO] = Xt[aO] = Xt[iO] = Xt[uO] = Xt[cO] = Xt[dO] = Xt[fO] = !1;
  function _O(e) {
    return Lo(e) && uh(e.length) && !!Xt[Ds(e)];
  }
  function dh(e) {
    return function(t) {
      return e(t);
    };
  }
  var w1 = typeof Wn == "object" && Wn && !Wn.nodeType && Wn, ha = w1 && typeof Un == "object" && Un && !Un.nodeType && Un, kO = ha && ha.exports === w1, Cd = kO && c1.process, $O = function() {
    try {
      var e = ha && ha.require && ha.require("util").types;
      return e || Cd && Cd.binding && Cd.binding("util");
    } catch {
    }
  }();
  const _l = $O;
  var Wm = _l && _l.isTypedArray, NO = Wm ? dh(Wm) : _O;
  const fh = NO;
  var TO = Object.prototype, OO = TO.hasOwnProperty;
  function C1(e, t) {
    var n = Nn(e), o = !n && Da(e), r = !n && !o && La(e), s = !n && !o && !r && fh(e), l = n || o || r || s, a = l ? WT(e.length, String) : [], u = a.length;
    for (var c in e)
      (t || OO.call(e, c)) && !(l && (c == "length" || r && (c == "offset" || c == "parent") || s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || Ac(c, u))) && a.push(c);
    return a;
  }
  function E1(e, t) {
    return function(n) {
      return e(t(n));
    };
  }
  var MO = E1(Object.keys, Object);
  const IO = MO;
  var PO = Object.prototype, AO = PO.hasOwnProperty;
  function RO(e) {
    if (!ch(e))
      return IO(e);
    var t = [];
    for (var n in Object(e))
      AO.call(e, n) && n != "constructor" && t.push(n);
    return t;
  }
  function mi(e) {
    return jl(e) ? C1(e) : RO(e);
  }
  function xO(e) {
    var t = [];
    if (e != null)
      for (var n in Object(e))
        t.push(n);
    return t;
  }
  var DO = Object.prototype, LO = DO.hasOwnProperty;
  function VO(e) {
    if (!Tn(e))
      return xO(e);
    var t = ch(e), n = [];
    for (var o in e)
      o == "constructor" && (t || !LO.call(e, o)) || n.push(o);
    return n;
  }
  function gi(e) {
    return jl(e) ? C1(e, !0) : VO(e);
  }
  var BO = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, FO = /^\w*$/;
  function ph(e, t) {
    if (Nn(e))
      return !1;
    var n = typeof e;
    return n == "number" || n == "symbol" || n == "boolean" || e == null || Pc(e) ? !0 : FO.test(e) || !BO.test(e) || t != null && e in Object(t);
  }
  var HO = Vs(Object, "create");
  const Va = HO;
  function zO() {
    this.__data__ = Va ? Va(null) : {}, this.size = 0;
  }
  function KO(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0, t;
  }
  var jO = "__lodash_hash_undefined__", WO = Object.prototype, UO = WO.hasOwnProperty;
  function qO(e) {
    var t = this.__data__;
    if (Va) {
      var n = t[e];
      return n === jO ? void 0 : n;
    }
    return UO.call(t, e) ? t[e] : void 0;
  }
  var YO = Object.prototype, GO = YO.hasOwnProperty;
  function XO(e) {
    var t = this.__data__;
    return Va ? t[e] !== void 0 : GO.call(t, e);
  }
  var JO = "__lodash_hash_undefined__";
  function ZO(e, t) {
    var n = this.__data__;
    return this.size += this.has(e) ? 0 : 1, n[e] = Va && t === void 0 ? JO : t, this;
  }
  function Ms(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var o = e[t];
      this.set(o[0], o[1]);
    }
  }
  Ms.prototype.clear = zO;
  Ms.prototype.delete = KO;
  Ms.prototype.get = qO;
  Ms.prototype.has = XO;
  Ms.prototype.set = ZO;
  function QO() {
    this.__data__ = [], this.size = 0;
  }
  function Rc(e, t) {
    for (var n = e.length; n--; )
      if (hi(e[n][0], t))
        return n;
    return -1;
  }
  var eM = Array.prototype, tM = eM.splice;
  function nM(e) {
    var t = this.__data__, n = Rc(t, e);
    if (n < 0)
      return !1;
    var o = t.length - 1;
    return n == o ? t.pop() : tM.call(t, n, 1), --this.size, !0;
  }
  function oM(e) {
    var t = this.__data__, n = Rc(t, e);
    return n < 0 ? void 0 : t[n][1];
  }
  function rM(e) {
    return Rc(this.__data__, e) > -1;
  }
  function sM(e, t) {
    var n = this.__data__, o = Rc(n, e);
    return o < 0 ? (++this.size, n.push([e, t])) : n[o][1] = t, this;
  }
  function dr(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var o = e[t];
      this.set(o[0], o[1]);
    }
  }
  dr.prototype.clear = QO;
  dr.prototype.delete = nM;
  dr.prototype.get = oM;
  dr.prototype.has = rM;
  dr.prototype.set = sM;
  var lM = Vs(ko, "Map");
  const Ba = lM;
  function aM() {
    this.size = 0, this.__data__ = {
      hash: new Ms(),
      map: new (Ba || dr)(),
      string: new Ms()
    };
  }
  function iM(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
  }
  function xc(e, t) {
    var n = e.__data__;
    return iM(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
  }
  function uM(e) {
    var t = xc(this, e).delete(e);
    return this.size -= t ? 1 : 0, t;
  }
  function cM(e) {
    return xc(this, e).get(e);
  }
  function dM(e) {
    return xc(this, e).has(e);
  }
  function fM(e, t) {
    var n = xc(this, e), o = n.size;
    return n.set(e, t), this.size += n.size == o ? 0 : 1, this;
  }
  function fr(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var o = e[t];
      this.set(o[0], o[1]);
    }
  }
  fr.prototype.clear = aM;
  fr.prototype.delete = uM;
  fr.prototype.get = cM;
  fr.prototype.has = dM;
  fr.prototype.set = fM;
  var pM = "Expected a function";
  function Dc(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function")
      throw new TypeError(pM);
    var n = function() {
      var o = arguments, r = t ? t.apply(this, o) : o[0], s = n.cache;
      if (s.has(r))
        return s.get(r);
      var l = e.apply(this, o);
      return n.cache = s.set(r, l) || s, l;
    };
    return n.cache = new (Dc.Cache || fr)(), n;
  }
  Dc.Cache = fr;
  var hM = 500;
  function vM(e) {
    var t = Dc(e, function(o) {
      return n.size === hM && n.clear(), o;
    }), n = t.cache;
    return t;
  }
  var mM = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, gM = /\\(\\)?/g, yM = vM(function(e) {
    var t = [];
    return e.charCodeAt(0) === 46 && t.push(""), e.replace(mM, function(n, o, r, s) {
      t.push(r ? s.replace(gM, "$1") : o || n);
    }), t;
  });
  const bM = yM;
  function wM(e) {
    return e == null ? "" : p1(e);
  }
  function Lc(e, t) {
    return Nn(e) ? e : ph(e, t) ? [e] : bM(wM(e));
  }
  var CM = 1 / 0;
  function yi(e) {
    if (typeof e == "string" || Pc(e))
      return e;
    var t = e + "";
    return t == "0" && 1 / e == -CM ? "-0" : t;
  }
  function hh(e, t) {
    t = Lc(t, e);
    for (var n = 0, o = t.length; e != null && n < o; )
      e = e[yi(t[n++])];
    return n && n == o ? e : void 0;
  }
  function Kt(e, t, n) {
    var o = e == null ? void 0 : hh(e, t);
    return o === void 0 ? n : o;
  }
  function vh(e, t) {
    for (var n = -1, o = t.length, r = e.length; ++n < o; )
      e[r + n] = t[n];
    return e;
  }
  var Um = so ? so.isConcatSpreadable : void 0;
  function EM(e) {
    return Nn(e) || Da(e) || !!(Um && e && e[Um]);
  }
  function bi(e, t, n, o, r) {
    var s = -1, l = e.length;
    for (n || (n = EM), r || (r = []); ++s < l; ) {
      var a = e[s];
      t > 0 && n(a) ? t > 1 ? bi(a, t - 1, n, o, r) : vh(r, a) : o || (r[r.length] = a);
    }
    return r;
  }
  function S1(e) {
    var t = e == null ? 0 : e.length;
    return t ? bi(e, 1) : [];
  }
  function SM(e) {
    return v1(m1(e, void 0, S1), e + "");
  }
  var _M = E1(Object.getPrototypeOf, Object);
  const mh = _M;
  var kM = "[object Object]", $M = Function.prototype, NM = Object.prototype, _1 = $M.toString, TM = NM.hasOwnProperty, OM = _1.call(Object);
  function MM(e) {
    if (!Lo(e) || Ds(e) != kM)
      return !1;
    var t = mh(e);
    if (t === null)
      return !0;
    var n = TM.call(t, "constructor") && t.constructor;
    return typeof n == "function" && n instanceof n && _1.call(n) == OM;
  }
  function kl() {
    if (!arguments.length)
      return [];
    var e = arguments[0];
    return Nn(e) ? e : [e];
  }
  function IM() {
    this.__data__ = new dr(), this.size = 0;
  }
  function PM(e) {
    var t = this.__data__, n = t.delete(e);
    return this.size = t.size, n;
  }
  function AM(e) {
    return this.__data__.get(e);
  }
  function RM(e) {
    return this.__data__.has(e);
  }
  var xM = 200;
  function DM(e, t) {
    var n = this.__data__;
    if (n instanceof dr) {
      var o = n.__data__;
      if (!Ba || o.length < xM - 1)
        return o.push([e, t]), this.size = ++n.size, this;
      n = this.__data__ = new fr(o);
    }
    return n.set(e, t), this.size = n.size, this;
  }
  function wo(e) {
    var t = this.__data__ = new dr(e);
    this.size = t.size;
  }
  wo.prototype.clear = IM;
  wo.prototype.delete = PM;
  wo.prototype.get = AM;
  wo.prototype.has = RM;
  wo.prototype.set = DM;
  function LM(e, t) {
    return e && vi(t, mi(t), e);
  }
  function VM(e, t) {
    return e && vi(t, gi(t), e);
  }
  var k1 = typeof Wn == "object" && Wn && !Wn.nodeType && Wn, qm = k1 && typeof Un == "object" && Un && !Un.nodeType && Un, BM = qm && qm.exports === k1, Ym = BM ? ko.Buffer : void 0, Gm = Ym ? Ym.allocUnsafe : void 0;
  function $1(e, t) {
    if (t)
      return e.slice();
    var n = e.length, o = Gm ? Gm(n) : new e.constructor(n);
    return e.copy(o), o;
  }
  function FM(e, t) {
    for (var n = -1, o = e == null ? 0 : e.length, r = 0, s = []; ++n < o; ) {
      var l = e[n];
      t(l, n, e) && (s[r++] = l);
    }
    return s;
  }
  function N1() {
    return [];
  }
  var HM = Object.prototype, zM = HM.propertyIsEnumerable, Xm = Object.getOwnPropertySymbols, KM = Xm ? function(e) {
    return e == null ? [] : (e = Object(e), FM(Xm(e), function(t) {
      return zM.call(e, t);
    }));
  } : N1;
  const gh = KM;
  function jM(e, t) {
    return vi(e, gh(e), t);
  }
  var WM = Object.getOwnPropertySymbols, UM = WM ? function(e) {
    for (var t = []; e; )
      vh(t, gh(e)), e = mh(e);
    return t;
  } : N1;
  const T1 = UM;
  function qM(e, t) {
    return vi(e, T1(e), t);
  }
  function O1(e, t, n) {
    var o = t(e);
    return Nn(e) ? o : vh(o, n(e));
  }
  function Ef(e) {
    return O1(e, mi, gh);
  }
  function YM(e) {
    return O1(e, gi, T1);
  }
  var GM = Vs(ko, "DataView");
  const Sf = GM;
  var XM = Vs(ko, "Promise");
  const _f = XM;
  var JM = Vs(ko, "Set");
  const cl = JM;
  var Jm = "[object Map]", ZM = "[object Object]", Zm = "[object Promise]", Qm = "[object Set]", eg = "[object WeakMap]", tg = "[object DataView]", QM = Ls(Sf), eI = Ls(Ba), tI = Ls(_f), nI = Ls(cl), oI = Ls(Cf), ss = Ds;
  (Sf && ss(new Sf(new ArrayBuffer(1))) != tg || Ba && ss(new Ba()) != Jm || _f && ss(_f.resolve()) != Zm || cl && ss(new cl()) != Qm || Cf && ss(new Cf()) != eg) && (ss = function(e) {
    var t = Ds(e), n = t == ZM ? e.constructor : void 0, o = n ? Ls(n) : "";
    if (o)
      switch (o) {
        case QM:
          return tg;
        case eI:
          return Jm;
        case tI:
          return Zm;
        case nI:
          return Qm;
        case oI:
          return eg;
      }
    return t;
  });
  const Fa = ss;
  var rI = Object.prototype, sI = rI.hasOwnProperty;
  function lI(e) {
    var t = e.length, n = new e.constructor(t);
    return t && typeof e[0] == "string" && sI.call(e, "index") && (n.index = e.index, n.input = e.input), n;
  }
  var aI = ko.Uint8Array;
  const Gu = aI;
  function yh(e) {
    var t = new e.constructor(e.byteLength);
    return new Gu(t).set(new Gu(e)), t;
  }
  function iI(e, t) {
    var n = t ? yh(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.byteLength);
  }
  var uI = /\w*$/;
  function cI(e) {
    var t = new e.constructor(e.source, uI.exec(e));
    return t.lastIndex = e.lastIndex, t;
  }
  var ng = so ? so.prototype : void 0, og = ng ? ng.valueOf : void 0;
  function dI(e) {
    return og ? Object(og.call(e)) : {};
  }
  function M1(e, t) {
    var n = t ? yh(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.length);
  }
  var fI = "[object Boolean]", pI = "[object Date]", hI = "[object Map]", vI = "[object Number]", mI = "[object RegExp]", gI = "[object Set]", yI = "[object String]", bI = "[object Symbol]", wI = "[object ArrayBuffer]", CI = "[object DataView]", EI = "[object Float32Array]", SI = "[object Float64Array]", _I = "[object Int8Array]", kI = "[object Int16Array]", $I = "[object Int32Array]", NI = "[object Uint8Array]", TI = "[object Uint8ClampedArray]", OI = "[object Uint16Array]", MI = "[object Uint32Array]";
  function II(e, t, n) {
    var o = e.constructor;
    switch (t) {
      case wI:
        return yh(e);
      case fI:
      case pI:
        return new o(+e);
      case CI:
        return iI(e, n);
      case EI:
      case SI:
      case _I:
      case kI:
      case $I:
      case NI:
      case TI:
      case OI:
      case MI:
        return M1(e, n);
      case hI:
        return new o();
      case vI:
      case yI:
        return new o(e);
      case mI:
        return cI(e);
      case gI:
        return new o();
      case bI:
        return dI(e);
    }
  }
  function I1(e) {
    return typeof e.constructor == "function" && !ch(e) ? bT(mh(e)) : {};
  }
  var PI = "[object Map]";
  function AI(e) {
    return Lo(e) && Fa(e) == PI;
  }
  var rg = _l && _l.isMap, RI = rg ? dh(rg) : AI;
  const xI = RI;
  var DI = "[object Set]";
  function LI(e) {
    return Lo(e) && Fa(e) == DI;
  }
  var sg = _l && _l.isSet, VI = sg ? dh(sg) : LI;
  const BI = VI;
  var FI = 1, HI = 2, zI = 4, P1 = "[object Arguments]", KI = "[object Array]", jI = "[object Boolean]", WI = "[object Date]", UI = "[object Error]", A1 = "[object Function]", qI = "[object GeneratorFunction]", YI = "[object Map]", GI = "[object Number]", R1 = "[object Object]", XI = "[object RegExp]", JI = "[object Set]", ZI = "[object String]", QI = "[object Symbol]", e4 = "[object WeakMap]", t4 = "[object ArrayBuffer]", n4 = "[object DataView]", o4 = "[object Float32Array]", r4 = "[object Float64Array]", s4 = "[object Int8Array]", l4 = "[object Int16Array]", a4 = "[object Int32Array]", i4 = "[object Uint8Array]", u4 = "[object Uint8ClampedArray]", c4 = "[object Uint16Array]", d4 = "[object Uint32Array]", Ut = {};
  Ut[P1] = Ut[KI] = Ut[t4] = Ut[n4] = Ut[jI] = Ut[WI] = Ut[o4] = Ut[r4] = Ut[s4] = Ut[l4] = Ut[a4] = Ut[YI] = Ut[GI] = Ut[R1] = Ut[XI] = Ut[JI] = Ut[ZI] = Ut[QI] = Ut[i4] = Ut[u4] = Ut[c4] = Ut[d4] = !0;
  Ut[UI] = Ut[A1] = Ut[e4] = !1;
  function va(e, t, n, o, r, s) {
    var l, a = t & FI, u = t & HI, c = t & zI;
    if (n && (l = r ? n(e, o, r, s) : n(e)), l !== void 0)
      return l;
    if (!Tn(e))
      return e;
    var f = Nn(e);
    if (f) {
      if (l = lI(e), !a)
        return h1(e, l);
    } else {
      var d = Fa(e), p = d == A1 || d == qI;
      if (La(e))
        return $1(e, a);
      if (d == R1 || d == P1 || p && !r) {
        if (l = u || p ? {} : I1(e), !a)
          return u ? qM(e, VM(l, e)) : jM(e, LM(l, e));
      } else {
        if (!Ut[d])
          return r ? e : {};
        l = II(e, d, a);
      }
    }
    s || (s = new wo());
    var h = s.get(e);
    if (h)
      return h;
    s.set(e, l), BI(e) ? e.forEach(function(g) {
      l.add(va(g, t, n, g, e, s));
    }) : xI(e) && e.forEach(function(g, y) {
      l.set(y, va(g, t, n, y, e, s));
    });
    var m = c ? u ? YM : Ef : u ? gi : mi, v = f ? void 0 : m(e);
    return IT(v || e, function(g, y) {
      v && (y = g, g = e[y]), ih(l, y, va(g, t, n, y, e, s));
    }), l;
  }
  var f4 = 4;
  function lg(e) {
    return va(e, f4);
  }
  var p4 = 1, h4 = 4;
  function bh(e) {
    return va(e, p4 | h4);
  }
  var v4 = "__lodash_hash_undefined__";
  function m4(e) {
    return this.__data__.set(e, v4), this;
  }
  function g4(e) {
    return this.__data__.has(e);
  }
  function Ha(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.__data__ = new fr(); ++t < n; )
      this.add(e[t]);
  }
  Ha.prototype.add = Ha.prototype.push = m4;
  Ha.prototype.has = g4;
  function y4(e, t) {
    for (var n = -1, o = e == null ? 0 : e.length; ++n < o; )
      if (t(e[n], n, e))
        return !0;
    return !1;
  }
  function x1(e, t) {
    return e.has(t);
  }
  var b4 = 1, w4 = 2;
  function D1(e, t, n, o, r, s) {
    var l = n & b4, a = e.length, u = t.length;
    if (a != u && !(l && u > a))
      return !1;
    var c = s.get(e), f = s.get(t);
    if (c && f)
      return c == t && f == e;
    var d = -1, p = !0, h = n & w4 ? new Ha() : void 0;
    for (s.set(e, t), s.set(t, e); ++d < a; ) {
      var m = e[d], v = t[d];
      if (o)
        var g = l ? o(v, m, d, t, e, s) : o(m, v, d, e, t, s);
      if (g !== void 0) {
        if (g)
          continue;
        p = !1;
        break;
      }
      if (h) {
        if (!y4(t, function(y, w) {
          if (!x1(h, w) && (m === y || r(m, y, n, o, s)))
            return h.push(w);
        })) {
          p = !1;
          break;
        }
      } else if (!(m === v || r(m, v, n, o, s))) {
        p = !1;
        break;
      }
    }
    return s.delete(e), s.delete(t), p;
  }
  function C4(e) {
    var t = -1, n = Array(e.size);
    return e.forEach(function(o, r) {
      n[++t] = [r, o];
    }), n;
  }
  function wh(e) {
    var t = -1, n = Array(e.size);
    return e.forEach(function(o) {
      n[++t] = o;
    }), n;
  }
  var E4 = 1, S4 = 2, _4 = "[object Boolean]", k4 = "[object Date]", $4 = "[object Error]", N4 = "[object Map]", T4 = "[object Number]", O4 = "[object RegExp]", M4 = "[object Set]", I4 = "[object String]", P4 = "[object Symbol]", A4 = "[object ArrayBuffer]", R4 = "[object DataView]", ag = so ? so.prototype : void 0, Ed = ag ? ag.valueOf : void 0;
  function x4(e, t, n, o, r, s, l) {
    switch (n) {
      case R4:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
          return !1;
        e = e.buffer, t = t.buffer;
      case A4:
        return !(e.byteLength != t.byteLength || !s(new Gu(e), new Gu(t)));
      case _4:
      case k4:
      case T4:
        return hi(+e, +t);
      case $4:
        return e.name == t.name && e.message == t.message;
      case O4:
      case I4:
        return e == t + "";
      case N4:
        var a = C4;
      case M4:
        var u = o & E4;
        if (a || (a = wh), e.size != t.size && !u)
          return !1;
        var c = l.get(e);
        if (c)
          return c == t;
        o |= S4, l.set(e, t);
        var f = D1(a(e), a(t), o, r, s, l);
        return l.delete(e), f;
      case P4:
        if (Ed)
          return Ed.call(e) == Ed.call(t);
    }
    return !1;
  }
  var D4 = 1, L4 = Object.prototype, V4 = L4.hasOwnProperty;
  function B4(e, t, n, o, r, s) {
    var l = n & D4, a = Ef(e), u = a.length, c = Ef(t), f = c.length;
    if (u != f && !l)
      return !1;
    for (var d = u; d--; ) {
      var p = a[d];
      if (!(l ? p in t : V4.call(t, p)))
        return !1;
    }
    var h = s.get(e), m = s.get(t);
    if (h && m)
      return h == t && m == e;
    var v = !0;
    s.set(e, t), s.set(t, e);
    for (var g = l; ++d < u; ) {
      p = a[d];
      var y = e[p], w = t[p];
      if (o)
        var b = l ? o(w, y, p, t, e, s) : o(y, w, p, e, t, s);
      if (!(b === void 0 ? y === w || r(y, w, n, o, s) : b)) {
        v = !1;
        break;
      }
      g || (g = p == "constructor");
    }
    if (v && !g) {
      var C = e.constructor, _ = t.constructor;
      C != _ && "constructor" in e && "constructor" in t && !(typeof C == "function" && C instanceof C && typeof _ == "function" && _ instanceof _) && (v = !1);
    }
    return s.delete(e), s.delete(t), v;
  }
  var F4 = 1, ig = "[object Arguments]", ug = "[object Array]", Li = "[object Object]", H4 = Object.prototype, cg = H4.hasOwnProperty;
  function z4(e, t, n, o, r, s) {
    var l = Nn(e), a = Nn(t), u = l ? ug : Fa(e), c = a ? ug : Fa(t);
    u = u == ig ? Li : u, c = c == ig ? Li : c;
    var f = u == Li, d = c == Li, p = u == c;
    if (p && La(e)) {
      if (!La(t))
        return !1;
      l = !0, f = !1;
    }
    if (p && !f)
      return s || (s = new wo()), l || fh(e) ? D1(e, t, n, o, r, s) : x4(e, t, u, n, o, r, s);
    if (!(n & F4)) {
      var h = f && cg.call(e, "__wrapped__"), m = d && cg.call(t, "__wrapped__");
      if (h || m) {
        var v = h ? e.value() : e, g = m ? t.value() : t;
        return s || (s = new wo()), r(v, g, n, o, s);
      }
    }
    return p ? (s || (s = new wo()), B4(e, t, n, o, r, s)) : !1;
  }
  function Vc(e, t, n, o, r) {
    return e === t ? !0 : e == null || t == null || !Lo(e) && !Lo(t) ? e !== e && t !== t : z4(e, t, n, o, Vc, r);
  }
  var K4 = 1, j4 = 2;
  function W4(e, t, n, o) {
    var r = n.length, s = r, l = !o;
    if (e == null)
      return !s;
    for (e = Object(e); r--; ) {
      var a = n[r];
      if (l && a[2] ? a[1] !== e[a[0]] : !(a[0] in e))
        return !1;
    }
    for (; ++r < s; ) {
      a = n[r];
      var u = a[0], c = e[u], f = a[1];
      if (l && a[2]) {
        if (c === void 0 && !(u in e))
          return !1;
      } else {
        var d = new wo();
        if (o)
          var p = o(c, f, u, e, t, d);
        if (!(p === void 0 ? Vc(f, c, K4 | j4, o, d) : p))
          return !1;
      }
    }
    return !0;
  }
  function L1(e) {
    return e === e && !Tn(e);
  }
  function U4(e) {
    for (var t = mi(e), n = t.length; n--; ) {
      var o = t[n], r = e[o];
      t[n] = [o, r, L1(r)];
    }
    return t;
  }
  function V1(e, t) {
    return function(n) {
      return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
    };
  }
  function q4(e) {
    var t = U4(e);
    return t.length == 1 && t[0][2] ? V1(t[0][0], t[0][1]) : function(n) {
      return n === e || W4(n, e, t);
    };
  }
  function Y4(e, t) {
    return e != null && t in Object(e);
  }
  function G4(e, t, n) {
    t = Lc(t, e);
    for (var o = -1, r = t.length, s = !1; ++o < r; ) {
      var l = yi(t[o]);
      if (!(s = e != null && n(e, l)))
        break;
      e = e[l];
    }
    return s || ++o != r ? s : (r = e == null ? 0 : e.length, !!r && uh(r) && Ac(l, r) && (Nn(e) || Da(e)));
  }
  function B1(e, t) {
    return e != null && G4(e, t, Y4);
  }
  var X4 = 1, J4 = 2;
  function Z4(e, t) {
    return ph(e) && L1(t) ? V1(yi(e), t) : function(n) {
      var o = Kt(n, e);
      return o === void 0 && o === t ? B1(n, e) : Vc(t, o, X4 | J4);
    };
  }
  function Q4(e) {
    return function(t) {
      return t == null ? void 0 : t[e];
    };
  }
  function eP(e) {
    return function(t) {
      return hh(t, e);
    };
  }
  function tP(e) {
    return ph(e) ? Q4(yi(e)) : eP(e);
  }
  function nP(e) {
    return typeof e == "function" ? e : e == null ? sh : typeof e == "object" ? Nn(e) ? Z4(e[0], e[1]) : q4(e) : tP(e);
  }
  function oP(e) {
    return function(t, n, o) {
      for (var r = -1, s = Object(t), l = o(t), a = l.length; a--; ) {
        var u = l[e ? a : ++r];
        if (n(s[u], u, s) === !1)
          break;
      }
      return t;
    };
  }
  var rP = oP();
  const F1 = rP;
  function sP(e, t) {
    return e && F1(e, t, mi);
  }
  function lP(e, t) {
    return function(n, o) {
      if (n == null)
        return n;
      if (!jl(n))
        return e(n, o);
      for (var r = n.length, s = t ? r : -1, l = Object(n); (t ? s-- : ++s < r) && o(l[s], s, l) !== !1; )
        ;
      return n;
    };
  }
  var aP = lP(sP);
  const iP = aP;
  var uP = function() {
    return ko.Date.now();
  };
  const Sd = uP;
  var cP = "Expected a function", dP = Math.max, fP = Math.min;
  function On(e, t, n) {
    var o, r, s, l, a, u, c = 0, f = !1, d = !1, p = !0;
    if (typeof e != "function")
      throw new TypeError(cP);
    t = Vm(t) || 0, Tn(n) && (f = !!n.leading, d = "maxWait" in n, s = d ? dP(Vm(n.maxWait) || 0, t) : s, p = "trailing" in n ? !!n.trailing : p);
    function h(k) {
      var O = o, T = r;
      return o = r = void 0, c = k, l = e.apply(T, O), l;
    }
    function m(k) {
      return c = k, a = setTimeout(y, t), f ? h(k) : l;
    }
    function v(k) {
      var O = k - u, T = k - c, P = t - O;
      return d ? fP(P, s - T) : P;
    }
    function g(k) {
      var O = k - u, T = k - c;
      return u === void 0 || O >= t || O < 0 || d && T >= s;
    }
    function y() {
      var k = Sd();
      if (g(k))
        return w(k);
      a = setTimeout(y, v(k));
    }
    function w(k) {
      return a = void 0, p && o ? h(k) : (o = r = void 0, l);
    }
    function b() {
      a !== void 0 && clearTimeout(a), c = 0, o = u = r = a = void 0;
    }
    function C() {
      return a === void 0 ? l : w(Sd());
    }
    function _() {
      var k = Sd(), O = g(k);
      if (o = arguments, r = this, u = k, O) {
        if (a === void 0)
          return m(u);
        if (d)
          return clearTimeout(a), a = setTimeout(y, t), h(u);
      }
      return a === void 0 && (a = setTimeout(y, t)), l;
    }
    return _.cancel = b, _.flush = C, _;
  }
  function kf(e, t, n) {
    (n !== void 0 && !hi(e[t], n) || n === void 0 && !(t in e)) && ah(e, t, n);
  }
  function H1(e) {
    return Lo(e) && jl(e);
  }
  function $f(e, t) {
    if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
      return e[t];
  }
  function pP(e) {
    return vi(e, gi(e));
  }
  function hP(e, t, n, o, r, s, l) {
    var a = $f(e, n), u = $f(t, n), c = l.get(u);
    if (c) {
      kf(e, n, c);
      return;
    }
    var f = s ? s(a, u, n + "", e, t, l) : void 0, d = f === void 0;
    if (d) {
      var p = Nn(u), h = !p && La(u), m = !p && !h && fh(u);
      f = u, p || h || m ? Nn(a) ? f = a : H1(a) ? f = h1(a) : h ? (d = !1, f = $1(u, !0)) : m ? (d = !1, f = M1(u, !0)) : f = [] : MM(u) || Da(u) ? (f = a, Da(a) ? f = pP(a) : (!Tn(a) || lh(a)) && (f = I1(u))) : d = !1;
    }
    d && (l.set(u, f), r(f, u, o, s, l), l.delete(u)), kf(e, n, f);
  }
  function z1(e, t, n, o, r) {
    e !== t && F1(t, function(s, l) {
      if (r || (r = new wo()), Tn(s))
        hP(e, t, l, n, z1, o, r);
      else {
        var a = o ? o($f(e, l), s, l + "", e, t, r) : void 0;
        a === void 0 && (a = s), kf(e, l, a);
      }
    }, gi);
  }
  function vP(e, t, n) {
    for (var o = -1, r = e == null ? 0 : e.length; ++o < r; )
      if (n(t, e[o]))
        return !0;
    return !1;
  }
  function mP(e, t) {
    var n = -1, o = jl(e) ? Array(e.length) : [];
    return iP(e, function(r, s, l) {
      o[++n] = t(r, s, l);
    }), o;
  }
  function gP(e, t) {
    var n = Nn(e) ? f1 : mP;
    return n(e, nP(t));
  }
  function yP(e, t) {
    return bi(gP(e, t), 1);
  }
  var bP = 1 / 0;
  function wP(e) {
    var t = e == null ? 0 : e.length;
    return t ? bi(e, bP) : [];
  }
  function Xu(e) {
    for (var t = -1, n = e == null ? 0 : e.length, o = {}; ++t < n; ) {
      var r = e[t];
      o[r[0]] = r[1];
    }
    return o;
  }
  function qn(e, t) {
    return Vc(e, t);
  }
  function nn(e) {
    return e == null;
  }
  function CP(e) {
    return e === void 0;
  }
  var EP = KT(function(e, t, n) {
    z1(e, t, n);
  });
  const K1 = EP;
  function j1(e, t, n, o) {
    if (!Tn(e))
      return e;
    t = Lc(t, e);
    for (var r = -1, s = t.length, l = s - 1, a = e; a != null && ++r < s; ) {
      var u = yi(t[r]), c = n;
      if (u === "__proto__" || u === "constructor" || u === "prototype")
        return e;
      if (r != l) {
        var f = a[u];
        c = o ? o(f, u, a) : void 0, c === void 0 && (c = Tn(f) ? f : Ac(t[r + 1]) ? [] : {});
      }
      ih(a, u, c), a = a[u];
    }
    return e;
  }
  function SP(e, t, n) {
    for (var o = -1, r = t.length, s = {}; ++o < r; ) {
      var l = t[o], a = hh(e, l);
      n(a, l) && j1(s, Lc(l, e), a);
    }
    return s;
  }
  function _P(e, t) {
    return SP(e, t, function(n, o) {
      return B1(e, o);
    });
  }
  var kP = SM(function(e, t) {
    return e == null ? {} : _P(e, t);
  });
  const tr = kP;
  function $P(e, t, n) {
    return e == null ? e : j1(e, t, n);
  }
  var NP = "Expected a function";
  function Ss(e, t, n) {
    var o = !0, r = !0;
    if (typeof e != "function")
      throw new TypeError(NP);
    return Tn(n) && (o = "leading" in n ? !!n.leading : o, r = "trailing" in n ? !!n.trailing : r), On(e, t, {
      leading: o,
      maxWait: t,
      trailing: r
    });
  }
  var TP = 1 / 0, OP = cl && 1 / wh(new cl([, -0]))[1] == TP ? function(e) {
    return new cl(e);
  } : CT;
  const MP = OP;
  var IP = 200;
  function PP(e, t, n) {
    var o = -1, r = DT, s = e.length, l = !0, a = [], u = a;
    if (n)
      l = !1, r = vP;
    else if (s >= IP) {
      var c = t ? null : MP(e);
      if (c)
        return wh(c);
      l = !1, r = x1, u = new Ha();
    } else
      u = t ? [] : a;
    e:
      for (; ++o < s; ) {
        var f = e[o], d = t ? t(f) : f;
        if (f = n || f !== 0 ? f : 0, l && d === d) {
          for (var p = u.length; p--; )
            if (u[p] === d)
              continue e;
          t && u.push(d), a.push(f);
        } else
          r(u, d, n) || (u !== a && u.push(d), a.push(f));
      }
    return a;
  }
  var AP = g1(function(e) {
    return PP(bi(e, 1, H1, !0));
  });
  const _d = AP, pn = (e) => e === void 0, Qn = (e) => !e && e !== 0 || De(e) && e.length === 0 || rt(e) && !Object.keys(e).length, So = (e) => typeof Element > "u" ? !1 : e instanceof Element, RP = (e) => nn(e), xP = (e) => et(e) ? !Number.isNaN(Number(e)) : !1, W1 = (e = "") => e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), Po = (e) => xr(e), za = (e) => Object.keys(e), DP = (e) => Object.entries(e), iu = (e, t, n) => ({
    get value() {
      return Kt(e, t, n);
    },
    set value(o) {
      $P(e, t, o);
    }
  });
  class U1 extends Error {
    constructor(t) {
      super(t), this.name = "ElementPlusError";
    }
  }
  function Yt(e, t) {
    throw new U1(`[${e}] ${t}`);
  }
  function yt(e, t) {
    if (process.env.NODE_ENV !== "production") {
      const n = et(e) ? new U1(`[${e}] ${t}`) : e;
      console.warn(n);
    }
  }
  const LP = "utils/dom/style", q1 = (e = "") => e.split(" ").filter((t) => !!t.trim()), Co = (e, t) => {
    if (!e || !t)
      return !1;
    if (t.includes(" "))
      throw new Error("className should not contain space.");
    return e.classList.contains(t);
  }, Ao = (e, t) => {
    !e || !t.trim() || e.classList.add(...q1(t));
  }, Dn = (e, t) => {
    !e || !t.trim() || e.classList.remove(...q1(t));
  }, Qo = (e, t) => {
    var n;
    if (!bt || !e || !t)
      return "";
    let o = ro(t);
    o === "float" && (o = "cssFloat");
    try {
      const r = e.style[o];
      if (r)
        return r;
      const s = (n = document.defaultView) == null ? void 0 : n.getComputedStyle(e, "");
      return s ? s[o] : "";
    } catch {
      return e.style[o];
    }
  };
  function Jt(e, t = "px") {
    if (!e)
      return "";
    if (Xe(e) || xP(e))
      return `${e}${t}`;
    if (et(e))
      return e;
    yt(LP, "binding value must be a string or number");
  }
  const VP = (e, t) => {
    if (!bt)
      return !1;
    const n = {
      undefined: "overflow",
      true: "overflow-y",
      false: "overflow-x"
    }[String(t)], o = Qo(e, n);
    return ["scroll", "auto", "overlay"].some((r) => o.includes(r));
  }, Ch = (e, t) => {
    if (!bt)
      return;
    let n = e;
    for (; n; ) {
      if ([window, document, document.documentElement].includes(n))
        return window;
      if (VP(n, t))
        return n;
      n = n.parentNode;
    }
    return n;
  };
  let Vi;
  const Y1 = (e) => {
    var t;
    if (!bt)
      return 0;
    if (Vi !== void 0)
      return Vi;
    const n = document.createElement("div");
    n.className = `${e}-scrollbar__wrap`, n.style.visibility = "hidden", n.style.width = "100px", n.style.position = "absolute", n.style.top = "-9999px", document.body.appendChild(n);
    const o = n.offsetWidth;
    n.style.overflow = "scroll";
    const r = document.createElement("div");
    r.style.width = "100%", n.appendChild(r);
    const s = r.offsetWidth;
    return (t = n.parentNode) == null || t.removeChild(n), Vi = o - s, Vi;
  };
  function G1(e, t) {
    if (!bt)
      return;
    if (!t) {
      e.scrollTop = 0;
      return;
    }
    const n = [];
    let o = t.offsetParent;
    for (; o !== null && e !== o && e.contains(o); )
      n.push(o), o = o.offsetParent;
    const r = t.offsetTop + n.reduce((u, c) => u + c.offsetTop, 0), s = r + t.offsetHeight, l = e.scrollTop, a = l + e.clientHeight;
    r < l ? e.scrollTop = r : s > a && (e.scrollTop = s - e.clientHeight);
  }
  /*! Element Plus Icons Vue v2.1.0 */
  var Ot = (e, t) => {
    let n = e.__vccOpts || e;
    for (let [o, r] of t)
      n[o] = r;
    return n;
  }, BP = {
    name: "ArrowDown"
  }, FP = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, HP = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
    },
    null,
    -1
  ), zP = [
    HP
  ];
  function KP(e, t, n, o, r, s) {
    return S(), V("svg", FP, zP);
  }
  var qr = /* @__PURE__ */ Ot(BP, [["render", KP], ["__file", "arrow-down.vue"]]), jP = {
    name: "ArrowLeft"
  }, WP = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, UP = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
    },
    null,
    -1
  ), qP = [
    UP
  ];
  function YP(e, t, n, o, r, s) {
    return S(), V("svg", WP, qP);
  }
  var Br = /* @__PURE__ */ Ot(jP, [["render", YP], ["__file", "arrow-left.vue"]]), GP = {
    name: "ArrowRight"
  }, XP = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, JP = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
    },
    null,
    -1
  ), ZP = [
    JP
  ];
  function QP(e, t, n, o, r, s) {
    return S(), V("svg", XP, ZP);
  }
  var kn = /* @__PURE__ */ Ot(GP, [["render", QP], ["__file", "arrow-right.vue"]]), e3 = {
    name: "ArrowUp"
  }, t3 = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, n3 = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
    },
    null,
    -1
  ), o3 = [
    n3
  ];
  function r3(e, t, n, o, r, s) {
    return S(), V("svg", t3, o3);
  }
  var Bc = /* @__PURE__ */ Ot(e3, [["render", r3], ["__file", "arrow-up.vue"]]), s3 = {
    name: "Back"
  }, l3 = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, a3 = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64z"
    },
    null,
    -1
  ), i3 = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312L237.248 512z"
    },
    null,
    -1
  ), u3 = [
    a3,
    i3
  ];
  function c3(e, t, n, o, r, s) {
    return S(), V("svg", l3, u3);
  }
  var d3 = /* @__PURE__ */ Ot(s3, [["render", c3], ["__file", "back.vue"]]), f3 = {
    name: "Calendar"
  }, p3 = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, h3 = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64H128zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0v32zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64z"
    },
    null,
    -1
  ), v3 = [
    h3
  ];
  function m3(e, t, n, o, r, s) {
    return S(), V("svg", p3, v3);
  }
  var g3 = /* @__PURE__ */ Ot(f3, [["render", m3], ["__file", "calendar.vue"]]), y3 = {
    name: "CaretRight"
  }, b3 = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, w3 = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M384 192v640l384-320.064z"
    },
    null,
    -1
  ), C3 = [
    w3
  ];
  function E3(e, t, n, o, r, s) {
    return S(), V("svg", b3, C3);
  }
  var X1 = /* @__PURE__ */ Ot(y3, [["render", E3], ["__file", "caret-right.vue"]]), S3 = {
    name: "CaretTop"
  }, _3 = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, k3 = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M512 320 192 704h639.936z"
    },
    null,
    -1
  ), $3 = [
    k3
  ];
  function N3(e, t, n, o, r, s) {
    return S(), V("svg", _3, $3);
  }
  var T3 = /* @__PURE__ */ Ot(S3, [["render", N3], ["__file", "caret-top.vue"]]), O3 = {
    name: "Check"
  }, M3 = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, I3 = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
    },
    null,
    -1
  ), P3 = [
    I3
  ];
  function A3(e, t, n, o, r, s) {
    return S(), V("svg", M3, P3);
  }
  var wi = /* @__PURE__ */ Ot(O3, [["render", A3], ["__file", "check.vue"]]), R3 = {
    name: "CircleCheckFilled"
  }, x3 = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, D3 = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
    },
    null,
    -1
  ), L3 = [
    D3
  ];
  function V3(e, t, n, o, r, s) {
    return S(), V("svg", x3, L3);
  }
  var B3 = /* @__PURE__ */ Ot(R3, [["render", V3], ["__file", "circle-check-filled.vue"]]), F3 = {
    name: "CircleCheck"
  }, H3 = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, z3 = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
    },
    null,
    -1
  ), K3 = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
    },
    null,
    -1
  ), j3 = [
    z3,
    K3
  ];
  function W3(e, t, n, o, r, s) {
    return S(), V("svg", H3, j3);
  }
  var Eh = /* @__PURE__ */ Ot(F3, [["render", W3], ["__file", "circle-check.vue"]]), U3 = {
    name: "CircleCloseFilled"
  }, q3 = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, Y3 = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
    },
    null,
    -1
  ), G3 = [
    Y3
  ];
  function X3(e, t, n, o, r, s) {
    return S(), V("svg", q3, G3);
  }
  var Sh = /* @__PURE__ */ Ot(U3, [["render", X3], ["__file", "circle-close-filled.vue"]]), J3 = {
    name: "CircleClose"
  }, Z3 = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, Q3 = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
    },
    null,
    -1
  ), eA = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
    },
    null,
    -1
  ), tA = [
    Q3,
    eA
  ];
  function nA(e, t, n, o, r, s) {
    return S(), V("svg", Z3, tA);
  }
  var Yr = /* @__PURE__ */ Ot(J3, [["render", nA], ["__file", "circle-close.vue"]]), oA = {
    name: "Clock"
  }, rA = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, sA = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
    },
    null,
    -1
  ), lA = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32z"
    },
    null,
    -1
  ), aA = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32z"
    },
    null,
    -1
  ), iA = [
    sA,
    lA,
    aA
  ];
  function uA(e, t, n, o, r, s) {
    return S(), V("svg", rA, iA);
  }
  var J1 = /* @__PURE__ */ Ot(oA, [["render", uA], ["__file", "clock.vue"]]), cA = {
    name: "Close"
  }, dA = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, fA = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
    },
    null,
    -1
  ), pA = [
    fA
  ];
  function hA(e, t, n, o, r, s) {
    return S(), V("svg", dA, pA);
  }
  var _o = /* @__PURE__ */ Ot(cA, [["render", hA], ["__file", "close.vue"]]), vA = {
    name: "DArrowLeft"
  }, mA = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, gA = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
    },
    null,
    -1
  ), yA = [
    gA
  ];
  function bA(e, t, n, o, r, s) {
    return S(), V("svg", mA, yA);
  }
  var $l = /* @__PURE__ */ Ot(vA, [["render", bA], ["__file", "d-arrow-left.vue"]]), wA = {
    name: "DArrowRight"
  }, CA = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, EA = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688zm-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
    },
    null,
    -1
  ), SA = [
    EA
  ];
  function _A(e, t, n, o, r, s) {
    return S(), V("svg", CA, SA);
  }
  var Nl = /* @__PURE__ */ Ot(wA, [["render", _A], ["__file", "d-arrow-right.vue"]]), kA = {
    name: "Delete"
  }, $A = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, NA = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
    },
    null,
    -1
  ), TA = [
    NA
  ];
  function OA(e, t, n, o, r, s) {
    return S(), V("svg", $A, TA);
  }
  var MA = /* @__PURE__ */ Ot(kA, [["render", OA], ["__file", "delete.vue"]]), IA = {
    name: "Document"
  }, PA = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, AA = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"
    },
    null,
    -1
  ), RA = [
    AA
  ];
  function xA(e, t, n, o, r, s) {
    return S(), V("svg", PA, RA);
  }
  var DA = /* @__PURE__ */ Ot(IA, [["render", xA], ["__file", "document.vue"]]), LA = {
    name: "FullScreen"
  }, VA = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, BA = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64l-192 .192zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64v-.064z"
    },
    null,
    -1
  ), FA = [
    BA
  ];
  function HA(e, t, n, o, r, s) {
    return S(), V("svg", VA, FA);
  }
  var zA = /* @__PURE__ */ Ot(LA, [["render", HA], ["__file", "full-screen.vue"]]), KA = {
    name: "Hide"
  }, jA = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, WA = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
    },
    null,
    -1
  ), UA = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
    },
    null,
    -1
  ), qA = [
    WA,
    UA
  ];
  function YA(e, t, n, o, r, s) {
    return S(), V("svg", jA, qA);
  }
  var GA = /* @__PURE__ */ Ot(KA, [["render", YA], ["__file", "hide.vue"]]), XA = {
    name: "InfoFilled"
  }, JA = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, ZA = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
    },
    null,
    -1
  ), QA = [
    ZA
  ];
  function eR(e, t, n, o, r, s) {
    return S(), V("svg", JA, QA);
  }
  var _h = /* @__PURE__ */ Ot(XA, [["render", eR], ["__file", "info-filled.vue"]]), tR = {
    name: "Loading"
  }, nR = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, oR = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
    },
    null,
    -1
  ), rR = [
    oR
  ];
  function sR(e, t, n, o, r, s) {
    return S(), V("svg", nR, rR);
  }
  var Gr = /* @__PURE__ */ Ot(tR, [["render", sR], ["__file", "loading.vue"]]), lR = {
    name: "Minus"
  }, aR = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, iR = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z"
    },
    null,
    -1
  ), uR = [
    iR
  ];
  function cR(e, t, n, o, r, s) {
    return S(), V("svg", aR, uR);
  }
  var dR = /* @__PURE__ */ Ot(lR, [["render", cR], ["__file", "minus.vue"]]), fR = {
    name: "MoreFilled"
  }, pR = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, hR = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224z"
    },
    null,
    -1
  ), vR = [
    hR
  ];
  function mR(e, t, n, o, r, s) {
    return S(), V("svg", pR, vR);
  }
  var dg = /* @__PURE__ */ Ot(fR, [["render", mR], ["__file", "more-filled.vue"]]), gR = {
    name: "More"
  }, yR = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, bR = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96z"
    },
    null,
    -1
  ), wR = [
    bR
  ];
  function CR(e, t, n, o, r, s) {
    return S(), V("svg", yR, wR);
  }
  var ER = /* @__PURE__ */ Ot(gR, [["render", CR], ["__file", "more.vue"]]), SR = {
    name: "PictureFilled"
  }, _R = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, kR = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32H96zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112zM256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384z"
    },
    null,
    -1
  ), $R = [
    kR
  ];
  function NR(e, t, n, o, r, s) {
    return S(), V("svg", _R, $R);
  }
  var TR = /* @__PURE__ */ Ot(SR, [["render", NR], ["__file", "picture-filled.vue"]]), OR = {
    name: "Plus"
  }, MR = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, IR = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z"
    },
    null,
    -1
  ), PR = [
    IR
  ];
  function AR(e, t, n, o, r, s) {
    return S(), V("svg", MR, PR);
  }
  var Z1 = /* @__PURE__ */ Ot(OR, [["render", AR], ["__file", "plus.vue"]]), RR = {
    name: "QuestionFilled"
  }, xR = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, DR = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
    },
    null,
    -1
  ), LR = [
    DR
  ];
  function VR(e, t, n, o, r, s) {
    return S(), V("svg", xR, LR);
  }
  var BR = /* @__PURE__ */ Ot(RR, [["render", VR], ["__file", "question-filled.vue"]]), FR = {
    name: "RefreshLeft"
  }, HR = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, zR = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
    },
    null,
    -1
  ), KR = [
    zR
  ];
  function jR(e, t, n, o, r, s) {
    return S(), V("svg", HR, KR);
  }
  var WR = /* @__PURE__ */ Ot(FR, [["render", jR], ["__file", "refresh-left.vue"]]), UR = {
    name: "RefreshRight"
  }, qR = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, YR = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
    },
    null,
    -1
  ), GR = [
    YR
  ];
  function XR(e, t, n, o, r, s) {
    return S(), V("svg", qR, GR);
  }
  var JR = /* @__PURE__ */ Ot(UR, [["render", XR], ["__file", "refresh-right.vue"]]), ZR = {
    name: "ScaleToOriginal"
  }, QR = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, ex = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zM512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412zM512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512z"
    },
    null,
    -1
  ), tx = [
    ex
  ];
  function nx(e, t, n, o, r, s) {
    return S(), V("svg", QR, tx);
  }
  var ox = /* @__PURE__ */ Ot(ZR, [["render", nx], ["__file", "scale-to-original.vue"]]), rx = {
    name: "Search"
  }, sx = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, lx = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704z"
    },
    null,
    -1
  ), ax = [
    lx
  ];
  function ix(e, t, n, o, r, s) {
    return S(), V("svg", sx, ax);
  }
  var ux = /* @__PURE__ */ Ot(rx, [["render", ix], ["__file", "search.vue"]]), cx = {
    name: "SortDown"
  }, dx = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, fx = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0z"
    },
    null,
    -1
  ), px = [
    fx
  ];
  function hx(e, t, n, o, r, s) {
    return S(), V("svg", dx, px);
  }
  var vx = /* @__PURE__ */ Ot(cx, [["render", hx], ["__file", "sort-down.vue"]]), mx = {
    name: "SortUp"
  }, gx = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, yx = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248z"
    },
    null,
    -1
  ), bx = [
    yx
  ];
  function wx(e, t, n, o, r, s) {
    return S(), V("svg", gx, bx);
  }
  var Cx = /* @__PURE__ */ Ot(mx, [["render", wx], ["__file", "sort-up.vue"]]), Ex = {
    name: "StarFilled"
  }, Sx = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, _x = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M283.84 867.84 512 747.776l228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72z"
    },
    null,
    -1
  ), kx = [
    _x
  ];
  function $x(e, t, n, o, r, s) {
    return S(), V("svg", Sx, kx);
  }
  var Bi = /* @__PURE__ */ Ot(Ex, [["render", $x], ["__file", "star-filled.vue"]]), Nx = {
    name: "Star"
  }, Tx = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, Ox = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72L512 747.84zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
    },
    null,
    -1
  ), Mx = [
    Ox
  ];
  function Ix(e, t, n, o, r, s) {
    return S(), V("svg", Tx, Mx);
  }
  var Px = /* @__PURE__ */ Ot(Nx, [["render", Ix], ["__file", "star.vue"]]), Ax = {
    name: "SuccessFilled"
  }, Rx = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, xx = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
    },
    null,
    -1
  ), Dx = [
    xx
  ];
  function Lx(e, t, n, o, r, s) {
    return S(), V("svg", Rx, Dx);
  }
  var Q1 = /* @__PURE__ */ Ot(Ax, [["render", Lx], ["__file", "success-filled.vue"]]), Vx = {
    name: "View"
  }, Bx = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, Fx = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
    },
    null,
    -1
  ), Hx = [
    Fx
  ];
  function zx(e, t, n, o, r, s) {
    return S(), V("svg", Bx, Hx);
  }
  var Kx = /* @__PURE__ */ Ot(Vx, [["render", zx], ["__file", "view.vue"]]), jx = {
    name: "WarningFilled"
  }, Wx = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, Ux = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
    },
    null,
    -1
  ), qx = [
    Ux
  ];
  function Yx(e, t, n, o, r, s) {
    return S(), V("svg", Wx, qx);
  }
  var Fc = /* @__PURE__ */ Ot(jx, [["render", Yx], ["__file", "warning-filled.vue"]]), Gx = {
    name: "ZoomIn"
  }, Xx = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, Jx = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z"
    },
    null,
    -1
  ), Zx = [
    Jx
  ];
  function Qx(e, t, n, o, r, s) {
    return S(), V("svg", Xx, Zx);
  }
  var ew = /* @__PURE__ */ Ot(Gx, [["render", Qx], ["__file", "zoom-in.vue"]]), eD = {
    name: "ZoomOut"
  }, tD = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, nD = /* @__PURE__ */ H(
    "path",
    {
      fill: "currentColor",
      d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zM352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64z"
    },
    null,
    -1
  ), oD = [
    nD
  ];
  function rD(e, t, n, o, r, s) {
    return S(), V("svg", tD, oD);
  }
  var sD = /* @__PURE__ */ Ot(eD, [["render", rD], ["__file", "zoom-out.vue"]]);
  const tw = "__epPropKey", le = (e) => e, lD = (e) => rt(e) && !!e[tw], $o = (e, t) => {
    if (!rt(e) || lD(e))
      return e;
    const { values: n, required: o, default: r, type: s, validator: l } = e, u = {
      type: s,
      required: !!o,
      validator: n || l ? (c) => {
        let f = !1, d = [];
        if (n && (d = Array.from(n), ht(e, "default") && d.push(r), f || (f = d.includes(c))), l && (f || (f = l(c))), !f && d.length > 0) {
          const p = [...new Set(d)].map((h) => JSON.stringify(h)).join(", ");
          Ue(`Invalid prop: validation failed${t ? ` for prop "${t}"` : ""}. Expected one of [${p}], got value ${JSON.stringify(c)}.`);
        }
        return f;
      } : void 0,
      [tw]: !0
    };
    return ht(e, "default") && (u.default = r), u;
  }, Ie = (e) => Xu(Object.entries(e).map(([t, n]) => [
    t,
    $o(n, t)
  ])), Vt = le([
    String,
    Object,
    Function
  ]), nw = {
    Close: _o
  }, kh = {
    Close: _o,
    SuccessFilled: Q1,
    InfoFilled: _h,
    WarningFilled: Fc,
    CircleCloseFilled: Sh
  }, Fr = {
    success: Q1,
    warning: Fc,
    error: Sh,
    info: _h
  }, ow = {
    validating: Gr,
    success: Eh,
    error: Yr
  }, ut = (e, t) => {
    if (e.install = (n) => {
      for (const o of [e, ...Object.values(t != null ? t : {})])
        n.component(o.name, o);
    }, t)
      for (const [n, o] of Object.entries(t))
        e[n] = o;
    return e;
  }, rw = (e, t) => (e.install = (n) => {
    e._context = n._context, n.config.globalProperties[t] = e;
  }, e), aD = (e, t) => (e.install = (n) => {
    n.directive(t, e);
  }, e), Gt = (e) => (e.install = Nt, e), Hc = (...e) => (t) => {
    e.forEach((n) => {
      Ge(n) ? n(t) : n.value = t;
    });
  }, We = {
    tab: "Tab",
    enter: "Enter",
    space: "Space",
    left: "ArrowLeft",
    up: "ArrowUp",
    right: "ArrowRight",
    down: "ArrowDown",
    esc: "Escape",
    delete: "Delete",
    backspace: "Backspace",
    numpadEnter: "NumpadEnter",
    pageUp: "PageUp",
    pageDown: "PageDown",
    home: "Home",
    end: "End"
  }, iD = [
    "year",
    "month",
    "date",
    "dates",
    "week",
    "datetime",
    "datetimerange",
    "daterange",
    "monthrange"
  ], kd = [
    "sun",
    "mon",
    "tue",
    "wed",
    "thu",
    "fri",
    "sat"
  ], dt = "update:modelValue", Ft = "change", $n = "input", fg = Symbol("INSTALLED_KEY"), zo = ["", "default", "small", "large"], uD = {
    large: 40,
    default: 32,
    small: 24
  }, cD = (e) => uD[e || "default"], zc = (e) => ["", ...zo].includes(e), dD = "utils/vue/vnode";
  var Zn = /* @__PURE__ */ ((e) => (e[e.TEXT = 1] = "TEXT", e[e.CLASS = 2] = "CLASS", e[e.STYLE = 4] = "STYLE", e[e.PROPS = 8] = "PROPS", e[e.FULL_PROPS = 16] = "FULL_PROPS", e[e.HYDRATE_EVENTS = 32] = "HYDRATE_EVENTS", e[e.STABLE_FRAGMENT = 64] = "STABLE_FRAGMENT", e[e.KEYED_FRAGMENT = 128] = "KEYED_FRAGMENT", e[e.UNKEYED_FRAGMENT = 256] = "UNKEYED_FRAGMENT", e[e.NEED_PATCH = 512] = "NEED_PATCH", e[e.DYNAMIC_SLOTS = 1024] = "DYNAMIC_SLOTS", e[e.HOISTED = -1] = "HOISTED", e[e.BAIL = -2] = "BAIL", e))(Zn || {});
  function Nf(e) {
    return Bt(e) && e.type === ze;
  }
  function fD(e) {
    return Bt(e) && e.type === en;
  }
  function pD(e) {
    return Bt(e) && !Nf(e) && !fD(e);
  }
  const hD = (e) => {
    if (!Bt(e))
      return yt(dD, "[getNormalizedProps] must be a VNode"), {};
    const t = e.props || {}, n = (Bt(e.type) ? e.type.props : void 0) || {}, o = {};
    return Object.keys(n).forEach((r) => {
      ht(n[r], "default") && (o[r] = n[r].default);
    }), Object.keys(t).forEach((r) => {
      o[ro(r)] = t[r];
    }), o;
  }, vD = (e) => {
    if (!De(e) || e.length > 1)
      throw new Error("expect to receive a single Vue element child");
    return e[0];
  }, dl = (e) => {
    const t = De(e) ? e : [e], n = [];
    return t.forEach((o) => {
      var r;
      De(o) ? n.push(...dl(o)) : Bt(o) && De(o.children) ? n.push(...dl(o.children)) : (n.push(o), Bt(o) && ((r = o.component) == null ? void 0 : r.subTree) && n.push(...dl(o.component.subTree)));
    }), n;
  }, pg = (e) => [...new Set(e)], or = (e) => !e && e !== 0 ? [] : Array.isArray(e) ? e : [e], sw = () => bt && /firefox/i.test(window.navigator.userAgent), Kc = (e) => /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi.test(e), Ka = (e) => bt ? window.requestAnimationFrame(e) : setTimeout(e, 16), jc = (e) => bt ? window.cancelAnimationFrame(e) : clearTimeout(e), Wc = () => Math.floor(Math.random() * 1e4), jt = (e) => e, mD = ["class", "style"], gD = /^on[A-Z]/, $h = (e = {}) => {
    const { excludeListeners: t = !1, excludeKeys: n } = e, o = E(() => ((n == null ? void 0 : n.value) || []).concat(mD)), r = it();
    return r ? E(() => {
      var s;
      return Xu(Object.entries((s = r.proxy) == null ? void 0 : s.$attrs).filter(([l]) => !o.value.includes(l) && !(t && gD.test(l))));
    }) : (yt("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function"), E(() => ({})));
  }, Vo = ({ from: e, replacement: t, scope: n, version: o, ref: r, type: s = "API" }, l) => {
    me(() => i(l), (a) => {
      a && yt(n, `[${s}] ${e} is about to be deprecated in version ${o}, please use ${t} instead.
For more detail, please visit: ${r}
`);
    }, {
      immediate: !0
    });
  }, lw = (e, t, n) => {
    let o = {
      offsetX: 0,
      offsetY: 0
    };
    const r = (a) => {
      const u = a.clientX, c = a.clientY, { offsetX: f, offsetY: d } = o, p = e.value.getBoundingClientRect(), h = p.left, m = p.top, v = p.width, g = p.height, y = document.documentElement.clientWidth, w = document.documentElement.clientHeight, b = -h + f, C = -m + d, _ = y - h - v + f, k = w - m - g + d, O = (P) => {
        const A = Math.min(Math.max(f + P.clientX - u, b), _), L = Math.min(Math.max(d + P.clientY - c, C), k);
        o = {
          offsetX: A,
          offsetY: L
        }, e.value.style.transform = `translate(${Jt(A)}, ${Jt(L)})`;
      }, T = () => {
        document.removeEventListener("mousemove", O), document.removeEventListener("mouseup", T);
      };
      document.addEventListener("mousemove", O), document.addEventListener("mouseup", T);
    }, s = () => {
      t.value && e.value && t.value.addEventListener("mousedown", r);
    }, l = () => {
      t.value && e.value && t.value.removeEventListener("mousedown", r);
    };
    st(() => {
      xn(() => {
        n.value ? s() : l();
      });
    }), zt(() => {
      l();
    });
  }, yD = (e) => ({
    focus: () => {
      var t, n;
      (n = (t = e.value) == null ? void 0 : t.focus) == null || n.call(t);
    }
  });
  var bD = {
    name: "en",
    el: {
      colorpicker: {
        confirm: "OK",
        clear: "Clear",
        defaultLabel: "color picker",
        description: "current color is {color}. press enter to select a new color."
      },
      datepicker: {
        now: "Now",
        today: "Today",
        cancel: "Cancel",
        clear: "Clear",
        confirm: "OK",
        dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
        monthTablePrompt: "Use the arrow keys and enter to select the month",
        yearTablePrompt: "Use the arrow keys and enter to select the year",
        selectedDate: "Selected date",
        selectDate: "Select date",
        selectTime: "Select time",
        startDate: "Start Date",
        startTime: "Start Time",
        endDate: "End Date",
        endTime: "End Time",
        prevYear: "Previous Year",
        nextYear: "Next Year",
        prevMonth: "Previous Month",
        nextMonth: "Next Month",
        year: "",
        month1: "January",
        month2: "February",
        month3: "March",
        month4: "April",
        month5: "May",
        month6: "June",
        month7: "July",
        month8: "August",
        month9: "September",
        month10: "October",
        month11: "November",
        month12: "December",
        week: "week",
        weeks: {
          sun: "Sun",
          mon: "Mon",
          tue: "Tue",
          wed: "Wed",
          thu: "Thu",
          fri: "Fri",
          sat: "Sat"
        },
        weeksFull: {
          sun: "Sunday",
          mon: "Monday",
          tue: "Tuesday",
          wed: "Wednesday",
          thu: "Thursday",
          fri: "Friday",
          sat: "Saturday"
        },
        months: {
          jan: "Jan",
          feb: "Feb",
          mar: "Mar",
          apr: "Apr",
          may: "May",
          jun: "Jun",
          jul: "Jul",
          aug: "Aug",
          sep: "Sep",
          oct: "Oct",
          nov: "Nov",
          dec: "Dec"
        }
      },
      inputNumber: {
        decrease: "decrease number",
        increase: "increase number"
      },
      select: {
        loading: "Loading",
        noMatch: "No matching data",
        noData: "No data",
        placeholder: "Select"
      },
      dropdown: {
        toggleDropdown: "Toggle Dropdown"
      },
      cascader: {
        noMatch: "No matching data",
        loading: "Loading",
        placeholder: "Select",
        noData: "No data"
      },
      pagination: {
        goto: "Go to",
        pagesize: "/page",
        total: "Total {total}",
        pageClassifier: "",
        page: "Page",
        prev: "Go to previous page",
        next: "Go to next page",
        currentPage: "page {pager}",
        prevPages: "Previous {pager} pages",
        nextPages: "Next {pager} pages",
        deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
      },
      dialog: {
        close: "Close this dialog"
      },
      drawer: {
        close: "Close this dialog"
      },
      messagebox: {
        title: "Message",
        confirm: "OK",
        cancel: "Cancel",
        error: "Illegal input",
        close: "Close this dialog"
      },
      upload: {
        deleteTip: "press delete to remove",
        delete: "Delete",
        preview: "Preview",
        continue: "Continue"
      },
      slider: {
        defaultLabel: "slider between {min} and {max}",
        defaultRangeStartLabel: "pick start value",
        defaultRangeEndLabel: "pick end value"
      },
      table: {
        emptyText: "No Data",
        confirmFilter: "Confirm",
        resetFilter: "Reset",
        clearFilter: "All",
        sumText: "Sum"
      },
      tree: {
        emptyText: "No Data"
      },
      transfer: {
        noMatch: "No matching data",
        noData: "No data",
        titles: ["List 1", "List 2"],
        filterPlaceholder: "Enter keyword",
        noCheckedFormat: "{total} items",
        hasCheckedFormat: "{checked}/{total} checked"
      },
      image: {
        error: "FAILED"
      },
      pageHeader: {
        title: "Back"
      },
      popconfirm: {
        confirmButtonText: "Yes",
        cancelButtonText: "No"
      }
    }
  };
  const wD = (e) => (t, n) => CD(t, n, i(e)), CD = (e, t, n) => Kt(n, e, e).replace(/\{(\w+)\}/g, (o, r) => {
    var s;
    return `${(s = t == null ? void 0 : t[r]) != null ? s : `{${r}}`}`;
  }), ED = (e) => {
    const t = E(() => i(e).name), n = Pt(e) ? e : I(e);
    return {
      lang: t,
      locale: n,
      t: wD(e)
    };
  }, aw = Symbol("localeContextKey"), St = (e) => {
    const t = e || Be(aw, I());
    return ED(E(() => t.value || bD));
  }, Ju = "el", SD = "is-", ns = (e, t, n, o, r) => {
    let s = `${e}-${t}`;
    return n && (s += `-${n}`), o && (s += `__${o}`), r && (s += `--${r}`), s;
  }, iw = Symbol("namespaceContextKey"), Nh = (e) => {
    const t = e || Be(iw, I(Ju));
    return E(() => i(t) || Ju);
  }, ge = (e, t) => {
    const n = Nh(t);
    return {
      namespace: n,
      b: (v = "") => ns(n.value, e, v, "", ""),
      e: (v) => v ? ns(n.value, e, "", v, "") : "",
      m: (v) => v ? ns(n.value, e, "", "", v) : "",
      be: (v, g) => v && g ? ns(n.value, e, v, g, "") : "",
      em: (v, g) => v && g ? ns(n.value, e, "", v, g) : "",
      bm: (v, g) => v && g ? ns(n.value, e, v, "", g) : "",
      bem: (v, g, y) => v && g && y ? ns(n.value, e, v, g, y) : "",
      is: (v, ...g) => {
        const y = g.length >= 1 ? g[0] : !0;
        return v && y ? `${SD}${v}` : "";
      },
      cssVar: (v) => {
        const g = {};
        for (const y in v)
          v[y] && (g[`--${n.value}-${y}`] = v[y]);
        return g;
      },
      cssVarName: (v) => `--${n.value}-${v}`,
      cssVarBlock: (v) => {
        const g = {};
        for (const y in v)
          v[y] && (g[`--${n.value}-${e}-${y}`] = v[y]);
        return g;
      },
      cssVarBlockName: (v) => `--${n.value}-${e}-${v}`
    };
  }, uw = (e, t = {}) => {
    Pt(e) || Yt("[useLockscreen]", "You need to pass a ref param to this function");
    const n = t.ns || ge("popup"), o = s0(() => n.bm("parent", "hidden"));
    if (!bt || Co(document.body, o.value))
      return;
    let r = 0, s = !1, l = "0";
    const a = () => {
      setTimeout(() => {
        Dn(document == null ? void 0 : document.body, o.value), s && document && (document.body.style.width = l);
      }, 200);
    };
    me(e, (u) => {
      if (!u) {
        a();
        return;
      }
      s = !Co(document.body, o.value), s && (l = document.body.style.width), r = Y1(n.namespace.value);
      const c = document.documentElement.clientHeight < document.body.scrollHeight, f = Qo(document.body, "overflowY");
      r > 0 && (c || f === "scroll") && s && (document.body.style.width = `calc(100% - ${r}px)`), Ao(document.body, o.value);
    }), Hb(() => a());
  }, _D = $o({
    type: le(Boolean),
    default: null
  }), kD = $o({
    type: le(Function)
  }), $D = (e) => {
    const t = `update:${e}`, n = `onUpdate:${e}`, o = [t], r = {
      [e]: _D,
      [n]: kD
    };
    return {
      useModelToggle: ({
        indicator: l,
        toggleReason: a,
        shouldHideWhenRouteChanges: u,
        shouldProceed: c,
        onShow: f,
        onHide: d
      }) => {
        const p = it(), { emit: h } = p, m = p.props, v = E(() => Ge(m[n])), g = E(() => m[e] === null), y = (O) => {
          l.value !== !0 && (l.value = !0, a && (a.value = O), Ge(f) && f(O));
        }, w = (O) => {
          l.value !== !1 && (l.value = !1, a && (a.value = O), Ge(d) && d(O));
        }, b = (O) => {
          if (m.disabled === !0 || Ge(c) && !c())
            return;
          const T = v.value && bt;
          T && h(t, !0), (g.value || !T) && y(O);
        }, C = (O) => {
          if (m.disabled === !0 || !bt)
            return;
          const T = v.value && bt;
          T && h(t, !1), (g.value || !T) && w(O);
        }, _ = (O) => {
          !tn(O) || (m.disabled && O ? v.value && h(t, !1) : l.value !== O && (O ? y() : w()));
        }, k = () => {
          l.value ? C() : b();
        };
        return me(() => m[e], _), u && p.appContext.config.globalProperties.$route !== void 0 && me(() => ({
          ...p.proxy.$route
        }), () => {
          u.value && l.value && C();
        }), st(() => {
          _(m[e]);
        }), {
          hide: C,
          show: b,
          toggle: k,
          hasUpdateHandler: v
        };
      },
      useModelToggleProps: r,
      useModelToggleEmits: o
    };
  }, cw = (e) => {
    const t = it();
    return E(() => {
      var n, o;
      return (o = (n = t == null ? void 0 : t.proxy) == null ? void 0 : n.$props) == null ? void 0 : o[e];
    });
  };
  var Ln = "top", lo = "bottom", ao = "right", Vn = "left", Th = "auto", Ci = [Ln, lo, ao, Vn], Tl = "start", ja = "end", ND = "clippingParents", dw = "viewport", Ql = "popper", TD = "reference", hg = /* @__PURE__ */ Ci.reduce(function(e, t) {
    return e.concat([t + "-" + Tl, t + "-" + ja]);
  }, []), Bs = /* @__PURE__ */ [].concat(Ci, [Th]).reduce(function(e, t) {
    return e.concat([t, t + "-" + Tl, t + "-" + ja]);
  }, []), OD = "beforeRead", MD = "read", ID = "afterRead", PD = "beforeMain", AD = "main", RD = "afterMain", xD = "beforeWrite", DD = "write", LD = "afterWrite", VD = [OD, MD, ID, PD, AD, RD, xD, DD, LD];
  function Bo(e) {
    return e ? (e.nodeName || "").toLowerCase() : null;
  }
  function Gn(e) {
    if (e == null)
      return window;
    if (e.toString() !== "[object Window]") {
      var t = e.ownerDocument;
      return t && t.defaultView || window;
    }
    return e;
  }
  function Is(e) {
    var t = Gn(e).Element;
    return e instanceof t || e instanceof Element;
  }
  function no(e) {
    var t = Gn(e).HTMLElement;
    return e instanceof t || e instanceof HTMLElement;
  }
  function Oh(e) {
    if (typeof ShadowRoot > "u")
      return !1;
    var t = Gn(e).ShadowRoot;
    return e instanceof t || e instanceof ShadowRoot;
  }
  function BD(e) {
    var t = e.state;
    Object.keys(t.elements).forEach(function(n) {
      var o = t.styles[n] || {}, r = t.attributes[n] || {}, s = t.elements[n];
      !no(s) || !Bo(s) || (Object.assign(s.style, o), Object.keys(r).forEach(function(l) {
        var a = r[l];
        a === !1 ? s.removeAttribute(l) : s.setAttribute(l, a === !0 ? "" : a);
      }));
    });
  }
  function FD(e) {
    var t = e.state, n = {
      popper: {
        position: t.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
      Object.keys(t.elements).forEach(function(o) {
        var r = t.elements[o], s = t.attributes[o] || {}, l = Object.keys(t.styles.hasOwnProperty(o) ? t.styles[o] : n[o]), a = l.reduce(function(u, c) {
          return u[c] = "", u;
        }, {});
        !no(r) || !Bo(r) || (Object.assign(r.style, a), Object.keys(s).forEach(function(u) {
          r.removeAttribute(u);
        }));
      });
    };
  }
  const HD = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: BD,
    effect: FD,
    requires: ["computeStyles"]
  };
  function xo(e) {
    return e.split("-")[0];
  }
  var _s = Math.max, Zu = Math.min, Ol = Math.round;
  function Tf() {
    var e = navigator.userAgentData;
    return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
      return t.brand + "/" + t.version;
    }).join(" ") : navigator.userAgent;
  }
  function fw() {
    return !/^((?!chrome|android).)*safari/i.test(Tf());
  }
  function Ml(e, t, n) {
    t === void 0 && (t = !1), n === void 0 && (n = !1);
    var o = e.getBoundingClientRect(), r = 1, s = 1;
    t && no(e) && (r = e.offsetWidth > 0 && Ol(o.width) / e.offsetWidth || 1, s = e.offsetHeight > 0 && Ol(o.height) / e.offsetHeight || 1);
    var l = Is(e) ? Gn(e) : window, a = l.visualViewport, u = !fw() && n, c = (o.left + (u && a ? a.offsetLeft : 0)) / r, f = (o.top + (u && a ? a.offsetTop : 0)) / s, d = o.width / r, p = o.height / s;
    return {
      width: d,
      height: p,
      top: f,
      right: c + d,
      bottom: f + p,
      left: c,
      x: c,
      y: f
    };
  }
  function Mh(e) {
    var t = Ml(e), n = e.offsetWidth, o = e.offsetHeight;
    return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - o) <= 1 && (o = t.height), {
      x: e.offsetLeft,
      y: e.offsetTop,
      width: n,
      height: o
    };
  }
  function pw(e, t) {
    var n = t.getRootNode && t.getRootNode();
    if (e.contains(t))
      return !0;
    if (n && Oh(n)) {
      var o = t;
      do {
        if (o && e.isSameNode(o))
          return !0;
        o = o.parentNode || o.host;
      } while (o);
    }
    return !1;
  }
  function ar(e) {
    return Gn(e).getComputedStyle(e);
  }
  function zD(e) {
    return ["table", "td", "th"].indexOf(Bo(e)) >= 0;
  }
  function Xr(e) {
    return ((Is(e) ? e.ownerDocument : e.document) || window.document).documentElement;
  }
  function Uc(e) {
    return Bo(e) === "html" ? e : e.assignedSlot || e.parentNode || (Oh(e) ? e.host : null) || Xr(e);
  }
  function vg(e) {
    return !no(e) || ar(e).position === "fixed" ? null : e.offsetParent;
  }
  function KD(e) {
    var t = /firefox/i.test(Tf()), n = /Trident/i.test(Tf());
    if (n && no(e)) {
      var o = ar(e);
      if (o.position === "fixed")
        return null;
    }
    var r = Uc(e);
    for (Oh(r) && (r = r.host); no(r) && ["html", "body"].indexOf(Bo(r)) < 0; ) {
      var s = ar(r);
      if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none")
        return r;
      r = r.parentNode;
    }
    return null;
  }
  function Ei(e) {
    for (var t = Gn(e), n = vg(e); n && zD(n) && ar(n).position === "static"; )
      n = vg(n);
    return n && (Bo(n) === "html" || Bo(n) === "body" && ar(n).position === "static") ? t : n || KD(e) || t;
  }
  function Ih(e) {
    return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
  }
  function ma(e, t, n) {
    return _s(e, Zu(t, n));
  }
  function jD(e, t, n) {
    var o = ma(e, t, n);
    return o > n ? n : o;
  }
  function hw() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function vw(e) {
    return Object.assign({}, hw(), e);
  }
  function mw(e, t) {
    return t.reduce(function(n, o) {
      return n[o] = e, n;
    }, {});
  }
  var WD = function(t, n) {
    return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
      placement: n.placement
    })) : t, vw(typeof t != "number" ? t : mw(t, Ci));
  };
  function UD(e) {
    var t, n = e.state, o = e.name, r = e.options, s = n.elements.arrow, l = n.modifiersData.popperOffsets, a = xo(n.placement), u = Ih(a), c = [Vn, ao].indexOf(a) >= 0, f = c ? "height" : "width";
    if (!(!s || !l)) {
      var d = WD(r.padding, n), p = Mh(s), h = u === "y" ? Ln : Vn, m = u === "y" ? lo : ao, v = n.rects.reference[f] + n.rects.reference[u] - l[u] - n.rects.popper[f], g = l[u] - n.rects.reference[u], y = Ei(s), w = y ? u === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, b = v / 2 - g / 2, C = d[h], _ = w - p[f] - d[m], k = w / 2 - p[f] / 2 + b, O = ma(C, k, _), T = u;
      n.modifiersData[o] = (t = {}, t[T] = O, t.centerOffset = O - k, t);
    }
  }
  function qD(e) {
    var t = e.state, n = e.options, o = n.element, r = o === void 0 ? "[data-popper-arrow]" : o;
    r != null && (typeof r == "string" && (r = t.elements.popper.querySelector(r), !r) || !pw(t.elements.popper, r) || (t.elements.arrow = r));
  }
  const YD = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: UD,
    effect: qD,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function Il(e) {
    return e.split("-")[1];
  }
  var GD = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function XD(e, t) {
    var n = e.x, o = e.y, r = t.devicePixelRatio || 1;
    return {
      x: Ol(n * r) / r || 0,
      y: Ol(o * r) / r || 0
    };
  }
  function mg(e) {
    var t, n = e.popper, o = e.popperRect, r = e.placement, s = e.variation, l = e.offsets, a = e.position, u = e.gpuAcceleration, c = e.adaptive, f = e.roundOffsets, d = e.isFixed, p = l.x, h = p === void 0 ? 0 : p, m = l.y, v = m === void 0 ? 0 : m, g = typeof f == "function" ? f({
      x: h,
      y: v
    }) : {
      x: h,
      y: v
    };
    h = g.x, v = g.y;
    var y = l.hasOwnProperty("x"), w = l.hasOwnProperty("y"), b = Vn, C = Ln, _ = window;
    if (c) {
      var k = Ei(n), O = "clientHeight", T = "clientWidth";
      if (k === Gn(n) && (k = Xr(n), ar(k).position !== "static" && a === "absolute" && (O = "scrollHeight", T = "scrollWidth")), k = k, r === Ln || (r === Vn || r === ao) && s === ja) {
        C = lo;
        var P = d && k === _ && _.visualViewport ? _.visualViewport.height : k[O];
        v -= P - o.height, v *= u ? 1 : -1;
      }
      if (r === Vn || (r === Ln || r === lo) && s === ja) {
        b = ao;
        var A = d && k === _ && _.visualViewport ? _.visualViewport.width : k[T];
        h -= A - o.width, h *= u ? 1 : -1;
      }
    }
    var L = Object.assign({
      position: a
    }, c && GD), D = f === !0 ? XD({
      x: h,
      y: v
    }, Gn(n)) : {
      x: h,
      y: v
    };
    if (h = D.x, v = D.y, u) {
      var B;
      return Object.assign({}, L, (B = {}, B[C] = w ? "0" : "", B[b] = y ? "0" : "", B.transform = (_.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + v + "px)" : "translate3d(" + h + "px, " + v + "px, 0)", B));
    }
    return Object.assign({}, L, (t = {}, t[C] = w ? v + "px" : "", t[b] = y ? h + "px" : "", t.transform = "", t));
  }
  function JD(e) {
    var t = e.state, n = e.options, o = n.gpuAcceleration, r = o === void 0 ? !0 : o, s = n.adaptive, l = s === void 0 ? !0 : s, a = n.roundOffsets, u = a === void 0 ? !0 : a, c = {
      placement: xo(t.placement),
      variation: Il(t.placement),
      popper: t.elements.popper,
      popperRect: t.rects.popper,
      gpuAcceleration: r,
      isFixed: t.options.strategy === "fixed"
    };
    t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, mg(Object.assign({}, c, {
      offsets: t.modifiersData.popperOffsets,
      position: t.options.strategy,
      adaptive: l,
      roundOffsets: u
    })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, mg(Object.assign({}, c, {
      offsets: t.modifiersData.arrow,
      position: "absolute",
      adaptive: !1,
      roundOffsets: u
    })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
      "data-popper-placement": t.placement
    });
  }
  const ZD = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: JD,
    data: {}
  };
  var Fi = {
    passive: !0
  };
  function QD(e) {
    var t = e.state, n = e.instance, o = e.options, r = o.scroll, s = r === void 0 ? !0 : r, l = o.resize, a = l === void 0 ? !0 : l, u = Gn(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
    return s && c.forEach(function(f) {
      f.addEventListener("scroll", n.update, Fi);
    }), a && u.addEventListener("resize", n.update, Fi), function() {
      s && c.forEach(function(f) {
        f.removeEventListener("scroll", n.update, Fi);
      }), a && u.removeEventListener("resize", n.update, Fi);
    };
  }
  const e8 = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function() {
    },
    effect: QD,
    data: {}
  };
  var t8 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function uu(e) {
    return e.replace(/left|right|bottom|top/g, function(t) {
      return t8[t];
    });
  }
  var n8 = {
    start: "end",
    end: "start"
  };
  function gg(e) {
    return e.replace(/start|end/g, function(t) {
      return n8[t];
    });
  }
  function Ph(e) {
    var t = Gn(e), n = t.pageXOffset, o = t.pageYOffset;
    return {
      scrollLeft: n,
      scrollTop: o
    };
  }
  function Ah(e) {
    return Ml(Xr(e)).left + Ph(e).scrollLeft;
  }
  function o8(e, t) {
    var n = Gn(e), o = Xr(e), r = n.visualViewport, s = o.clientWidth, l = o.clientHeight, a = 0, u = 0;
    if (r) {
      s = r.width, l = r.height;
      var c = fw();
      (c || !c && t === "fixed") && (a = r.offsetLeft, u = r.offsetTop);
    }
    return {
      width: s,
      height: l,
      x: a + Ah(e),
      y: u
    };
  }
  function r8(e) {
    var t, n = Xr(e), o = Ph(e), r = (t = e.ownerDocument) == null ? void 0 : t.body, s = _s(n.scrollWidth, n.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), l = _s(n.scrollHeight, n.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), a = -o.scrollLeft + Ah(e), u = -o.scrollTop;
    return ar(r || n).direction === "rtl" && (a += _s(n.clientWidth, r ? r.clientWidth : 0) - s), {
      width: s,
      height: l,
      x: a,
      y: u
    };
  }
  function Rh(e) {
    var t = ar(e), n = t.overflow, o = t.overflowX, r = t.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + r + o);
  }
  function gw(e) {
    return ["html", "body", "#document"].indexOf(Bo(e)) >= 0 ? e.ownerDocument.body : no(e) && Rh(e) ? e : gw(Uc(e));
  }
  function ga(e, t) {
    var n;
    t === void 0 && (t = []);
    var o = gw(e), r = o === ((n = e.ownerDocument) == null ? void 0 : n.body), s = Gn(o), l = r ? [s].concat(s.visualViewport || [], Rh(o) ? o : []) : o, a = t.concat(l);
    return r ? a : a.concat(ga(Uc(l)));
  }
  function Of(e) {
    return Object.assign({}, e, {
      left: e.x,
      top: e.y,
      right: e.x + e.width,
      bottom: e.y + e.height
    });
  }
  function s8(e, t) {
    var n = Ml(e, !1, t === "fixed");
    return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n;
  }
  function yg(e, t, n) {
    return t === dw ? Of(o8(e, n)) : Is(t) ? s8(t, n) : Of(r8(Xr(e)));
  }
  function l8(e) {
    var t = ga(Uc(e)), n = ["absolute", "fixed"].indexOf(ar(e).position) >= 0, o = n && no(e) ? Ei(e) : e;
    return Is(o) ? t.filter(function(r) {
      return Is(r) && pw(r, o) && Bo(r) !== "body";
    }) : [];
  }
  function a8(e, t, n, o) {
    var r = t === "clippingParents" ? l8(e) : [].concat(t), s = [].concat(r, [n]), l = s[0], a = s.reduce(function(u, c) {
      var f = yg(e, c, o);
      return u.top = _s(f.top, u.top), u.right = Zu(f.right, u.right), u.bottom = Zu(f.bottom, u.bottom), u.left = _s(f.left, u.left), u;
    }, yg(e, l, o));
    return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
  }
  function yw(e) {
    var t = e.reference, n = e.element, o = e.placement, r = o ? xo(o) : null, s = o ? Il(o) : null, l = t.x + t.width / 2 - n.width / 2, a = t.y + t.height / 2 - n.height / 2, u;
    switch (r) {
      case Ln:
        u = {
          x: l,
          y: t.y - n.height
        };
        break;
      case lo:
        u = {
          x: l,
          y: t.y + t.height
        };
        break;
      case ao:
        u = {
          x: t.x + t.width,
          y: a
        };
        break;
      case Vn:
        u = {
          x: t.x - n.width,
          y: a
        };
        break;
      default:
        u = {
          x: t.x,
          y: t.y
        };
    }
    var c = r ? Ih(r) : null;
    if (c != null) {
      var f = c === "y" ? "height" : "width";
      switch (s) {
        case Tl:
          u[c] = u[c] - (t[f] / 2 - n[f] / 2);
          break;
        case ja:
          u[c] = u[c] + (t[f] / 2 - n[f] / 2);
          break;
      }
    }
    return u;
  }
  function Wa(e, t) {
    t === void 0 && (t = {});
    var n = t, o = n.placement, r = o === void 0 ? e.placement : o, s = n.strategy, l = s === void 0 ? e.strategy : s, a = n.boundary, u = a === void 0 ? ND : a, c = n.rootBoundary, f = c === void 0 ? dw : c, d = n.elementContext, p = d === void 0 ? Ql : d, h = n.altBoundary, m = h === void 0 ? !1 : h, v = n.padding, g = v === void 0 ? 0 : v, y = vw(typeof g != "number" ? g : mw(g, Ci)), w = p === Ql ? TD : Ql, b = e.rects.popper, C = e.elements[m ? w : p], _ = a8(Is(C) ? C : C.contextElement || Xr(e.elements.popper), u, f, l), k = Ml(e.elements.reference), O = yw({
      reference: k,
      element: b,
      strategy: "absolute",
      placement: r
    }), T = Of(Object.assign({}, b, O)), P = p === Ql ? T : k, A = {
      top: _.top - P.top + y.top,
      bottom: P.bottom - _.bottom + y.bottom,
      left: _.left - P.left + y.left,
      right: P.right - _.right + y.right
    }, L = e.modifiersData.offset;
    if (p === Ql && L) {
      var D = L[r];
      Object.keys(A).forEach(function(B) {
        var F = [ao, lo].indexOf(B) >= 0 ? 1 : -1, W = [Ln, lo].indexOf(B) >= 0 ? "y" : "x";
        A[B] += D[W] * F;
      });
    }
    return A;
  }
  function i8(e, t) {
    t === void 0 && (t = {});
    var n = t, o = n.placement, r = n.boundary, s = n.rootBoundary, l = n.padding, a = n.flipVariations, u = n.allowedAutoPlacements, c = u === void 0 ? Bs : u, f = Il(o), d = f ? a ? hg : hg.filter(function(m) {
      return Il(m) === f;
    }) : Ci, p = d.filter(function(m) {
      return c.indexOf(m) >= 0;
    });
    p.length === 0 && (p = d);
    var h = p.reduce(function(m, v) {
      return m[v] = Wa(e, {
        placement: v,
        boundary: r,
        rootBoundary: s,
        padding: l
      })[xo(v)], m;
    }, {});
    return Object.keys(h).sort(function(m, v) {
      return h[m] - h[v];
    });
  }
  function u8(e) {
    if (xo(e) === Th)
      return [];
    var t = uu(e);
    return [gg(e), t, gg(t)];
  }
  function c8(e) {
    var t = e.state, n = e.options, o = e.name;
    if (!t.modifiersData[o]._skip) {
      for (var r = n.mainAxis, s = r === void 0 ? !0 : r, l = n.altAxis, a = l === void 0 ? !0 : l, u = n.fallbackPlacements, c = n.padding, f = n.boundary, d = n.rootBoundary, p = n.altBoundary, h = n.flipVariations, m = h === void 0 ? !0 : h, v = n.allowedAutoPlacements, g = t.options.placement, y = xo(g), w = y === g, b = u || (w || !m ? [uu(g)] : u8(g)), C = [g].concat(b).reduce(function(pe, J) {
        return pe.concat(xo(J) === Th ? i8(t, {
          placement: J,
          boundary: f,
          rootBoundary: d,
          padding: c,
          flipVariations: m,
          allowedAutoPlacements: v
        }) : J);
      }, []), _ = t.rects.reference, k = t.rects.popper, O = /* @__PURE__ */ new Map(), T = !0, P = C[0], A = 0; A < C.length; A++) {
        var L = C[A], D = xo(L), B = Il(L) === Tl, F = [Ln, lo].indexOf(D) >= 0, W = F ? "width" : "height", x = Wa(t, {
          placement: L,
          boundary: f,
          rootBoundary: d,
          altBoundary: p,
          padding: c
        }), N = F ? B ? ao : Vn : B ? lo : Ln;
        _[W] > k[W] && (N = uu(N));
        var R = uu(N), M = [];
        if (s && M.push(x[D] <= 0), a && M.push(x[N] <= 0, x[R] <= 0), M.every(function(pe) {
          return pe;
        })) {
          P = L, T = !1;
          break;
        }
        O.set(L, M);
      }
      if (T)
        for (var j = m ? 3 : 1, te = function(J) {
          var ee = C.find(function(ne) {
            var Y = O.get(ne);
            if (Y)
              return Y.slice(0, J).every(function(re) {
                return re;
              });
          });
          if (ee)
            return P = ee, "break";
        }, U = j; U > 0; U--) {
          var Z = te(U);
          if (Z === "break")
            break;
        }
      t.placement !== P && (t.modifiersData[o]._skip = !0, t.placement = P, t.reset = !0);
    }
  }
  const d8 = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: c8,
    requiresIfExists: ["offset"],
    data: {
      _skip: !1
    }
  };
  function bg(e, t, n) {
    return n === void 0 && (n = {
      x: 0,
      y: 0
    }), {
      top: e.top - t.height - n.y,
      right: e.right - t.width + n.x,
      bottom: e.bottom - t.height + n.y,
      left: e.left - t.width - n.x
    };
  }
  function wg(e) {
    return [Ln, ao, lo, Vn].some(function(t) {
      return e[t] >= 0;
    });
  }
  function f8(e) {
    var t = e.state, n = e.name, o = t.rects.reference, r = t.rects.popper, s = t.modifiersData.preventOverflow, l = Wa(t, {
      elementContext: "reference"
    }), a = Wa(t, {
      altBoundary: !0
    }), u = bg(l, o), c = bg(a, r, s), f = wg(u), d = wg(c);
    t.modifiersData[n] = {
      referenceClippingOffsets: u,
      popperEscapeOffsets: c,
      isReferenceHidden: f,
      hasPopperEscaped: d
    }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
      "data-popper-reference-hidden": f,
      "data-popper-escaped": d
    });
  }
  const p8 = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: f8
  };
  function h8(e, t, n) {
    var o = xo(e), r = [Vn, Ln].indexOf(o) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, t, {
      placement: e
    })) : n, l = s[0], a = s[1];
    return l = l || 0, a = (a || 0) * r, [Vn, ao].indexOf(o) >= 0 ? {
      x: a,
      y: l
    } : {
      x: l,
      y: a
    };
  }
  function v8(e) {
    var t = e.state, n = e.options, o = e.name, r = n.offset, s = r === void 0 ? [0, 0] : r, l = Bs.reduce(function(f, d) {
      return f[d] = h8(d, t.rects, s), f;
    }, {}), a = l[t.placement], u = a.x, c = a.y;
    t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += u, t.modifiersData.popperOffsets.y += c), t.modifiersData[o] = l;
  }
  const m8 = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: v8
  };
  function g8(e) {
    var t = e.state, n = e.name;
    t.modifiersData[n] = yw({
      reference: t.rects.reference,
      element: t.rects.popper,
      strategy: "absolute",
      placement: t.placement
    });
  }
  const y8 = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: g8,
    data: {}
  };
  function b8(e) {
    return e === "x" ? "y" : "x";
  }
  function w8(e) {
    var t = e.state, n = e.options, o = e.name, r = n.mainAxis, s = r === void 0 ? !0 : r, l = n.altAxis, a = l === void 0 ? !1 : l, u = n.boundary, c = n.rootBoundary, f = n.altBoundary, d = n.padding, p = n.tether, h = p === void 0 ? !0 : p, m = n.tetherOffset, v = m === void 0 ? 0 : m, g = Wa(t, {
      boundary: u,
      rootBoundary: c,
      padding: d,
      altBoundary: f
    }), y = xo(t.placement), w = Il(t.placement), b = !w, C = Ih(y), _ = b8(C), k = t.modifiersData.popperOffsets, O = t.rects.reference, T = t.rects.popper, P = typeof v == "function" ? v(Object.assign({}, t.rects, {
      placement: t.placement
    })) : v, A = typeof P == "number" ? {
      mainAxis: P,
      altAxis: P
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, P), L = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, D = {
      x: 0,
      y: 0
    };
    if (!!k) {
      if (s) {
        var B, F = C === "y" ? Ln : Vn, W = C === "y" ? lo : ao, x = C === "y" ? "height" : "width", N = k[C], R = N + g[F], M = N - g[W], j = h ? -T[x] / 2 : 0, te = w === Tl ? O[x] : T[x], U = w === Tl ? -T[x] : -O[x], Z = t.elements.arrow, pe = h && Z ? Mh(Z) : {
          width: 0,
          height: 0
        }, J = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : hw(), ee = J[F], ne = J[W], Y = ma(0, O[x], pe[x]), re = b ? O[x] / 2 - j - Y - ee - A.mainAxis : te - Y - ee - A.mainAxis, ce = b ? -O[x] / 2 + j + Y + ne + A.mainAxis : U + Y + ne + A.mainAxis, Te = t.elements.arrow && Ei(t.elements.arrow), Pe = Te ? C === "y" ? Te.clientTop || 0 : Te.clientLeft || 0 : 0, z = (B = L == null ? void 0 : L[C]) != null ? B : 0, Q = N + re - z - Pe, de = N + ce - z, Oe = ma(h ? Zu(R, Q) : R, N, h ? _s(M, de) : M);
        k[C] = Oe, D[C] = Oe - N;
      }
      if (a) {
        var ae, Ee = C === "x" ? Ln : Vn, we = C === "x" ? lo : ao, Se = k[_], _e = _ === "y" ? "height" : "width", ke = Se + g[Ee], Re = Se - g[we], fe = [Ln, Vn].indexOf(y) !== -1, Ae = (ae = L == null ? void 0 : L[_]) != null ? ae : 0, qe = fe ? ke : Se - O[_e] - T[_e] - Ae + A.altAxis, tt = fe ? Se + O[_e] + T[_e] - Ae - A.altAxis : Re, Je = h && fe ? jD(qe, Se, tt) : ma(h ? qe : ke, Se, h ? tt : Re);
        k[_] = Je, D[_] = Je - Se;
      }
      t.modifiersData[o] = D;
    }
  }
  const C8 = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: w8,
    requiresIfExists: ["offset"]
  };
  function E8(e) {
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTop
    };
  }
  function S8(e) {
    return e === Gn(e) || !no(e) ? Ph(e) : E8(e);
  }
  function _8(e) {
    var t = e.getBoundingClientRect(), n = Ol(t.width) / e.offsetWidth || 1, o = Ol(t.height) / e.offsetHeight || 1;
    return n !== 1 || o !== 1;
  }
  function k8(e, t, n) {
    n === void 0 && (n = !1);
    var o = no(t), r = no(t) && _8(t), s = Xr(t), l = Ml(e, r, n), a = {
      scrollLeft: 0,
      scrollTop: 0
    }, u = {
      x: 0,
      y: 0
    };
    return (o || !o && !n) && ((Bo(t) !== "body" || Rh(s)) && (a = S8(t)), no(t) ? (u = Ml(t, !0), u.x += t.clientLeft, u.y += t.clientTop) : s && (u.x = Ah(s))), {
      x: l.left + a.scrollLeft - u.x,
      y: l.top + a.scrollTop - u.y,
      width: l.width,
      height: l.height
    };
  }
  function $8(e) {
    var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), o = [];
    e.forEach(function(s) {
      t.set(s.name, s);
    });
    function r(s) {
      n.add(s.name);
      var l = [].concat(s.requires || [], s.requiresIfExists || []);
      l.forEach(function(a) {
        if (!n.has(a)) {
          var u = t.get(a);
          u && r(u);
        }
      }), o.push(s);
    }
    return e.forEach(function(s) {
      n.has(s.name) || r(s);
    }), o;
  }
  function N8(e) {
    var t = $8(e);
    return VD.reduce(function(n, o) {
      return n.concat(t.filter(function(r) {
        return r.phase === o;
      }));
    }, []);
  }
  function T8(e) {
    var t;
    return function() {
      return t || (t = new Promise(function(n) {
        Promise.resolve().then(function() {
          t = void 0, n(e());
        });
      })), t;
    };
  }
  function O8(e) {
    var t = e.reduce(function(n, o) {
      var r = n[o.name];
      return n[o.name] = r ? Object.assign({}, r, o, {
        options: Object.assign({}, r.options, o.options),
        data: Object.assign({}, r.data, o.data)
      }) : o, n;
    }, {});
    return Object.keys(t).map(function(n) {
      return t[n];
    });
  }
  var Cg = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function Eg() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return !t.some(function(o) {
      return !(o && typeof o.getBoundingClientRect == "function");
    });
  }
  function M8(e) {
    e === void 0 && (e = {});
    var t = e, n = t.defaultModifiers, o = n === void 0 ? [] : n, r = t.defaultOptions, s = r === void 0 ? Cg : r;
    return function(a, u, c) {
      c === void 0 && (c = s);
      var f = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, Cg, s),
        modifiersData: {},
        elements: {
          reference: a,
          popper: u
        },
        attributes: {},
        styles: {}
      }, d = [], p = !1, h = {
        state: f,
        setOptions: function(y) {
          var w = typeof y == "function" ? y(f.options) : y;
          v(), f.options = Object.assign({}, s, f.options, w), f.scrollParents = {
            reference: Is(a) ? ga(a) : a.contextElement ? ga(a.contextElement) : [],
            popper: ga(u)
          };
          var b = N8(O8([].concat(o, f.options.modifiers)));
          return f.orderedModifiers = b.filter(function(C) {
            return C.enabled;
          }), m(), h.update();
        },
        forceUpdate: function() {
          if (!p) {
            var y = f.elements, w = y.reference, b = y.popper;
            if (!!Eg(w, b)) {
              f.rects = {
                reference: k8(w, Ei(b), f.options.strategy === "fixed"),
                popper: Mh(b)
              }, f.reset = !1, f.placement = f.options.placement, f.orderedModifiers.forEach(function(A) {
                return f.modifiersData[A.name] = Object.assign({}, A.data);
              });
              for (var C = 0; C < f.orderedModifiers.length; C++) {
                if (f.reset === !0) {
                  f.reset = !1, C = -1;
                  continue;
                }
                var _ = f.orderedModifiers[C], k = _.fn, O = _.options, T = O === void 0 ? {} : O, P = _.name;
                typeof k == "function" && (f = k({
                  state: f,
                  options: T,
                  name: P,
                  instance: h
                }) || f);
              }
            }
          }
        },
        update: T8(function() {
          return new Promise(function(g) {
            h.forceUpdate(), g(f);
          });
        }),
        destroy: function() {
          v(), p = !0;
        }
      };
      if (!Eg(a, u))
        return h;
      h.setOptions(c).then(function(g) {
        !p && c.onFirstUpdate && c.onFirstUpdate(g);
      });
      function m() {
        f.orderedModifiers.forEach(function(g) {
          var y = g.name, w = g.options, b = w === void 0 ? {} : w, C = g.effect;
          if (typeof C == "function") {
            var _ = C({
              state: f,
              name: y,
              instance: h,
              options: b
            }), k = function() {
            };
            d.push(_ || k);
          }
        });
      }
      function v() {
        d.forEach(function(g) {
          return g();
        }), d = [];
      }
      return h;
    };
  }
  var I8 = [e8, y8, ZD, HD, m8, d8, C8, YD, p8], bw = /* @__PURE__ */ M8({
    defaultModifiers: I8
  });
  const P8 = (e, t, n = {}) => {
    const o = {
      name: "updateState",
      enabled: !0,
      phase: "write",
      fn: ({ state: u }) => {
        const c = A8(u);
        Object.assign(l.value, c);
      },
      requires: ["computeStyles"]
    }, r = E(() => {
      const { onFirstUpdate: u, placement: c, strategy: f, modifiers: d } = i(n);
      return {
        onFirstUpdate: u,
        placement: c || "bottom",
        strategy: f || "absolute",
        modifiers: [
          ...d || [],
          o,
          { name: "applyStyles", enabled: !1 }
        ]
      };
    }), s = xt(), l = I({
      styles: {
        popper: {
          position: i(r).strategy,
          left: "0",
          top: "0"
        },
        arrow: {
          position: "absolute"
        }
      },
      attributes: {}
    }), a = () => {
      !s.value || (s.value.destroy(), s.value = void 0);
    };
    return me(r, (u) => {
      const c = i(s);
      c && c.setOptions(u);
    }, {
      deep: !0
    }), me([e, t], ([u, c]) => {
      a(), !(!u || !c) && (s.value = bw(u, c, i(r)));
    }), zt(() => {
      a();
    }), {
      state: E(() => {
        var u;
        return { ...((u = i(s)) == null ? void 0 : u.state) || {} };
      }),
      styles: E(() => i(l).styles),
      attributes: E(() => i(l).attributes),
      update: () => {
        var u;
        return (u = i(s)) == null ? void 0 : u.update();
      },
      forceUpdate: () => {
        var u;
        return (u = i(s)) == null ? void 0 : u.forceUpdate();
      },
      instanceRef: E(() => i(s))
    };
  };
  function A8(e) {
    const t = Object.keys(e.elements), n = Xu(t.map((r) => [r, e.styles[r] || {}])), o = Xu(t.map((r) => [r, e.attributes[r]]));
    return {
      styles: n,
      attributes: o
    };
  }
  const R8 = (e, t) => {
    let n;
    me(() => e.value, (o) => {
      var r, s;
      o ? (n = document.activeElement, Pt(t) && ((s = (r = t.value).focus) == null || s.call(r))) : process.env.NODE_ENV === "test" ? n.focus.call(n) : n.focus();
    });
  }, xh = (e) => {
    if (!e)
      return { onClick: Nt, onMousedown: Nt, onMouseup: Nt };
    let t = !1, n = !1;
    return { onClick: (l) => {
      t && n && e(l), t = n = !1;
    }, onMousedown: (l) => {
      t = l.target === l.currentTarget;
    }, onMouseup: (l) => {
      n = l.target === l.currentTarget;
    } };
  }, x8 = (e, t = 0) => {
    if (t === 0)
      return e;
    const n = I(!1);
    let o = 0;
    const r = () => {
      o && clearTimeout(o), o = window.setTimeout(() => {
        n.value = e.value;
      }, t);
    };
    return st(r), me(() => e.value, (s) => {
      s ? r() : n.value = s;
    }), n;
  };
  function Sg() {
    let e;
    const t = (o, r) => {
      n(), e = window.setTimeout(o, r);
    }, n = () => window.clearTimeout(e);
    return Ic(() => n()), {
      registerTimeout: t,
      cancelTimeout: n
    };
  }
  const Mf = {
    prefix: Math.floor(Math.random() * 1e4),
    current: 0
  }, D8 = Symbol("elIdInjection"), ww = () => it() ? Be(D8, Mf) : Mf, io = (e) => {
    const t = ww();
    !bt && t === Mf && yt("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
    const n = Nh();
    return E(() => i(e) || `${n.value}-id-${t.prefix}-${t.current++}`);
  };
  let Xs = [];
  const _g = (e) => {
    const t = e;
    t.key === We.esc && Xs.forEach((n) => n(t));
  }, L8 = (e) => {
    st(() => {
      Xs.length === 0 && document.addEventListener("keydown", _g), bt && Xs.push(e);
    }), zt(() => {
      Xs = Xs.filter((t) => t !== e), Xs.length === 0 && bt && document.removeEventListener("keydown", _g);
    });
  };
  let kg;
  const Cw = () => {
    const e = Nh(), t = ww(), n = E(() => `${e.value}-popper-container-${t.prefix}`), o = E(() => `#${n.value}`);
    return {
      id: n,
      selector: o
    };
  }, V8 = (e) => {
    const t = document.createElement("div");
    return t.id = e, document.body.appendChild(t), t;
  }, B8 = () => {
    const { id: e, selector: t } = Cw();
    return kc(() => {
      !bt || (process.env.NODE_ENV === "test" || !kg && !document.body.querySelector(t.value)) && (kg = V8(e.value));
    }), {
      id: e,
      selector: t
    };
  }, F8 = Ie({
    showAfter: {
      type: Number,
      default: 0
    },
    hideAfter: {
      type: Number,
      default: 200
    },
    autoClose: {
      type: Number,
      default: 0
    }
  }), Ew = ({
    showAfter: e,
    hideAfter: t,
    autoClose: n,
    open: o,
    close: r
  }) => {
    const { registerTimeout: s } = Sg(), {
      registerTimeout: l,
      cancelTimeout: a
    } = Sg();
    return {
      onOpen: (f) => {
        s(() => {
          o(f);
          const d = i(n);
          Xe(d) && d > 0 && l(() => {
            r(f);
          }, d);
        }, i(e));
      },
      onClose: (f) => {
        a(), s(() => {
          r(f);
        }, i(t));
      }
    };
  }, Sw = Symbol("elForwardRef"), H8 = (e) => {
    pt(Sw, {
      setForwardRef: (n) => {
        e.value = n;
      }
    });
  }, z8 = (e) => ({
    mounted(t) {
      e(t);
    },
    updated(t) {
      e(t);
    },
    unmounted() {
      e(null);
    }
  }), $g = I(0), _w = 2e3, kw = Symbol("zIndexContextKey"), Fs = (e) => {
    const t = e || Be(kw, void 0), n = E(() => {
      const s = i(t);
      return Xe(s) ? s : _w;
    }), o = E(() => n.value + $g.value);
    return {
      initialZIndex: n,
      currentZIndex: o,
      nextZIndex: () => ($g.value++, o.value)
    };
  }, Ua = Math.min, fl = Math.max, Qu = Math.round, Hr = (e) => ({
    x: e,
    y: e
  });
  function K8(e, t, n) {
    return fl(e, Ua(t, n));
  }
  function $w(e, t) {
    return typeof e == "function" ? e(t) : e;
  }
  function Dh(e) {
    return e.split("-")[0];
  }
  function Lh(e) {
    return e.split("-")[1];
  }
  function j8(e) {
    return e === "x" ? "y" : "x";
  }
  function Nw(e) {
    return e === "y" ? "height" : "width";
  }
  function Vh(e) {
    return ["top", "bottom"].includes(Dh(e)) ? "y" : "x";
  }
  function Tw(e) {
    return j8(Vh(e));
  }
  function W8(e) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...e
    };
  }
  function U8(e) {
    return typeof e != "number" ? W8(e) : {
      top: e,
      right: e,
      bottom: e,
      left: e
    };
  }
  function Ow(e) {
    return {
      ...e,
      top: e.y,
      left: e.x,
      right: e.x + e.width,
      bottom: e.y + e.height
    };
  }
  function Ng(e, t, n) {
    let {
      reference: o,
      floating: r
    } = e;
    const s = Vh(t), l = Tw(t), a = Nw(l), u = Dh(t), c = s === "y", f = o.x + o.width / 2 - r.width / 2, d = o.y + o.height / 2 - r.height / 2, p = o[a] / 2 - r[a] / 2;
    let h;
    switch (u) {
      case "top":
        h = {
          x: f,
          y: o.y - r.height
        };
        break;
      case "bottom":
        h = {
          x: f,
          y: o.y + o.height
        };
        break;
      case "right":
        h = {
          x: o.x + o.width,
          y: d
        };
        break;
      case "left":
        h = {
          x: o.x - r.width,
          y: d
        };
        break;
      default:
        h = {
          x: o.x,
          y: o.y
        };
    }
    switch (Lh(t)) {
      case "start":
        h[l] -= p * (n && c ? -1 : 1);
        break;
      case "end":
        h[l] += p * (n && c ? -1 : 1);
        break;
    }
    return h;
  }
  const q8 = async (e, t, n) => {
    const {
      placement: o = "bottom",
      strategy: r = "absolute",
      middleware: s = [],
      platform: l
    } = n, a = s.filter(Boolean), u = await (l.isRTL == null ? void 0 : l.isRTL(t));
    let c = await l.getElementRects({
      reference: e,
      floating: t,
      strategy: r
    }), {
      x: f,
      y: d
    } = Ng(c, o, u), p = o, h = {}, m = 0;
    for (let v = 0; v < a.length; v++) {
      const {
        name: g,
        fn: y
      } = a[v], {
        x: w,
        y: b,
        data: C,
        reset: _
      } = await y({
        x: f,
        y: d,
        initialPlacement: o,
        placement: p,
        strategy: r,
        middlewareData: h,
        rects: c,
        platform: l,
        elements: {
          reference: e,
          floating: t
        }
      });
      if (f = w != null ? w : f, d = b != null ? b : d, h = {
        ...h,
        [g]: {
          ...h[g],
          ...C
        }
      }, _ && m <= 50) {
        m++, typeof _ == "object" && (_.placement && (p = _.placement), _.rects && (c = _.rects === !0 ? await l.getElementRects({
          reference: e,
          floating: t,
          strategy: r
        }) : _.rects), {
          x: f,
          y: d
        } = Ng(c, p, u)), v = -1;
        continue;
      }
    }
    return {
      x: f,
      y: d,
      placement: p,
      strategy: r,
      middlewareData: h
    };
  }, Y8 = (e) => ({
    name: "arrow",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: o,
        placement: r,
        rects: s,
        platform: l,
        elements: a,
        middlewareData: u
      } = t, {
        element: c,
        padding: f = 0
      } = $w(e, t) || {};
      if (c == null)
        return {};
      const d = U8(f), p = {
        x: n,
        y: o
      }, h = Tw(r), m = Nw(h), v = await l.getDimensions(c), g = h === "y", y = g ? "top" : "left", w = g ? "bottom" : "right", b = g ? "clientHeight" : "clientWidth", C = s.reference[m] + s.reference[h] - p[h] - s.floating[m], _ = p[h] - s.reference[h], k = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(c));
      let O = k ? k[b] : 0;
      (!O || !await (l.isElement == null ? void 0 : l.isElement(k))) && (O = a.floating[b] || s.floating[m]);
      const T = C / 2 - _ / 2, P = O / 2 - v[m] / 2 - 1, A = Ua(d[y], P), L = Ua(d[w], P), D = A, B = O - v[m] - L, F = O / 2 - v[m] / 2 + T, W = K8(D, F, B), x = !u.arrow && Lh(r) != null && F != W && s.reference[m] / 2 - (F < D ? A : L) - v[m] / 2 < 0, N = x ? F < D ? F - D : F - B : 0;
      return {
        [h]: p[h] + N,
        data: {
          [h]: W,
          centerOffset: F - W - N,
          ...x && {
            alignmentOffset: N
          }
        },
        reset: x
      };
    }
  });
  async function G8(e, t) {
    const {
      placement: n,
      platform: o,
      elements: r
    } = e, s = await (o.isRTL == null ? void 0 : o.isRTL(r.floating)), l = Dh(n), a = Lh(n), u = Vh(n) === "y", c = ["left", "top"].includes(l) ? -1 : 1, f = s && u ? -1 : 1, d = $w(t, e);
    let {
      mainAxis: p,
      crossAxis: h,
      alignmentAxis: m
    } = typeof d == "number" ? {
      mainAxis: d,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: 0,
      crossAxis: 0,
      alignmentAxis: null,
      ...d
    };
    return a && typeof m == "number" && (h = a === "end" ? m * -1 : m), u ? {
      x: h * f,
      y: p * c
    } : {
      x: p * c,
      y: h * f
    };
  }
  const X8 = function(e) {
    return e === void 0 && (e = 0), {
      name: "offset",
      options: e,
      async fn(t) {
        const {
          x: n,
          y: o
        } = t, r = await G8(t, e);
        return {
          x: n + r.x,
          y: o + r.y,
          data: r
        };
      }
    };
  };
  function zr(e) {
    return Mw(e) ? (e.nodeName || "").toLowerCase() : "#document";
  }
  function Yn(e) {
    var t;
    return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
  }
  function Jr(e) {
    var t;
    return (t = (Mw(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
  }
  function Mw(e) {
    return e instanceof Node || e instanceof Yn(e).Node;
  }
  function ir(e) {
    return e instanceof Element || e instanceof Yn(e).Element;
  }
  function Fo(e) {
    return e instanceof HTMLElement || e instanceof Yn(e).HTMLElement;
  }
  function Tg(e) {
    return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Yn(e).ShadowRoot;
  }
  function Si(e) {
    const {
      overflow: t,
      overflowX: n,
      overflowY: o,
      display: r
    } = uo(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !["inline", "contents"].includes(r);
  }
  function J8(e) {
    return ["table", "td", "th"].includes(zr(e));
  }
  function Bh(e) {
    const t = Fh(), n = uo(e);
    return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((o) => (n.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (n.contain || "").includes(o));
  }
  function Z8(e) {
    let t = Pl(e);
    for (; Fo(t) && !qc(t); ) {
      if (Bh(t))
        return t;
      t = Pl(t);
    }
    return null;
  }
  function Fh() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
  }
  function qc(e) {
    return ["html", "body", "#document"].includes(zr(e));
  }
  function uo(e) {
    return Yn(e).getComputedStyle(e);
  }
  function Yc(e) {
    return ir(e) ? {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTop
    } : {
      scrollLeft: e.pageXOffset,
      scrollTop: e.pageYOffset
    };
  }
  function Pl(e) {
    if (zr(e) === "html")
      return e;
    const t = e.assignedSlot || e.parentNode || Tg(e) && e.host || Jr(e);
    return Tg(t) ? t.host : t;
  }
  function Iw(e) {
    const t = Pl(e);
    return qc(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Fo(t) && Si(t) ? t : Iw(t);
  }
  function If(e, t, n) {
    var o;
    t === void 0 && (t = []), n === void 0 && (n = !0);
    const r = Iw(e), s = r === ((o = e.ownerDocument) == null ? void 0 : o.body), l = Yn(r);
    return s ? t.concat(l, l.visualViewport || [], Si(r) ? r : [], l.frameElement && n ? If(l.frameElement) : []) : t.concat(r, If(r, [], n));
  }
  function Pw(e) {
    const t = uo(e);
    let n = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0;
    const r = Fo(e), s = r ? e.offsetWidth : n, l = r ? e.offsetHeight : o, a = Qu(n) !== s || Qu(o) !== l;
    return a && (n = s, o = l), {
      width: n,
      height: o,
      $: a
    };
  }
  function Aw(e) {
    return ir(e) ? e : e.contextElement;
  }
  function pl(e) {
    const t = Aw(e);
    if (!Fo(t))
      return Hr(1);
    const n = t.getBoundingClientRect(), {
      width: o,
      height: r,
      $: s
    } = Pw(t);
    let l = (s ? Qu(n.width) : n.width) / o, a = (s ? Qu(n.height) : n.height) / r;
    return (!l || !Number.isFinite(l)) && (l = 1), (!a || !Number.isFinite(a)) && (a = 1), {
      x: l,
      y: a
    };
  }
  const Q8 = /* @__PURE__ */ Hr(0);
  function Rw(e) {
    const t = Yn(e);
    return !Fh() || !t.visualViewport ? Q8 : {
      x: t.visualViewport.offsetLeft,
      y: t.visualViewport.offsetTop
    };
  }
  function eL(e, t, n) {
    return t === void 0 && (t = !1), !n || t && n !== Yn(e) ? !1 : t;
  }
  function qa(e, t, n, o) {
    t === void 0 && (t = !1), n === void 0 && (n = !1);
    const r = e.getBoundingClientRect(), s = Aw(e);
    let l = Hr(1);
    t && (o ? ir(o) && (l = pl(o)) : l = pl(e));
    const a = eL(s, n, o) ? Rw(s) : Hr(0);
    let u = (r.left + a.x) / l.x, c = (r.top + a.y) / l.y, f = r.width / l.x, d = r.height / l.y;
    if (s) {
      const p = Yn(s), h = o && ir(o) ? Yn(o) : o;
      let m = p.frameElement;
      for (; m && o && h !== p; ) {
        const v = pl(m), g = m.getBoundingClientRect(), y = uo(m), w = g.left + (m.clientLeft + parseFloat(y.paddingLeft)) * v.x, b = g.top + (m.clientTop + parseFloat(y.paddingTop)) * v.y;
        u *= v.x, c *= v.y, f *= v.x, d *= v.y, u += w, c += b, m = Yn(m).frameElement;
      }
    }
    return Ow({
      width: f,
      height: d,
      x: u,
      y: c
    });
  }
  function tL(e) {
    let {
      rect: t,
      offsetParent: n,
      strategy: o
    } = e;
    const r = Fo(n), s = Jr(n);
    if (n === s)
      return t;
    let l = {
      scrollLeft: 0,
      scrollTop: 0
    }, a = Hr(1);
    const u = Hr(0);
    if ((r || !r && o !== "fixed") && ((zr(n) !== "body" || Si(s)) && (l = Yc(n)), Fo(n))) {
      const c = qa(n);
      a = pl(n), u.x = c.x + n.clientLeft, u.y = c.y + n.clientTop;
    }
    return {
      width: t.width * a.x,
      height: t.height * a.y,
      x: t.x * a.x - l.scrollLeft * a.x + u.x,
      y: t.y * a.y - l.scrollTop * a.y + u.y
    };
  }
  function nL(e) {
    return Array.from(e.getClientRects());
  }
  function xw(e) {
    return qa(Jr(e)).left + Yc(e).scrollLeft;
  }
  function oL(e) {
    const t = Jr(e), n = Yc(e), o = e.ownerDocument.body, r = fl(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth), s = fl(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
    let l = -n.scrollLeft + xw(e);
    const a = -n.scrollTop;
    return uo(o).direction === "rtl" && (l += fl(t.clientWidth, o.clientWidth) - r), {
      width: r,
      height: s,
      x: l,
      y: a
    };
  }
  function rL(e, t) {
    const n = Yn(e), o = Jr(e), r = n.visualViewport;
    let s = o.clientWidth, l = o.clientHeight, a = 0, u = 0;
    if (r) {
      s = r.width, l = r.height;
      const c = Fh();
      (!c || c && t === "fixed") && (a = r.offsetLeft, u = r.offsetTop);
    }
    return {
      width: s,
      height: l,
      x: a,
      y: u
    };
  }
  function sL(e, t) {
    const n = qa(e, !0, t === "fixed"), o = n.top + e.clientTop, r = n.left + e.clientLeft, s = Fo(e) ? pl(e) : Hr(1), l = e.clientWidth * s.x, a = e.clientHeight * s.y, u = r * s.x, c = o * s.y;
    return {
      width: l,
      height: a,
      x: u,
      y: c
    };
  }
  function Og(e, t, n) {
    let o;
    if (t === "viewport")
      o = rL(e, n);
    else if (t === "document")
      o = oL(Jr(e));
    else if (ir(t))
      o = sL(t, n);
    else {
      const r = Rw(e);
      o = {
        ...t,
        x: t.x - r.x,
        y: t.y - r.y
      };
    }
    return Ow(o);
  }
  function Dw(e, t) {
    const n = Pl(e);
    return n === t || !ir(n) || qc(n) ? !1 : uo(n).position === "fixed" || Dw(n, t);
  }
  function lL(e, t) {
    const n = t.get(e);
    if (n)
      return n;
    let o = If(e, [], !1).filter((a) => ir(a) && zr(a) !== "body"), r = null;
    const s = uo(e).position === "fixed";
    let l = s ? Pl(e) : e;
    for (; ir(l) && !qc(l); ) {
      const a = uo(l), u = Bh(l);
      !u && a.position === "fixed" && (r = null), (s ? !u && !r : !u && a.position === "static" && !!r && ["absolute", "fixed"].includes(r.position) || Si(l) && !u && Dw(e, l)) ? o = o.filter((f) => f !== l) : r = a, l = Pl(l);
    }
    return t.set(e, o), o;
  }
  function aL(e) {
    let {
      element: t,
      boundary: n,
      rootBoundary: o,
      strategy: r
    } = e;
    const l = [...n === "clippingAncestors" ? lL(t, this._c) : [].concat(n), o], a = l[0], u = l.reduce((c, f) => {
      const d = Og(t, f, r);
      return c.top = fl(d.top, c.top), c.right = Ua(d.right, c.right), c.bottom = Ua(d.bottom, c.bottom), c.left = fl(d.left, c.left), c;
    }, Og(t, a, r));
    return {
      width: u.right - u.left,
      height: u.bottom - u.top,
      x: u.left,
      y: u.top
    };
  }
  function iL(e) {
    return Pw(e);
  }
  function uL(e, t, n) {
    const o = Fo(t), r = Jr(t), s = n === "fixed", l = qa(e, !0, s, t);
    let a = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const u = Hr(0);
    if (o || !o && !s)
      if ((zr(t) !== "body" || Si(r)) && (a = Yc(t)), o) {
        const c = qa(t, !0, s, t);
        u.x = c.x + t.clientLeft, u.y = c.y + t.clientTop;
      } else
        r && (u.x = xw(r));
    return {
      x: l.left + a.scrollLeft - u.x,
      y: l.top + a.scrollTop - u.y,
      width: l.width,
      height: l.height
    };
  }
  function Mg(e, t) {
    return !Fo(e) || uo(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
  }
  function Lw(e, t) {
    const n = Yn(e);
    if (!Fo(e))
      return n;
    let o = Mg(e, t);
    for (; o && J8(o) && uo(o).position === "static"; )
      o = Mg(o, t);
    return o && (zr(o) === "html" || zr(o) === "body" && uo(o).position === "static" && !Bh(o)) ? n : o || Z8(e) || n;
  }
  const cL = async function(e) {
    let {
      reference: t,
      floating: n,
      strategy: o
    } = e;
    const r = this.getOffsetParent || Lw, s = this.getDimensions;
    return {
      reference: uL(t, await r(n), o),
      floating: {
        x: 0,
        y: 0,
        ...await s(n)
      }
    };
  };
  function dL(e) {
    return uo(e).direction === "rtl";
  }
  const fL = {
    convertOffsetParentRelativeRectToViewportRelativeRect: tL,
    getDocumentElement: Jr,
    getClippingRect: aL,
    getOffsetParent: Lw,
    getElementRects: cL,
    getClientRects: nL,
    getDimensions: iL,
    getScale: pl,
    isElement: ir,
    isRTL: dL
  }, pL = (e, t, n) => {
    const o = /* @__PURE__ */ new Map(), r = {
      platform: fL,
      ...n
    }, s = {
      ...r.platform,
      _c: o
    };
    return q8(e, t, {
      ...r,
      platform: s
    });
  };
  Ie({});
  const hL = (e) => {
    if (!bt)
      return;
    if (!e)
      return e;
    const t = Kn(e);
    return t || (Pt(e) ? t : e);
  }, vL = ({
    middleware: e,
    placement: t,
    strategy: n
  }) => {
    const o = I(), r = I(), s = I(), l = I(), a = I({}), u = {
      x: s,
      y: l,
      placement: t,
      strategy: n,
      middlewareData: a
    }, c = async () => {
      if (!bt)
        return;
      const f = hL(o), d = Kn(r);
      if (!f || !d)
        return;
      const p = await pL(f, d, {
        placement: i(t),
        strategy: i(n),
        middleware: i(e)
      });
      za(u).forEach((h) => {
        u[h].value = p[h];
      });
    };
    return st(() => {
      xn(() => {
        c();
      });
    }), {
      ...u,
      update: c,
      referenceRef: o,
      contentRef: r
    };
  }, mL = ({
    arrowRef: e,
    padding: t
  }) => ({
    name: "arrow",
    options: {
      element: e,
      padding: t
    },
    fn(n) {
      const o = i(e);
      return o ? Y8({
        element: o,
        padding: t
      }).fn(n) : {};
    }
  });
  function gL(e) {
    const t = I();
    function n() {
      if (e.value == null)
        return;
      const { selectionStart: r, selectionEnd: s, value: l } = e.value;
      if (r == null || s == null)
        return;
      const a = l.slice(0, Math.max(0, r)), u = l.slice(Math.max(0, s));
      t.value = {
        selectionStart: r,
        selectionEnd: s,
        value: l,
        beforeTxt: a,
        afterTxt: u
      };
    }
    function o() {
      if (e.value == null || t.value == null)
        return;
      const { value: r } = e.value, { beforeTxt: s, afterTxt: l, selectionStart: a } = t.value;
      if (s == null || l == null || a == null)
        return;
      let u = r.length;
      if (r.endsWith(l))
        u = r.length - l.length;
      else if (r.startsWith(s))
        u = s.length;
      else {
        const c = s[a - 1], f = r.indexOf(c, a - 1);
        f !== -1 && (u = f + 1);
      }
      e.value.setSelectionRange(u, u);
    }
    return [n, o];
  }
  const yL = (e, t, n) => dl(e.subTree).filter((s) => {
    var l;
    return Bt(s) && ((l = s.type) == null ? void 0 : l.name) === t && !!s.component;
  }).map((s) => s.component.uid).map((s) => n[s]).filter((s) => !!s), Vw = (e, t) => {
    const n = {}, o = xt([]);
    return {
      children: o,
      addChild: (l) => {
        n[l.uid] = l, o.value = yL(e, t, n);
      },
      removeChild: (l) => {
        delete n[l], o.value = o.value.filter((a) => a.uid !== l);
      }
    };
  }, yn = $o({
    type: String,
    values: zo,
    required: !1
  }), Bw = Symbol("size"), bL = () => {
    const e = Be(Bw, {});
    return E(() => i(e.size) || "");
  }, Fw = Symbol(), ec = I();
  function Gc(e, t = void 0) {
    const n = it() ? Be(Fw, ec) : ec;
    return e ? E(() => {
      var o, r;
      return (r = (o = n.value) == null ? void 0 : o[e]) != null ? r : t;
    }) : n;
  }
  function Xc(e, t) {
    const n = Gc(), o = ge(e, E(() => {
      var a;
      return ((a = n.value) == null ? void 0 : a.namespace) || Ju;
    })), r = St(E(() => {
      var a;
      return (a = n.value) == null ? void 0 : a.locale;
    })), s = Fs(E(() => {
      var a;
      return ((a = n.value) == null ? void 0 : a.zIndex) || _w;
    })), l = E(() => {
      var a;
      return i(t) || ((a = n.value) == null ? void 0 : a.size) || "";
    });
    return Hh(E(() => i(n) || {})), {
      ns: o,
      locale: r,
      zIndex: s,
      size: l
    };
  }
  const Hh = (e, t, n = !1) => {
    var o;
    const r = !!it(), s = r ? Gc() : void 0, l = (o = t == null ? void 0 : t.provide) != null ? o : r ? pt : void 0;
    if (!l) {
      yt("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
      return;
    }
    const a = E(() => {
      const u = i(e);
      return s != null && s.value ? wL(s.value, u) : u;
    });
    return l(Fw, a), l(aw, E(() => a.value.locale)), l(iw, E(() => a.value.namespace)), l(kw, E(() => a.value.zIndex)), l(Bw, {
      size: E(() => a.value.size || "")
    }), (n || !ec.value) && (ec.value = a.value), a;
  }, wL = (e, t) => {
    var n;
    const o = [.../* @__PURE__ */ new Set([...za(e), ...za(t)])], r = {};
    for (const s of o)
      r[s] = (n = t[s]) != null ? n : e[s];
    return r;
  }, CL = Ie({
    a11y: {
      type: Boolean,
      default: !0
    },
    locale: {
      type: le(Object)
    },
    size: yn,
    button: {
      type: le(Object)
    },
    experimentalFeatures: {
      type: le(Object)
    },
    keyboardNavigation: {
      type: Boolean,
      default: !0
    },
    message: {
      type: le(Object)
    },
    zIndex: Number,
    namespace: {
      type: String,
      default: "el"
    }
  }), Pf = {}, EL = G({
    name: "ElConfigProvider",
    props: CL,
    setup(e, { slots: t }) {
      me(() => e.message, (o) => {
        Object.assign(Pf, o != null ? o : {});
      }, { immediate: !0, deep: !0 });
      const n = Hh(e);
      return () => he(t, "default", { config: n == null ? void 0 : n.value });
    }
  }), SL = ut(EL), _L = "2.3.3", kL = (e = []) => ({
    version: _L,
    install: (n, o) => {
      n[fg] || (n[fg] = !0, e.forEach((r) => n.use(r)), o && Hh(o, n, !0));
    }
  }), $L = Ie({
    zIndex: {
      type: le([Number, String]),
      default: 100
    },
    target: {
      type: String,
      default: ""
    },
    offset: {
      type: Number,
      default: 0
    },
    position: {
      type: String,
      values: ["top", "bottom"],
      default: "top"
    }
  }), NL = {
    scroll: ({ scrollTop: e, fixed: t }) => Xe(e) && tn(t),
    [Ft]: (e) => tn(e)
  };
  var Me = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [o, r] of t)
      n[o] = r;
    return n;
  };
  const Hw = "ElAffix", TL = G({
    name: Hw
  }), OL = /* @__PURE__ */ G({
    ...TL,
    props: $L,
    emits: NL,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = ge("affix"), s = xt(), l = xt(), a = xt(), { height: u } = TN(), {
        height: c,
        width: f,
        top: d,
        bottom: p,
        update: h
      } = Om(l, { windowScroll: !1 }), m = Om(s), v = I(!1), g = I(0), y = I(0), w = E(() => ({
        height: v.value ? `${c.value}px` : "",
        width: v.value ? `${f.value}px` : ""
      })), b = E(() => {
        if (!v.value)
          return {};
        const k = o.offset ? Jt(o.offset) : 0;
        return {
          height: `${c.value}px`,
          width: `${f.value}px`,
          top: o.position === "top" ? k : "",
          bottom: o.position === "bottom" ? k : "",
          transform: y.value ? `translateY(${y.value}px)` : "",
          zIndex: o.zIndex
        };
      }), C = () => {
        if (!!a.value)
          if (g.value = a.value instanceof Window ? document.documentElement.scrollTop : a.value.scrollTop || 0, o.position === "top")
            if (o.target) {
              const k = m.bottom.value - o.offset - c.value;
              v.value = o.offset > d.value && m.bottom.value > 0, y.value = k < 0 ? k : 0;
            } else
              v.value = o.offset > d.value;
          else if (o.target) {
            const k = u.value - m.top.value - o.offset - c.value;
            v.value = u.value - o.offset < p.value && u.value > m.top.value, y.value = k < 0 ? -k : 0;
          } else
            v.value = u.value - o.offset < p.value;
      }, _ = () => {
        h(), n("scroll", {
          scrollTop: g.value,
          fixed: v.value
        });
      };
      return me(v, (k) => n("change", k)), st(() => {
        var k;
        o.target ? (s.value = (k = document.querySelector(o.target)) != null ? k : void 0, s.value || Yt(Hw, `Target is not existed: ${o.target}`)) : s.value = document.documentElement, a.value = Ch(l.value, !0), h();
      }), Wt(a, "scroll", _), xn(C), t({
        update: C,
        updateRoot: h
      }), (k, O) => (S(), V("div", {
        ref_key: "root",
        ref: l,
        class: $(i(r).b()),
        style: Ke(i(w))
      }, [
        H("div", {
          class: $({ [i(r).m("fixed")]: v.value }),
          style: Ke(i(b))
        }, [
          he(k.$slots, "default")
        ], 6)
      ], 6));
    }
  });
  var ML = /* @__PURE__ */ Me(OL, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/affix/src/affix.vue"]]);
  const IL = ut(ML), PL = Ie({
    size: {
      type: le([Number, String])
    },
    color: {
      type: String
    }
  }), AL = G({
    name: "ElIcon",
    inheritAttrs: !1
  }), RL = /* @__PURE__ */ G({
    ...AL,
    props: PL,
    setup(e) {
      const t = e, n = ge("icon"), o = E(() => {
        const { size: r, color: s } = t;
        return !r && !s ? {} : {
          fontSize: pn(r) ? void 0 : Jt(r),
          "--color": s
        };
      });
      return (r, s) => (S(), V("i", ft({
        class: i(n).b(),
        style: i(o)
      }, r.$attrs), [
        he(r.$slots, "default")
      ], 16));
    }
  });
  var xL = /* @__PURE__ */ Me(RL, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
  const He = ut(xL), DL = ["light", "dark"], LL = Ie({
    title: {
      type: String,
      default: ""
    },
    description: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      values: za(Fr),
      default: "info"
    },
    closable: {
      type: Boolean,
      default: !0
    },
    closeText: {
      type: String,
      default: ""
    },
    showIcon: Boolean,
    center: Boolean,
    effect: {
      type: String,
      values: DL,
      default: "light"
    }
  }), VL = {
    close: (e) => e instanceof MouseEvent
  }, BL = G({
    name: "ElAlert"
  }), FL = /* @__PURE__ */ G({
    ...BL,
    props: LL,
    emits: VL,
    setup(e, { emit: t }) {
      const n = e, { Close: o } = kh, r = hn(), s = ge("alert"), l = I(!0), a = E(() => Fr[n.type]), u = E(() => [
        s.e("icon"),
        { [s.is("big")]: !!n.description || !!r.default }
      ]), c = E(() => ({ [s.is("bold")]: n.description || r.default })), f = (d) => {
        l.value = !1, t("close", d);
      };
      return (d, p) => (S(), ie(Qt, {
        name: i(s).b("fade"),
        persisted: ""
      }, {
        default: X(() => [
          ot(H("div", {
            class: $([i(s).b(), i(s).m(d.type), i(s).is("center", d.center), i(s).is(d.effect)]),
            role: "alert"
          }, [
            d.showIcon && i(a) ? (S(), ie(i(He), {
              key: 0,
              class: $(i(u))
            }, {
              default: X(() => [
                (S(), ie(vt(i(a))))
              ]),
              _: 1
            }, 8, ["class"])) : se("v-if", !0),
            H("div", {
              class: $(i(s).e("content"))
            }, [
              d.title || d.$slots.title ? (S(), V("span", {
                key: 0,
                class: $([i(s).e("title"), i(c)])
              }, [
                he(d.$slots, "title", {}, () => [
                  wt(Ne(d.title), 1)
                ])
              ], 2)) : se("v-if", !0),
              d.$slots.default || d.description ? (S(), V("p", {
                key: 1,
                class: $(i(s).e("description"))
              }, [
                he(d.$slots, "default", {}, () => [
                  wt(Ne(d.description), 1)
                ])
              ], 2)) : se("v-if", !0),
              d.closable ? (S(), V(ze, { key: 2 }, [
                d.closeText ? (S(), V("div", {
                  key: 0,
                  class: $([i(s).e("close-btn"), i(s).is("customed")]),
                  onClick: f
                }, Ne(d.closeText), 3)) : (S(), ie(i(He), {
                  key: 1,
                  class: $(i(s).e("close-btn")),
                  onClick: f
                }, {
                  default: X(() => [
                    K(i(o))
                  ]),
                  _: 1
                }, 8, ["class"]))
              ], 64)) : se("v-if", !0)
            ], 2)
          ], 2), [
            [$t, l.value]
          ])
        ]),
        _: 3
      }, 8, ["name"]));
    }
  });
  var HL = /* @__PURE__ */ Me(FL, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/alert/src/alert.vue"]]);
  const zL = ut(HL), Hs = Symbol("formContextKey"), Ho = Symbol("formItemContextKey"), on = (e, t = {}) => {
    const n = I(void 0), o = t.prop ? n : cw("size"), r = t.global ? n : bL(), s = t.form ? { size: void 0 } : Be(Hs, void 0), l = t.formItem ? { size: void 0 } : Be(Ho, void 0);
    return E(() => o.value || i(e) || (l == null ? void 0 : l.size) || (s == null ? void 0 : s.size) || r.value || "");
  }, Fn = (e) => {
    const t = cw("disabled"), n = Be(Hs, void 0);
    return E(() => t.value || i(e) || (n == null ? void 0 : n.disabled) || !1);
  }, In = () => {
    const e = Be(Hs, void 0), t = Be(Ho, void 0);
    return {
      form: e,
      formItem: t
    };
  }, Zr = (e, {
    formItemContext: t,
    disableIdGeneration: n,
    disableIdManagement: o
  }) => {
    n || (n = I(!1)), o || (o = I(!1));
    const r = I();
    let s;
    const l = E(() => {
      var a;
      return !!(!e.label && t && t.inputIds && ((a = t.inputIds) == null ? void 0 : a.length) <= 1);
    });
    return st(() => {
      s = me([Ht(e, "id"), n], ([a, u]) => {
        const c = a != null ? a : u ? void 0 : io().value;
        c !== r.value && (t != null && t.removeInputId && (r.value && t.removeInputId(r.value), !(o != null && o.value) && !u && c && t.addInputId(c)), r.value = c);
      }, { immediate: !0 });
    }), Ur(() => {
      s && s(), t != null && t.removeInputId && r.value && t.removeInputId(r.value);
    }), {
      isLabeledByFormItem: l,
      inputId: r
    };
  }, KL = Ie({
    size: {
      type: String,
      values: zo
    },
    disabled: Boolean
  }), jL = Ie({
    ...KL,
    model: Object,
    rules: {
      type: le(Object)
    },
    labelPosition: {
      type: String,
      values: ["left", "right", "top"],
      default: "right"
    },
    requireAsteriskPosition: {
      type: String,
      values: ["left", "right"],
      default: "left"
    },
    labelWidth: {
      type: [String, Number],
      default: ""
    },
    labelSuffix: {
      type: String,
      default: ""
    },
    inline: Boolean,
    inlineMessage: Boolean,
    statusIcon: Boolean,
    showMessage: {
      type: Boolean,
      default: !0
    },
    validateOnRuleChange: {
      type: Boolean,
      default: !0
    },
    hideRequiredAsterisk: {
      type: Boolean,
      default: !1
    },
    scrollToError: Boolean,
    scrollIntoViewOptions: {
      type: [Object, Boolean]
    }
  }), WL = {
    validate: (e, t, n) => (De(e) || et(e)) && tn(t) && et(n)
  }, UL = "ElForm";
  function qL() {
    const e = I([]), t = E(() => {
      if (!e.value.length)
        return "0";
      const s = Math.max(...e.value);
      return s ? `${s}px` : "";
    });
    function n(s) {
      const l = e.value.indexOf(s);
      return l === -1 && t.value === "0" && yt(UL, `unexpected width ${s}`), l;
    }
    function o(s, l) {
      if (s && l) {
        const a = n(l);
        e.value.splice(a, 1, s);
      } else
        s && e.value.push(s);
    }
    function r(s) {
      const l = n(s);
      l > -1 && e.value.splice(l, 1);
    }
    return {
      autoLabelWidth: t,
      registerLabelWidth: o,
      deregisterLabelWidth: r
    };
  }
  const Hi = (e, t) => {
    const n = kl(t);
    return n.length > 0 ? e.filter((o) => o.prop && n.includes(o.prop)) : e;
  }, cu = "ElForm", YL = G({
    name: cu
  }), GL = /* @__PURE__ */ G({
    ...YL,
    props: jL,
    emits: WL,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = [], s = on(), l = ge("form"), a = E(() => {
        const { labelPosition: w, inline: b } = o;
        return [
          l.b(),
          l.m(s.value || "default"),
          {
            [l.m(`label-${w}`)]: w,
            [l.m("inline")]: b
          }
        ];
      }), u = (w) => {
        r.push(w);
      }, c = (w) => {
        w.prop && r.splice(r.indexOf(w), 1);
      }, f = (w = []) => {
        if (!o.model) {
          yt(cu, "model is required for resetFields to work.");
          return;
        }
        Hi(r, w).forEach((b) => b.resetField());
      }, d = (w = []) => {
        Hi(r, w).forEach((b) => b.clearValidate());
      }, p = E(() => {
        const w = !!o.model;
        return w || yt(cu, "model is required for validate to work."), w;
      }), h = (w) => {
        if (r.length === 0)
          return [];
        const b = Hi(r, w);
        return b.length ? b : (yt(cu, "please pass correct props!"), []);
      }, m = async (w) => g(void 0, w), v = async (w = []) => {
        if (!p.value)
          return !1;
        const b = h(w);
        if (b.length === 0)
          return !0;
        let C = {};
        for (const _ of b)
          try {
            await _.validate("");
          } catch (k) {
            C = {
              ...C,
              ...k
            };
          }
        return Object.keys(C).length === 0 ? !0 : Promise.reject(C);
      }, g = async (w = [], b) => {
        const C = !Ge(b);
        try {
          const _ = await v(w);
          return _ === !0 && (b == null || b(_)), _;
        } catch (_) {
          if (_ instanceof Error)
            throw _;
          const k = _;
          return o.scrollToError && y(Object.keys(k)[0]), b == null || b(!1, k), C && Promise.reject(k);
        }
      }, y = (w) => {
        var b;
        const C = Hi(r, w)[0];
        C && ((b = C.$el) == null || b.scrollIntoView(o.scrollIntoViewOptions));
      };
      return me(() => o.rules, () => {
        o.validateOnRuleChange && m().catch((w) => yt(w));
      }, { deep: !0 }), pt(Hs, Tt({
        ...rn(o),
        emit: n,
        resetFields: f,
        clearValidate: d,
        validateField: g,
        addField: u,
        removeField: c,
        ...qL()
      })), t({
        validate: m,
        validateField: g,
        resetFields: f,
        clearValidate: d,
        scrollToField: y
      }), (w, b) => (S(), V("form", {
        class: $(i(a))
      }, [
        he(w.$slots, "default")
      ], 2));
    }
  });
  var XL = /* @__PURE__ */ Me(GL, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]);
  function ds() {
    return ds = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var o in n)
          Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
      }
      return e;
    }, ds.apply(this, arguments);
  }
  function JL(e, t) {
    e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Ya(e, t);
  }
  function Af(e) {
    return Af = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
      return n.__proto__ || Object.getPrototypeOf(n);
    }, Af(e);
  }
  function Ya(e, t) {
    return Ya = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, r) {
      return o.__proto__ = r, o;
    }, Ya(e, t);
  }
  function ZL() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function du(e, t, n) {
    return ZL() ? du = Reflect.construct.bind() : du = function(r, s, l) {
      var a = [null];
      a.push.apply(a, s);
      var u = Function.bind.apply(r, a), c = new u();
      return l && Ya(c, l.prototype), c;
    }, du.apply(null, arguments);
  }
  function QL(e) {
    return Function.toString.call(e).indexOf("[native code]") !== -1;
  }
  function Rf(e) {
    var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return Rf = function(o) {
      if (o === null || !QL(o))
        return o;
      if (typeof o != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof t < "u") {
        if (t.has(o))
          return t.get(o);
        t.set(o, r);
      }
      function r() {
        return du(o, arguments, Af(this).constructor);
      }
      return r.prototype = Object.create(o.prototype, {
        constructor: {
          value: r,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), Ya(r, o);
    }, Rf(e);
  }
  var eV = /%[sdj%]/g, zw = function() {
  };
  typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (zw = function(t, n) {
    typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && n.every(function(o) {
      return typeof o == "string";
    }) && console.warn(t, n);
  });
  function xf(e) {
    if (!e || !e.length)
      return null;
    var t = {};
    return e.forEach(function(n) {
      var o = n.field;
      t[o] = t[o] || [], t[o].push(n);
    }), t;
  }
  function jn(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
      n[o - 1] = arguments[o];
    var r = 0, s = n.length;
    if (typeof e == "function")
      return e.apply(null, n);
    if (typeof e == "string") {
      var l = e.replace(eV, function(a) {
        if (a === "%%")
          return "%";
        if (r >= s)
          return a;
        switch (a) {
          case "%s":
            return String(n[r++]);
          case "%d":
            return Number(n[r++]);
          case "%j":
            try {
              return JSON.stringify(n[r++]);
            } catch {
              return "[Circular]";
            }
            break;
          default:
            return a;
        }
      });
      return l;
    }
    return e;
  }
  function tV(e) {
    return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern";
  }
  function un(e, t) {
    return !!(e == null || t === "array" && Array.isArray(e) && !e.length || tV(t) && typeof e == "string" && !e);
  }
  function nV(e, t, n) {
    var o = [], r = 0, s = e.length;
    function l(a) {
      o.push.apply(o, a || []), r++, r === s && n(o);
    }
    e.forEach(function(a) {
      t(a, l);
    });
  }
  function Ig(e, t, n) {
    var o = 0, r = e.length;
    function s(l) {
      if (l && l.length) {
        n(l);
        return;
      }
      var a = o;
      o = o + 1, a < r ? t(e[a], s) : n([]);
    }
    s([]);
  }
  function oV(e) {
    var t = [];
    return Object.keys(e).forEach(function(n) {
      t.push.apply(t, e[n] || []);
    }), t;
  }
  var Pg = /* @__PURE__ */ function(e) {
    JL(t, e);
    function t(n, o) {
      var r;
      return r = e.call(this, "Async Validation Error") || this, r.errors = n, r.fields = o, r;
    }
    return t;
  }(/* @__PURE__ */ Rf(Error));
  function rV(e, t, n, o, r) {
    if (t.first) {
      var s = new Promise(function(p, h) {
        var m = function(y) {
          return o(y), y.length ? h(new Pg(y, xf(y))) : p(r);
        }, v = oV(e);
        Ig(v, n, m);
      });
      return s.catch(function(p) {
        return p;
      }), s;
    }
    var l = t.firstFields === !0 ? Object.keys(e) : t.firstFields || [], a = Object.keys(e), u = a.length, c = 0, f = [], d = new Promise(function(p, h) {
      var m = function(g) {
        if (f.push.apply(f, g), c++, c === u)
          return o(f), f.length ? h(new Pg(f, xf(f))) : p(r);
      };
      a.length || (o(f), p(r)), a.forEach(function(v) {
        var g = e[v];
        l.indexOf(v) !== -1 ? Ig(g, n, m) : nV(g, n, m);
      });
    });
    return d.catch(function(p) {
      return p;
    }), d;
  }
  function sV(e) {
    return !!(e && e.message !== void 0);
  }
  function lV(e, t) {
    for (var n = e, o = 0; o < t.length; o++) {
      if (n == null)
        return n;
      n = n[t[o]];
    }
    return n;
  }
  function Ag(e, t) {
    return function(n) {
      var o;
      return e.fullFields ? o = lV(t, e.fullFields) : o = t[n.field || e.fullField], sV(n) ? (n.field = n.field || e.fullField, n.fieldValue = o, n) : {
        message: typeof n == "function" ? n() : n,
        fieldValue: o,
        field: n.field || e.fullField
      };
    };
  }
  function Rg(e, t) {
    if (t) {
      for (var n in t)
        if (t.hasOwnProperty(n)) {
          var o = t[n];
          typeof o == "object" && typeof e[n] == "object" ? e[n] = ds({}, e[n], o) : e[n] = o;
        }
    }
    return e;
  }
  var Kw = function(t, n, o, r, s, l) {
    t.required && (!o.hasOwnProperty(t.field) || un(n, l || t.type)) && r.push(jn(s.messages.required, t.fullField));
  }, aV = function(t, n, o, r, s) {
    (/^\s+$/.test(n) || n === "") && r.push(jn(s.messages.whitespace, t.fullField));
  }, zi, iV = function() {
    if (zi)
      return zi;
    var e = "[a-fA-F\\d:]", t = function(C) {
      return C && C.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : "";
    }, n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", o = "[a-fA-F\\d]{1,4}", r = (`
(?:
(?:` + o + ":){7}(?:" + o + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + o + ":){6}(?:" + n + "|:" + o + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + o + ":){5}(?::" + n + "|(?::" + o + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + o + ":){4}(?:(?::" + o + "){0,1}:" + n + "|(?::" + o + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + o + ":){3}(?:(?::" + o + "){0,2}:" + n + "|(?::" + o + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + o + ":){2}(?:(?::" + o + "){0,3}:" + n + "|(?::" + o + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + o + ":){1}(?:(?::" + o + "){0,4}:" + n + "|(?::" + o + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + o + "){0,5}:" + n + "|(?::" + o + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), s = new RegExp("(?:^" + n + "$)|(?:^" + r + "$)"), l = new RegExp("^" + n + "$"), a = new RegExp("^" + r + "$"), u = function(C) {
      return C && C.exact ? s : new RegExp("(?:" + t(C) + n + t(C) + ")|(?:" + t(C) + r + t(C) + ")", "g");
    };
    u.v4 = function(b) {
      return b && b.exact ? l : new RegExp("" + t(b) + n + t(b), "g");
    }, u.v6 = function(b) {
      return b && b.exact ? a : new RegExp("" + t(b) + r + t(b), "g");
    };
    var c = "(?:(?:[a-z]+:)?//)", f = "(?:\\S+(?::\\S*)?@)?", d = u.v4().source, p = u.v6().source, h = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", m = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", v = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", g = "(?::\\d{2,5})?", y = '(?:[/?#][^\\s"]*)?', w = "(?:" + c + "|www\\.)" + f + "(?:localhost|" + d + "|" + p + "|" + h + m + v + ")" + g + y;
    return zi = new RegExp("(?:^" + w + "$)", "i"), zi;
  }, xg = {
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  }, ia = {
    integer: function(t) {
      return ia.number(t) && parseInt(t, 10) === t;
    },
    float: function(t) {
      return ia.number(t) && !ia.integer(t);
    },
    array: function(t) {
      return Array.isArray(t);
    },
    regexp: function(t) {
      if (t instanceof RegExp)
        return !0;
      try {
        return !!new RegExp(t);
      } catch {
        return !1;
      }
    },
    date: function(t) {
      return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
    },
    number: function(t) {
      return isNaN(t) ? !1 : typeof t == "number";
    },
    object: function(t) {
      return typeof t == "object" && !ia.array(t);
    },
    method: function(t) {
      return typeof t == "function";
    },
    email: function(t) {
      return typeof t == "string" && t.length <= 320 && !!t.match(xg.email);
    },
    url: function(t) {
      return typeof t == "string" && t.length <= 2048 && !!t.match(iV());
    },
    hex: function(t) {
      return typeof t == "string" && !!t.match(xg.hex);
    }
  }, uV = function(t, n, o, r, s) {
    if (t.required && n === void 0) {
      Kw(t, n, o, r, s);
      return;
    }
    var l = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], a = t.type;
    l.indexOf(a) > -1 ? ia[a](n) || r.push(jn(s.messages.types[a], t.fullField, t.type)) : a && typeof n !== t.type && r.push(jn(s.messages.types[a], t.fullField, t.type));
  }, cV = function(t, n, o, r, s) {
    var l = typeof t.len == "number", a = typeof t.min == "number", u = typeof t.max == "number", c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, f = n, d = null, p = typeof n == "number", h = typeof n == "string", m = Array.isArray(n);
    if (p ? d = "number" : h ? d = "string" : m && (d = "array"), !d)
      return !1;
    m && (f = n.length), h && (f = n.replace(c, "_").length), l ? f !== t.len && r.push(jn(s.messages[d].len, t.fullField, t.len)) : a && !u && f < t.min ? r.push(jn(s.messages[d].min, t.fullField, t.min)) : u && !a && f > t.max ? r.push(jn(s.messages[d].max, t.fullField, t.max)) : a && u && (f < t.min || f > t.max) && r.push(jn(s.messages[d].range, t.fullField, t.min, t.max));
  }, zs = "enum", dV = function(t, n, o, r, s) {
    t[zs] = Array.isArray(t[zs]) ? t[zs] : [], t[zs].indexOf(n) === -1 && r.push(jn(s.messages[zs], t.fullField, t[zs].join(", ")));
  }, fV = function(t, n, o, r, s) {
    if (t.pattern) {
      if (t.pattern instanceof RegExp)
        t.pattern.lastIndex = 0, t.pattern.test(n) || r.push(jn(s.messages.pattern.mismatch, t.fullField, n, t.pattern));
      else if (typeof t.pattern == "string") {
        var l = new RegExp(t.pattern);
        l.test(n) || r.push(jn(s.messages.pattern.mismatch, t.fullField, n, t.pattern));
      }
    }
  }, It = {
    required: Kw,
    whitespace: aV,
    type: uV,
    range: cV,
    enum: dV,
    pattern: fV
  }, pV = function(t, n, o, r, s) {
    var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
      if (un(n, "string") && !t.required)
        return o();
      It.required(t, n, r, l, s, "string"), un(n, "string") || (It.type(t, n, r, l, s), It.range(t, n, r, l, s), It.pattern(t, n, r, l, s), t.whitespace === !0 && It.whitespace(t, n, r, l, s));
    }
    o(l);
  }, hV = function(t, n, o, r, s) {
    var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
      if (un(n) && !t.required)
        return o();
      It.required(t, n, r, l, s), n !== void 0 && It.type(t, n, r, l, s);
    }
    o(l);
  }, vV = function(t, n, o, r, s) {
    var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
      if (n === "" && (n = void 0), un(n) && !t.required)
        return o();
      It.required(t, n, r, l, s), n !== void 0 && (It.type(t, n, r, l, s), It.range(t, n, r, l, s));
    }
    o(l);
  }, mV = function(t, n, o, r, s) {
    var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
      if (un(n) && !t.required)
        return o();
      It.required(t, n, r, l, s), n !== void 0 && It.type(t, n, r, l, s);
    }
    o(l);
  }, gV = function(t, n, o, r, s) {
    var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
      if (un(n) && !t.required)
        return o();
      It.required(t, n, r, l, s), un(n) || It.type(t, n, r, l, s);
    }
    o(l);
  }, yV = function(t, n, o, r, s) {
    var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
      if (un(n) && !t.required)
        return o();
      It.required(t, n, r, l, s), n !== void 0 && (It.type(t, n, r, l, s), It.range(t, n, r, l, s));
    }
    o(l);
  }, bV = function(t, n, o, r, s) {
    var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
      if (un(n) && !t.required)
        return o();
      It.required(t, n, r, l, s), n !== void 0 && (It.type(t, n, r, l, s), It.range(t, n, r, l, s));
    }
    o(l);
  }, wV = function(t, n, o, r, s) {
    var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
      if (n == null && !t.required)
        return o();
      It.required(t, n, r, l, s, "array"), n != null && (It.type(t, n, r, l, s), It.range(t, n, r, l, s));
    }
    o(l);
  }, CV = function(t, n, o, r, s) {
    var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
      if (un(n) && !t.required)
        return o();
      It.required(t, n, r, l, s), n !== void 0 && It.type(t, n, r, l, s);
    }
    o(l);
  }, EV = "enum", SV = function(t, n, o, r, s) {
    var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
      if (un(n) && !t.required)
        return o();
      It.required(t, n, r, l, s), n !== void 0 && It[EV](t, n, r, l, s);
    }
    o(l);
  }, _V = function(t, n, o, r, s) {
    var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
      if (un(n, "string") && !t.required)
        return o();
      It.required(t, n, r, l, s), un(n, "string") || It.pattern(t, n, r, l, s);
    }
    o(l);
  }, kV = function(t, n, o, r, s) {
    var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
      if (un(n, "date") && !t.required)
        return o();
      if (It.required(t, n, r, l, s), !un(n, "date")) {
        var u;
        n instanceof Date ? u = n : u = new Date(n), It.type(t, u, r, l, s), u && It.range(t, u.getTime(), r, l, s);
      }
    }
    o(l);
  }, $V = function(t, n, o, r, s) {
    var l = [], a = Array.isArray(n) ? "array" : typeof n;
    It.required(t, n, r, l, s, a), o(l);
  }, $d = function(t, n, o, r, s) {
    var l = t.type, a = [], u = t.required || !t.required && r.hasOwnProperty(t.field);
    if (u) {
      if (un(n, l) && !t.required)
        return o();
      It.required(t, n, r, a, s, l), un(n, l) || It.type(t, n, r, a, s);
    }
    o(a);
  }, NV = function(t, n, o, r, s) {
    var l = [], a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
      if (un(n) && !t.required)
        return o();
      It.required(t, n, r, l, s);
    }
    o(l);
  }, ya = {
    string: pV,
    method: hV,
    number: vV,
    boolean: mV,
    regexp: gV,
    integer: yV,
    float: bV,
    array: wV,
    object: CV,
    enum: SV,
    pattern: _V,
    date: kV,
    url: $d,
    hex: $d,
    email: $d,
    required: $V,
    any: NV
  };
  function Df() {
    return {
      default: "Validation error on field %s",
      required: "%s is required",
      enum: "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid"
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        boolean: "%s is not a %s",
        integer: "%s is not an %s",
        float: "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s"
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters"
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s"
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length"
      },
      pattern: {
        mismatch: "%s value %s does not match pattern %s"
      },
      clone: function() {
        var t = JSON.parse(JSON.stringify(this));
        return t.clone = this.clone, t;
      }
    };
  }
  var Lf = Df(), _i = /* @__PURE__ */ function() {
    function e(n) {
      this.rules = null, this._messages = Lf, this.define(n);
    }
    var t = e.prototype;
    return t.define = function(o) {
      var r = this;
      if (!o)
        throw new Error("Cannot configure a schema with no rules");
      if (typeof o != "object" || Array.isArray(o))
        throw new Error("Rules must be an object");
      this.rules = {}, Object.keys(o).forEach(function(s) {
        var l = o[s];
        r.rules[s] = Array.isArray(l) ? l : [l];
      });
    }, t.messages = function(o) {
      return o && (this._messages = Rg(Df(), o)), this._messages;
    }, t.validate = function(o, r, s) {
      var l = this;
      r === void 0 && (r = {}), s === void 0 && (s = function() {
      });
      var a = o, u = r, c = s;
      if (typeof u == "function" && (c = u, u = {}), !this.rules || Object.keys(this.rules).length === 0)
        return c && c(null, a), Promise.resolve(a);
      function f(v) {
        var g = [], y = {};
        function w(C) {
          if (Array.isArray(C)) {
            var _;
            g = (_ = g).concat.apply(_, C);
          } else
            g.push(C);
        }
        for (var b = 0; b < v.length; b++)
          w(v[b]);
        g.length ? (y = xf(g), c(g, y)) : c(null, a);
      }
      if (u.messages) {
        var d = this.messages();
        d === Lf && (d = Df()), Rg(d, u.messages), u.messages = d;
      } else
        u.messages = this.messages();
      var p = {}, h = u.keys || Object.keys(this.rules);
      h.forEach(function(v) {
        var g = l.rules[v], y = a[v];
        g.forEach(function(w) {
          var b = w;
          typeof b.transform == "function" && (a === o && (a = ds({}, a)), y = a[v] = b.transform(y)), typeof b == "function" ? b = {
            validator: b
          } : b = ds({}, b), b.validator = l.getValidationMethod(b), b.validator && (b.field = v, b.fullField = b.fullField || v, b.type = l.getType(b), p[v] = p[v] || [], p[v].push({
            rule: b,
            value: y,
            source: a,
            field: v
          }));
        });
      });
      var m = {};
      return rV(p, u, function(v, g) {
        var y = v.rule, w = (y.type === "object" || y.type === "array") && (typeof y.fields == "object" || typeof y.defaultField == "object");
        w = w && (y.required || !y.required && v.value), y.field = v.field;
        function b(k, O) {
          return ds({}, O, {
            fullField: y.fullField + "." + k,
            fullFields: y.fullFields ? [].concat(y.fullFields, [k]) : [k]
          });
        }
        function C(k) {
          k === void 0 && (k = []);
          var O = Array.isArray(k) ? k : [k];
          !u.suppressWarning && O.length && e.warning("async-validator:", O), O.length && y.message !== void 0 && (O = [].concat(y.message));
          var T = O.map(Ag(y, a));
          if (u.first && T.length)
            return m[y.field] = 1, g(T);
          if (!w)
            g(T);
          else {
            if (y.required && !v.value)
              return y.message !== void 0 ? T = [].concat(y.message).map(Ag(y, a)) : u.error && (T = [u.error(y, jn(u.messages.required, y.field))]), g(T);
            var P = {};
            y.defaultField && Object.keys(v.value).map(function(D) {
              P[D] = y.defaultField;
            }), P = ds({}, P, v.rule.fields);
            var A = {};
            Object.keys(P).forEach(function(D) {
              var B = P[D], F = Array.isArray(B) ? B : [B];
              A[D] = F.map(b.bind(null, D));
            });
            var L = new e(A);
            L.messages(u.messages), v.rule.options && (v.rule.options.messages = u.messages, v.rule.options.error = u.error), L.validate(v.value, v.rule.options || u, function(D) {
              var B = [];
              T && T.length && B.push.apply(B, T), D && D.length && B.push.apply(B, D), g(B.length ? B : null);
            });
          }
        }
        var _;
        if (y.asyncValidator)
          _ = y.asyncValidator(y, v.value, C, v.source, u);
        else if (y.validator) {
          try {
            _ = y.validator(y, v.value, C, v.source, u);
          } catch (k) {
            console.error == null || console.error(k), u.suppressValidatorError || setTimeout(function() {
              throw k;
            }, 0), C(k.message);
          }
          _ === !0 ? C() : _ === !1 ? C(typeof y.message == "function" ? y.message(y.fullField || y.field) : y.message || (y.fullField || y.field) + " fails") : _ instanceof Array ? C(_) : _ instanceof Error && C(_.message);
        }
        _ && _.then && _.then(function() {
          return C();
        }, function(k) {
          return C(k);
        });
      }, function(v) {
        f(v);
      }, a);
    }, t.getType = function(o) {
      if (o.type === void 0 && o.pattern instanceof RegExp && (o.type = "pattern"), typeof o.validator != "function" && o.type && !ya.hasOwnProperty(o.type))
        throw new Error(jn("Unknown rule type %s", o.type));
      return o.type || "string";
    }, t.getValidationMethod = function(o) {
      if (typeof o.validator == "function")
        return o.validator;
      var r = Object.keys(o), s = r.indexOf("message");
      return s !== -1 && r.splice(s, 1), r.length === 1 && r[0] === "required" ? ya.required : ya[this.getType(o)] || void 0;
    }, e;
  }();
  _i.register = function(t, n) {
    if (typeof n != "function")
      throw new Error("Cannot register a validator by type, validator is not a function");
    ya[t] = n;
  };
  _i.warning = zw;
  _i.messages = Lf;
  _i.validators = ya;
  const TV = [
    "",
    "error",
    "validating",
    "success"
  ], OV = Ie({
    label: String,
    labelWidth: {
      type: [String, Number],
      default: ""
    },
    prop: {
      type: le([String, Array])
    },
    required: {
      type: Boolean,
      default: void 0
    },
    rules: {
      type: le([Object, Array])
    },
    error: String,
    validateStatus: {
      type: String,
      values: TV
    },
    for: String,
    inlineMessage: {
      type: [String, Boolean],
      default: ""
    },
    showMessage: {
      type: Boolean,
      default: !0
    },
    size: {
      type: String,
      values: zo
    }
  }), Dg = "ElLabelWrap";
  var MV = G({
    name: Dg,
    props: {
      isAutoWidth: Boolean,
      updateAll: Boolean
    },
    setup(e, {
      slots: t
    }) {
      const n = Be(Hs, void 0), o = Be(Ho);
      o || Yt(Dg, "usage: <el-form-item><label-wrap /></el-form-item>");
      const r = ge("form"), s = I(), l = I(0), a = () => {
        var f;
        if ((f = s.value) != null && f.firstElementChild) {
          const d = window.getComputedStyle(s.value.firstElementChild).width;
          return Math.ceil(Number.parseFloat(d));
        } else
          return 0;
      }, u = (f = "update") => {
        Fe(() => {
          t.default && e.isAutoWidth && (f === "update" ? l.value = a() : f === "remove" && (n == null || n.deregisterLabelWidth(l.value)));
        });
      }, c = () => u("update");
      return st(() => {
        c();
      }), zt(() => {
        u("remove");
      }), cr(() => c()), me(l, (f, d) => {
        e.updateAll && (n == null || n.registerLabelWidth(f, d));
      }), Cn(E(() => {
        var f, d;
        return (d = (f = s.value) == null ? void 0 : f.firstElementChild) != null ? d : null;
      }), c), () => {
        var f, d;
        if (!t)
          return null;
        const {
          isAutoWidth: p
        } = e;
        if (p) {
          const h = n == null ? void 0 : n.autoLabelWidth, m = o == null ? void 0 : o.hasLabel, v = {};
          if (m && h && h !== "auto") {
            const g = Math.max(0, Number.parseInt(h, 10) - l.value), y = n.labelPosition === "left" ? "marginRight" : "marginLeft";
            g && (v[y] = `${g}px`);
          }
          return K("div", {
            ref: s,
            class: [r.be("item", "label-wrap")],
            style: v
          }, [(f = t.default) == null ? void 0 : f.call(t)]);
        } else
          return K(ze, {
            ref: s
          }, [(d = t.default) == null ? void 0 : d.call(t)]);
      };
    }
  });
  const IV = ["role", "aria-labelledby"], PV = G({
    name: "ElFormItem"
  }), AV = /* @__PURE__ */ G({
    ...PV,
    props: OV,
    setup(e, { expose: t }) {
      const n = e, o = hn(), r = Be(Hs, void 0), s = Be(Ho, void 0), l = on(void 0, { formItem: !1 }), a = ge("form-item"), u = io().value, c = I([]), f = I(""), d = fN(f, 100), p = I(""), h = I();
      let m, v = !1;
      const g = E(() => {
        if ((r == null ? void 0 : r.labelPosition) === "top")
          return {};
        const ne = Jt(n.labelWidth || (r == null ? void 0 : r.labelWidth) || "");
        return ne ? { width: ne } : {};
      }), y = E(() => {
        if ((r == null ? void 0 : r.labelPosition) === "top" || (r == null ? void 0 : r.inline))
          return {};
        if (!n.label && !n.labelWidth && P)
          return {};
        const ne = Jt(n.labelWidth || (r == null ? void 0 : r.labelWidth) || "");
        return !n.label && !o.label ? { marginLeft: ne } : {};
      }), w = E(() => [
        a.b(),
        a.m(l.value),
        a.is("error", f.value === "error"),
        a.is("validating", f.value === "validating"),
        a.is("success", f.value === "success"),
        a.is("required", F.value || n.required),
        a.is("no-asterisk", r == null ? void 0 : r.hideRequiredAsterisk),
        (r == null ? void 0 : r.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
        { [a.m("feedback")]: r == null ? void 0 : r.statusIcon }
      ]), b = E(() => tn(n.inlineMessage) ? n.inlineMessage : (r == null ? void 0 : r.inlineMessage) || !1), C = E(() => [
        a.e("error"),
        { [a.em("error", "inline")]: b.value }
      ]), _ = E(() => n.prop ? et(n.prop) ? n.prop : n.prop.join(".") : ""), k = E(() => !!(n.label || o.label)), O = E(() => n.for || c.value.length === 1 ? c.value[0] : void 0), T = E(() => !O.value && k.value), P = !!s, A = E(() => {
        const ne = r == null ? void 0 : r.model;
        if (!(!ne || !n.prop))
          return iu(ne, n.prop).value;
      }), L = E(() => {
        const { required: ne } = n, Y = [];
        n.rules && Y.push(...kl(n.rules));
        const re = r == null ? void 0 : r.rules;
        if (re && n.prop) {
          const ce = iu(re, n.prop).value;
          ce && Y.push(...kl(ce));
        }
        if (ne !== void 0) {
          const ce = Y.map((Te, Pe) => [Te, Pe]).filter(([Te]) => Object.keys(Te).includes("required"));
          if (ce.length > 0)
            for (const [Te, Pe] of ce)
              Te.required !== ne && (Y[Pe] = { ...Te, required: ne });
          else
            Y.push({ required: ne });
        }
        return Y;
      }), D = E(() => L.value.length > 0), B = (ne) => L.value.filter((re) => !re.trigger || !ne ? !0 : Array.isArray(re.trigger) ? re.trigger.includes(ne) : re.trigger === ne).map(({ trigger: re, ...ce }) => ce), F = E(() => L.value.some((ne) => ne.required)), W = E(() => {
        var ne;
        return d.value === "error" && n.showMessage && ((ne = r == null ? void 0 : r.showMessage) != null ? ne : !0);
      }), x = E(() => `${n.label || ""}${(r == null ? void 0 : r.labelSuffix) || ""}`), N = (ne) => {
        f.value = ne;
      }, R = (ne) => {
        var Y, re;
        const { errors: ce, fields: Te } = ne;
        (!ce || !Te) && console.error(ne), N("error"), p.value = ce ? (re = (Y = ce == null ? void 0 : ce[0]) == null ? void 0 : Y.message) != null ? re : `${n.prop} is required` : "", r == null || r.emit("validate", n.prop, !1, p.value);
      }, M = () => {
        N("success"), r == null || r.emit("validate", n.prop, !0, "");
      }, j = async (ne) => {
        const Y = _.value;
        return new _i({
          [Y]: ne
        }).validate({ [Y]: A.value }, { firstFields: !0 }).then(() => (M(), !0)).catch((ce) => (R(ce), Promise.reject(ce)));
      }, te = async (ne, Y) => {
        if (v || !n.prop)
          return !1;
        const re = Ge(Y);
        if (!D.value)
          return Y == null || Y(!1), !1;
        const ce = B(ne);
        return ce.length === 0 ? (Y == null || Y(!0), !0) : (N("validating"), j(ce).then(() => (Y == null || Y(!0), !0)).catch((Te) => {
          const { fields: Pe } = Te;
          return Y == null || Y(!1, Pe), re ? !1 : Promise.reject(Pe);
        }));
      }, U = () => {
        N(""), p.value = "", v = !1;
      }, Z = async () => {
        const ne = r == null ? void 0 : r.model;
        if (!ne || !n.prop)
          return;
        const Y = iu(ne, n.prop);
        v = !0, Y.value = lg(m), await Fe(), U(), v = !1;
      }, pe = (ne) => {
        c.value.includes(ne) || c.value.push(ne);
      }, J = (ne) => {
        c.value = c.value.filter((Y) => Y !== ne);
      };
      me(() => n.error, (ne) => {
        p.value = ne || "", N(ne ? "error" : "");
      }, { immediate: !0 }), me(() => n.validateStatus, (ne) => N(ne || ""));
      const ee = Tt({
        ...rn(n),
        $el: h,
        size: l,
        validateState: f,
        labelId: u,
        inputIds: c,
        isGroup: T,
        hasLabel: k,
        addInputId: pe,
        removeInputId: J,
        resetField: Z,
        clearValidate: U,
        validate: te
      });
      return pt(Ho, ee), st(() => {
        n.prop && (r == null || r.addField(ee), m = lg(A.value));
      }), zt(() => {
        r == null || r.removeField(ee);
      }), t({
        size: l,
        validateMessage: p,
        validateState: f,
        validate: te,
        clearValidate: U,
        resetField: Z
      }), (ne, Y) => {
        var re;
        return S(), V("div", {
          ref_key: "formItemRef",
          ref: h,
          class: $(i(w)),
          role: i(T) ? "group" : void 0,
          "aria-labelledby": i(T) ? i(u) : void 0
        }, [
          K(i(MV), {
            "is-auto-width": i(g).width === "auto",
            "update-all": ((re = i(r)) == null ? void 0 : re.labelWidth) === "auto"
          }, {
            default: X(() => [
              i(k) ? (S(), ie(vt(i(O) ? "label" : "div"), {
                key: 0,
                id: i(u),
                for: i(O),
                class: $(i(a).e("label")),
                style: Ke(i(g))
              }, {
                default: X(() => [
                  he(ne.$slots, "label", { label: i(x) }, () => [
                    wt(Ne(i(x)), 1)
                  ])
                ]),
                _: 3
              }, 8, ["id", "for", "class", "style"])) : se("v-if", !0)
            ]),
            _: 3
          }, 8, ["is-auto-width", "update-all"]),
          H("div", {
            class: $(i(a).e("content")),
            style: Ke(i(y))
          }, [
            he(ne.$slots, "default"),
            K(Q0, {
              name: `${i(a).namespace.value}-zoom-in-top`
            }, {
              default: X(() => [
                i(W) ? he(ne.$slots, "error", {
                  key: 0,
                  error: p.value
                }, () => [
                  H("div", {
                    class: $(i(C))
                  }, Ne(p.value), 3)
                ]) : se("v-if", !0)
              ]),
              _: 3
            }, 8, ["name"])
          ], 6)
        ], 10, IV);
      };
    }
  });
  var jw = /* @__PURE__ */ Me(AV, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]);
  const RV = ut(XL, {
    FormItem: jw
  }), xV = Gt(jw);
  let fo;
  const DV = `
  height:0 !important;
  visibility:hidden !important;
  ${sw() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`, LV = [
    "letter-spacing",
    "line-height",
    "padding-top",
    "padding-bottom",
    "font-family",
    "font-weight",
    "font-size",
    "text-rendering",
    "text-transform",
    "width",
    "text-indent",
    "padding-left",
    "padding-right",
    "border-width",
    "box-sizing"
  ];
  function VV(e) {
    const t = window.getComputedStyle(e), n = t.getPropertyValue("box-sizing"), o = Number.parseFloat(t.getPropertyValue("padding-bottom")) + Number.parseFloat(t.getPropertyValue("padding-top")), r = Number.parseFloat(t.getPropertyValue("border-bottom-width")) + Number.parseFloat(t.getPropertyValue("border-top-width"));
    return { contextStyle: LV.map((l) => `${l}:${t.getPropertyValue(l)}`).join(";"), paddingSize: o, borderSize: r, boxSizing: n };
  }
  function Lg(e, t = 1, n) {
    var o;
    fo || (fo = document.createElement("textarea"), document.body.appendChild(fo));
    const { paddingSize: r, borderSize: s, boxSizing: l, contextStyle: a } = VV(e);
    fo.setAttribute("style", `${a};${DV}`), fo.value = e.value || e.placeholder || "";
    let u = fo.scrollHeight;
    const c = {};
    l === "border-box" ? u = u + s : l === "content-box" && (u = u - r), fo.value = "";
    const f = fo.scrollHeight - r;
    if (Xe(t)) {
      let d = f * t;
      l === "border-box" && (d = d + r + s), u = Math.max(d, u), c.minHeight = `${d}px`;
    }
    if (Xe(n)) {
      let d = f * n;
      l === "border-box" && (d = d + r + s), u = Math.min(d, u);
    }
    return c.height = `${u}px`, (o = fo.parentNode) == null || o.removeChild(fo), fo = void 0, c;
  }
  const BV = Ie({
    id: {
      type: String,
      default: void 0
    },
    size: yn,
    disabled: Boolean,
    modelValue: {
      type: le([
        String,
        Number,
        Object
      ]),
      default: ""
    },
    type: {
      type: String,
      default: "text"
    },
    resize: {
      type: String,
      values: ["none", "both", "horizontal", "vertical"]
    },
    autosize: {
      type: le([Boolean, Object]),
      default: !1
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    formatter: {
      type: Function
    },
    parser: {
      type: Function
    },
    placeholder: {
      type: String
    },
    form: {
      type: String
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    clearable: {
      type: Boolean,
      default: !1
    },
    showPassword: {
      type: Boolean,
      default: !1
    },
    showWordLimit: {
      type: Boolean,
      default: !1
    },
    suffixIcon: {
      type: Vt
    },
    prefixIcon: {
      type: Vt
    },
    containerRole: {
      type: String,
      default: void 0
    },
    label: {
      type: String,
      default: void 0
    },
    tabindex: {
      type: [String, Number],
      default: 0
    },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    inputStyle: {
      type: le([Object, Array, String]),
      default: () => jt({})
    }
  }), FV = {
    [dt]: (e) => et(e),
    input: (e) => et(e),
    change: (e) => et(e),
    focus: (e) => e instanceof FocusEvent,
    blur: (e) => e instanceof FocusEvent,
    clear: () => !0,
    mouseleave: (e) => e instanceof MouseEvent,
    mouseenter: (e) => e instanceof MouseEvent,
    keydown: (e) => e instanceof Event,
    compositionstart: (e) => e instanceof CompositionEvent,
    compositionupdate: (e) => e instanceof CompositionEvent,
    compositionend: (e) => e instanceof CompositionEvent
  }, HV = ["role"], zV = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form"], KV = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form"], jV = G({
    name: "ElInput",
    inheritAttrs: !1
  }), WV = /* @__PURE__ */ G({
    ...jV,
    props: BV,
    emits: FV,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = zl(), s = hn(), l = E(() => {
        const fe = {};
        return o.containerRole === "combobox" && (fe["aria-haspopup"] = r["aria-haspopup"], fe["aria-owns"] = r["aria-owns"], fe["aria-expanded"] = r["aria-expanded"]), fe;
      }), a = E(() => [
        o.type === "textarea" ? g.b() : v.b(),
        v.m(h.value),
        v.is("disabled", m.value),
        v.is("exceed", te.value),
        {
          [v.b("group")]: s.prepend || s.append,
          [v.bm("group", "append")]: s.append,
          [v.bm("group", "prepend")]: s.prepend,
          [v.m("prefix")]: s.prefix || o.prefixIcon,
          [v.m("suffix")]: s.suffix || o.suffixIcon || o.clearable || o.showPassword,
          [v.bm("suffix", "password-clear")]: N.value && R.value
        },
        r.class
      ]), u = E(() => [
        v.e("wrapper"),
        v.is("focus", b.value)
      ]), c = $h({
        excludeKeys: E(() => Object.keys(l.value))
      }), { form: f, formItem: d } = In(), { inputId: p } = Zr(o, {
        formItemContext: d
      }), h = on(), m = Fn(), v = ge("input"), g = ge("textarea"), y = xt(), w = xt(), b = I(!1), C = I(!1), _ = I(!1), k = I(!1), O = I(), T = xt(o.inputStyle), P = E(() => y.value || w.value), A = E(() => {
        var fe;
        return (fe = f == null ? void 0 : f.statusIcon) != null ? fe : !1;
      }), L = E(() => (d == null ? void 0 : d.validateState) || ""), D = E(() => L.value && ow[L.value]), B = E(() => k.value ? Kx : GA), F = E(() => [
        r.style,
        o.inputStyle
      ]), W = E(() => [
        o.inputStyle,
        T.value,
        { resize: o.resize }
      ]), x = E(() => nn(o.modelValue) ? "" : String(o.modelValue)), N = E(() => o.clearable && !m.value && !o.readonly && !!x.value && (b.value || C.value)), R = E(() => o.showPassword && !m.value && !o.readonly && !!x.value && (!!x.value || b.value)), M = E(() => o.showWordLimit && !!c.value.maxlength && (o.type === "text" || o.type === "textarea") && !m.value && !o.readonly && !o.showPassword), j = E(() => x.value.length), te = E(() => !!M.value && j.value > Number(c.value.maxlength)), U = E(() => !!s.suffix || !!o.suffixIcon || N.value || o.showPassword || M.value || !!L.value && A.value), [Z, pe] = gL(y);
      Cn(w, (fe) => {
        if (ne(), !M.value || o.resize !== "both")
          return;
        const Ae = fe[0], { width: qe } = Ae.contentRect;
        O.value = {
          right: `calc(100% - ${qe + 15 + 6}px)`
        };
      });
      const J = () => {
        const { type: fe, autosize: Ae } = o;
        if (!(!bt || fe !== "textarea" || !w.value))
          if (Ae) {
            const qe = rt(Ae) ? Ae.minRows : void 0, tt = rt(Ae) ? Ae.maxRows : void 0, Je = Lg(w.value, qe, tt);
            T.value = {
              overflowY: "hidden",
              ...Je
            }, Fe(() => {
              w.value.offsetHeight, T.value = Je;
            });
          } else
            T.value = {
              minHeight: Lg(w.value).minHeight
            };
      }, ne = ((fe) => {
        let Ae = !1;
        return () => {
          var qe;
          if (Ae || !o.autosize)
            return;
          ((qe = w.value) == null ? void 0 : qe.offsetParent) === null || (fe(), Ae = !0);
        };
      })(J), Y = () => {
        const fe = P.value;
        !fe || fe.value === x.value || (fe.value = x.value);
      }, re = async (fe) => {
        Z();
        let { value: Ae } = fe.target;
        if (o.formatter && (Ae = o.parser ? o.parser(Ae) : Ae, Ae = o.formatter(Ae)), !_.value) {
          if (Ae === x.value) {
            Y();
            return;
          }
          n(dt, Ae), n("input", Ae), await Fe(), Y(), pe();
        }
      }, ce = (fe) => {
        n("change", fe.target.value);
      }, Te = (fe) => {
        n("compositionstart", fe), _.value = !0;
      }, Pe = (fe) => {
        var Ae;
        n("compositionupdate", fe);
        const qe = (Ae = fe.target) == null ? void 0 : Ae.value, tt = qe[qe.length - 1] || "";
        _.value = !Kc(tt);
      }, z = (fe) => {
        n("compositionend", fe), _.value && (_.value = !1, re(fe));
      }, Q = () => {
        k.value = !k.value, de();
      }, de = async () => {
        var fe;
        await Fe(), (fe = P.value) == null || fe.focus();
      }, Oe = () => {
        var fe;
        return (fe = P.value) == null ? void 0 : fe.blur();
      }, ae = (fe) => {
        b.value = !0, n("focus", fe);
      }, Ee = (fe) => {
        var Ae;
        b.value = !1, n("blur", fe), o.validateEvent && ((Ae = d == null ? void 0 : d.validate) == null || Ae.call(d, "blur").catch((qe) => yt(qe)));
      }, we = (fe) => {
        C.value = !1, n("mouseleave", fe);
      }, Se = (fe) => {
        C.value = !0, n("mouseenter", fe);
      }, _e = (fe) => {
        n("keydown", fe);
      }, ke = () => {
        var fe;
        (fe = P.value) == null || fe.select();
      }, Re = () => {
        n(dt, ""), n("change", ""), n("clear"), n("input", "");
      };
      return me(() => o.modelValue, () => {
        var fe;
        Fe(() => J()), o.validateEvent && ((fe = d == null ? void 0 : d.validate) == null || fe.call(d, "change").catch((Ae) => yt(Ae)));
      }), me(x, () => Y()), me(() => o.type, async () => {
        await Fe(), Y(), J();
      }), st(() => {
        !o.formatter && o.parser && yt("ElInput", "If you set the parser, you also need to set the formatter."), Y(), Fe(J);
      }), t({
        input: y,
        textarea: w,
        ref: P,
        textareaStyle: W,
        autosize: Ht(o, "autosize"),
        focus: de,
        blur: Oe,
        select: ke,
        clear: Re,
        resizeTextarea: J
      }), (fe, Ae) => ot((S(), V("div", ft(i(l), {
        class: i(a),
        style: i(F),
        role: fe.containerRole,
        onMouseenter: Se,
        onMouseleave: we
      }), [
        se(" input "),
        fe.type !== "textarea" ? (S(), V(ze, { key: 0 }, [
          se(" prepend slot "),
          fe.$slots.prepend ? (S(), V("div", {
            key: 0,
            class: $(i(v).be("group", "prepend"))
          }, [
            he(fe.$slots, "prepend")
          ], 2)) : se("v-if", !0),
          H("div", {
            class: $(i(u))
          }, [
            se(" prefix slot "),
            fe.$slots.prefix || fe.prefixIcon ? (S(), V("span", {
              key: 0,
              class: $(i(v).e("prefix"))
            }, [
              H("span", {
                class: $(i(v).e("prefix-inner")),
                onClick: de
              }, [
                he(fe.$slots, "prefix"),
                fe.prefixIcon ? (S(), ie(i(He), {
                  key: 0,
                  class: $(i(v).e("icon"))
                }, {
                  default: X(() => [
                    (S(), ie(vt(fe.prefixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : se("v-if", !0)
              ], 2)
            ], 2)) : se("v-if", !0),
            H("input", ft({
              id: i(p),
              ref_key: "input",
              ref: y,
              class: i(v).e("inner")
            }, i(c), {
              type: fe.showPassword ? k.value ? "text" : "password" : fe.type,
              disabled: i(m),
              formatter: fe.formatter,
              parser: fe.parser,
              readonly: fe.readonly,
              autocomplete: fe.autocomplete,
              tabindex: fe.tabindex,
              "aria-label": fe.label,
              placeholder: fe.placeholder,
              style: fe.inputStyle,
              form: o.form,
              onCompositionstart: Te,
              onCompositionupdate: Pe,
              onCompositionend: z,
              onInput: re,
              onFocus: ae,
              onBlur: Ee,
              onChange: ce,
              onKeydown: _e
            }), null, 16, zV),
            se(" suffix slot "),
            i(U) ? (S(), V("span", {
              key: 1,
              class: $(i(v).e("suffix"))
            }, [
              H("span", {
                class: $(i(v).e("suffix-inner")),
                onClick: de
              }, [
                !i(N) || !i(R) || !i(M) ? (S(), V(ze, { key: 0 }, [
                  he(fe.$slots, "suffix"),
                  fe.suffixIcon ? (S(), ie(i(He), {
                    key: 0,
                    class: $(i(v).e("icon"))
                  }, {
                    default: X(() => [
                      (S(), ie(vt(fe.suffixIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : se("v-if", !0)
                ], 64)) : se("v-if", !0),
                i(N) ? (S(), ie(i(He), {
                  key: 1,
                  class: $([i(v).e("icon"), i(v).e("clear")]),
                  onMousedown: Ze(i(Nt), ["prevent"]),
                  onClick: Re
                }, {
                  default: X(() => [
                    K(i(Yr))
                  ]),
                  _: 1
                }, 8, ["class", "onMousedown"])) : se("v-if", !0),
                i(R) ? (S(), ie(i(He), {
                  key: 2,
                  class: $([i(v).e("icon"), i(v).e("password")]),
                  onClick: Q
                }, {
                  default: X(() => [
                    (S(), ie(vt(i(B))))
                  ]),
                  _: 1
                }, 8, ["class"])) : se("v-if", !0),
                i(M) ? (S(), V("span", {
                  key: 3,
                  class: $(i(v).e("count"))
                }, [
                  H("span", {
                    class: $(i(v).e("count-inner"))
                  }, Ne(i(j)) + " / " + Ne(i(c).maxlength), 3)
                ], 2)) : se("v-if", !0),
                i(L) && i(D) && i(A) ? (S(), ie(i(He), {
                  key: 4,
                  class: $([
                    i(v).e("icon"),
                    i(v).e("validateIcon"),
                    i(v).is("loading", i(L) === "validating")
                  ])
                }, {
                  default: X(() => [
                    (S(), ie(vt(i(D))))
                  ]),
                  _: 1
                }, 8, ["class"])) : se("v-if", !0)
              ], 2)
            ], 2)) : se("v-if", !0)
          ], 2),
          se(" append slot "),
          fe.$slots.append ? (S(), V("div", {
            key: 1,
            class: $(i(v).be("group", "append"))
          }, [
            he(fe.$slots, "append")
          ], 2)) : se("v-if", !0)
        ], 64)) : (S(), V(ze, { key: 1 }, [
          se(" textarea "),
          H("textarea", ft({
            id: i(p),
            ref_key: "textarea",
            ref: w,
            class: i(g).e("inner")
          }, i(c), {
            tabindex: fe.tabindex,
            disabled: i(m),
            readonly: fe.readonly,
            autocomplete: fe.autocomplete,
            style: i(W),
            "aria-label": fe.label,
            placeholder: fe.placeholder,
            form: o.form,
            onCompositionstart: Te,
            onCompositionupdate: Pe,
            onCompositionend: z,
            onInput: re,
            onFocus: ae,
            onBlur: Ee,
            onChange: ce,
            onKeydown: _e
          }), null, 16, KV),
          i(M) ? (S(), V("span", {
            key: 0,
            style: Ke(O.value),
            class: $(i(v).e("count"))
          }, Ne(i(j)) + " / " + Ne(i(c).maxlength), 7)) : se("v-if", !0)
        ], 64))
      ], 16, HV)), [
        [$t, fe.type !== "hidden"]
      ]);
    }
  });
  var UV = /* @__PURE__ */ Me(WV, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
  const wn = ut(UV), nl = 4, Ww = {
    vertical: {
      offset: "offsetHeight",
      scroll: "scrollTop",
      scrollSize: "scrollHeight",
      size: "height",
      key: "vertical",
      axis: "Y",
      client: "clientY",
      direction: "top"
    },
    horizontal: {
      offset: "offsetWidth",
      scroll: "scrollLeft",
      scrollSize: "scrollWidth",
      size: "width",
      key: "horizontal",
      axis: "X",
      client: "clientX",
      direction: "left"
    }
  }, qV = ({
    move: e,
    size: t,
    bar: n
  }) => ({
    [n.size]: t,
    transform: `translate${n.axis}(${e}%)`
  }), Uw = Symbol("scrollbarContextKey"), YV = Ie({
    vertical: Boolean,
    size: String,
    move: Number,
    ratio: {
      type: Number,
      required: !0
    },
    always: Boolean
  }), GV = "Thumb", XV = /* @__PURE__ */ G({
    __name: "thumb",
    props: YV,
    setup(e) {
      const t = e, n = Be(Uw), o = ge("scrollbar");
      n || Yt(GV, "can not inject scrollbar context");
      const r = I(), s = I(), l = I({}), a = I(!1);
      let u = !1, c = !1, f = bt ? document.onselectstart : null;
      const d = E(() => Ww[t.vertical ? "vertical" : "horizontal"]), p = E(() => qV({
        size: t.size,
        move: t.move,
        bar: d.value
      })), h = E(() => r.value[d.value.offset] ** 2 / n.wrapElement[d.value.scrollSize] / t.ratio / s.value[d.value.offset]), m = (k) => {
        var O;
        if (k.stopPropagation(), k.ctrlKey || [1, 2].includes(k.button))
          return;
        (O = window.getSelection()) == null || O.removeAllRanges(), g(k);
        const T = k.currentTarget;
        !T || (l.value[d.value.axis] = T[d.value.offset] - (k[d.value.client] - T.getBoundingClientRect()[d.value.direction]));
      }, v = (k) => {
        if (!s.value || !r.value || !n.wrapElement)
          return;
        const O = Math.abs(k.target.getBoundingClientRect()[d.value.direction] - k[d.value.client]), T = s.value[d.value.offset] / 2, P = (O - T) * 100 * h.value / r.value[d.value.offset];
        n.wrapElement[d.value.scroll] = P * n.wrapElement[d.value.scrollSize] / 100;
      }, g = (k) => {
        k.stopImmediatePropagation(), u = !0, document.addEventListener("mousemove", y), document.addEventListener("mouseup", w), f = document.onselectstart, document.onselectstart = () => !1;
      }, y = (k) => {
        if (!r.value || !s.value || u === !1)
          return;
        const O = l.value[d.value.axis];
        if (!O)
          return;
        const T = (r.value.getBoundingClientRect()[d.value.direction] - k[d.value.client]) * -1, P = s.value[d.value.offset] - O, A = (T - P) * 100 * h.value / r.value[d.value.offset];
        n.wrapElement[d.value.scroll] = A * n.wrapElement[d.value.scrollSize] / 100;
      }, w = () => {
        u = !1, l.value[d.value.axis] = 0, document.removeEventListener("mousemove", y), document.removeEventListener("mouseup", w), _(), c && (a.value = !1);
      }, b = () => {
        c = !1, a.value = !!t.size;
      }, C = () => {
        c = !0, a.value = u;
      };
      zt(() => {
        _(), document.removeEventListener("mouseup", w);
      });
      const _ = () => {
        document.onselectstart !== f && (document.onselectstart = f);
      };
      return Wt(Ht(n, "scrollbarElement"), "mousemove", b), Wt(Ht(n, "scrollbarElement"), "mouseleave", C), (k, O) => (S(), ie(Qt, {
        name: i(o).b("fade"),
        persisted: ""
      }, {
        default: X(() => [
          ot(H("div", {
            ref_key: "instance",
            ref: r,
            class: $([i(o).e("bar"), i(o).is(i(d).key)]),
            onMousedown: v
          }, [
            H("div", {
              ref_key: "thumb",
              ref: s,
              class: $(i(o).e("thumb")),
              style: Ke(i(p)),
              onMousedown: m
            }, null, 38)
          ], 34), [
            [$t, k.always || a.value]
          ])
        ]),
        _: 1
      }, 8, ["name"]));
    }
  });
  var Vg = /* @__PURE__ */ Me(XV, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
  const JV = Ie({
    always: {
      type: Boolean,
      default: !0
    },
    width: String,
    height: String,
    ratioX: {
      type: Number,
      default: 1
    },
    ratioY: {
      type: Number,
      default: 1
    }
  }), ZV = /* @__PURE__ */ G({
    __name: "bar",
    props: JV,
    setup(e, { expose: t }) {
      const n = e, o = I(0), r = I(0);
      return t({
        handleScroll: (l) => {
          if (l) {
            const a = l.offsetHeight - nl, u = l.offsetWidth - nl;
            r.value = l.scrollTop * 100 / a * n.ratioY, o.value = l.scrollLeft * 100 / u * n.ratioX;
          }
        }
      }), (l, a) => (S(), V(ze, null, [
        K(Vg, {
          move: o.value,
          ratio: l.ratioX,
          size: l.width,
          always: l.always
        }, null, 8, ["move", "ratio", "size", "always"]),
        K(Vg, {
          move: r.value,
          ratio: l.ratioY,
          size: l.height,
          vertical: "",
          always: l.always
        }, null, 8, ["move", "ratio", "size", "always"])
      ], 64));
    }
  });
  var QV = /* @__PURE__ */ Me(ZV, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
  const e6 = Ie({
    height: {
      type: [String, Number],
      default: ""
    },
    maxHeight: {
      type: [String, Number],
      default: ""
    },
    native: {
      type: Boolean,
      default: !1
    },
    wrapStyle: {
      type: le([String, Object, Array]),
      default: ""
    },
    wrapClass: {
      type: [String, Array],
      default: ""
    },
    viewClass: {
      type: [String, Array],
      default: ""
    },
    viewStyle: {
      type: [String, Array, Object],
      default: ""
    },
    noresize: Boolean,
    tag: {
      type: String,
      default: "div"
    },
    always: Boolean,
    minSize: {
      type: Number,
      default: 20
    }
  }), t6 = {
    scroll: ({
      scrollTop: e,
      scrollLeft: t
    }) => [e, t].every(Xe)
  }, Vf = "ElScrollbar", n6 = G({
    name: Vf
  }), o6 = /* @__PURE__ */ G({
    ...n6,
    props: e6,
    emits: t6,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = ge("scrollbar");
      let s, l;
      const a = I(), u = I(), c = I(), f = I("0"), d = I("0"), p = I(), h = I(1), m = I(1), v = E(() => {
        const O = {};
        return o.height && (O.height = Jt(o.height)), o.maxHeight && (O.maxHeight = Jt(o.maxHeight)), [o.wrapStyle, O];
      }), g = E(() => [
        o.wrapClass,
        r.e("wrap"),
        { [r.em("wrap", "hidden-default")]: !o.native }
      ]), y = E(() => [r.e("view"), o.viewClass]), w = () => {
        var O;
        u.value && ((O = p.value) == null || O.handleScroll(u.value), n("scroll", {
          scrollTop: u.value.scrollTop,
          scrollLeft: u.value.scrollLeft
        }));
      };
      function b(O, T) {
        rt(O) ? u.value.scrollTo(O) : Xe(O) && Xe(T) && u.value.scrollTo(O, T);
      }
      const C = (O) => {
        if (!Xe(O)) {
          yt(Vf, "value must be a number");
          return;
        }
        u.value.scrollTop = O;
      }, _ = (O) => {
        if (!Xe(O)) {
          yt(Vf, "value must be a number");
          return;
        }
        u.value.scrollLeft = O;
      }, k = () => {
        if (!u.value)
          return;
        const O = u.value.offsetHeight - nl, T = u.value.offsetWidth - nl, P = O ** 2 / u.value.scrollHeight, A = T ** 2 / u.value.scrollWidth, L = Math.max(P, o.minSize), D = Math.max(A, o.minSize);
        h.value = P / (O - P) / (L / (O - L)), m.value = A / (T - A) / (D / (T - D)), d.value = L + nl < O ? `${L}px` : "", f.value = D + nl < T ? `${D}px` : "";
      };
      return me(() => o.noresize, (O) => {
        O ? (s == null || s(), l == null || l()) : ({ stop: s } = Cn(c, k), l = Wt("resize", k));
      }, { immediate: !0 }), me(() => [o.maxHeight, o.height], () => {
        o.native || Fe(() => {
          var O;
          k(), u.value && ((O = p.value) == null || O.handleScroll(u.value));
        });
      }), pt(Uw, Tt({
        scrollbarElement: a,
        wrapElement: u
      })), st(() => {
        o.native || Fe(() => {
          k();
        });
      }), cr(() => k()), t({
        wrapRef: u,
        update: k,
        scrollTo: b,
        setScrollTop: C,
        setScrollLeft: _,
        handleScroll: w
      }), (O, T) => (S(), V("div", {
        ref_key: "scrollbarRef",
        ref: a,
        class: $(i(r).b())
      }, [
        H("div", {
          ref_key: "wrapRef",
          ref: u,
          class: $(i(g)),
          style: Ke(i(v)),
          onScroll: w
        }, [
          (S(), ie(vt(O.tag), {
            ref_key: "resizeRef",
            ref: c,
            class: $(i(y)),
            style: Ke(O.viewStyle)
          }, {
            default: X(() => [
              he(O.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"]))
        ], 38),
        O.native ? se("v-if", !0) : (S(), ie(QV, {
          key: 0,
          ref_key: "barRef",
          ref: p,
          height: d.value,
          width: f.value,
          always: O.always,
          "ratio-x": m.value,
          "ratio-y": h.value
        }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"]))
      ], 2));
    }
  });
  var r6 = /* @__PURE__ */ Me(o6, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
  const pr = ut(r6), zh = Symbol("popper"), qw = Symbol("popperContent"), s6 = [
    "dialog",
    "grid",
    "group",
    "listbox",
    "menu",
    "navigation",
    "tooltip",
    "tree"
  ], Yw = Ie({
    role: {
      type: String,
      values: s6,
      default: "tooltip"
    }
  }), l6 = G({
    name: "ElPopper",
    inheritAttrs: !1
  }), a6 = /* @__PURE__ */ G({
    ...l6,
    props: Yw,
    setup(e, { expose: t }) {
      const n = e, o = I(), r = I(), s = I(), l = I(), a = E(() => n.role), u = {
        triggerRef: o,
        popperInstanceRef: r,
        contentRef: s,
        referenceRef: l,
        role: a
      };
      return t(u), pt(zh, u), (c, f) => he(c.$slots, "default");
    }
  });
  var i6 = /* @__PURE__ */ Me(a6, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
  const Gw = Ie({
    arrowOffset: {
      type: Number,
      default: 5
    }
  }), u6 = G({
    name: "ElPopperArrow",
    inheritAttrs: !1
  }), c6 = /* @__PURE__ */ G({
    ...u6,
    props: Gw,
    setup(e, { expose: t }) {
      const n = e, o = ge("popper"), { arrowOffset: r, arrowRef: s, arrowStyle: l } = Be(qw, void 0);
      return me(() => n.arrowOffset, (a) => {
        r.value = a;
      }), zt(() => {
        s.value = void 0;
      }), t({
        arrowRef: s
      }), (a, u) => (S(), V("span", {
        ref_key: "arrowRef",
        ref: s,
        class: $(i(o).e("arrow")),
        style: Ke(i(l)),
        "data-popper-arrow": ""
      }, null, 6));
    }
  });
  var d6 = /* @__PURE__ */ Me(c6, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
  const Nd = "ElOnlyChild", Xw = G({
    name: Nd,
    setup(e, {
      slots: t,
      attrs: n
    }) {
      var o;
      const r = Be(Sw), s = z8((o = r == null ? void 0 : r.setForwardRef) != null ? o : Nt);
      return () => {
        var l;
        const a = (l = t.default) == null ? void 0 : l.call(t, n);
        if (!a)
          return null;
        if (a.length > 1)
          return yt(Nd, "requires exact only one valid child."), null;
        const u = Jw(a);
        return u ? ot(Eo(u, n), [[s]]) : (yt(Nd, "no valid child node found"), null);
      };
    }
  });
  function Jw(e) {
    if (!e)
      return null;
    const t = e;
    for (const n of t) {
      if (rt(n))
        switch (n.type) {
          case en:
            continue;
          case Hl:
          case "svg":
            return Bg(n);
          case ze:
            return Jw(n.children);
          default:
            return n;
        }
      return Bg(n);
    }
    return null;
  }
  function Bg(e) {
    const t = ge("only-child");
    return K("span", {
      class: t.e("content")
    }, [e]);
  }
  const Zw = Ie({
    virtualRef: {
      type: le(Object)
    },
    virtualTriggering: Boolean,
    onMouseenter: {
      type: le(Function)
    },
    onMouseleave: {
      type: le(Function)
    },
    onClick: {
      type: le(Function)
    },
    onKeydown: {
      type: le(Function)
    },
    onFocus: {
      type: le(Function)
    },
    onBlur: {
      type: le(Function)
    },
    onContextmenu: {
      type: le(Function)
    },
    id: String,
    open: Boolean
  }), f6 = G({
    name: "ElPopperTrigger",
    inheritAttrs: !1
  }), p6 = /* @__PURE__ */ G({
    ...f6,
    props: Zw,
    setup(e, { expose: t }) {
      const n = e, { role: o, triggerRef: r } = Be(zh, void 0);
      H8(r);
      const s = E(() => a.value ? n.id : void 0), l = E(() => {
        if (o && o.value === "tooltip")
          return n.open && n.id ? n.id : void 0;
      }), a = E(() => {
        if (o && o.value !== "tooltip")
          return o.value;
      }), u = E(() => a.value ? `${n.open}` : void 0);
      let c;
      return st(() => {
        me(() => n.virtualRef, (f) => {
          f && (r.value = Kn(f));
        }, {
          immediate: !0
        }), me(r, (f, d) => {
          c == null || c(), c = void 0, So(f) && ([
            "onMouseenter",
            "onMouseleave",
            "onClick",
            "onKeydown",
            "onFocus",
            "onBlur",
            "onContextmenu"
          ].forEach((p) => {
            var h;
            const m = n[p];
            m && (f.addEventListener(p.slice(2).toLowerCase(), m), (h = d == null ? void 0 : d.removeEventListener) == null || h.call(d, p.slice(2).toLowerCase(), m));
          }), c = me([s, l, a, u], (p) => {
            [
              "aria-controls",
              "aria-describedby",
              "aria-haspopup",
              "aria-expanded"
            ].forEach((h, m) => {
              nn(p[m]) ? f.removeAttribute(h) : f.setAttribute(h, p[m]);
            });
          }, { immediate: !0 })), So(d) && [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((p) => d.removeAttribute(p));
        }, {
          immediate: !0
        });
      }), zt(() => {
        c == null || c(), c = void 0;
      }), t({
        triggerRef: r
      }), (f, d) => f.virtualTriggering ? se("v-if", !0) : (S(), ie(i(Xw), ft({ key: 0 }, f.$attrs, {
        "aria-controls": i(s),
        "aria-describedby": i(l),
        "aria-expanded": i(u),
        "aria-haspopup": i(a)
      }), {
        default: X(() => [
          he(f.$slots, "default")
        ]),
        _: 3
      }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]));
    }
  });
  var h6 = /* @__PURE__ */ Me(p6, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
  const Td = "focus-trap.focus-after-trapped", Od = "focus-trap.focus-after-released", v6 = "focus-trap.focusout-prevented", Fg = {
    cancelable: !0,
    bubbles: !1
  }, m6 = {
    cancelable: !0,
    bubbles: !1
  }, Hg = "focusAfterTrapped", zg = "focusAfterReleased", Kh = Symbol("elFocusTrap"), jh = I(), Jc = I(0), Wh = I(0);
  let Ki = 0;
  const Qw = (e) => {
    const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (o) => {
        const r = o.tagName === "INPUT" && o.type === "hidden";
        return o.disabled || o.hidden || r ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 || o === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; n.nextNode(); )
      t.push(n.currentNode);
    return t;
  }, Kg = (e, t) => {
    for (const n of e)
      if (!g6(n, t))
        return n;
  }, g6 = (e, t) => {
    if (process.env.NODE_ENV === "test")
      return !1;
    if (getComputedStyle(e).visibility === "hidden")
      return !0;
    for (; e; ) {
      if (t && e === t)
        return !1;
      if (getComputedStyle(e).display === "none")
        return !0;
      e = e.parentElement;
    }
    return !1;
  }, y6 = (e) => {
    const t = Qw(e), n = Kg(t, e), o = Kg(t.reverse(), e);
    return [n, o];
  }, b6 = (e) => e instanceof HTMLInputElement && "select" in e, Cr = (e, t) => {
    if (e && e.focus) {
      const n = document.activeElement;
      e.focus({ preventScroll: !0 }), Wh.value = window.performance.now(), e !== n && b6(e) && t && e.select();
    }
  };
  function jg(e, t) {
    const n = [...e], o = e.indexOf(t);
    return o !== -1 && n.splice(o, 1), n;
  }
  const w6 = () => {
    let e = [];
    return {
      push: (o) => {
        const r = e[0];
        r && o !== r && r.pause(), e = jg(e, o), e.unshift(o);
      },
      remove: (o) => {
        var r, s;
        e = jg(e, o), (s = (r = e[0]) == null ? void 0 : r.resume) == null || s.call(r);
      }
    };
  }, C6 = (e, t = !1) => {
    const n = document.activeElement;
    for (const o of e)
      if (Cr(o, t), document.activeElement !== n)
        return;
  }, Wg = w6(), E6 = () => Jc.value > Wh.value, ji = () => {
    jh.value = "pointer", Jc.value = window.performance.now();
  }, Ug = () => {
    jh.value = "keyboard", Jc.value = window.performance.now();
  }, S6 = () => (st(() => {
    Ki === 0 && (document.addEventListener("mousedown", ji), document.addEventListener("touchstart", ji), document.addEventListener("keydown", Ug)), Ki++;
  }), zt(() => {
    Ki--, Ki <= 0 && (document.removeEventListener("mousedown", ji), document.removeEventListener("touchstart", ji), document.removeEventListener("keydown", Ug));
  }), {
    focusReason: jh,
    lastUserFocusTimestamp: Jc,
    lastAutomatedFocusTimestamp: Wh
  }), Wi = (e) => new CustomEvent(v6, {
    ...m6,
    detail: e
  }), _6 = G({
    name: "ElFocusTrap",
    inheritAttrs: !1,
    props: {
      loop: Boolean,
      trapped: Boolean,
      focusTrapEl: Object,
      focusStartEl: {
        type: [Object, String],
        default: "first"
      }
    },
    emits: [
      Hg,
      zg,
      "focusin",
      "focusout",
      "focusout-prevented",
      "release-requested"
    ],
    setup(e, { emit: t }) {
      const n = I();
      let o, r;
      const { focusReason: s } = S6();
      L8((m) => {
        e.trapped && !l.paused && t("release-requested", m);
      });
      const l = {
        paused: !1,
        pause() {
          this.paused = !0;
        },
        resume() {
          this.paused = !1;
        }
      }, a = (m) => {
        if (!e.loop && !e.trapped || l.paused)
          return;
        const { key: v, altKey: g, ctrlKey: y, metaKey: w, currentTarget: b, shiftKey: C } = m, { loop: _ } = e, k = v === We.tab && !g && !y && !w, O = document.activeElement;
        if (k && O) {
          const T = b, [P, A] = y6(T);
          if (P && A) {
            if (!C && O === A) {
              const D = Wi({
                focusReason: s.value
              });
              t("focusout-prevented", D), D.defaultPrevented || (m.preventDefault(), _ && Cr(P, !0));
            } else if (C && [P, T].includes(O)) {
              const D = Wi({
                focusReason: s.value
              });
              t("focusout-prevented", D), D.defaultPrevented || (m.preventDefault(), _ && Cr(A, !0));
            }
          } else if (O === T) {
            const D = Wi({
              focusReason: s.value
            });
            t("focusout-prevented", D), D.defaultPrevented || m.preventDefault();
          }
        }
      };
      pt(Kh, {
        focusTrapRef: n,
        onKeydown: a
      }), me(() => e.focusTrapEl, (m) => {
        m && (n.value = m);
      }, { immediate: !0 }), me([n], ([m], [v]) => {
        m && (m.addEventListener("keydown", a), m.addEventListener("focusin", f), m.addEventListener("focusout", d)), v && (v.removeEventListener("keydown", a), v.removeEventListener("focusin", f), v.removeEventListener("focusout", d));
      });
      const u = (m) => {
        t(Hg, m);
      }, c = (m) => t(zg, m), f = (m) => {
        const v = i(n);
        if (!v)
          return;
        const g = m.target, y = m.relatedTarget, w = g && v.contains(g);
        e.trapped || y && v.contains(y) || (o = y), w && t("focusin", m), !l.paused && e.trapped && (w ? r = g : Cr(r, !0));
      }, d = (m) => {
        const v = i(n);
        if (!(l.paused || !v))
          if (e.trapped) {
            const g = m.relatedTarget;
            !nn(g) && !v.contains(g) && setTimeout(() => {
              if (!l.paused && e.trapped) {
                const y = Wi({
                  focusReason: s.value
                });
                t("focusout-prevented", y), y.defaultPrevented || Cr(r, !0);
              }
            }, 0);
          } else {
            const g = m.target;
            g && v.contains(g) || t("focusout", m);
          }
      };
      async function p() {
        await Fe();
        const m = i(n);
        if (m) {
          Wg.push(l);
          const v = m.contains(document.activeElement) ? o : document.activeElement;
          if (o = v, !m.contains(v)) {
            const y = new Event(Td, Fg);
            m.addEventListener(Td, u), m.dispatchEvent(y), y.defaultPrevented || Fe(() => {
              let w = e.focusStartEl;
              et(w) || (Cr(w), document.activeElement !== w && (w = "first")), w === "first" && C6(Qw(m), !0), (document.activeElement === v || w === "container") && Cr(m);
            });
          }
        }
      }
      function h() {
        const m = i(n);
        if (m) {
          m.removeEventListener(Td, u);
          const v = new CustomEvent(Od, {
            ...Fg,
            detail: {
              focusReason: s.value
            }
          });
          m.addEventListener(Od, c), m.dispatchEvent(v), !v.defaultPrevented && (s.value == "keyboard" || !E6() || m.contains(document.activeElement)) && Cr(o != null ? o : document.body), m.removeEventListener(Od, u), Wg.remove(l);
        }
      }
      return st(() => {
        e.trapped && p(), me(() => e.trapped, (m) => {
          m ? p() : h();
        });
      }), zt(() => {
        e.trapped && h();
      }), {
        onKeydown: a
      };
    }
  });
  function k6(e, t, n, o, r, s) {
    return he(e.$slots, "default", { handleKeydown: e.onKeydown });
  }
  var Zc = /* @__PURE__ */ Me(_6, [["render", k6], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
  const $6 = ["fixed", "absolute"], N6 = Ie({
    boundariesPadding: {
      type: Number,
      default: 0
    },
    fallbackPlacements: {
      type: le(Array),
      default: void 0
    },
    gpuAcceleration: {
      type: Boolean,
      default: !0
    },
    offset: {
      type: Number,
      default: 12
    },
    placement: {
      type: String,
      values: Bs,
      default: "bottom"
    },
    popperOptions: {
      type: le(Object),
      default: () => ({})
    },
    strategy: {
      type: String,
      values: $6,
      default: "absolute"
    }
  }), eC = Ie({
    ...N6,
    id: String,
    style: {
      type: le([String, Array, Object])
    },
    className: {
      type: le([String, Array, Object])
    },
    effect: {
      type: String,
      default: "dark"
    },
    visible: Boolean,
    enterable: {
      type: Boolean,
      default: !0
    },
    pure: Boolean,
    focusOnShow: {
      type: Boolean,
      default: !1
    },
    trapping: {
      type: Boolean,
      default: !1
    },
    popperClass: {
      type: le([String, Array, Object])
    },
    popperStyle: {
      type: le([String, Array, Object])
    },
    referenceEl: {
      type: le(Object)
    },
    triggerTargetEl: {
      type: le(Object)
    },
    stopPopperMouseEvent: {
      type: Boolean,
      default: !0
    },
    ariaLabel: {
      type: String,
      default: void 0
    },
    virtualTriggering: Boolean,
    zIndex: Number
  }), T6 = {
    mouseenter: (e) => e instanceof MouseEvent,
    mouseleave: (e) => e instanceof MouseEvent,
    focus: () => !0,
    blur: () => !0,
    close: () => !0
  }, O6 = (e, t = []) => {
    const { placement: n, strategy: o, popperOptions: r } = e, s = {
      placement: n,
      strategy: o,
      ...r,
      modifiers: [...I6(e), ...t]
    };
    return P6(s, r == null ? void 0 : r.modifiers), s;
  }, M6 = (e) => {
    if (!!bt)
      return Kn(e);
  };
  function I6(e) {
    const { offset: t, gpuAcceleration: n, fallbackPlacements: o } = e;
    return [
      {
        name: "offset",
        options: {
          offset: [0, t != null ? t : 12]
        }
      },
      {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      },
      {
        name: "flip",
        options: {
          padding: 5,
          fallbackPlacements: o
        }
      },
      {
        name: "computeStyles",
        options: {
          gpuAcceleration: n
        }
      }
    ];
  }
  function P6(e, t) {
    t && (e.modifiers = [...e.modifiers, ...t != null ? t : []]);
  }
  const A6 = 0, R6 = (e) => {
    const { popperInstanceRef: t, contentRef: n, triggerRef: o, role: r } = Be(zh, void 0), s = I(), l = I(), a = E(() => ({
      name: "eventListeners",
      enabled: !!e.visible
    })), u = E(() => {
      var y;
      const w = i(s), b = (y = i(l)) != null ? y : A6;
      return {
        name: "arrow",
        enabled: !CP(w),
        options: {
          element: w,
          padding: b
        }
      };
    }), c = E(() => ({
      onFirstUpdate: () => {
        m();
      },
      ...O6(e, [
        i(u),
        i(a)
      ])
    })), f = E(() => M6(e.referenceEl) || i(o)), { attributes: d, state: p, styles: h, update: m, forceUpdate: v, instanceRef: g } = P8(f, n, c);
    return me(g, (y) => t.value = y), st(() => {
      me(() => {
        var y;
        return (y = i(f)) == null ? void 0 : y.getBoundingClientRect();
      }, () => {
        m();
      });
    }), {
      attributes: d,
      arrowRef: s,
      contentRef: n,
      instanceRef: g,
      state: p,
      styles: h,
      role: r,
      forceUpdate: v,
      update: m
    };
  }, x6 = (e, {
    attributes: t,
    styles: n,
    role: o
  }) => {
    const { nextZIndex: r } = Fs(), s = ge("popper"), l = E(() => i(t).popper), a = I(e.zIndex || r()), u = E(() => [
      s.b(),
      s.is("pure", e.pure),
      s.is(e.effect),
      e.popperClass
    ]), c = E(() => [
      { zIndex: i(a) },
      e.popperStyle || {},
      i(n).popper
    ]), f = E(() => o.value === "dialog" ? "false" : void 0), d = E(() => i(n).arrow || {});
    return {
      ariaModal: f,
      arrowStyle: d,
      contentAttrs: l,
      contentClass: u,
      contentStyle: c,
      contentZIndex: a,
      updateZIndex: () => {
        a.value = e.zIndex || r();
      }
    };
  }, D6 = (e, t) => {
    const n = I(!1), o = I();
    return {
      focusStartRef: o,
      trapped: n,
      onFocusAfterReleased: (c) => {
        var f;
        ((f = c.detail) == null ? void 0 : f.focusReason) !== "pointer" && (o.value = "first", t("blur"));
      },
      onFocusAfterTrapped: () => {
        t("focus");
      },
      onFocusInTrap: (c) => {
        e.visible && !n.value && (c.target && (o.value = c.target), n.value = !0);
      },
      onFocusoutPrevented: (c) => {
        e.trapping || (c.detail.focusReason === "pointer" && c.preventDefault(), n.value = !1);
      },
      onReleaseRequested: () => {
        n.value = !1, t("close");
      }
    };
  }, L6 = G({
    name: "ElPopperContent"
  }), V6 = /* @__PURE__ */ G({
    ...L6,
    props: eC,
    emits: T6,
    setup(e, { expose: t, emit: n }) {
      const o = e, {
        focusStartRef: r,
        trapped: s,
        onFocusAfterReleased: l,
        onFocusAfterTrapped: a,
        onFocusInTrap: u,
        onFocusoutPrevented: c,
        onReleaseRequested: f
      } = D6(o, n), { attributes: d, arrowRef: p, contentRef: h, styles: m, instanceRef: v, role: g, update: y } = R6(o), {
        ariaModal: w,
        arrowStyle: b,
        contentAttrs: C,
        contentClass: _,
        contentStyle: k,
        updateZIndex: O
      } = x6(o, {
        styles: m,
        attributes: d,
        role: g
      }), T = Be(Ho, void 0), P = I();
      pt(qw, {
        arrowStyle: b,
        arrowRef: p,
        arrowOffset: P
      }), T && (T.addInputId || T.removeInputId) && pt(Ho, {
        ...T,
        addInputId: Nt,
        removeInputId: Nt
      });
      let A;
      const L = (B = !0) => {
        y(), B && O();
      }, D = () => {
        L(!1), o.visible && o.focusOnShow ? s.value = !0 : o.visible === !1 && (s.value = !1);
      };
      return st(() => {
        me(() => o.triggerTargetEl, (B, F) => {
          A == null || A(), A = void 0;
          const W = i(B || h.value), x = i(F || h.value);
          So(W) && (A = me([g, () => o.ariaLabel, w, () => o.id], (N) => {
            ["role", "aria-label", "aria-modal", "id"].forEach((R, M) => {
              nn(N[M]) ? W.removeAttribute(R) : W.setAttribute(R, N[M]);
            });
          }, { immediate: !0 })), x !== W && So(x) && ["role", "aria-label", "aria-modal", "id"].forEach((N) => {
            x.removeAttribute(N);
          });
        }, { immediate: !0 }), me(() => o.visible, D, { immediate: !0 });
      }), zt(() => {
        A == null || A(), A = void 0;
      }), t({
        popperContentRef: h,
        popperInstanceRef: v,
        updatePopper: L,
        contentStyle: k
      }), (B, F) => (S(), V("div", ft({
        ref_key: "contentRef",
        ref: h
      }, i(C), {
        style: i(k),
        class: i(_),
        tabindex: "-1",
        onMouseenter: F[0] || (F[0] = (W) => B.$emit("mouseenter", W)),
        onMouseleave: F[1] || (F[1] = (W) => B.$emit("mouseleave", W))
      }), [
        K(i(Zc), {
          trapped: i(s),
          "trap-on-focus-in": !0,
          "focus-trap-el": i(h),
          "focus-start-el": i(r),
          onFocusAfterTrapped: i(a),
          onFocusAfterReleased: i(l),
          onFocusin: i(u),
          onFocusoutPrevented: i(c),
          onReleaseRequested: i(f)
        }, {
          default: X(() => [
            he(B.$slots, "default")
          ]),
          _: 3
        }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
      ], 16));
    }
  });
  var B6 = /* @__PURE__ */ Me(V6, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
  const tC = ut(i6), Qc = Symbol("elTooltip"), dn = Ie({
    ...F8,
    ...eC,
    appendTo: {
      type: le([String, Object])
    },
    content: {
      type: String,
      default: ""
    },
    rawContent: {
      type: Boolean,
      default: !1
    },
    persistent: Boolean,
    ariaLabel: String,
    visible: {
      type: le(Boolean),
      default: null
    },
    transition: String,
    teleported: {
      type: Boolean,
      default: !0
    },
    disabled: Boolean
  }), Ga = Ie({
    ...Zw,
    disabled: Boolean,
    trigger: {
      type: le([String, Array]),
      default: "hover"
    },
    triggerKeys: {
      type: le(Array),
      default: () => [We.enter, We.space]
    }
  }), {
    useModelToggleProps: F6,
    useModelToggleEmits: H6,
    useModelToggle: z6
  } = $D("visible"), K6 = Ie({
    ...Yw,
    ...F6,
    ...dn,
    ...Ga,
    ...Gw,
    showArrow: {
      type: Boolean,
      default: !0
    }
  }), j6 = [
    ...H6,
    "before-show",
    "before-hide",
    "show",
    "hide",
    "open",
    "close"
  ], W6 = (e, t) => De(e) ? e.includes(t) : e === t, Ks = (e, t, n) => (o) => {
    W6(i(e), t) && n(o);
  }, U6 = G({
    name: "ElTooltipTrigger"
  }), q6 = /* @__PURE__ */ G({
    ...U6,
    props: Ga,
    setup(e, { expose: t }) {
      const n = e, o = ge("tooltip"), { controlled: r, id: s, open: l, onOpen: a, onClose: u, onToggle: c } = Be(Qc, void 0), f = I(null), d = () => {
        if (i(r) || n.disabled)
          return !0;
      }, p = Ht(n, "trigger"), h = qt(d, Ks(p, "hover", a)), m = qt(d, Ks(p, "hover", u)), v = qt(d, Ks(p, "click", (C) => {
        C.button === 0 && c(C);
      })), g = qt(d, Ks(p, "focus", a)), y = qt(d, Ks(p, "focus", u)), w = qt(d, Ks(p, "contextmenu", (C) => {
        C.preventDefault(), c(C);
      })), b = qt(d, (C) => {
        const { code: _ } = C;
        n.triggerKeys.includes(_) && (C.preventDefault(), c(C));
      });
      return t({
        triggerRef: f
      }), (C, _) => (S(), ie(i(h6), {
        id: i(s),
        "virtual-ref": C.virtualRef,
        open: i(l),
        "virtual-triggering": C.virtualTriggering,
        class: $(i(o).e("trigger")),
        onBlur: i(y),
        onClick: i(v),
        onContextmenu: i(w),
        onFocus: i(g),
        onMouseenter: i(h),
        onMouseleave: i(m),
        onKeydown: i(b)
      }, {
        default: X(() => [
          he(C.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]));
    }
  });
  var Y6 = /* @__PURE__ */ Me(q6, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
  const G6 = G({
    name: "ElTooltipContent",
    inheritAttrs: !1
  }), X6 = /* @__PURE__ */ G({
    ...G6,
    props: dn,
    setup(e, { expose: t }) {
      const n = e, { selector: o } = Cw(), r = ge("tooltip"), s = I(null), l = I(!1), {
        controlled: a,
        id: u,
        open: c,
        trigger: f,
        onClose: d,
        onOpen: p,
        onShow: h,
        onHide: m,
        onBeforeShow: v,
        onBeforeHide: g
      } = Be(Qc, void 0), y = E(() => n.transition || `${r.namespace.value}-fade-in-linear`), w = E(() => process.env.NODE_ENV === "test" ? !0 : n.persistent);
      zt(() => {
        l.value = !0;
      });
      const b = E(() => i(w) ? !0 : i(c)), C = E(() => n.disabled ? !1 : i(c)), _ = E(() => n.appendTo || o.value), k = E(() => {
        var N;
        return (N = n.style) != null ? N : {};
      }), O = E(() => !i(c)), T = () => {
        m();
      }, P = () => {
        if (i(a))
          return !0;
      }, A = qt(P, () => {
        n.enterable && i(f) === "hover" && p();
      }), L = qt(P, () => {
        i(f) === "hover" && d();
      }), D = () => {
        var N, R;
        (R = (N = s.value) == null ? void 0 : N.updatePopper) == null || R.call(N), v == null || v();
      }, B = () => {
        g == null || g();
      }, F = () => {
        h(), x = oh(E(() => {
          var N;
          return (N = s.value) == null ? void 0 : N.popperContentRef;
        }), () => {
          if (i(a))
            return;
          i(f) !== "hover" && d();
        });
      }, W = () => {
        n.virtualTriggering || d();
      };
      let x;
      return me(() => i(c), (N) => {
        N || x == null || x();
      }, {
        flush: "post"
      }), me(() => n.content, () => {
        var N, R;
        (R = (N = s.value) == null ? void 0 : N.updatePopper) == null || R.call(N);
      }), t({
        contentRef: s
      }), (N, R) => (S(), ie(pi, {
        disabled: !N.teleported,
        to: i(_)
      }, [
        K(Qt, {
          name: i(y),
          onAfterLeave: T,
          onBeforeEnter: D,
          onAfterEnter: F,
          onBeforeLeave: B
        }, {
          default: X(() => [
            i(b) ? ot((S(), ie(i(B6), ft({
              key: 0,
              id: i(u),
              ref_key: "contentRef",
              ref: s
            }, N.$attrs, {
              "aria-label": N.ariaLabel,
              "aria-hidden": i(O),
              "boundaries-padding": N.boundariesPadding,
              "fallback-placements": N.fallbackPlacements,
              "gpu-acceleration": N.gpuAcceleration,
              offset: N.offset,
              placement: N.placement,
              "popper-options": N.popperOptions,
              strategy: N.strategy,
              effect: N.effect,
              enterable: N.enterable,
              pure: N.pure,
              "popper-class": N.popperClass,
              "popper-style": [N.popperStyle, i(k)],
              "reference-el": N.referenceEl,
              "trigger-target-el": N.triggerTargetEl,
              visible: i(C),
              "z-index": N.zIndex,
              onMouseenter: i(A),
              onMouseleave: i(L),
              onBlur: W,
              onClose: i(d)
            }), {
              default: X(() => [
                l.value ? se("v-if", !0) : he(N.$slots, "default", { key: 0 })
              ]),
              _: 3
            }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
              [$t, i(C)]
            ]) : se("v-if", !0)
          ]),
          _: 3
        }, 8, ["name"])
      ], 8, ["disabled", "to"]));
    }
  });
  var J6 = /* @__PURE__ */ Me(X6, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
  const Z6 = ["innerHTML"], Q6 = { key: 1 }, eB = G({
    name: "ElTooltip"
  }), tB = /* @__PURE__ */ G({
    ...eB,
    props: K6,
    emits: j6,
    setup(e, { expose: t, emit: n }) {
      const o = e;
      B8();
      const r = io(), s = I(), l = I(), a = () => {
        var y;
        const w = i(s);
        w && ((y = w.popperInstanceRef) == null || y.update());
      }, u = I(!1), c = I(), { show: f, hide: d, hasUpdateHandler: p } = z6({
        indicator: u,
        toggleReason: c
      }), { onOpen: h, onClose: m } = Ew({
        showAfter: Ht(o, "showAfter"),
        hideAfter: Ht(o, "hideAfter"),
        autoClose: Ht(o, "autoClose"),
        open: f,
        close: d
      }), v = E(() => tn(o.visible) && !p.value);
      pt(Qc, {
        controlled: v,
        id: r,
        open: Fl(u),
        trigger: Ht(o, "trigger"),
        onOpen: (y) => {
          h(y);
        },
        onClose: (y) => {
          m(y);
        },
        onToggle: (y) => {
          i(u) ? m(y) : h(y);
        },
        onShow: () => {
          n("show", c.value);
        },
        onHide: () => {
          n("hide", c.value);
        },
        onBeforeShow: () => {
          n("before-show", c.value);
        },
        onBeforeHide: () => {
          n("before-hide", c.value);
        },
        updatePopper: a
      }), me(() => o.disabled, (y) => {
        y && u.value && (u.value = !1);
      });
      const g = () => {
        var y, w;
        const b = (w = (y = l.value) == null ? void 0 : y.contentRef) == null ? void 0 : w.popperContentRef;
        return b && b.contains(document.activeElement);
      };
      return E0(() => u.value && d()), t({
        popperRef: s,
        contentRef: l,
        isFocusInsideContent: g,
        updatePopper: a,
        onOpen: h,
        onClose: m,
        hide: d
      }), (y, w) => (S(), ie(i(tC), {
        ref_key: "popperRef",
        ref: s,
        role: y.role
      }, {
        default: X(() => [
          K(Y6, {
            disabled: y.disabled,
            trigger: y.trigger,
            "trigger-keys": y.triggerKeys,
            "virtual-ref": y.virtualRef,
            "virtual-triggering": y.virtualTriggering
          }, {
            default: X(() => [
              y.$slots.default ? he(y.$slots, "default", { key: 0 }) : se("v-if", !0)
            ]),
            _: 3
          }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
          K(J6, {
            ref_key: "contentRef",
            ref: l,
            "aria-label": y.ariaLabel,
            "boundaries-padding": y.boundariesPadding,
            content: y.content,
            disabled: y.disabled,
            effect: y.effect,
            enterable: y.enterable,
            "fallback-placements": y.fallbackPlacements,
            "hide-after": y.hideAfter,
            "gpu-acceleration": y.gpuAcceleration,
            offset: y.offset,
            persistent: y.persistent,
            "popper-class": y.popperClass,
            "popper-style": y.popperStyle,
            placement: y.placement,
            "popper-options": y.popperOptions,
            pure: y.pure,
            "raw-content": y.rawContent,
            "reference-el": y.referenceEl,
            "trigger-target-el": y.triggerTargetEl,
            "show-after": y.showAfter,
            strategy: y.strategy,
            teleported: y.teleported,
            transition: y.transition,
            "virtual-triggering": y.virtualTriggering,
            "z-index": y.zIndex,
            "append-to": y.appendTo
          }, {
            default: X(() => [
              he(y.$slots, "content", {}, () => [
                y.rawContent ? (S(), V("span", {
                  key: 0,
                  innerHTML: y.content
                }, null, 8, Z6)) : (S(), V("span", Q6, Ne(y.content), 1))
              ]),
              y.showArrow ? (S(), ie(i(d6), {
                key: 0,
                "arrow-offset": y.arrowOffset
              }, null, 8, ["arrow-offset"])) : se("v-if", !0)
            ]),
            _: 3
          }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
        ]),
        _: 3
      }, 8, ["role"]));
    }
  });
  var nB = /* @__PURE__ */ Me(tB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
  const Mn = ut(nB), oB = Ie({
    valueKey: {
      type: String,
      default: "value"
    },
    modelValue: {
      type: [String, Number],
      default: ""
    },
    debounce: {
      type: Number,
      default: 300
    },
    placement: {
      type: le(String),
      values: [
        "top",
        "top-start",
        "top-end",
        "bottom",
        "bottom-start",
        "bottom-end"
      ],
      default: "bottom-start"
    },
    fetchSuggestions: {
      type: le([Function, Array]),
      default: Nt
    },
    popperClass: {
      type: String,
      default: ""
    },
    triggerOnFocus: {
      type: Boolean,
      default: !0
    },
    selectWhenUnmatched: {
      type: Boolean,
      default: !1
    },
    hideLoading: {
      type: Boolean,
      default: !1
    },
    label: {
      type: String
    },
    teleported: dn.teleported,
    highlightFirstItem: {
      type: Boolean,
      default: !1
    },
    fitInputWidth: {
      type: Boolean,
      default: !1
    },
    clearable: {
      type: Boolean,
      default: !1
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    name: String
  }), rB = {
    [dt]: (e) => et(e),
    [$n]: (e) => et(e),
    [Ft]: (e) => et(e),
    focus: (e) => e instanceof FocusEvent,
    blur: (e) => e instanceof FocusEvent,
    clear: () => !0,
    select: (e) => rt(e)
  }, sB = ["aria-expanded", "aria-owns"], lB = { key: 0 }, aB = ["id", "aria-selected", "onClick"], nC = "ElAutocomplete", iB = G({
    name: nC,
    inheritAttrs: !1
  }), uB = /* @__PURE__ */ G({
    ...iB,
    props: oB,
    emits: rB,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = $h(), s = zl(), l = Fn(), a = ge("autocomplete"), u = I(), c = I(), f = I(), d = I();
      let p = !1, h = !1;
      const m = I([]), v = I(-1), g = I(""), y = I(!1), w = I(!1), b = I(!1), C = E(() => a.b(String(Wc()))), _ = E(() => s.style), k = E(() => (m.value.length > 0 || b.value) && y.value), O = E(() => !o.hideLoading && b.value), T = E(() => u.value ? Array.from(u.value.$el.querySelectorAll("input")) : []), P = async () => {
        await Fe(), k.value && (g.value = `${u.value.$el.offsetWidth}px`);
      }, A = () => {
        v.value = -1;
      }, D = On(async (ee) => {
        if (w.value)
          return;
        const ne = (Y) => {
          b.value = !1, !w.value && (De(Y) ? (m.value = Y, v.value = o.highlightFirstItem ? 0 : -1) : Yt(nC, "autocomplete suggestions must be an array"));
        };
        if (b.value = !0, De(o.fetchSuggestions))
          ne(o.fetchSuggestions);
        else {
          const Y = await o.fetchSuggestions(ee, ne);
          De(Y) && ne(Y);
        }
      }, o.debounce), B = (ee) => {
        const ne = !!ee;
        if (n($n, ee), n(dt, ee), w.value = !1, y.value || (y.value = ne), !o.triggerOnFocus && !ee) {
          w.value = !0, m.value = [];
          return;
        }
        D(ee);
      }, F = (ee) => {
        var ne;
        l.value || (((ne = ee.target) == null ? void 0 : ne.tagName) !== "INPUT" || T.value.includes(document.activeElement)) && (y.value = !0);
      }, W = (ee) => {
        n(Ft, ee);
      }, x = (ee) => {
        h ? h = !1 : (y.value = !0, n("focus", ee), o.triggerOnFocus && !p && D(String(o.modelValue)));
      }, N = (ee) => {
        setTimeout(() => {
          var ne;
          if ((ne = f.value) != null && ne.isFocusInsideContent()) {
            h = !0;
            return;
          }
          y.value && te(), n("blur", ee);
        });
      }, R = () => {
        y.value = !1, n(dt, ""), n("clear");
      }, M = async () => {
        k.value && v.value >= 0 && v.value < m.value.length ? pe(m.value[v.value]) : o.selectWhenUnmatched && (n("select", { value: o.modelValue }), m.value = [], v.value = -1);
      }, j = (ee) => {
        k.value && (ee.preventDefault(), ee.stopPropagation(), te());
      }, te = () => {
        y.value = !1;
      }, U = () => {
        var ee;
        (ee = u.value) == null || ee.focus();
      }, Z = () => {
        var ee;
        (ee = u.value) == null || ee.blur();
      }, pe = async (ee) => {
        n($n, ee[o.valueKey]), n(dt, ee[o.valueKey]), n("select", ee), m.value = [], v.value = -1;
      }, J = (ee) => {
        if (!k.value || b.value)
          return;
        if (ee < 0) {
          v.value = -1;
          return;
        }
        ee >= m.value.length && (ee = m.value.length - 1);
        const ne = c.value.querySelector(`.${a.be("suggestion", "wrap")}`), re = ne.querySelectorAll(`.${a.be("suggestion", "list")} li`)[ee], ce = ne.scrollTop, { offsetTop: Te, scrollHeight: Pe } = re;
        Te + Pe > ce + ne.clientHeight && (ne.scrollTop += Pe), Te < ce && (ne.scrollTop -= Pe), v.value = ee, u.value.ref.setAttribute("aria-activedescendant", `${C.value}-item-${v.value}`);
      };
      return oh(d, () => {
        k.value && te();
      }), st(() => {
        u.value.ref.setAttribute("role", "textbox"), u.value.ref.setAttribute("aria-autocomplete", "list"), u.value.ref.setAttribute("aria-controls", "id"), u.value.ref.setAttribute("aria-activedescendant", `${C.value}-item-${v.value}`), p = u.value.ref.hasAttribute("readonly");
      }), t({
        highlightedIndex: v,
        activated: y,
        loading: b,
        inputRef: u,
        popperRef: f,
        suggestions: m,
        handleSelect: pe,
        handleKeyEnter: M,
        focus: U,
        blur: Z,
        close: te,
        highlight: J
      }), (ee, ne) => (S(), ie(i(Mn), {
        ref_key: "popperRef",
        ref: f,
        visible: i(k),
        placement: ee.placement,
        "fallback-placements": ["bottom-start", "top-start"],
        "popper-class": [i(a).e("popper"), ee.popperClass],
        teleported: ee.teleported,
        "gpu-acceleration": !1,
        pure: "",
        "manual-mode": "",
        effect: "light",
        trigger: "click",
        transition: `${i(a).namespace.value}-zoom-in-top`,
        persistent: "",
        onBeforeShow: P,
        onHide: A
      }, {
        content: X(() => [
          H("div", {
            ref_key: "regionRef",
            ref: c,
            class: $([i(a).b("suggestion"), i(a).is("loading", i(O))]),
            style: Ke({
              [ee.fitInputWidth ? "width" : "minWidth"]: g.value,
              outline: "none"
            }),
            role: "region"
          }, [
            K(i(pr), {
              id: i(C),
              tag: "ul",
              "wrap-class": i(a).be("suggestion", "wrap"),
              "view-class": i(a).be("suggestion", "list"),
              role: "listbox"
            }, {
              default: X(() => [
                i(O) ? (S(), V("li", lB, [
                  K(i(He), {
                    class: $(i(a).is("loading"))
                  }, {
                    default: X(() => [
                      K(i(Gr))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ])) : (S(!0), V(ze, { key: 1 }, gt(m.value, (Y, re) => (S(), V("li", {
                  id: `${i(C)}-item-${re}`,
                  key: re,
                  class: $({ highlighted: v.value === re }),
                  role: "option",
                  "aria-selected": v.value === re,
                  onClick: (ce) => pe(Y)
                }, [
                  he(ee.$slots, "default", { item: Y }, () => [
                    wt(Ne(Y[ee.valueKey]), 1)
                  ])
                ], 10, aB))), 128))
              ]),
              _: 3
            }, 8, ["id", "wrap-class", "view-class"])
          ], 6)
        ]),
        default: X(() => [
          H("div", {
            ref_key: "listboxRef",
            ref: d,
            class: $([i(a).b(), ee.$attrs.class]),
            style: Ke(i(_)),
            role: "combobox",
            "aria-haspopup": "listbox",
            "aria-expanded": i(k),
            "aria-owns": i(C)
          }, [
            K(i(wn), ft({
              ref_key: "inputRef",
              ref: u
            }, i(r), {
              clearable: ee.clearable,
              disabled: i(l),
              name: ee.name,
              "model-value": ee.modelValue,
              onInput: B,
              onChange: W,
              onFocus: x,
              onBlur: N,
              onClear: R,
              onKeydown: [
                ne[0] || (ne[0] = Et(Ze((Y) => J(v.value - 1), ["prevent"]), ["up"])),
                ne[1] || (ne[1] = Et(Ze((Y) => J(v.value + 1), ["prevent"]), ["down"])),
                Et(M, ["enter"]),
                Et(te, ["tab"]),
                Et(j, ["esc"])
              ],
              onMousedown: F
            }), lr({ _: 2 }, [
              ee.$slots.prepend ? {
                name: "prepend",
                fn: X(() => [
                  he(ee.$slots, "prepend")
                ])
              } : void 0,
              ee.$slots.append ? {
                name: "append",
                fn: X(() => [
                  he(ee.$slots, "append")
                ])
              } : void 0,
              ee.$slots.prefix ? {
                name: "prefix",
                fn: X(() => [
                  he(ee.$slots, "prefix")
                ])
              } : void 0,
              ee.$slots.suffix ? {
                name: "suffix",
                fn: X(() => [
                  he(ee.$slots, "suffix")
                ])
              } : void 0
            ]), 1040, ["clearable", "disabled", "name", "model-value", "onKeydown"])
          ], 14, sB)
        ]),
        _: 3
      }, 8, ["visible", "placement", "popper-class", "teleported", "transition"]));
    }
  });
  var cB = /* @__PURE__ */ Me(uB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/autocomplete/src/autocomplete.vue"]]);
  const dB = ut(cB), fB = Ie({
    size: {
      type: [Number, String],
      values: zo,
      default: "",
      validator: (e) => Xe(e)
    },
    shape: {
      type: String,
      values: ["circle", "square"],
      default: "circle"
    },
    icon: {
      type: Vt
    },
    src: {
      type: String,
      default: ""
    },
    alt: String,
    srcSet: String,
    fit: {
      type: le(String),
      default: "cover"
    }
  }), pB = {
    error: (e) => e instanceof Event
  }, hB = ["src", "alt", "srcset"], vB = G({
    name: "ElAvatar"
  }), mB = /* @__PURE__ */ G({
    ...vB,
    props: fB,
    emits: pB,
    setup(e, { emit: t }) {
      const n = e, o = ge("avatar"), r = I(!1), s = E(() => {
        const { size: c, icon: f, shape: d } = n, p = [o.b()];
        return et(c) && p.push(o.m(c)), f && p.push(o.m("icon")), d && p.push(o.m(d)), p;
      }), l = E(() => {
        const { size: c } = n;
        return Xe(c) ? o.cssVarBlock({
          size: Jt(c) || ""
        }) : void 0;
      }), a = E(() => ({
        objectFit: n.fit
      }));
      me(() => n.src, () => r.value = !1);
      function u(c) {
        r.value = !0, t("error", c);
      }
      return (c, f) => (S(), V("span", {
        class: $(i(s)),
        style: Ke(i(l))
      }, [
        (c.src || c.srcSet) && !r.value ? (S(), V("img", {
          key: 0,
          src: c.src,
          alt: c.alt,
          srcset: c.srcSet,
          style: Ke(i(a)),
          onError: u
        }, null, 44, hB)) : c.icon ? (S(), ie(i(He), { key: 1 }, {
          default: X(() => [
            (S(), ie(vt(c.icon)))
          ]),
          _: 1
        })) : he(c.$slots, "default", { key: 2 })
      ], 6));
    }
  });
  var gB = /* @__PURE__ */ Me(mB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/avatar/src/avatar.vue"]]);
  const yB = ut(gB), bB = {
    visibilityHeight: {
      type: Number,
      default: 200
    },
    target: {
      type: String,
      default: ""
    },
    right: {
      type: Number,
      default: 40
    },
    bottom: {
      type: Number,
      default: 40
    }
  }, wB = {
    click: (e) => e instanceof MouseEvent
  }, CB = (e, t, n) => {
    const o = xt(), r = xt(), s = I(!1), l = () => {
      o.value && (s.value = o.value.scrollTop >= e.visibilityHeight);
    }, a = (c) => {
      var f;
      (f = o.value) == null || f.scrollTo({ top: 0, behavior: "smooth" }), t("click", c);
    }, u = u1(l, 300, !0);
    return Wt(r, "scroll", u), st(() => {
      var c;
      r.value = document, o.value = document.documentElement, e.target && (o.value = (c = document.querySelector(e.target)) != null ? c : void 0, o.value || Yt(n, `target does not exist: ${e.target}`), r.value = o.value);
    }), {
      visible: s,
      handleClick: a
    };
  }, oC = "ElBacktop", EB = G({
    name: oC
  }), SB = /* @__PURE__ */ G({
    ...EB,
    props: bB,
    emits: wB,
    setup(e, { emit: t }) {
      const n = e, o = ge("backtop"), { handleClick: r, visible: s } = CB(n, t, oC), l = E(() => ({
        right: `${n.right}px`,
        bottom: `${n.bottom}px`
      }));
      return (a, u) => (S(), ie(Qt, {
        name: `${i(o).namespace.value}-fade-in`
      }, {
        default: X(() => [
          i(s) ? (S(), V("div", {
            key: 0,
            style: Ke(i(l)),
            class: $(i(o).b()),
            onClick: u[0] || (u[0] = Ze((...c) => i(r) && i(r)(...c), ["stop"]))
          }, [
            he(a.$slots, "default", {}, () => [
              K(i(He), {
                class: $(i(o).e("icon"))
              }, {
                default: X(() => [
                  K(i(T3))
                ]),
                _: 1
              }, 8, ["class"])
            ])
          ], 6)) : se("v-if", !0)
        ]),
        _: 3
      }, 8, ["name"]));
    }
  });
  var _B = /* @__PURE__ */ Me(SB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/backtop/src/backtop.vue"]]);
  const kB = ut(_B), $B = Ie({
    value: {
      type: [String, Number],
      default: ""
    },
    max: {
      type: Number,
      default: 99
    },
    isDot: Boolean,
    hidden: Boolean,
    type: {
      type: String,
      values: ["primary", "success", "warning", "info", "danger"],
      default: "danger"
    }
  }), NB = ["textContent"], TB = G({
    name: "ElBadge"
  }), OB = /* @__PURE__ */ G({
    ...TB,
    props: $B,
    setup(e, { expose: t }) {
      const n = e, o = ge("badge"), r = E(() => n.isDot ? "" : Xe(n.value) && Xe(n.max) ? n.max < n.value ? `${n.max}+` : `${n.value}` : `${n.value}`);
      return t({
        content: r
      }), (s, l) => (S(), V("div", {
        class: $(i(o).b())
      }, [
        he(s.$slots, "default"),
        K(Qt, {
          name: `${i(o).namespace.value}-zoom-in-center`,
          persisted: ""
        }, {
          default: X(() => [
            ot(H("sup", {
              class: $([
                i(o).e("content"),
                i(o).em("content", s.type),
                i(o).is("fixed", !!s.$slots.default),
                i(o).is("dot", s.isDot)
              ]),
              textContent: Ne(i(r))
            }, null, 10, NB), [
              [$t, !s.hidden && (i(r) || s.isDot)]
            ])
          ]),
          _: 1
        }, 8, ["name"])
      ], 2));
    }
  });
  var MB = /* @__PURE__ */ Me(OB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);
  const rC = ut(MB), sC = Symbol("breadcrumbKey"), IB = Ie({
    separator: {
      type: String,
      default: "/"
    },
    separatorIcon: {
      type: Vt
    }
  }), PB = G({
    name: "ElBreadcrumb"
  }), AB = /* @__PURE__ */ G({
    ...PB,
    props: IB,
    setup(e) {
      const t = e, n = ge("breadcrumb"), o = I();
      return pt(sC, t), st(() => {
        const r = o.value.querySelectorAll(`.${n.e("item")}`);
        r.length && r[r.length - 1].setAttribute("aria-current", "page");
      }), (r, s) => (S(), V("div", {
        ref_key: "breadcrumb",
        ref: o,
        class: $(i(n).b()),
        "aria-label": "Breadcrumb",
        role: "navigation"
      }, [
        he(r.$slots, "default")
      ], 2));
    }
  });
  var RB = /* @__PURE__ */ Me(AB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb.vue"]]);
  const xB = Ie({
    to: {
      type: le([String, Object]),
      default: ""
    },
    replace: {
      type: Boolean,
      default: !1
    }
  }), DB = G({
    name: "ElBreadcrumbItem"
  }), LB = /* @__PURE__ */ G({
    ...DB,
    props: xB,
    setup(e) {
      const t = e, n = it(), o = Be(sC, void 0), r = ge("breadcrumb"), { separator: s, separatorIcon: l } = rn(o), a = n.appContext.config.globalProperties.$router, u = I(), c = () => {
        !t.to || !a || (t.replace ? a.replace(t.to) : a.push(t.to));
      };
      return (f, d) => (S(), V("span", {
        class: $(i(r).e("item"))
      }, [
        H("span", {
          ref_key: "link",
          ref: u,
          class: $([i(r).e("inner"), i(r).is("link", !!f.to)]),
          role: "link",
          onClick: c
        }, [
          he(f.$slots, "default")
        ], 2),
        i(l) ? (S(), ie(i(He), {
          key: 0,
          class: $(i(r).e("separator"))
        }, {
          default: X(() => [
            (S(), ie(vt(i(l))))
          ]),
          _: 1
        }, 8, ["class"])) : (S(), V("span", {
          key: 1,
          class: $(i(r).e("separator")),
          role: "presentation"
        }, Ne(i(s)), 3))
      ], 2));
    }
  });
  var lC = /* @__PURE__ */ Me(LB, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb-item.vue"]]);
  const VB = ut(RB, {
    BreadcrumbItem: lC
  }), BB = Gt(lC), aC = Symbol("buttonGroupContextKey"), FB = (e, t) => {
    Vo({
      from: "type.text",
      replacement: "link",
      version: "3.0.0",
      scope: "props",
      ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
    }, E(() => e.type === "text"));
    const n = Be(aC, void 0), o = Gc("button"), { form: r } = In(), s = on(E(() => n == null ? void 0 : n.size)), l = Fn(), a = I(), u = hn(), c = E(() => e.type || (n == null ? void 0 : n.type) || ""), f = E(() => {
      var h, m, v;
      return (v = (m = e.autoInsertSpace) != null ? m : (h = o.value) == null ? void 0 : h.autoInsertSpace) != null ? v : !1;
    }), d = E(() => {
      var h;
      const m = (h = u.default) == null ? void 0 : h.call(u);
      if (f.value && (m == null ? void 0 : m.length) === 1) {
        const v = m[0];
        if ((v == null ? void 0 : v.type) === Hl) {
          const g = v.children;
          return /^\p{Unified_Ideograph}{2}$/u.test(g.trim());
        }
      }
      return !1;
    });
    return {
      _disabled: l,
      _size: s,
      _type: c,
      _ref: a,
      shouldAddSpace: d,
      handleClick: (h) => {
        e.nativeType === "reset" && (r == null || r.resetFields()), t("click", h);
      }
    };
  }, Bf = [
    "default",
    "primary",
    "success",
    "warning",
    "info",
    "danger",
    "text",
    ""
  ], HB = ["button", "submit", "reset"], Ff = Ie({
    size: yn,
    disabled: Boolean,
    type: {
      type: String,
      values: Bf,
      default: ""
    },
    icon: {
      type: Vt
    },
    nativeType: {
      type: String,
      values: HB,
      default: "button"
    },
    loading: Boolean,
    loadingIcon: {
      type: Vt,
      default: () => Gr
    },
    plain: Boolean,
    text: Boolean,
    link: Boolean,
    bg: Boolean,
    autofocus: Boolean,
    round: Boolean,
    circle: Boolean,
    color: String,
    dark: Boolean,
    autoInsertSpace: {
      type: Boolean,
      default: void 0
    }
  }), zB = {
    click: (e) => e instanceof MouseEvent
  };
  function mn(e, t) {
    KB(e) && (e = "100%");
    var n = jB(e);
    return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))), n && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)), e);
  }
  function Ui(e) {
    return Math.min(1, Math.max(0, e));
  }
  function KB(e) {
    return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1;
  }
  function jB(e) {
    return typeof e == "string" && e.indexOf("%") !== -1;
  }
  function iC(e) {
    return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e;
  }
  function qi(e) {
    return e <= 1 ? "".concat(Number(e) * 100, "%") : e;
  }
  function fs(e) {
    return e.length === 1 ? "0" + e : String(e);
  }
  function WB(e, t, n) {
    return {
      r: mn(e, 255) * 255,
      g: mn(t, 255) * 255,
      b: mn(n, 255) * 255
    };
  }
  function qg(e, t, n) {
    e = mn(e, 255), t = mn(t, 255), n = mn(n, 255);
    var o = Math.max(e, t, n), r = Math.min(e, t, n), s = 0, l = 0, a = (o + r) / 2;
    if (o === r)
      l = 0, s = 0;
    else {
      var u = o - r;
      switch (l = a > 0.5 ? u / (2 - o - r) : u / (o + r), o) {
        case e:
          s = (t - n) / u + (t < n ? 6 : 0);
          break;
        case t:
          s = (n - e) / u + 2;
          break;
        case n:
          s = (e - t) / u + 4;
          break;
      }
      s /= 6;
    }
    return { h: s, s: l, l: a };
  }
  function Md(e, t, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
  }
  function UB(e, t, n) {
    var o, r, s;
    if (e = mn(e, 360), t = mn(t, 100), n = mn(n, 100), t === 0)
      r = n, s = n, o = n;
    else {
      var l = n < 0.5 ? n * (1 + t) : n + t - n * t, a = 2 * n - l;
      o = Md(a, l, e + 1 / 3), r = Md(a, l, e), s = Md(a, l, e - 1 / 3);
    }
    return { r: o * 255, g: r * 255, b: s * 255 };
  }
  function Yg(e, t, n) {
    e = mn(e, 255), t = mn(t, 255), n = mn(n, 255);
    var o = Math.max(e, t, n), r = Math.min(e, t, n), s = 0, l = o, a = o - r, u = o === 0 ? 0 : a / o;
    if (o === r)
      s = 0;
    else {
      switch (o) {
        case e:
          s = (t - n) / a + (t < n ? 6 : 0);
          break;
        case t:
          s = (n - e) / a + 2;
          break;
        case n:
          s = (e - t) / a + 4;
          break;
      }
      s /= 6;
    }
    return { h: s, s: u, v: l };
  }
  function qB(e, t, n) {
    e = mn(e, 360) * 6, t = mn(t, 100), n = mn(n, 100);
    var o = Math.floor(e), r = e - o, s = n * (1 - t), l = n * (1 - r * t), a = n * (1 - (1 - r) * t), u = o % 6, c = [n, l, s, s, a, n][u], f = [a, n, n, l, s, s][u], d = [s, s, a, n, n, l][u];
    return { r: c * 255, g: f * 255, b: d * 255 };
  }
  function Gg(e, t, n, o) {
    var r = [
      fs(Math.round(e).toString(16)),
      fs(Math.round(t).toString(16)),
      fs(Math.round(n).toString(16))
    ];
    return o && r[0].startsWith(r[0].charAt(1)) && r[1].startsWith(r[1].charAt(1)) && r[2].startsWith(r[2].charAt(1)) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) : r.join("");
  }
  function YB(e, t, n, o, r) {
    var s = [
      fs(Math.round(e).toString(16)),
      fs(Math.round(t).toString(16)),
      fs(Math.round(n).toString(16)),
      fs(GB(o))
    ];
    return r && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("");
  }
  function GB(e) {
    return Math.round(parseFloat(e) * 255).toString(16);
  }
  function Xg(e) {
    return Hn(e) / 255;
  }
  function Hn(e) {
    return parseInt(e, 16);
  }
  function XB(e) {
    return {
      r: e >> 16,
      g: (e & 65280) >> 8,
      b: e & 255
    };
  }
  var Hf = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
  function JB(e) {
    var t = { r: 0, g: 0, b: 0 }, n = 1, o = null, r = null, s = null, l = !1, a = !1;
    return typeof e == "string" && (e = eF(e)), typeof e == "object" && (Wo(e.r) && Wo(e.g) && Wo(e.b) ? (t = WB(e.r, e.g, e.b), l = !0, a = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : Wo(e.h) && Wo(e.s) && Wo(e.v) ? (o = qi(e.s), r = qi(e.v), t = qB(e.h, o, r), l = !0, a = "hsv") : Wo(e.h) && Wo(e.s) && Wo(e.l) && (o = qi(e.s), s = qi(e.l), t = UB(e.h, o, s), l = !0, a = "hsl"), Object.prototype.hasOwnProperty.call(e, "a") && (n = e.a)), n = iC(n), {
      ok: l,
      format: e.format || a,
      r: Math.min(255, Math.max(t.r, 0)),
      g: Math.min(255, Math.max(t.g, 0)),
      b: Math.min(255, Math.max(t.b, 0)),
      a: n
    };
  }
  var ZB = "[-\\+]?\\d+%?", QB = "[-\\+]?\\d*\\.\\d+%?", Mr = "(?:".concat(QB, ")|(?:").concat(ZB, ")"), Id = "[\\s|\\(]+(".concat(Mr, ")[,|\\s]+(").concat(Mr, ")[,|\\s]+(").concat(Mr, ")\\s*\\)?"), Pd = "[\\s|\\(]+(".concat(Mr, ")[,|\\s]+(").concat(Mr, ")[,|\\s]+(").concat(Mr, ")[,|\\s]+(").concat(Mr, ")\\s*\\)?"), po = {
    CSS_UNIT: new RegExp(Mr),
    rgb: new RegExp("rgb" + Id),
    rgba: new RegExp("rgba" + Pd),
    hsl: new RegExp("hsl" + Id),
    hsla: new RegExp("hsla" + Pd),
    hsv: new RegExp("hsv" + Id),
    hsva: new RegExp("hsva" + Pd),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
  function eF(e) {
    if (e = e.trim().toLowerCase(), e.length === 0)
      return !1;
    var t = !1;
    if (Hf[e])
      e = Hf[e], t = !0;
    else if (e === "transparent")
      return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    var n = po.rgb.exec(e);
    return n ? { r: n[1], g: n[2], b: n[3] } : (n = po.rgba.exec(e), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = po.hsl.exec(e), n ? { h: n[1], s: n[2], l: n[3] } : (n = po.hsla.exec(e), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = po.hsv.exec(e), n ? { h: n[1], s: n[2], v: n[3] } : (n = po.hsva.exec(e), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = po.hex8.exec(e), n ? {
      r: Hn(n[1]),
      g: Hn(n[2]),
      b: Hn(n[3]),
      a: Xg(n[4]),
      format: t ? "name" : "hex8"
    } : (n = po.hex6.exec(e), n ? {
      r: Hn(n[1]),
      g: Hn(n[2]),
      b: Hn(n[3]),
      format: t ? "name" : "hex"
    } : (n = po.hex4.exec(e), n ? {
      r: Hn(n[1] + n[1]),
      g: Hn(n[2] + n[2]),
      b: Hn(n[3] + n[3]),
      a: Xg(n[4] + n[4]),
      format: t ? "name" : "hex8"
    } : (n = po.hex3.exec(e), n ? {
      r: Hn(n[1] + n[1]),
      g: Hn(n[2] + n[2]),
      b: Hn(n[3] + n[3]),
      format: t ? "name" : "hex"
    } : !1)))))))));
  }
  function Wo(e) {
    return Boolean(po.CSS_UNIT.exec(String(e)));
  }
  var uC = function() {
    function e(t, n) {
      t === void 0 && (t = ""), n === void 0 && (n = {});
      var o;
      if (t instanceof e)
        return t;
      typeof t == "number" && (t = XB(t)), this.originalInput = t;
      var r = JB(t);
      this.originalInput = t, this.r = r.r, this.g = r.g, this.b = r.b, this.a = r.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (o = n.format) !== null && o !== void 0 ? o : r.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = r.ok;
    }
    return e.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, e.prototype.isLight = function() {
      return !this.isDark();
    }, e.prototype.getBrightness = function() {
      var t = this.toRgb();
      return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
    }, e.prototype.getLuminance = function() {
      var t = this.toRgb(), n, o, r, s = t.r / 255, l = t.g / 255, a = t.b / 255;
      return s <= 0.03928 ? n = s / 12.92 : n = Math.pow((s + 0.055) / 1.055, 2.4), l <= 0.03928 ? o = l / 12.92 : o = Math.pow((l + 0.055) / 1.055, 2.4), a <= 0.03928 ? r = a / 12.92 : r = Math.pow((a + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * o + 0.0722 * r;
    }, e.prototype.getAlpha = function() {
      return this.a;
    }, e.prototype.setAlpha = function(t) {
      return this.a = iC(t), this.roundA = Math.round(100 * this.a) / 100, this;
    }, e.prototype.isMonochrome = function() {
      var t = this.toHsl().s;
      return t === 0;
    }, e.prototype.toHsv = function() {
      var t = Yg(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, v: t.v, a: this.a };
    }, e.prototype.toHsvString = function() {
      var t = Yg(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), r = Math.round(t.v * 100);
      return this.a === 1 ? "hsv(".concat(n, ", ").concat(o, "%, ").concat(r, "%)") : "hsva(".concat(n, ", ").concat(o, "%, ").concat(r, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHsl = function() {
      var t = qg(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, l: t.l, a: this.a };
    }, e.prototype.toHslString = function() {
      var t = qg(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), r = Math.round(t.l * 100);
      return this.a === 1 ? "hsl(".concat(n, ", ").concat(o, "%, ").concat(r, "%)") : "hsla(".concat(n, ", ").concat(o, "%, ").concat(r, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHex = function(t) {
      return t === void 0 && (t = !1), Gg(this.r, this.g, this.b, t);
    }, e.prototype.toHexString = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex(t);
    }, e.prototype.toHex8 = function(t) {
      return t === void 0 && (t = !1), YB(this.r, this.g, this.b, this.a, t);
    }, e.prototype.toHex8String = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex8(t);
    }, e.prototype.toHexShortString = function(t) {
      return t === void 0 && (t = !1), this.a === 1 ? this.toHexString(t) : this.toHex8String(t);
    }, e.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, e.prototype.toRgbString = function() {
      var t = Math.round(this.r), n = Math.round(this.g), o = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(t, ", ").concat(n, ", ").concat(o, ")") : "rgba(".concat(t, ", ").concat(n, ", ").concat(o, ", ").concat(this.roundA, ")");
    }, e.prototype.toPercentageRgb = function() {
      var t = function(n) {
        return "".concat(Math.round(mn(n, 255) * 100), "%");
      };
      return {
        r: t(this.r),
        g: t(this.g),
        b: t(this.b),
        a: this.a
      };
    }, e.prototype.toPercentageRgbString = function() {
      var t = function(n) {
        return Math.round(mn(n, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")");
    }, e.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var t = "#" + Gg(this.r, this.g, this.b, !1), n = 0, o = Object.entries(Hf); n < o.length; n++) {
        var r = o[n], s = r[0], l = r[1];
        if (t === l)
          return s;
      }
      return !1;
    }, e.prototype.toString = function(t) {
      var n = Boolean(t);
      t = t != null ? t : this.format;
      var o = !1, r = this.a < 1 && this.a >= 0, s = !n && r && (t.startsWith("hex") || t === "name");
      return s ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (o = this.toRgbString()), t === "prgb" && (o = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (o = this.toHexString()), t === "hex3" && (o = this.toHexString(!0)), t === "hex4" && (o = this.toHex8String(!0)), t === "hex8" && (o = this.toHex8String()), t === "name" && (o = this.toName()), t === "hsl" && (o = this.toHslString()), t === "hsv" && (o = this.toHsvString()), o || this.toHexString());
    }, e.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, e.prototype.clone = function() {
      return new e(this.toString());
    }, e.prototype.lighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l += t / 100, n.l = Ui(n.l), new e(n);
    }, e.prototype.brighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100)))), new e(n);
    }, e.prototype.darken = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l -= t / 100, n.l = Ui(n.l), new e(n);
    }, e.prototype.tint = function(t) {
      return t === void 0 && (t = 10), this.mix("white", t);
    }, e.prototype.shade = function(t) {
      return t === void 0 && (t = 10), this.mix("black", t);
    }, e.prototype.desaturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s -= t / 100, n.s = Ui(n.s), new e(n);
    }, e.prototype.saturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s += t / 100, n.s = Ui(n.s), new e(n);
    }, e.prototype.greyscale = function() {
      return this.desaturate(100);
    }, e.prototype.spin = function(t) {
      var n = this.toHsl(), o = (n.h + t) % 360;
      return n.h = o < 0 ? 360 + o : o, new e(n);
    }, e.prototype.mix = function(t, n) {
      n === void 0 && (n = 50);
      var o = this.toRgb(), r = new e(t).toRgb(), s = n / 100, l = {
        r: (r.r - o.r) * s + o.r,
        g: (r.g - o.g) * s + o.g,
        b: (r.b - o.b) * s + o.b,
        a: (r.a - o.a) * s + o.a
      };
      return new e(l);
    }, e.prototype.analogous = function(t, n) {
      t === void 0 && (t = 6), n === void 0 && (n = 30);
      var o = this.toHsl(), r = 360 / n, s = [this];
      for (o.h = (o.h - (r * t >> 1) + 720) % 360; --t; )
        o.h = (o.h + r) % 360, s.push(new e(o));
      return s;
    }, e.prototype.complement = function() {
      var t = this.toHsl();
      return t.h = (t.h + 180) % 360, new e(t);
    }, e.prototype.monochromatic = function(t) {
      t === void 0 && (t = 6);
      for (var n = this.toHsv(), o = n.h, r = n.s, s = n.v, l = [], a = 1 / t; t--; )
        l.push(new e({ h: o, s: r, v: s })), s = (s + a) % 1;
      return l;
    }, e.prototype.splitcomplement = function() {
      var t = this.toHsl(), n = t.h;
      return [
        this,
        new e({ h: (n + 72) % 360, s: t.s, l: t.l }),
        new e({ h: (n + 216) % 360, s: t.s, l: t.l })
      ];
    }, e.prototype.onBackground = function(t) {
      var n = this.toRgb(), o = new e(t).toRgb(), r = n.a + o.a * (1 - n.a);
      return new e({
        r: (n.r * n.a + o.r * o.a * (1 - n.a)) / r,
        g: (n.g * n.a + o.g * o.a * (1 - n.a)) / r,
        b: (n.b * n.a + o.b * o.a * (1 - n.a)) / r,
        a: r
      });
    }, e.prototype.triad = function() {
      return this.polyad(3);
    }, e.prototype.tetrad = function() {
      return this.polyad(4);
    }, e.prototype.polyad = function(t) {
      for (var n = this.toHsl(), o = n.h, r = [this], s = 360 / t, l = 1; l < t; l++)
        r.push(new e({ h: (o + l * s) % 360, s: n.s, l: n.l }));
      return r;
    }, e.prototype.equals = function(t) {
      return this.toRgbString() === new e(t).toRgbString();
    }, e;
  }();
  function gr(e, t = 20) {
    return e.mix("#141414", t).toString();
  }
  function tF(e) {
    const t = Fn(), n = ge("button");
    return E(() => {
      let o = {};
      const r = e.color;
      if (r) {
        const s = new uC(r), l = e.dark ? s.tint(20).toString() : gr(s, 20);
        if (e.plain)
          o = n.cssVarBlock({
            "bg-color": e.dark ? gr(s, 90) : s.tint(90).toString(),
            "text-color": r,
            "border-color": e.dark ? gr(s, 50) : s.tint(50).toString(),
            "hover-text-color": `var(${n.cssVarName("color-white")})`,
            "hover-bg-color": r,
            "hover-border-color": r,
            "active-bg-color": l,
            "active-text-color": `var(${n.cssVarName("color-white")})`,
            "active-border-color": l
          }), t.value && (o[n.cssVarBlockName("disabled-bg-color")] = e.dark ? gr(s, 90) : s.tint(90).toString(), o[n.cssVarBlockName("disabled-text-color")] = e.dark ? gr(s, 50) : s.tint(50).toString(), o[n.cssVarBlockName("disabled-border-color")] = e.dark ? gr(s, 80) : s.tint(80).toString());
        else {
          const a = e.dark ? gr(s, 30) : s.tint(30).toString(), u = s.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
          if (o = n.cssVarBlock({
            "bg-color": r,
            "text-color": u,
            "border-color": r,
            "hover-bg-color": a,
            "hover-text-color": u,
            "hover-border-color": a,
            "active-bg-color": l,
            "active-border-color": l
          }), t.value) {
            const c = e.dark ? gr(s, 50) : s.tint(50).toString();
            o[n.cssVarBlockName("disabled-bg-color")] = c, o[n.cssVarBlockName("disabled-text-color")] = e.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`, o[n.cssVarBlockName("disabled-border-color")] = c;
          }
        }
      }
      return o;
    });
  }
  const nF = ["aria-disabled", "disabled", "autofocus", "type"], oF = G({
    name: "ElButton"
  }), rF = /* @__PURE__ */ G({
    ...oF,
    props: Ff,
    emits: zB,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = tF(o), s = ge("button"), { _ref: l, _size: a, _type: u, _disabled: c, shouldAddSpace: f, handleClick: d } = FB(o, n);
      return t({
        ref: l,
        size: a,
        type: u,
        disabled: c,
        shouldAddSpace: f
      }), (p, h) => (S(), V("button", {
        ref_key: "_ref",
        ref: l,
        class: $([
          i(s).b(),
          i(s).m(i(u)),
          i(s).m(i(a)),
          i(s).is("disabled", i(c)),
          i(s).is("loading", p.loading),
          i(s).is("plain", p.plain),
          i(s).is("round", p.round),
          i(s).is("circle", p.circle),
          i(s).is("text", p.text),
          i(s).is("link", p.link),
          i(s).is("has-bg", p.bg)
        ]),
        "aria-disabled": i(c) || p.loading,
        disabled: i(c) || p.loading,
        autofocus: p.autofocus,
        type: p.nativeType,
        style: Ke(i(r)),
        onClick: h[0] || (h[0] = (...m) => i(d) && i(d)(...m))
      }, [
        p.loading ? (S(), V(ze, { key: 0 }, [
          p.$slots.loading ? he(p.$slots, "loading", { key: 0 }) : (S(), ie(i(He), {
            key: 1,
            class: $(i(s).is("loading"))
          }, {
            default: X(() => [
              (S(), ie(vt(p.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : p.icon || p.$slots.icon ? (S(), ie(i(He), { key: 1 }, {
          default: X(() => [
            p.icon ? (S(), ie(vt(p.icon), { key: 0 })) : he(p.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : se("v-if", !0),
        p.$slots.default ? (S(), V("span", {
          key: 2,
          class: $({ [i(s).em("text", "expand")]: i(f) })
        }, [
          he(p.$slots, "default")
        ], 2)) : se("v-if", !0)
      ], 14, nF));
    }
  });
  var sF = /* @__PURE__ */ Me(rF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
  const lF = {
    size: Ff.size,
    type: Ff.type
  }, aF = G({
    name: "ElButtonGroup"
  }), iF = /* @__PURE__ */ G({
    ...aF,
    props: lF,
    setup(e) {
      const t = e;
      pt(aC, Tt({
        size: Ht(t, "size"),
        type: Ht(t, "type")
      }));
      const n = ge("button");
      return (o, r) => (S(), V("div", {
        class: $(`${i(n).b("group")}`)
      }, [
        he(o.$slots, "default")
      ], 2));
    }
  });
  var cC = /* @__PURE__ */ Me(iF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
  const gn = ut(sF, {
    ButtonGroup: cC
  }), dC = Gt(cC);
  var hr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, fC = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(hr, function() {
      var n = 1e3, o = 6e4, r = 36e5, s = "millisecond", l = "second", a = "minute", u = "hour", c = "day", f = "week", d = "month", p = "quarter", h = "year", m = "date", v = "Invalid Date", g = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, w = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(F) {
        var W = ["th", "st", "nd", "rd"], x = F % 100;
        return "[" + F + (W[(x - 20) % 10] || W[x] || W[0]) + "]";
      } }, b = function(F, W, x) {
        var N = String(F);
        return !N || N.length >= W ? F : "" + Array(W + 1 - N.length).join(x) + F;
      }, C = { s: b, z: function(F) {
        var W = -F.utcOffset(), x = Math.abs(W), N = Math.floor(x / 60), R = x % 60;
        return (W <= 0 ? "+" : "-") + b(N, 2, "0") + ":" + b(R, 2, "0");
      }, m: function F(W, x) {
        if (W.date() < x.date())
          return -F(x, W);
        var N = 12 * (x.year() - W.year()) + (x.month() - W.month()), R = W.clone().add(N, d), M = x - R < 0, j = W.clone().add(N + (M ? -1 : 1), d);
        return +(-(N + (x - R) / (M ? R - j : j - R)) || 0);
      }, a: function(F) {
        return F < 0 ? Math.ceil(F) || 0 : Math.floor(F);
      }, p: function(F) {
        return { M: d, y: h, w: f, d: c, D: m, h: u, m: a, s: l, ms: s, Q: p }[F] || String(F || "").toLowerCase().replace(/s$/, "");
      }, u: function(F) {
        return F === void 0;
      } }, _ = "en", k = {};
      k[_] = w;
      var O = "$isDayjsObject", T = function(F) {
        return F instanceof D || !(!F || !F[O]);
      }, P = function F(W, x, N) {
        var R;
        if (!W)
          return _;
        if (typeof W == "string") {
          var M = W.toLowerCase();
          k[M] && (R = M), x && (k[M] = x, R = M);
          var j = W.split("-");
          if (!R && j.length > 1)
            return F(j[0]);
        } else {
          var te = W.name;
          k[te] = W, R = te;
        }
        return !N && R && (_ = R), R || !N && _;
      }, A = function(F, W) {
        if (T(F))
          return F.clone();
        var x = typeof W == "object" ? W : {};
        return x.date = F, x.args = arguments, new D(x);
      }, L = C;
      L.l = P, L.i = T, L.w = function(F, W) {
        return A(F, { locale: W.$L, utc: W.$u, x: W.$x, $offset: W.$offset });
      };
      var D = function() {
        function F(x) {
          this.$L = P(x.locale, null, !0), this.parse(x), this.$x = this.$x || x.x || {}, this[O] = !0;
        }
        var W = F.prototype;
        return W.parse = function(x) {
          this.$d = function(N) {
            var R = N.date, M = N.utc;
            if (R === null)
              return new Date(NaN);
            if (L.u(R))
              return new Date();
            if (R instanceof Date)
              return new Date(R);
            if (typeof R == "string" && !/Z$/i.test(R)) {
              var j = R.match(g);
              if (j) {
                var te = j[2] - 1 || 0, U = (j[7] || "0").substring(0, 3);
                return M ? new Date(Date.UTC(j[1], te, j[3] || 1, j[4] || 0, j[5] || 0, j[6] || 0, U)) : new Date(j[1], te, j[3] || 1, j[4] || 0, j[5] || 0, j[6] || 0, U);
              }
            }
            return new Date(R);
          }(x), this.init();
        }, W.init = function() {
          var x = this.$d;
          this.$y = x.getFullYear(), this.$M = x.getMonth(), this.$D = x.getDate(), this.$W = x.getDay(), this.$H = x.getHours(), this.$m = x.getMinutes(), this.$s = x.getSeconds(), this.$ms = x.getMilliseconds();
        }, W.$utils = function() {
          return L;
        }, W.isValid = function() {
          return this.$d.toString() !== v;
        }, W.isSame = function(x, N) {
          var R = A(x);
          return this.startOf(N) <= R && R <= this.endOf(N);
        }, W.isAfter = function(x, N) {
          return A(x) < this.startOf(N);
        }, W.isBefore = function(x, N) {
          return this.endOf(N) < A(x);
        }, W.$g = function(x, N, R) {
          return L.u(x) ? this[N] : this.set(R, x);
        }, W.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, W.valueOf = function() {
          return this.$d.getTime();
        }, W.startOf = function(x, N) {
          var R = this, M = !!L.u(N) || N, j = L.p(x), te = function(re, ce) {
            var Te = L.w(R.$u ? Date.UTC(R.$y, ce, re) : new Date(R.$y, ce, re), R);
            return M ? Te : Te.endOf(c);
          }, U = function(re, ce) {
            return L.w(R.toDate()[re].apply(R.toDate("s"), (M ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ce)), R);
          }, Z = this.$W, pe = this.$M, J = this.$D, ee = "set" + (this.$u ? "UTC" : "");
          switch (j) {
            case h:
              return M ? te(1, 0) : te(31, 11);
            case d:
              return M ? te(1, pe) : te(0, pe + 1);
            case f:
              var ne = this.$locale().weekStart || 0, Y = (Z < ne ? Z + 7 : Z) - ne;
              return te(M ? J - Y : J + (6 - Y), pe);
            case c:
            case m:
              return U(ee + "Hours", 0);
            case u:
              return U(ee + "Minutes", 1);
            case a:
              return U(ee + "Seconds", 2);
            case l:
              return U(ee + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, W.endOf = function(x) {
          return this.startOf(x, !1);
        }, W.$set = function(x, N) {
          var R, M = L.p(x), j = "set" + (this.$u ? "UTC" : ""), te = (R = {}, R[c] = j + "Date", R[m] = j + "Date", R[d] = j + "Month", R[h] = j + "FullYear", R[u] = j + "Hours", R[a] = j + "Minutes", R[l] = j + "Seconds", R[s] = j + "Milliseconds", R)[M], U = M === c ? this.$D + (N - this.$W) : N;
          if (M === d || M === h) {
            var Z = this.clone().set(m, 1);
            Z.$d[te](U), Z.init(), this.$d = Z.set(m, Math.min(this.$D, Z.daysInMonth())).$d;
          } else
            te && this.$d[te](U);
          return this.init(), this;
        }, W.set = function(x, N) {
          return this.clone().$set(x, N);
        }, W.get = function(x) {
          return this[L.p(x)]();
        }, W.add = function(x, N) {
          var R, M = this;
          x = Number(x);
          var j = L.p(N), te = function(pe) {
            var J = A(M);
            return L.w(J.date(J.date() + Math.round(pe * x)), M);
          };
          if (j === d)
            return this.set(d, this.$M + x);
          if (j === h)
            return this.set(h, this.$y + x);
          if (j === c)
            return te(1);
          if (j === f)
            return te(7);
          var U = (R = {}, R[a] = o, R[u] = r, R[l] = n, R)[j] || 1, Z = this.$d.getTime() + x * U;
          return L.w(Z, this);
        }, W.subtract = function(x, N) {
          return this.add(-1 * x, N);
        }, W.format = function(x) {
          var N = this, R = this.$locale();
          if (!this.isValid())
            return R.invalidDate || v;
          var M = x || "YYYY-MM-DDTHH:mm:ssZ", j = L.z(this), te = this.$H, U = this.$m, Z = this.$M, pe = R.weekdays, J = R.months, ee = R.meridiem, ne = function(ce, Te, Pe, z) {
            return ce && (ce[Te] || ce(N, M)) || Pe[Te].slice(0, z);
          }, Y = function(ce) {
            return L.s(te % 12 || 12, ce, "0");
          }, re = ee || function(ce, Te, Pe) {
            var z = ce < 12 ? "AM" : "PM";
            return Pe ? z.toLowerCase() : z;
          };
          return M.replace(y, function(ce, Te) {
            return Te || function(Pe) {
              switch (Pe) {
                case "YY":
                  return String(N.$y).slice(-2);
                case "YYYY":
                  return L.s(N.$y, 4, "0");
                case "M":
                  return Z + 1;
                case "MM":
                  return L.s(Z + 1, 2, "0");
                case "MMM":
                  return ne(R.monthsShort, Z, J, 3);
                case "MMMM":
                  return ne(J, Z);
                case "D":
                  return N.$D;
                case "DD":
                  return L.s(N.$D, 2, "0");
                case "d":
                  return String(N.$W);
                case "dd":
                  return ne(R.weekdaysMin, N.$W, pe, 2);
                case "ddd":
                  return ne(R.weekdaysShort, N.$W, pe, 3);
                case "dddd":
                  return pe[N.$W];
                case "H":
                  return String(te);
                case "HH":
                  return L.s(te, 2, "0");
                case "h":
                  return Y(1);
                case "hh":
                  return Y(2);
                case "a":
                  return re(te, U, !0);
                case "A":
                  return re(te, U, !1);
                case "m":
                  return String(U);
                case "mm":
                  return L.s(U, 2, "0");
                case "s":
                  return String(N.$s);
                case "ss":
                  return L.s(N.$s, 2, "0");
                case "SSS":
                  return L.s(N.$ms, 3, "0");
                case "Z":
                  return j;
              }
              return null;
            }(ce) || j.replace(":", "");
          });
        }, W.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, W.diff = function(x, N, R) {
          var M, j = this, te = L.p(N), U = A(x), Z = (U.utcOffset() - this.utcOffset()) * o, pe = this - U, J = function() {
            return L.m(j, U);
          };
          switch (te) {
            case h:
              M = J() / 12;
              break;
            case d:
              M = J();
              break;
            case p:
              M = J() / 3;
              break;
            case f:
              M = (pe - Z) / 6048e5;
              break;
            case c:
              M = (pe - Z) / 864e5;
              break;
            case u:
              M = pe / r;
              break;
            case a:
              M = pe / o;
              break;
            case l:
              M = pe / n;
              break;
            default:
              M = pe;
          }
          return R ? M : L.a(M);
        }, W.daysInMonth = function() {
          return this.endOf(d).$D;
        }, W.$locale = function() {
          return k[this.$L];
        }, W.locale = function(x, N) {
          if (!x)
            return this.$L;
          var R = this.clone(), M = P(x, N, !0);
          return M && (R.$L = M), R;
        }, W.clone = function() {
          return L.w(this.$d, this);
        }, W.toDate = function() {
          return new Date(this.valueOf());
        }, W.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, W.toISOString = function() {
          return this.$d.toISOString();
        }, W.toString = function() {
          return this.$d.toUTCString();
        }, F;
      }(), B = D.prototype;
      return A.prototype = B, [["$ms", s], ["$s", l], ["$m", a], ["$H", u], ["$W", c], ["$M", d], ["$y", h], ["$D", m]].forEach(function(F) {
        B[F[1]] = function(W) {
          return this.$g(W, F[0], F[1]);
        };
      }), A.extend = function(F, W) {
        return F.$i || (F(W, D, A), F.$i = !0), A;
      }, A.locale = P, A.isDayjs = T, A.unix = function(F) {
        return A(1e3 * F);
      }, A.en = k[_], A.Ls = k, A.p = {}, A;
    });
  })(fC);
  const at = fC.exports;
  var pC = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(hr, function() {
      var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, o = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, r = /\d\d/, s = /\d\d?/, l = /\d*[^-_:/,()\s\d]+/, a = {}, u = function(v) {
        return (v = +v) + (v > 68 ? 1900 : 2e3);
      }, c = function(v) {
        return function(g) {
          this[v] = +g;
        };
      }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(v) {
        (this.zone || (this.zone = {})).offset = function(g) {
          if (!g || g === "Z")
            return 0;
          var y = g.match(/([+-]|\d\d)/g), w = 60 * y[1] + (+y[2] || 0);
          return w === 0 ? 0 : y[0] === "+" ? -w : w;
        }(v);
      }], d = function(v) {
        var g = a[v];
        return g && (g.indexOf ? g : g.s.concat(g.f));
      }, p = function(v, g) {
        var y, w = a.meridiem;
        if (w) {
          for (var b = 1; b <= 24; b += 1)
            if (v.indexOf(w(b, 0, g)) > -1) {
              y = b > 12;
              break;
            }
        } else
          y = v === (g ? "pm" : "PM");
        return y;
      }, h = { A: [l, function(v) {
        this.afternoon = p(v, !1);
      }], a: [l, function(v) {
        this.afternoon = p(v, !0);
      }], S: [/\d/, function(v) {
        this.milliseconds = 100 * +v;
      }], SS: [r, function(v) {
        this.milliseconds = 10 * +v;
      }], SSS: [/\d{3}/, function(v) {
        this.milliseconds = +v;
      }], s: [s, c("seconds")], ss: [s, c("seconds")], m: [s, c("minutes")], mm: [s, c("minutes")], H: [s, c("hours")], h: [s, c("hours")], HH: [s, c("hours")], hh: [s, c("hours")], D: [s, c("day")], DD: [r, c("day")], Do: [l, function(v) {
        var g = a.ordinal, y = v.match(/\d+/);
        if (this.day = y[0], g)
          for (var w = 1; w <= 31; w += 1)
            g(w).replace(/\[|\]/g, "") === v && (this.day = w);
      }], M: [s, c("month")], MM: [r, c("month")], MMM: [l, function(v) {
        var g = d("months"), y = (d("monthsShort") || g.map(function(w) {
          return w.slice(0, 3);
        })).indexOf(v) + 1;
        if (y < 1)
          throw new Error();
        this.month = y % 12 || y;
      }], MMMM: [l, function(v) {
        var g = d("months").indexOf(v) + 1;
        if (g < 1)
          throw new Error();
        this.month = g % 12 || g;
      }], Y: [/[+-]?\d+/, c("year")], YY: [r, function(v) {
        this.year = u(v);
      }], YYYY: [/\d{4}/, c("year")], Z: f, ZZ: f };
      function m(v) {
        var g, y;
        g = v, y = a && a.formats;
        for (var w = (v = g.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(P, A, L) {
          var D = L && L.toUpperCase();
          return A || y[L] || n[L] || y[D].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(B, F, W) {
            return F || W.slice(1);
          });
        })).match(o), b = w.length, C = 0; C < b; C += 1) {
          var _ = w[C], k = h[_], O = k && k[0], T = k && k[1];
          w[C] = T ? { regex: O, parser: T } : _.replace(/^\[|\]$/g, "");
        }
        return function(P) {
          for (var A = {}, L = 0, D = 0; L < b; L += 1) {
            var B = w[L];
            if (typeof B == "string")
              D += B.length;
            else {
              var F = B.regex, W = B.parser, x = P.slice(D), N = F.exec(x)[0];
              W.call(A, N), P = P.replace(N, "");
            }
          }
          return function(R) {
            var M = R.afternoon;
            if (M !== void 0) {
              var j = R.hours;
              M ? j < 12 && (R.hours += 12) : j === 12 && (R.hours = 0), delete R.afternoon;
            }
          }(A), A;
        };
      }
      return function(v, g, y) {
        y.p.customParseFormat = !0, v && v.parseTwoDigitYear && (u = v.parseTwoDigitYear);
        var w = g.prototype, b = w.parse;
        w.parse = function(C) {
          var _ = C.date, k = C.utc, O = C.args;
          this.$u = k;
          var T = O[1];
          if (typeof T == "string") {
            var P = O[2] === !0, A = O[3] === !0, L = P || A, D = O[2];
            A && (D = O[2]), a = this.$locale(), !P && D && (a = y.Ls[D]), this.$d = function(x, N, R) {
              try {
                if (["x", "X"].indexOf(N) > -1)
                  return new Date((N === "X" ? 1e3 : 1) * x);
                var M = m(N)(x), j = M.year, te = M.month, U = M.day, Z = M.hours, pe = M.minutes, J = M.seconds, ee = M.milliseconds, ne = M.zone, Y = new Date(), re = U || (j || te ? 1 : Y.getDate()), ce = j || Y.getFullYear(), Te = 0;
                j && !te || (Te = te > 0 ? te - 1 : Y.getMonth());
                var Pe = Z || 0, z = pe || 0, Q = J || 0, de = ee || 0;
                return ne ? new Date(Date.UTC(ce, Te, re, Pe, z, Q, de + 60 * ne.offset * 1e3)) : R ? new Date(Date.UTC(ce, Te, re, Pe, z, Q, de)) : new Date(ce, Te, re, Pe, z, Q, de);
              } catch {
                return new Date("");
              }
            }(_, T, k), this.init(), D && D !== !0 && (this.$L = this.locale(D).$L), L && _ != this.format(T) && (this.$d = new Date("")), a = {};
          } else if (T instanceof Array)
            for (var B = T.length, F = 1; F <= B; F += 1) {
              O[1] = T[F - 1];
              var W = y.apply(this, O);
              if (W.isValid()) {
                this.$d = W.$d, this.$L = W.$L, this.init();
                break;
              }
              F === B && (this.$d = new Date(""));
            }
          else
            b.call(this, C);
        };
      };
    });
  })(pC);
  const Uh = pC.exports, Jg = ["hours", "minutes", "seconds"], zf = "HH:mm:ss", Js = "YYYY-MM-DD", uF = {
    date: Js,
    dates: Js,
    week: "gggg[w]ww",
    year: "YYYY",
    month: "YYYY-MM",
    datetime: `${Js} ${zf}`,
    monthrange: "YYYY-MM",
    daterange: Js,
    datetimerange: `${Js} ${zf}`
  }, Ad = (e, t) => [
    e > 0 ? e - 1 : void 0,
    e,
    e < t ? e + 1 : void 0
  ], Rr = (e) => Array.from(Array.from({ length: e }).keys()), hC = (e) => e.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim(), vC = (e) => e.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim(), Zg = function(e, t) {
    const n = Ns(e), o = Ns(t);
    return n && o ? e.getTime() === t.getTime() : !n && !o ? e === t : !1;
  }, Qg = function(e, t) {
    const n = De(e), o = De(t);
    return n && o ? e.length !== t.length ? !1 : e.every((r, s) => Zg(r, t[s])) : !n && !o ? Zg(e, t) : !1;
  }, ey = function(e, t, n) {
    const o = Qn(t) || t === "x" ? at(e).locale(n) : at(e, t).locale(n);
    return o.isValid() ? o : void 0;
  }, ty = function(e, t, n) {
    return Qn(t) ? e : t === "x" ? +e : at(e).locale(n).format(t);
  }, Rd = (e, t) => {
    var n;
    const o = [], r = t == null ? void 0 : t();
    for (let s = 0; s < e; s++)
      o.push((n = r == null ? void 0 : r.includes(s)) != null ? n : !1);
    return o;
  }, mC = Ie({
    disabledHours: {
      type: le(Function)
    },
    disabledMinutes: {
      type: le(Function)
    },
    disabledSeconds: {
      type: le(Function)
    }
  }), gC = Ie({
    visible: Boolean,
    actualVisible: {
      type: Boolean,
      default: void 0
    },
    format: {
      type: String,
      default: ""
    }
  }), qh = Ie({
    id: {
      type: le([Array, String])
    },
    name: {
      type: le([Array, String]),
      default: ""
    },
    popperClass: {
      type: String,
      default: ""
    },
    format: String,
    valueFormat: String,
    type: {
      type: String,
      default: ""
    },
    clearable: {
      type: Boolean,
      default: !0
    },
    clearIcon: {
      type: le([String, Object]),
      default: Yr
    },
    editable: {
      type: Boolean,
      default: !0
    },
    prefixIcon: {
      type: le([String, Object]),
      default: ""
    },
    size: yn,
    readonly: {
      type: Boolean,
      default: !1
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    placeholder: {
      type: String,
      default: ""
    },
    popperOptions: {
      type: le(Object),
      default: () => ({})
    },
    modelValue: {
      type: le([Date, Array, String, Number]),
      default: ""
    },
    rangeSeparator: {
      type: String,
      default: "-"
    },
    startPlaceholder: String,
    endPlaceholder: String,
    defaultValue: {
      type: le([Date, Array])
    },
    defaultTime: {
      type: le([Date, Array])
    },
    isRange: {
      type: Boolean,
      default: !1
    },
    ...mC,
    disabledDate: {
      type: Function
    },
    cellClassName: {
      type: Function
    },
    shortcuts: {
      type: Array,
      default: () => []
    },
    arrowControl: {
      type: Boolean,
      default: !1
    },
    label: {
      type: String,
      default: void 0
    },
    tabindex: {
      type: le([String, Number]),
      default: 0
    },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    unlinkPanels: Boolean
  }), cF = ["id", "name", "placeholder", "value", "disabled", "readonly"], dF = ["id", "name", "placeholder", "value", "disabled", "readonly"], fF = G({
    name: "Picker"
  }), pF = /* @__PURE__ */ G({
    ...fF,
    props: qh,
    emits: [
      "update:modelValue",
      "change",
      "focus",
      "blur",
      "calendar-change",
      "panel-change",
      "visible-change",
      "keydown"
    ],
    setup(e, { expose: t, emit: n }) {
      const o = e, { lang: r } = St(), s = ge("date"), l = ge("input"), a = ge("range"), { form: u, formItem: c } = In(), f = Be("ElPopperOptions", {}), d = I(), p = I(), h = I(!1), m = I(!1), v = I(null);
      let g = !1, y = !1;
      me(h, (q) => {
        q ? Fe(() => {
          q && (v.value = o.modelValue);
        }) : (ae.value = null, Fe(() => {
          w(o.modelValue);
        }));
      });
      const w = (q, oe) => {
        (oe || !Qg(q, v.value)) && (n("change", q), o.validateEvent && (c == null || c.validate("change").catch((be) => yt(be))));
      }, b = (q) => {
        if (!Qg(o.modelValue, q)) {
          let oe;
          De(q) ? oe = q.map((be) => ty(be, o.valueFormat, r.value)) : q && (oe = ty(q, o.valueFormat, r.value)), n("update:modelValue", q && oe, r.value);
        }
      }, C = (q) => {
        n("keydown", q);
      }, _ = E(() => {
        if (p.value) {
          const q = z.value ? p.value : p.value.$el;
          return Array.from(q.querySelectorAll("input"));
        }
        return [];
      }), k = (q, oe, be) => {
        const xe = _.value;
        !xe.length || (!be || be === "min" ? (xe[0].setSelectionRange(q, oe), xe[0].focus()) : be === "max" && (xe[1].setSelectionRange(q, oe), xe[1].focus()));
      }, O = () => {
        W(!0, !0), Fe(() => {
          y = !1;
        });
      }, T = (q = "", oe = !1) => {
        oe || (y = !0), h.value = oe;
        let be;
        De(q) ? be = q.map((xe) => xe.toDate()) : be = q && q.toDate(), ae.value = null, b(be);
      }, P = () => {
        m.value = !0;
      }, A = () => {
        n("visible-change", !0);
      }, L = (q) => {
        (q == null ? void 0 : q.key) === We.esc && W(!0, !0);
      }, D = () => {
        m.value = !1, h.value = !1, y = !1, n("visible-change", !1);
      }, B = () => {
        h.value = !0;
      }, F = () => {
        h.value = !1;
      }, W = (q = !0, oe = !1) => {
        y = oe;
        const [be, xe] = i(_);
        let nt = be;
        !q && z.value && (nt = xe), nt && nt.focus();
      }, x = (q) => {
        o.readonly || M.value || h.value || y || (h.value = !0, n("focus", q));
      };
      let N;
      const R = (q) => {
        const oe = async () => {
          setTimeout(() => {
            var be;
            N === oe && (!(((be = d.value) == null ? void 0 : be.isFocusInsideContent()) && !g) && _.value.filter((xe) => xe.contains(document.activeElement)).length === 0 && (Ee(), h.value = !1, n("blur", q), o.validateEvent && (c == null || c.validate("blur").catch((xe) => yt(xe)))), g = !1);
          }, 0);
        };
        N = oe, oe();
      }, M = E(() => o.disabled || (u == null ? void 0 : u.disabled)), j = E(() => {
        let q;
        if (Y.value ? Je.value.getDefaultValue && (q = Je.value.getDefaultValue()) : De(o.modelValue) ? q = o.modelValue.map((oe) => ey(oe, o.valueFormat, r.value)) : q = ey(o.modelValue, o.valueFormat, r.value), Je.value.getRangeAvailableTime) {
          const oe = Je.value.getRangeAvailableTime(q);
          qn(oe, q) || (q = oe, b(De(q) ? q.map((be) => be.toDate()) : q.toDate()));
        }
        return De(q) && q.some((oe) => !oe) && (q = []), q;
      }), te = E(() => {
        if (!Je.value.panelReady)
          return "";
        const q = Se(j.value);
        return De(ae.value) ? [
          ae.value[0] || q && q[0] || "",
          ae.value[1] || q && q[1] || ""
        ] : ae.value !== null ? ae.value : !Z.value && Y.value || !h.value && Y.value ? "" : q ? pe.value ? q.join(", ") : q : "";
      }), U = E(() => o.type.includes("time")), Z = E(() => o.type.startsWith("time")), pe = E(() => o.type === "dates"), J = E(() => o.prefixIcon || (U.value ? J1 : g3)), ee = I(!1), ne = (q) => {
        o.readonly || M.value || ee.value && (q.stopPropagation(), O(), b(null), w(null, !0), ee.value = !1, h.value = !1, Je.value.handleClear && Je.value.handleClear());
      }, Y = E(() => {
        const { modelValue: q } = o;
        return !q || De(q) && !q.filter(Boolean).length;
      }), re = async (q) => {
        var oe;
        o.readonly || M.value || (((oe = q.target) == null ? void 0 : oe.tagName) !== "INPUT" || _.value.includes(document.activeElement)) && (h.value = !0);
      }, ce = () => {
        o.readonly || M.value || !Y.value && o.clearable && (ee.value = !0);
      }, Te = () => {
        ee.value = !1;
      }, Pe = (q) => {
        var oe;
        o.readonly || M.value || (((oe = q.touches[0].target) == null ? void 0 : oe.tagName) !== "INPUT" || _.value.includes(document.activeElement)) && (h.value = !0);
      }, z = E(() => o.type.includes("range")), Q = on(), de = E(() => {
        var q, oe;
        return (oe = (q = i(d)) == null ? void 0 : q.popperRef) == null ? void 0 : oe.contentRef;
      }), Oe = E(() => {
        var q;
        return i(z) ? i(p) : (q = i(p)) == null ? void 0 : q.$el;
      });
      oh(Oe, (q) => {
        const oe = i(de), be = i(Oe);
        oe && (q.target === oe || q.composedPath().includes(oe)) || q.target === be || q.composedPath().includes(be) || (h.value = !1);
      });
      const ae = I(null), Ee = () => {
        if (ae.value) {
          const q = we(te.value);
          q && _e(q) && (b(De(q) ? q.map((oe) => oe.toDate()) : q.toDate()), ae.value = null);
        }
        ae.value === "" && (b(null), w(null), ae.value = null);
      }, we = (q) => q ? Je.value.parseUserInput(q) : null, Se = (q) => q ? Je.value.formatToString(q) : null, _e = (q) => Je.value.isValidValue(q), ke = async (q) => {
        if (o.readonly || M.value)
          return;
        const { code: oe } = q;
        if (C(q), oe === We.esc) {
          h.value === !0 && (h.value = !1, q.preventDefault(), q.stopPropagation());
          return;
        }
        if (oe === We.down && (Je.value.handleFocusPicker && (q.preventDefault(), q.stopPropagation()), h.value === !1 && (h.value = !0, await Fe()), Je.value.handleFocusPicker)) {
          Je.value.handleFocusPicker();
          return;
        }
        if (oe === We.tab) {
          g = !0;
          return;
        }
        if (oe === We.enter || oe === We.numpadEnter) {
          (ae.value === null || ae.value === "" || _e(we(te.value))) && (Ee(), h.value = !1), q.stopPropagation();
          return;
        }
        if (ae.value) {
          q.stopPropagation();
          return;
        }
        Je.value.handleKeydownInput && Je.value.handleKeydownInput(q);
      }, Re = (q) => {
        ae.value = q, h.value || (h.value = !0);
      }, fe = (q) => {
        const oe = q.target;
        ae.value ? ae.value = [oe.value, ae.value[1]] : ae.value = [oe.value, null];
      }, Ae = (q) => {
        const oe = q.target;
        ae.value ? ae.value = [ae.value[0], oe.value] : ae.value = [null, oe.value];
      }, qe = () => {
        var q;
        const oe = ae.value, be = we(oe && oe[0]), xe = i(j);
        if (be && be.isValid()) {
          ae.value = [
            Se(be),
            ((q = te.value) == null ? void 0 : q[1]) || null
          ];
          const nt = [be, xe && (xe[1] || null)];
          _e(nt) && (b(nt), ae.value = null);
        }
      }, tt = () => {
        var q;
        const oe = i(ae), be = we(oe && oe[1]), xe = i(j);
        if (be && be.isValid()) {
          ae.value = [
            ((q = i(te)) == null ? void 0 : q[0]) || null,
            Se(be)
          ];
          const nt = [xe && xe[0], be];
          _e(nt) && (b(nt), ae.value = null);
        }
      }, Je = I({}), ye = (q) => {
        Je.value[q[0]] = q[1], Je.value.panelReady = !0;
      }, Ce = (q) => {
        n("calendar-change", q);
      }, ue = (q, oe, be) => {
        n("panel-change", q, oe, be);
      };
      return pt("EP_PICKER_BASE", {
        props: o
      }), t({
        focus: W,
        handleFocusInput: x,
        handleBlurInput: R,
        handleOpen: B,
        handleClose: F,
        onPick: T
      }), (q, oe) => (S(), ie(i(Mn), ft({
        ref_key: "refPopper",
        ref: d,
        visible: h.value,
        effect: "light",
        pure: "",
        trigger: "click"
      }, q.$attrs, {
        role: "dialog",
        teleported: "",
        transition: `${i(s).namespace.value}-zoom-in-top`,
        "popper-class": [`${i(s).namespace.value}-picker__popper`, q.popperClass],
        "popper-options": i(f),
        "fallback-placements": ["bottom", "top", "right", "left"],
        "gpu-acceleration": !1,
        "stop-popper-mouse-event": !1,
        "hide-after": 0,
        persistent: "",
        onBeforeShow: P,
        onShow: A,
        onHide: D
      }), {
        default: X(() => [
          i(z) ? (S(), V("div", {
            key: 1,
            ref_key: "inputRef",
            ref: p,
            class: $([
              i(s).b("editor"),
              i(s).bm("editor", q.type),
              i(l).e("wrapper"),
              i(s).is("disabled", i(M)),
              i(s).is("active", h.value),
              i(a).b("editor"),
              i(Q) ? i(a).bm("editor", i(Q)) : "",
              q.$attrs.class
            ]),
            style: Ke(q.$attrs.style),
            onClick: x,
            onMouseenter: ce,
            onMouseleave: Te,
            onTouchstart: Pe,
            onKeydown: ke
          }, [
            i(J) ? (S(), ie(i(He), {
              key: 0,
              class: $([i(l).e("icon"), i(a).e("icon")]),
              onMousedown: Ze(re, ["prevent"]),
              onTouchstart: Pe
            }, {
              default: X(() => [
                (S(), ie(vt(i(J))))
              ]),
              _: 1
            }, 8, ["class", "onMousedown"])) : se("v-if", !0),
            H("input", {
              id: q.id && q.id[0],
              autocomplete: "off",
              name: q.name && q.name[0],
              placeholder: q.startPlaceholder,
              value: i(te) && i(te)[0],
              disabled: i(M),
              readonly: !q.editable || q.readonly,
              class: $(i(a).b("input")),
              onMousedown: re,
              onInput: fe,
              onChange: qe,
              onFocus: x,
              onBlur: R
            }, null, 42, cF),
            he(q.$slots, "range-separator", {}, () => [
              H("span", {
                class: $(i(a).b("separator"))
              }, Ne(q.rangeSeparator), 3)
            ]),
            H("input", {
              id: q.id && q.id[1],
              autocomplete: "off",
              name: q.name && q.name[1],
              placeholder: q.endPlaceholder,
              value: i(te) && i(te)[1],
              disabled: i(M),
              readonly: !q.editable || q.readonly,
              class: $(i(a).b("input")),
              onMousedown: re,
              onFocus: x,
              onBlur: R,
              onInput: Ae,
              onChange: tt
            }, null, 42, dF),
            q.clearIcon ? (S(), ie(i(He), {
              key: 1,
              class: $([
                i(l).e("icon"),
                i(a).e("close-icon"),
                {
                  [i(a).e("close-icon--hidden")]: !ee.value
                }
              ]),
              onClick: ne
            }, {
              default: X(() => [
                (S(), ie(vt(q.clearIcon)))
              ]),
              _: 1
            }, 8, ["class"])) : se("v-if", !0)
          ], 38)) : (S(), ie(i(wn), {
            key: 0,
            id: q.id,
            ref_key: "inputRef",
            ref: p,
            "container-role": "combobox",
            "model-value": i(te),
            name: q.name,
            size: i(Q),
            disabled: i(M),
            placeholder: q.placeholder,
            class: $([i(s).b("editor"), i(s).bm("editor", q.type), q.$attrs.class]),
            style: Ke(q.$attrs.style),
            readonly: !q.editable || q.readonly || i(pe) || q.type === "week",
            label: q.label,
            tabindex: q.tabindex,
            "validate-event": !1,
            onInput: Re,
            onFocus: x,
            onBlur: R,
            onKeydown: ke,
            onChange: Ee,
            onMousedown: re,
            onMouseenter: ce,
            onMouseleave: Te,
            onTouchstart: Pe,
            onClick: oe[0] || (oe[0] = Ze(() => {
            }, ["stop"]))
          }, {
            prefix: X(() => [
              i(J) ? (S(), ie(i(He), {
                key: 0,
                class: $(i(l).e("icon")),
                onMousedown: Ze(re, ["prevent"]),
                onTouchstart: Pe
              }, {
                default: X(() => [
                  (S(), ie(vt(i(J))))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : se("v-if", !0)
            ]),
            suffix: X(() => [
              ee.value && q.clearIcon ? (S(), ie(i(He), {
                key: 0,
                class: $(`${i(l).e("icon")} clear-icon`),
                onClick: Ze(ne, ["stop"])
              }, {
                default: X(() => [
                  (S(), ie(vt(q.clearIcon)))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : se("v-if", !0)
            ]),
            _: 1
          }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "label", "tabindex", "onKeydown"]))
        ]),
        content: X(() => [
          he(q.$slots, "default", {
            visible: h.value,
            actualVisible: m.value,
            parsedValue: i(j),
            format: q.format,
            unlinkPanels: q.unlinkPanels,
            type: q.type,
            defaultValue: q.defaultValue,
            onPick: T,
            onSelectRange: k,
            onSetPickerOption: ye,
            onCalendarChange: Ce,
            onPanelChange: ue,
            onKeydown: L,
            onMousedown: oe[1] || (oe[1] = Ze(() => {
            }, ["stop"]))
          })
        ]),
        _: 3
      }, 16, ["visible", "transition", "popper-class", "popper-options"]));
    }
  });
  var yC = /* @__PURE__ */ Me(pF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/common/picker.vue"]]);
  const hF = Ie({
    ...gC,
    datetimeRole: String,
    parsedValue: {
      type: le(Object)
    }
  }), bC = ({
    getAvailableHours: e,
    getAvailableMinutes: t,
    getAvailableSeconds: n
  }) => {
    const o = (l, a, u, c) => {
      const f = {
        hour: e,
        minute: t,
        second: n
      };
      let d = l;
      return ["hour", "minute", "second"].forEach((p) => {
        if (f[p]) {
          let h;
          const m = f[p];
          switch (p) {
            case "minute": {
              h = m(d.hour(), a, c);
              break;
            }
            case "second": {
              h = m(d.hour(), d.minute(), a, c);
              break;
            }
            default: {
              h = m(a, c);
              break;
            }
          }
          if ((h == null ? void 0 : h.length) && !h.includes(d[p]())) {
            const v = u ? 0 : h.length - 1;
            d = d[p](h[v]);
          }
        }
      }), d;
    }, r = {};
    return {
      timePickerOptions: r,
      getAvailableTime: o,
      onSetOption: ([l, a]) => {
        r[l] = a;
      }
    };
  }, xd = (e) => {
    const t = (o, r) => o || r, n = (o) => o !== !0;
    return e.map(t).filter(n);
  }, wC = (e, t, n) => ({
    getHoursList: (l, a) => Rd(24, e && (() => e == null ? void 0 : e(l, a))),
    getMinutesList: (l, a, u) => Rd(60, t && (() => t == null ? void 0 : t(l, a, u))),
    getSecondsList: (l, a, u, c) => Rd(60, n && (() => n == null ? void 0 : n(l, a, u, c)))
  }), CC = (e, t, n) => {
    const { getHoursList: o, getMinutesList: r, getSecondsList: s } = wC(e, t, n);
    return {
      getAvailableHours: (c, f) => xd(o(c, f)),
      getAvailableMinutes: (c, f, d) => xd(r(c, f, d)),
      getAvailableSeconds: (c, f, d, p) => xd(s(c, f, d, p))
    };
  }, EC = (e) => {
    const t = I(e.parsedValue);
    return me(() => e.visible, (n) => {
      n || (t.value = e.parsedValue);
    }), t;
  }, Er = /* @__PURE__ */ new Map();
  let ny;
  bt && (document.addEventListener("mousedown", (e) => ny = e), document.addEventListener("mouseup", (e) => {
    for (const t of Er.values())
      for (const { documentHandler: n } of t)
        n(e, ny);
  }));
  function oy(e, t) {
    let n = [];
    return Array.isArray(t.arg) ? n = t.arg : So(t.arg) && n.push(t.arg), function(o, r) {
      const s = t.instance.popperRef, l = o.target, a = r == null ? void 0 : r.target, u = !t || !t.instance, c = !l || !a, f = e.contains(l) || e.contains(a), d = e === l, p = n.length && n.some((m) => m == null ? void 0 : m.contains(l)) || n.length && n.includes(a), h = s && (s.contains(l) || s.contains(a));
      u || c || f || d || p || h || t.value(o, r);
    };
  }
  const Kr = {
    beforeMount(e, t) {
      Er.has(e) || Er.set(e, []), Er.get(e).push({
        documentHandler: oy(e, t),
        bindingFn: t.value
      });
    },
    updated(e, t) {
      Er.has(e) || Er.set(e, []);
      const n = Er.get(e), o = n.findIndex((s) => s.bindingFn === t.oldValue), r = {
        documentHandler: oy(e, t),
        bindingFn: t.value
      };
      o >= 0 ? n.splice(o, 1, r) : n.push(r);
    },
    unmounted(e) {
      Er.delete(e);
    }
  }, vF = 100, mF = 600, tc = {
    beforeMount(e, t) {
      const n = t.value, { interval: o = vF, delay: r = mF } = Ge(n) ? {} : n;
      let s, l;
      const a = () => Ge(n) ? n() : n.handler(), u = () => {
        l && (clearTimeout(l), l = void 0), s && (clearInterval(s), s = void 0);
      };
      e.addEventListener("mousedown", (c) => {
        c.button === 0 && (u(), a(), document.addEventListener("mouseup", () => u(), {
          once: !0
        }), l = setTimeout(() => {
          s = setInterval(() => {
            a();
          }, o);
        }, r));
      });
    }
  }, Kf = "_trap-focus-children", ps = [], ry = (e) => {
    var t;
    if (ps.length === 0)
      return;
    const n = ps[ps.length - 1][Kf];
    if (n.length > 0 && e.code === We.tab) {
      if (n.length === 1) {
        e.preventDefault(), document.activeElement !== n[0] && n[0].focus();
        return;
      }
      const o = e.shiftKey, r = e.target === n[0], s = e.target === n[n.length - 1];
      if (r && o && (e.preventDefault(), n[n.length - 1].focus()), s && !o && (e.preventDefault(), n[0].focus()), process.env.NODE_ENV === "test") {
        const l = n.indexOf(e.target);
        l !== -1 && ((t = n[o ? l - 1 : l + 1]) == null || t.focus());
      }
    }
  }, gF = {
    beforeMount(e) {
      e[Kf] = Cm(e), ps.push(e), ps.length <= 1 && document.addEventListener("keydown", ry);
    },
    updated(e) {
      Fe(() => {
        e[Kf] = Cm(e);
      });
    },
    unmounted() {
      ps.shift(), ps.length === 0 && document.removeEventListener("keydown", ry);
    }
  };
  var sy = !1, is, jf, Wf, fu, pu, SC, hu, Uf, qf, Yf, _C, Gf, Xf, kC, $C;
  function Pn() {
    if (!sy) {
      sy = !0;
      var e = navigator.userAgent, t = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), n = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
      if (Gf = /\b(iPhone|iP[ao]d)/.exec(e), Xf = /\b(iP[ao]d)/.exec(e), Yf = /Android/i.exec(e), kC = /FBAN\/\w+;/i.exec(e), $C = /Mobile/i.exec(e), _C = !!/Win64/.exec(e), t) {
        is = t[1] ? parseFloat(t[1]) : t[5] ? parseFloat(t[5]) : NaN, is && document && document.documentMode && (is = document.documentMode);
        var o = /(?:Trident\/(\d+.\d+))/.exec(e);
        SC = o ? parseFloat(o[1]) + 4 : is, jf = t[2] ? parseFloat(t[2]) : NaN, Wf = t[3] ? parseFloat(t[3]) : NaN, fu = t[4] ? parseFloat(t[4]) : NaN, fu ? (t = /(?:Chrome\/(\d+\.\d+))/.exec(e), pu = t && t[1] ? parseFloat(t[1]) : NaN) : pu = NaN;
      } else
        is = jf = Wf = pu = fu = NaN;
      if (n) {
        if (n[1]) {
          var r = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
          hu = r ? parseFloat(r[1].replace("_", ".")) : !0;
        } else
          hu = !1;
        Uf = !!n[2], qf = !!n[3];
      } else
        hu = Uf = qf = !1;
    }
  }
  var Jf = { ie: function() {
    return Pn() || is;
  }, ieCompatibilityMode: function() {
    return Pn() || SC > is;
  }, ie64: function() {
    return Jf.ie() && _C;
  }, firefox: function() {
    return Pn() || jf;
  }, opera: function() {
    return Pn() || Wf;
  }, webkit: function() {
    return Pn() || fu;
  }, safari: function() {
    return Jf.webkit();
  }, chrome: function() {
    return Pn() || pu;
  }, windows: function() {
    return Pn() || Uf;
  }, osx: function() {
    return Pn() || hu;
  }, linux: function() {
    return Pn() || qf;
  }, iphone: function() {
    return Pn() || Gf;
  }, mobile: function() {
    return Pn() || Gf || Xf || Yf || $C;
  }, nativeApp: function() {
    return Pn() || kC;
  }, android: function() {
    return Pn() || Yf;
  }, ipad: function() {
    return Pn() || Xf;
  } }, yF = Jf, Yi = !!(typeof window < "u" && window.document && window.document.createElement), bF = { canUseDOM: Yi, canUseWorkers: typeof Worker < "u", canUseEventListeners: Yi && !!(window.addEventListener || window.attachEvent), canUseViewport: Yi && !!window.screen, isInWorker: !Yi }, NC = bF, TC;
  NC.canUseDOM && (TC = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
  function wF(e, t) {
    if (!NC.canUseDOM || t && !("addEventListener" in document))
      return !1;
    var n = "on" + e, o = n in document;
    if (!o) {
      var r = document.createElement("div");
      r.setAttribute(n, "return;"), o = typeof r[n] == "function";
    }
    return !o && TC && e === "wheel" && (o = document.implementation.hasFeature("Events.wheel", "3.0")), o;
  }
  var CF = wF, ly = 10, ay = 40, iy = 800;
  function OC(e) {
    var t = 0, n = 0, o = 0, r = 0;
    return "detail" in e && (n = e.detail), "wheelDelta" in e && (n = -e.wheelDelta / 120), "wheelDeltaY" in e && (n = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = n, n = 0), o = t * ly, r = n * ly, "deltaY" in e && (r = e.deltaY), "deltaX" in e && (o = e.deltaX), (o || r) && e.deltaMode && (e.deltaMode == 1 ? (o *= ay, r *= ay) : (o *= iy, r *= iy)), o && !t && (t = o < 1 ? -1 : 1), r && !n && (n = r < 1 ? -1 : 1), { spinX: t, spinY: n, pixelX: o, pixelY: r };
  }
  OC.getEventType = function() {
    return yF.firefox() ? "DOMMouseScroll" : CF("wheel") ? "wheel" : "mousewheel";
  };
  var EF = OC;
  /**
  * Checks if an event is supported in the current execution environment.
  *
  * NOTE: This will not work correctly for non-generic events such as `change`,
  * `reset`, `load`, `error`, and `select`.
  *
  * Borrows from Modernizr.
  *
  * @param {string} eventNameSuffix Event name, e.g. "click".
  * @param {?boolean} capture Check if the capture phase is supported.
  * @return {boolean} True if the event is supported.
  * @internal
  * @license Modernizr 3.0.0pre (Custom Build) | MIT
  */
  const SF = function(e, t) {
    if (e && e.addEventListener) {
      const n = function(o) {
        const r = EF(o);
        t && Reflect.apply(t, this, [o, r]);
      };
      e.addEventListener("wheel", n, { passive: !0 });
    }
  }, _F = {
    beforeMount(e, t) {
      SF(e, t.value);
    }
  }, kF = Ie({
    role: {
      type: String,
      required: !0
    },
    spinnerDate: {
      type: le(Object),
      required: !0
    },
    showSeconds: {
      type: Boolean,
      default: !0
    },
    arrowControl: Boolean,
    amPmMode: {
      type: le(String),
      default: ""
    },
    ...mC
  }), $F = ["onClick"], NF = ["onMouseenter"], TF = /* @__PURE__ */ G({
    __name: "basic-time-spinner",
    props: kF,
    emits: ["change", "select-range", "set-option"],
    setup(e, { emit: t }) {
      const n = e, o = ge("time"), { getHoursList: r, getMinutesList: s, getSecondsList: l } = wC(n.disabledHours, n.disabledMinutes, n.disabledSeconds);
      let a = !1;
      const u = I(), c = I(), f = I(), d = I(), p = {
        hours: c,
        minutes: f,
        seconds: d
      }, h = E(() => n.showSeconds ? Jg : Jg.slice(0, 2)), m = E(() => {
        const { spinnerDate: M } = n, j = M.hour(), te = M.minute(), U = M.second();
        return { hours: j, minutes: te, seconds: U };
      }), v = E(() => {
        const { hours: M, minutes: j } = i(m);
        return {
          hours: r(n.role),
          minutes: s(M, n.role),
          seconds: l(M, j, n.role)
        };
      }), g = E(() => {
        const { hours: M, minutes: j, seconds: te } = i(m);
        return {
          hours: Ad(M, 23),
          minutes: Ad(j, 59),
          seconds: Ad(te, 59)
        };
      }), y = On((M) => {
        a = !1, C(M);
      }, 200), w = (M) => {
        if (!!!n.amPmMode)
          return "";
        const te = n.amPmMode === "A";
        let U = M < 12 ? " am" : " pm";
        return te && (U = U.toUpperCase()), U;
      }, b = (M) => {
        let j;
        switch (M) {
          case "hours":
            j = [0, 2];
            break;
          case "minutes":
            j = [3, 5];
            break;
          case "seconds":
            j = [6, 8];
            break;
        }
        const [te, U] = j;
        t("select-range", te, U), u.value = M;
      }, C = (M) => {
        O(M, i(m)[M]);
      }, _ = () => {
        C("hours"), C("minutes"), C("seconds");
      }, k = (M) => M.querySelector(`.${o.namespace.value}-scrollbar__wrap`), O = (M, j) => {
        if (n.arrowControl)
          return;
        const te = i(p[M]);
        te && te.$el && (k(te.$el).scrollTop = Math.max(0, j * T(M)));
      }, T = (M) => {
        const j = i(p[M]);
        return (j == null ? void 0 : j.$el.querySelector("li").offsetHeight) || 0;
      }, P = () => {
        L(1);
      }, A = () => {
        L(-1);
      }, L = (M) => {
        u.value || b("hours");
        const j = u.value, te = i(m)[j], U = u.value === "hours" ? 24 : 60, Z = D(j, te, M, U);
        B(j, Z), O(j, Z), Fe(() => b(j));
      }, D = (M, j, te, U) => {
        let Z = (j + te + U) % U;
        const pe = i(v)[M];
        for (; pe[Z] && Z !== j; )
          Z = (Z + te + U) % U;
        return Z;
      }, B = (M, j) => {
        if (i(v)[M][j])
          return;
        const { hours: Z, minutes: pe, seconds: J } = i(m);
        let ee;
        switch (M) {
          case "hours":
            ee = n.spinnerDate.hour(j).minute(pe).second(J);
            break;
          case "minutes":
            ee = n.spinnerDate.hour(Z).minute(j).second(J);
            break;
          case "seconds":
            ee = n.spinnerDate.hour(Z).minute(pe).second(j);
            break;
        }
        t("change", ee);
      }, F = (M, { value: j, disabled: te }) => {
        te || (B(M, j), b(M), O(M, j));
      }, W = (M) => {
        a = !0, y(M);
        const j = Math.min(Math.round((k(i(p[M]).$el).scrollTop - (x(M) * 0.5 - 10) / T(M) + 3) / T(M)), M === "hours" ? 23 : 59);
        B(M, j);
      }, x = (M) => i(p[M]).$el.offsetHeight, N = () => {
        const M = (j) => {
          const te = i(p[j]);
          te && te.$el && (k(te.$el).onscroll = () => {
            W(j);
          });
        };
        M("hours"), M("minutes"), M("seconds");
      };
      st(() => {
        Fe(() => {
          !n.arrowControl && N(), _(), n.role === "start" && b("hours");
        });
      });
      const R = (M, j) => {
        p[j].value = M;
      };
      return t("set-option", [`${n.role}_scrollDown`, L]), t("set-option", [`${n.role}_emitSelectRange`, b]), me(() => n.spinnerDate, () => {
        a || _();
      }), (M, j) => (S(), V("div", {
        class: $([i(o).b("spinner"), { "has-seconds": M.showSeconds }])
      }, [
        M.arrowControl ? se("v-if", !0) : (S(!0), V(ze, { key: 0 }, gt(i(h), (te) => (S(), ie(i(pr), {
          key: te,
          ref_for: !0,
          ref: (U) => R(U, te),
          class: $(i(o).be("spinner", "wrapper")),
          "wrap-style": "max-height: inherit;",
          "view-class": i(o).be("spinner", "list"),
          noresize: "",
          tag: "ul",
          onMouseenter: (U) => b(te),
          onMousemove: (U) => C(te)
        }, {
          default: X(() => [
            (S(!0), V(ze, null, gt(i(v)[te], (U, Z) => (S(), V("li", {
              key: Z,
              class: $([
                i(o).be("spinner", "item"),
                i(o).is("active", Z === i(m)[te]),
                i(o).is("disabled", U)
              ]),
              onClick: (pe) => F(te, { value: Z, disabled: U })
            }, [
              te === "hours" ? (S(), V(ze, { key: 0 }, [
                wt(Ne(("0" + (M.amPmMode ? Z % 12 || 12 : Z)).slice(-2)) + Ne(w(Z)), 1)
              ], 64)) : (S(), V(ze, { key: 1 }, [
                wt(Ne(("0" + Z).slice(-2)), 1)
              ], 64))
            ], 10, $F))), 128))
          ]),
          _: 2
        }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]))), 128)),
        M.arrowControl ? (S(!0), V(ze, { key: 1 }, gt(i(h), (te) => (S(), V("div", {
          key: te,
          class: $([i(o).be("spinner", "wrapper"), i(o).is("arrow")]),
          onMouseenter: (U) => b(te)
        }, [
          ot((S(), ie(i(He), {
            class: $(["arrow-up", i(o).be("spinner", "arrow")])
          }, {
            default: X(() => [
              K(i(Bc))
            ]),
            _: 1
          }, 8, ["class"])), [
            [i(tc), A]
          ]),
          ot((S(), ie(i(He), {
            class: $(["arrow-down", i(o).be("spinner", "arrow")])
          }, {
            default: X(() => [
              K(i(qr))
            ]),
            _: 1
          }, 8, ["class"])), [
            [i(tc), P]
          ]),
          H("ul", {
            class: $(i(o).be("spinner", "list"))
          }, [
            (S(!0), V(ze, null, gt(i(g)[te], (U, Z) => (S(), V("li", {
              key: Z,
              class: $([
                i(o).be("spinner", "item"),
                i(o).is("active", U === i(m)[te]),
                i(o).is("disabled", i(v)[te][U])
              ])
            }, [
              typeof U == "number" ? (S(), V(ze, { key: 0 }, [
                te === "hours" ? (S(), V(ze, { key: 0 }, [
                  wt(Ne(("0" + (M.amPmMode ? U % 12 || 12 : U)).slice(-2)) + Ne(w(U)), 1)
                ], 64)) : (S(), V(ze, { key: 1 }, [
                  wt(Ne(("0" + U).slice(-2)), 1)
                ], 64))
              ], 64)) : se("v-if", !0)
            ], 2))), 128))
          ], 2)
        ], 42, NF))), 128)) : se("v-if", !0)
      ], 2));
    }
  });
  var Zf = /* @__PURE__ */ Me(TF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/basic-time-spinner.vue"]]);
  const OF = /* @__PURE__ */ G({
    __name: "panel-time-pick",
    props: hF,
    emits: ["pick", "select-range", "set-picker-option"],
    setup(e, { emit: t }) {
      const n = e, o = Be("EP_PICKER_BASE"), {
        arrowControl: r,
        disabledHours: s,
        disabledMinutes: l,
        disabledSeconds: a,
        defaultValue: u
      } = o.props, { getAvailableHours: c, getAvailableMinutes: f, getAvailableSeconds: d } = CC(s, l, a), p = ge("time"), { t: h, lang: m } = St(), v = I([0, 2]), g = EC(n), y = E(() => pn(n.actualVisible) ? `${p.namespace.value}-zoom-in-top` : ""), w = E(() => n.format.includes("ss")), b = E(() => n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""), C = (R) => {
        const M = at(R).locale(m.value), j = F(M);
        return M.isSame(j);
      }, _ = () => {
        t("pick", g.value, !1);
      }, k = (R = !1, M = !1) => {
        M || t("pick", n.parsedValue, R);
      }, O = (R) => {
        if (!n.visible)
          return;
        const M = F(R).millisecond(0);
        t("pick", M, !0);
      }, T = (R, M) => {
        t("select-range", R, M), v.value = [R, M];
      }, P = (R) => {
        const M = [0, 3].concat(w.value ? [6] : []), j = ["hours", "minutes"].concat(w.value ? ["seconds"] : []), U = (M.indexOf(v.value[0]) + R + M.length) % M.length;
        L.start_emitSelectRange(j[U]);
      }, A = (R) => {
        const M = R.code, { left: j, right: te, up: U, down: Z } = We;
        if ([j, te].includes(M)) {
          P(M === j ? -1 : 1), R.preventDefault();
          return;
        }
        if ([U, Z].includes(M)) {
          const pe = M === U ? -1 : 1;
          L.start_scrollDown(pe), R.preventDefault();
          return;
        }
      }, { timePickerOptions: L, onSetOption: D, getAvailableTime: B } = bC({
        getAvailableHours: c,
        getAvailableMinutes: f,
        getAvailableSeconds: d
      }), F = (R) => B(R, n.datetimeRole || "", !0), W = (R) => R ? at(R, n.format).locale(m.value) : null, x = (R) => R ? R.format(n.format) : null, N = () => at(u).locale(m.value);
      return t("set-picker-option", ["isValidValue", C]), t("set-picker-option", ["formatToString", x]), t("set-picker-option", ["parseUserInput", W]), t("set-picker-option", ["handleKeydownInput", A]), t("set-picker-option", ["getRangeAvailableTime", F]), t("set-picker-option", ["getDefaultValue", N]), (R, M) => (S(), ie(Qt, { name: i(y) }, {
        default: X(() => [
          R.actualVisible || R.visible ? (S(), V("div", {
            key: 0,
            class: $(i(p).b("panel"))
          }, [
            H("div", {
              class: $([i(p).be("panel", "content"), { "has-seconds": i(w) }])
            }, [
              K(Zf, {
                ref: "spinner",
                role: R.datetimeRole || "start",
                "arrow-control": i(r),
                "show-seconds": i(w),
                "am-pm-mode": i(b),
                "spinner-date": R.parsedValue,
                "disabled-hours": i(s),
                "disabled-minutes": i(l),
                "disabled-seconds": i(a),
                onChange: O,
                onSetOption: i(D),
                onSelectRange: T
              }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])
            ], 2),
            H("div", {
              class: $(i(p).be("panel", "footer"))
            }, [
              H("button", {
                type: "button",
                class: $([i(p).be("panel", "btn"), "cancel"]),
                onClick: _
              }, Ne(i(h)("el.datepicker.cancel")), 3),
              H("button", {
                type: "button",
                class: $([i(p).be("panel", "btn"), "confirm"]),
                onClick: M[0] || (M[0] = (j) => k())
              }, Ne(i(h)("el.datepicker.confirm")), 3)
            ], 2)
          ], 2)) : se("v-if", !0)
        ]),
        _: 1
      }, 8, ["name"]));
    }
  });
  var nc = /* @__PURE__ */ Me(OF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-pick.vue"]]);
  const MF = Ie({
    ...gC,
    parsedValue: {
      type: le(Array)
    }
  }), IF = ["disabled"], PF = /* @__PURE__ */ G({
    __name: "panel-time-range",
    props: MF,
    emits: ["pick", "select-range", "set-picker-option"],
    setup(e, { emit: t }) {
      const n = e, o = (re, ce) => {
        const Te = [];
        for (let Pe = re; Pe <= ce; Pe++)
          Te.push(Pe);
        return Te;
      }, { t: r, lang: s } = St(), l = ge("time"), a = ge("picker"), u = Be("EP_PICKER_BASE"), {
        arrowControl: c,
        disabledHours: f,
        disabledMinutes: d,
        disabledSeconds: p,
        defaultValue: h
      } = u.props, m = E(() => n.parsedValue[0]), v = E(() => n.parsedValue[1]), g = EC(n), y = () => {
        t("pick", g.value, !1);
      }, w = E(() => n.format.includes("ss")), b = E(() => n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""), C = (re = !1) => {
        t("pick", [m.value, v.value], re);
      }, _ = (re) => {
        T(re.millisecond(0), v.value);
      }, k = (re) => {
        T(m.value, re.millisecond(0));
      }, O = (re) => {
        const ce = re.map((Pe) => at(Pe).locale(s.value)), Te = M(ce);
        return ce[0].isSame(Te[0]) && ce[1].isSame(Te[1]);
      }, T = (re, ce) => {
        t("pick", [re, ce], !0);
      }, P = E(() => m.value > v.value), A = I([0, 2]), L = (re, ce) => {
        t("select-range", re, ce, "min"), A.value = [re, ce];
      }, D = E(() => w.value ? 11 : 8), B = (re, ce) => {
        t("select-range", re, ce, "max");
        const Te = i(D);
        A.value = [re + Te, ce + Te];
      }, F = (re) => {
        const ce = w.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11], Te = ["hours", "minutes"].concat(w.value ? ["seconds"] : []), z = (ce.indexOf(A.value[0]) + re + ce.length) % ce.length, Q = ce.length / 2;
        z < Q ? Z.start_emitSelectRange(Te[z]) : Z.end_emitSelectRange(Te[z - Q]);
      }, W = (re) => {
        const ce = re.code, { left: Te, right: Pe, up: z, down: Q } = We;
        if ([Te, Pe].includes(ce)) {
          F(ce === Te ? -1 : 1), re.preventDefault();
          return;
        }
        if ([z, Q].includes(ce)) {
          const de = ce === z ? -1 : 1, Oe = A.value[0] < D.value ? "start" : "end";
          Z[`${Oe}_scrollDown`](de), re.preventDefault();
          return;
        }
      }, x = (re, ce) => {
        const Te = f ? f(re) : [], Pe = re === "start", Q = (ce || (Pe ? v.value : m.value)).hour(), de = Pe ? o(Q + 1, 23) : o(0, Q - 1);
        return _d(Te, de);
      }, N = (re, ce, Te) => {
        const Pe = d ? d(re, ce) : [], z = ce === "start", Q = Te || (z ? v.value : m.value), de = Q.hour();
        if (re !== de)
          return Pe;
        const Oe = Q.minute(), ae = z ? o(Oe + 1, 59) : o(0, Oe - 1);
        return _d(Pe, ae);
      }, R = (re, ce, Te, Pe) => {
        const z = p ? p(re, ce, Te) : [], Q = Te === "start", de = Pe || (Q ? v.value : m.value), Oe = de.hour(), ae = de.minute();
        if (re !== Oe || ce !== ae)
          return z;
        const Ee = de.second(), we = Q ? o(Ee + 1, 59) : o(0, Ee - 1);
        return _d(z, we);
      }, M = ([re, ce]) => [
        pe(re, "start", !0, ce),
        pe(ce, "end", !1, re)
      ], { getAvailableHours: j, getAvailableMinutes: te, getAvailableSeconds: U } = CC(x, N, R), {
        timePickerOptions: Z,
        getAvailableTime: pe,
        onSetOption: J
      } = bC({
        getAvailableHours: j,
        getAvailableMinutes: te,
        getAvailableSeconds: U
      }), ee = (re) => re ? De(re) ? re.map((ce) => at(ce, n.format).locale(s.value)) : at(re, n.format).locale(s.value) : null, ne = (re) => re ? De(re) ? re.map((ce) => ce.format(n.format)) : re.format(n.format) : null, Y = () => {
        if (De(h))
          return h.map((ce) => at(ce).locale(s.value));
        const re = at(h).locale(s.value);
        return [re, re.add(60, "m")];
      };
      return t("set-picker-option", ["formatToString", ne]), t("set-picker-option", ["parseUserInput", ee]), t("set-picker-option", ["isValidValue", O]), t("set-picker-option", ["handleKeydownInput", W]), t("set-picker-option", ["getDefaultValue", Y]), t("set-picker-option", ["getRangeAvailableTime", M]), (re, ce) => re.actualVisible ? (S(), V("div", {
        key: 0,
        class: $([i(l).b("range-picker"), i(a).b("panel")])
      }, [
        H("div", {
          class: $(i(l).be("range-picker", "content"))
        }, [
          H("div", {
            class: $(i(l).be("range-picker", "cell"))
          }, [
            H("div", {
              class: $(i(l).be("range-picker", "header"))
            }, Ne(i(r)("el.datepicker.startTime")), 3),
            H("div", {
              class: $([
                i(l).be("range-picker", "body"),
                i(l).be("panel", "content"),
                i(l).is("arrow", i(c)),
                { "has-seconds": i(w) }
              ])
            }, [
              K(Zf, {
                ref: "minSpinner",
                role: "start",
                "show-seconds": i(w),
                "am-pm-mode": i(b),
                "arrow-control": i(c),
                "spinner-date": i(m),
                "disabled-hours": x,
                "disabled-minutes": N,
                "disabled-seconds": R,
                onChange: _,
                onSetOption: i(J),
                onSelectRange: L
              }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
            ], 2)
          ], 2),
          H("div", {
            class: $(i(l).be("range-picker", "cell"))
          }, [
            H("div", {
              class: $(i(l).be("range-picker", "header"))
            }, Ne(i(r)("el.datepicker.endTime")), 3),
            H("div", {
              class: $([
                i(l).be("range-picker", "body"),
                i(l).be("panel", "content"),
                i(l).is("arrow", i(c)),
                { "has-seconds": i(w) }
              ])
            }, [
              K(Zf, {
                ref: "maxSpinner",
                role: "end",
                "show-seconds": i(w),
                "am-pm-mode": i(b),
                "arrow-control": i(c),
                "spinner-date": i(v),
                "disabled-hours": x,
                "disabled-minutes": N,
                "disabled-seconds": R,
                onChange: k,
                onSetOption: i(J),
                onSelectRange: B
              }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
            ], 2)
          ], 2)
        ], 2),
        H("div", {
          class: $(i(l).be("panel", "footer"))
        }, [
          H("button", {
            type: "button",
            class: $([i(l).be("panel", "btn"), "cancel"]),
            onClick: ce[0] || (ce[0] = (Te) => y())
          }, Ne(i(r)("el.datepicker.cancel")), 3),
          H("button", {
            type: "button",
            class: $([i(l).be("panel", "btn"), "confirm"]),
            disabled: i(P),
            onClick: ce[1] || (ce[1] = (Te) => C())
          }, Ne(i(r)("el.datepicker.confirm")), 11, IF)
        ], 2)
      ], 2)) : se("v-if", !0);
    }
  });
  var AF = /* @__PURE__ */ Me(PF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-range.vue"]]);
  at.extend(Uh);
  var RF = G({
    name: "ElTimePicker",
    install: null,
    props: {
      ...qh,
      isRange: {
        type: Boolean,
        default: !1
      }
    },
    emits: ["update:modelValue"],
    setup(e, t) {
      const n = I(), [o, r] = e.isRange ? ["timerange", AF] : ["time", nc], s = (l) => t.emit("update:modelValue", l);
      return pt("ElPopperOptions", e.popperOptions), t.expose({
        focus: (l) => {
          var a;
          (a = n.value) == null || a.handleFocusInput(l);
        },
        blur: (l) => {
          var a;
          (a = n.value) == null || a.handleBlurInput(l);
        },
        handleOpen: () => {
          var l;
          (l = n.value) == null || l.handleOpen();
        },
        handleClose: () => {
          var l;
          (l = n.value) == null || l.handleClose();
        }
      }), () => {
        var l;
        const a = (l = e.format) != null ? l : zf;
        return K(yC, ft(e, {
          ref: n,
          type: o,
          format: a,
          "onUpdate:modelValue": s
        }), {
          default: (u) => K(r, u, null)
        });
      };
    }
  });
  const vu = RF;
  vu.install = (e) => {
    e.component(vu.name, vu);
  };
  const xF = vu, DF = (e, t) => {
    const n = e.subtract(1, "month").endOf("month").date();
    return Rr(t).map((o, r) => n - (t - r - 1));
  }, LF = (e) => {
    const t = e.daysInMonth();
    return Rr(t).map((n, o) => o + 1);
  }, VF = (e) => Rr(e.length / 7).map((t) => {
    const n = t * 7;
    return e.slice(n, n + 7);
  }), BF = Ie({
    selectedDay: {
      type: le(Object)
    },
    range: {
      type: le(Array)
    },
    date: {
      type: le(Object),
      required: !0
    },
    hideHeader: {
      type: Boolean
    }
  }), FF = {
    pick: (e) => rt(e)
  };
  var MC = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(hr, function() {
      return function(n, o, r) {
        var s = o.prototype, l = function(d) {
          return d && (d.indexOf ? d : d.s);
        }, a = function(d, p, h, m, v) {
          var g = d.name ? d : d.$locale(), y = l(g[p]), w = l(g[h]), b = y || w.map(function(_) {
            return _.slice(0, m);
          });
          if (!v)
            return b;
          var C = g.weekStart;
          return b.map(function(_, k) {
            return b[(k + (C || 0)) % 7];
          });
        }, u = function() {
          return r.Ls[r.locale()];
        }, c = function(d, p) {
          return d.formats[p] || function(h) {
            return h.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(m, v, g) {
              return v || g.slice(1);
            });
          }(d.formats[p.toUpperCase()]);
        }, f = function() {
          var d = this;
          return { months: function(p) {
            return p ? p.format("MMMM") : a(d, "months");
          }, monthsShort: function(p) {
            return p ? p.format("MMM") : a(d, "monthsShort", "months", 3);
          }, firstDayOfWeek: function() {
            return d.$locale().weekStart || 0;
          }, weekdays: function(p) {
            return p ? p.format("dddd") : a(d, "weekdays");
          }, weekdaysMin: function(p) {
            return p ? p.format("dd") : a(d, "weekdaysMin", "weekdays", 2);
          }, weekdaysShort: function(p) {
            return p ? p.format("ddd") : a(d, "weekdaysShort", "weekdays", 3);
          }, longDateFormat: function(p) {
            return c(d.$locale(), p);
          }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
        };
        s.localeData = function() {
          return f.bind(this)();
        }, r.localeData = function() {
          var d = u();
          return { firstDayOfWeek: function() {
            return d.weekStart || 0;
          }, weekdays: function() {
            return r.weekdays();
          }, weekdaysShort: function() {
            return r.weekdaysShort();
          }, weekdaysMin: function() {
            return r.weekdaysMin();
          }, months: function() {
            return r.months();
          }, monthsShort: function() {
            return r.monthsShort();
          }, longDateFormat: function(p) {
            return c(d, p);
          }, meridiem: d.meridiem, ordinal: d.ordinal };
        }, r.months = function() {
          return a(u(), "months");
        }, r.monthsShort = function() {
          return a(u(), "monthsShort", "months", 3);
        }, r.weekdays = function(d) {
          return a(u(), "weekdays", null, null, d);
        }, r.weekdaysShort = function(d) {
          return a(u(), "weekdaysShort", "weekdays", 3, d);
        }, r.weekdaysMin = function(d) {
          return a(u(), "weekdaysMin", "weekdays", 2, d);
        };
      };
    });
  })(MC);
  const IC = MC.exports, HF = (e, t) => {
    at.extend(IC);
    const n = at.localeData().firstDayOfWeek(), { t: o, lang: r } = St(), s = at().locale(r.value), l = E(() => !!e.range && !!e.range.length), a = E(() => {
      let p = [];
      if (l.value) {
        const [h, m] = e.range, v = Rr(m.date() - h.date() + 1).map((w) => ({
          text: h.date() + w,
          type: "current"
        }));
        let g = v.length % 7;
        g = g === 0 ? 0 : 7 - g;
        const y = Rr(g).map((w, b) => ({
          text: b + 1,
          type: "next"
        }));
        p = v.concat(y);
      } else {
        const h = e.date.startOf("month").day(), m = DF(e.date, (h - n + 7) % 7).map((w) => ({
          text: w,
          type: "prev"
        })), v = LF(e.date).map((w) => ({
          text: w,
          type: "current"
        }));
        p = [...m, ...v];
        const g = 7 - (p.length % 7 || 7), y = Rr(g).map((w, b) => ({
          text: b + 1,
          type: "next"
        }));
        p = p.concat(y);
      }
      return VF(p);
    }), u = E(() => {
      const p = n;
      return p === 0 ? kd.map((h) => o(`el.datepicker.weeks.${h}`)) : kd.slice(p).concat(kd.slice(0, p)).map((h) => o(`el.datepicker.weeks.${h}`));
    }), c = (p, h) => {
      switch (h) {
        case "prev":
          return e.date.startOf("month").subtract(1, "month").date(p);
        case "next":
          return e.date.startOf("month").add(1, "month").date(p);
        case "current":
          return e.date.date(p);
      }
    };
    return {
      now: s,
      isInRange: l,
      rows: a,
      weekDays: u,
      getFormattedDate: c,
      handlePickDay: ({ text: p, type: h }) => {
        const m = c(p, h);
        t("pick", m);
      },
      getSlotData: ({ text: p, type: h }) => {
        const m = c(p, h);
        return {
          isSelected: m.isSame(e.selectedDay),
          type: `${h}-month`,
          day: m.format("YYYY-MM-DD"),
          date: m.toDate()
        };
      }
    };
  }, zF = { key: 0 }, KF = ["onClick"], jF = G({
    name: "DateTable"
  }), WF = /* @__PURE__ */ G({
    ...jF,
    props: BF,
    emits: FF,
    setup(e, { expose: t, emit: n }) {
      const o = e, {
        isInRange: r,
        now: s,
        rows: l,
        weekDays: a,
        getFormattedDate: u,
        handlePickDay: c,
        getSlotData: f
      } = HF(o, n), d = ge("calendar-table"), p = ge("calendar-day"), h = ({ text: m, type: v }) => {
        const g = [v];
        if (v === "current") {
          const y = u(m, v);
          y.isSame(o.selectedDay, "day") && g.push(p.is("selected")), y.isSame(s, "day") && g.push(p.is("today"));
        }
        return g;
      };
      return t({
        getFormattedDate: u
      }), (m, v) => (S(), V("table", {
        class: $([i(d).b(), i(d).is("range", i(r))]),
        cellspacing: "0",
        cellpadding: "0"
      }, [
        m.hideHeader ? se("v-if", !0) : (S(), V("thead", zF, [
          (S(!0), V(ze, null, gt(i(a), (g) => (S(), V("th", { key: g }, Ne(g), 1))), 128))
        ])),
        H("tbody", null, [
          (S(!0), V(ze, null, gt(i(l), (g, y) => (S(), V("tr", {
            key: y,
            class: $({
              [i(d).e("row")]: !0,
              [i(d).em("row", "hide-border")]: y === 0 && m.hideHeader
            })
          }, [
            (S(!0), V(ze, null, gt(g, (w, b) => (S(), V("td", {
              key: b,
              class: $(h(w)),
              onClick: (C) => i(c)(w)
            }, [
              H("div", {
                class: $(i(p).b())
              }, [
                he(m.$slots, "date-cell", {
                  data: i(f)(w)
                }, () => [
                  H("span", null, Ne(w.text), 1)
                ])
              ], 2)
            ], 10, KF))), 128))
          ], 2))), 128))
        ])
      ], 2));
    }
  });
  var uy = /* @__PURE__ */ Me(WF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/date-table.vue"]]);
  const UF = (e, t) => {
    const n = e.endOf("month"), o = t.startOf("month"), s = n.isSame(o, "week") ? o.add(1, "week") : o;
    return [
      [e, n],
      [s.startOf("week"), t]
    ];
  }, qF = (e, t) => {
    const n = e.endOf("month"), o = e.add(1, "month").startOf("month"), r = n.isSame(o, "week") ? o.add(1, "week") : o, s = r.endOf("month"), l = t.startOf("month"), a = s.isSame(l, "week") ? l.add(1, "week") : l;
    return [
      [e, n],
      [r.startOf("week"), s],
      [a.startOf("week"), t]
    ];
  }, YF = (e, t, n) => {
    const o = hn(), { lang: r } = St(), s = I(), l = at().locale(r.value), a = E({
      get() {
        return e.modelValue ? c.value : s.value;
      },
      set(y) {
        if (!y)
          return;
        s.value = y;
        const w = y.toDate();
        t($n, w), t(dt, w);
      }
    }), u = E(() => {
      if (!e.range)
        return [];
      const y = e.range.map((C) => at(C).locale(r.value)), [w, b] = y;
      return w.isAfter(b) ? (yt(n, "end time should be greater than start time"), []) : w.isSame(b, "month") ? m(w, b) : w.add(1, "month").month() !== b.month() ? (yt(n, "start time and end time interval must not exceed two months"), []) : m(w, b);
    }), c = E(() => e.modelValue ? at(e.modelValue).locale(r.value) : a.value || (u.value.length ? u.value[0][0] : l)), f = E(() => c.value.subtract(1, "month").date(1)), d = E(() => c.value.add(1, "month").date(1)), p = E(() => c.value.subtract(1, "year").date(1)), h = E(() => c.value.add(1, "year").date(1)), m = (y, w) => {
      const b = y.startOf("week"), C = w.endOf("week"), _ = b.get("month"), k = C.get("month");
      return _ === k ? [[b, C]] : (_ + 1) % 12 === k ? UF(b, C) : _ + 2 === k || (_ + 1) % 11 === k ? qF(b, C) : (yt(n, "start time and end time interval must not exceed two months"), []);
    }, v = (y) => {
      a.value = y;
    }, g = (y) => {
      const b = {
        "prev-month": f.value,
        "next-month": d.value,
        "prev-year": p.value,
        "next-year": h.value,
        today: l
      }[y];
      b.isSame(c.value, "day") || v(b);
    };
    return Vo({
      from: '"dateCell"',
      replacement: '"date-cell"',
      scope: "ElCalendar",
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/calendar.html#slots",
      type: "Slot"
    }, E(() => !!o.dateCell)), {
      calculateValidatedDateRange: m,
      date: c,
      realSelectedDay: a,
      pickDay: v,
      selectDate: g,
      validatedRange: u
    };
  }, GF = (e) => De(e) && e.length === 2 && e.every((t) => Ns(t)), XF = Ie({
    modelValue: {
      type: Date
    },
    range: {
      type: le(Array),
      validator: GF
    }
  }), JF = {
    [dt]: (e) => Ns(e),
    [$n]: (e) => Ns(e)
  }, PC = "ElCalendar", ZF = G({
    name: PC
  }), QF = /* @__PURE__ */ G({
    ...ZF,
    props: XF,
    emits: JF,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = ge("calendar"), {
        calculateValidatedDateRange: s,
        date: l,
        pickDay: a,
        realSelectedDay: u,
        selectDate: c,
        validatedRange: f
      } = YF(o, n, PC), { t: d } = St(), p = E(() => {
        const h = `el.datepicker.month${l.value.format("M")}`;
        return `${l.value.year()} ${d("el.datepicker.year")} ${d(h)}`;
      });
      return t({
        selectedDay: u,
        pickDay: a,
        selectDate: c,
        calculateValidatedDateRange: s
      }), (h, m) => (S(), V("div", {
        class: $(i(r).b())
      }, [
        H("div", {
          class: $(i(r).e("header"))
        }, [
          he(h.$slots, "header", { date: i(p) }, () => [
            H("div", {
              class: $(i(r).e("title"))
            }, Ne(i(p)), 3),
            i(f).length === 0 ? (S(), V("div", {
              key: 0,
              class: $(i(r).e("button-group"))
            }, [
              K(i(dC), null, {
                default: X(() => [
                  K(i(gn), {
                    size: "small",
                    onClick: m[0] || (m[0] = (v) => i(c)("prev-month"))
                  }, {
                    default: X(() => [
                      wt(Ne(i(d)("el.datepicker.prevMonth")), 1)
                    ]),
                    _: 1
                  }),
                  K(i(gn), {
                    size: "small",
                    onClick: m[1] || (m[1] = (v) => i(c)("today"))
                  }, {
                    default: X(() => [
                      wt(Ne(i(d)("el.datepicker.today")), 1)
                    ]),
                    _: 1
                  }),
                  K(i(gn), {
                    size: "small",
                    onClick: m[2] || (m[2] = (v) => i(c)("next-month"))
                  }, {
                    default: X(() => [
                      wt(Ne(i(d)("el.datepicker.nextMonth")), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ], 2)) : se("v-if", !0)
          ])
        ], 2),
        i(f).length === 0 ? (S(), V("div", {
          key: 0,
          class: $(i(r).e("body"))
        }, [
          K(uy, {
            date: i(l),
            "selected-day": i(u),
            onPick: i(a)
          }, lr({ _: 2 }, [
            h.$slots["date-cell"] || h.$slots.dateCell ? {
              name: "date-cell",
              fn: X((v) => [
                h.$slots["date-cell"] ? he(h.$slots, "date-cell", mo(ft({ key: 0 }, v))) : he(h.$slots, "dateCell", mo(ft({ key: 1 }, v)))
              ])
            } : void 0
          ]), 1032, ["date", "selected-day", "onPick"])
        ], 2)) : (S(), V("div", {
          key: 1,
          class: $(i(r).e("body"))
        }, [
          (S(!0), V(ze, null, gt(i(f), (v, g) => (S(), ie(uy, {
            key: g,
            date: v[0],
            "selected-day": i(u),
            range: v,
            "hide-header": g !== 0,
            onPick: i(a)
          }, lr({ _: 2 }, [
            h.$slots["date-cell"] || h.$slots.dateCell ? {
              name: "date-cell",
              fn: X((y) => [
                h.$slots["date-cell"] ? he(h.$slots, "date-cell", mo(ft({ key: 0 }, y))) : he(h.$slots, "dateCell", mo(ft({ key: 1 }, y)))
              ])
            } : void 0
          ]), 1032, ["date", "selected-day", "range", "hide-header", "onPick"]))), 128))
        ], 2))
      ], 2));
    }
  });
  var e5 = /* @__PURE__ */ Me(QF, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/calendar.vue"]]);
  const t5 = ut(e5), n5 = Ie({
    header: {
      type: String,
      default: ""
    },
    bodyStyle: {
      type: le([String, Object, Array]),
      default: ""
    },
    shadow: {
      type: String,
      values: ["always", "hover", "never"],
      default: "always"
    }
  }), o5 = G({
    name: "ElCard"
  }), r5 = /* @__PURE__ */ G({
    ...o5,
    props: n5,
    setup(e) {
      const t = ge("card");
      return (n, o) => (S(), V("div", {
        class: $([i(t).b(), i(t).is(`${n.shadow}-shadow`)])
      }, [
        n.$slots.header || n.header ? (S(), V("div", {
          key: 0,
          class: $(i(t).e("header"))
        }, [
          he(n.$slots, "header", {}, () => [
            wt(Ne(n.header), 1)
          ])
        ], 2)) : se("v-if", !0),
        H("div", {
          class: $(i(t).e("body")),
          style: Ke(n.bodyStyle)
        }, [
          he(n.$slots, "default")
        ], 6)
      ], 2));
    }
  });
  var s5 = /* @__PURE__ */ Me(r5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/card/src/card.vue"]]);
  const l5 = ut(s5), a5 = Ie({
    initialIndex: {
      type: Number,
      default: 0
    },
    height: {
      type: String,
      default: ""
    },
    trigger: {
      type: String,
      values: ["hover", "click"],
      default: "hover"
    },
    autoplay: {
      type: Boolean,
      default: !0
    },
    interval: {
      type: Number,
      default: 3e3
    },
    indicatorPosition: {
      type: String,
      values: ["", "none", "outside"],
      default: ""
    },
    arrow: {
      type: String,
      values: ["always", "hover", "never"],
      default: "hover"
    },
    type: {
      type: String,
      values: ["", "card"],
      default: ""
    },
    loop: {
      type: Boolean,
      default: !0
    },
    direction: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "horizontal"
    },
    pauseOnHover: {
      type: Boolean,
      default: !0
    }
  }), i5 = {
    change: (e, t) => [e, t].every(Xe)
  }, AC = Symbol("carouselContextKey"), cy = 300, u5 = (e, t, n) => {
    const {
      children: o,
      addChild: r,
      removeChild: s
    } = Vw(it(), "ElCarouselItem"), l = I(-1), a = I(null), u = I(!1), c = I(), f = E(() => e.arrow !== "never" && !i(h)), d = E(() => o.value.some((x) => x.props.label.toString().length > 0)), p = E(() => e.type === "card"), h = E(() => e.direction === "vertical"), m = Ss((x) => {
      b(x);
    }, cy, { trailing: !0 }), v = Ss((x) => {
      L(x);
    }, cy);
    function g() {
      a.value && (clearInterval(a.value), a.value = null);
    }
    function y() {
      e.interval <= 0 || !e.autoplay || a.value || (a.value = setInterval(() => w(), e.interval));
    }
    const w = () => {
      l.value < o.value.length - 1 ? l.value = l.value + 1 : e.loop && (l.value = 0);
    };
    function b(x) {
      if (et(x)) {
        const M = o.value.filter((j) => j.props.name === x);
        M.length > 0 && (x = o.value.indexOf(M[0]));
      }
      if (x = Number(x), Number.isNaN(x) || x !== Math.floor(x)) {
        yt(n, "index must be integer.");
        return;
      }
      const N = o.value.length, R = l.value;
      x < 0 ? l.value = e.loop ? N - 1 : 0 : x >= N ? l.value = e.loop ? 0 : N - 1 : l.value = x, R === l.value && C(R), F();
    }
    function C(x) {
      o.value.forEach((N, R) => {
        N.translateItem(R, l.value, x);
      });
    }
    function _(x, N) {
      var R, M, j, te;
      const U = i(o), Z = U.length;
      if (Z === 0 || !x.states.inStage)
        return !1;
      const pe = N + 1, J = N - 1, ee = Z - 1, ne = U[ee].states.active, Y = U[0].states.active, re = (M = (R = U[pe]) == null ? void 0 : R.states) == null ? void 0 : M.active, ce = (te = (j = U[J]) == null ? void 0 : j.states) == null ? void 0 : te.active;
      return N === ee && Y || re ? "left" : N === 0 && ne || ce ? "right" : !1;
    }
    function k() {
      u.value = !0, e.pauseOnHover && g();
    }
    function O() {
      u.value = !1, y();
    }
    function T(x) {
      i(h) || o.value.forEach((N, R) => {
        x === _(N, R) && (N.states.hover = !0);
      });
    }
    function P() {
      i(h) || o.value.forEach((x) => {
        x.states.hover = !1;
      });
    }
    function A(x) {
      l.value = x;
    }
    function L(x) {
      e.trigger === "hover" && x !== l.value && (l.value = x);
    }
    function D() {
      b(l.value - 1);
    }
    function B() {
      b(l.value + 1);
    }
    function F() {
      g(), y();
    }
    me(() => l.value, (x, N) => {
      C(N), N > -1 && t("change", x, N);
    }), me(() => e.autoplay, (x) => {
      x ? y() : g();
    }), me(() => e.loop, () => {
      b(l.value);
    }), me(() => e.interval, () => {
      F();
    }), me(() => o.value, () => {
      o.value.length > 0 && b(e.initialIndex);
    });
    const W = xt();
    return st(() => {
      W.value = Cn(c.value, () => {
        C();
      }), y();
    }), zt(() => {
      g(), c.value && W.value && W.value.stop();
    }), pt(AC, {
      root: c,
      isCardType: p,
      isVertical: h,
      items: o,
      loop: e.loop,
      addItem: r,
      removeItem: s,
      setActiveItem: b
    }), {
      root: c,
      activeIndex: l,
      arrowDisplay: f,
      hasLabel: d,
      hover: u,
      isCardType: p,
      items: o,
      handleButtonEnter: T,
      handleButtonLeave: P,
      handleIndicatorClick: A,
      handleMouseEnter: k,
      handleMouseLeave: O,
      setActiveItem: b,
      prev: D,
      next: B,
      throttledArrowClick: m,
      throttledIndicatorHover: v
    };
  }, c5 = ["onMouseenter", "onClick"], d5 = { key: 0 }, RC = "ElCarousel", f5 = G({
    name: RC
  }), p5 = /* @__PURE__ */ G({
    ...f5,
    props: a5,
    emits: i5,
    setup(e, { expose: t, emit: n }) {
      const o = e, {
        root: r,
        activeIndex: s,
        arrowDisplay: l,
        hasLabel: a,
        hover: u,
        isCardType: c,
        items: f,
        handleButtonEnter: d,
        handleButtonLeave: p,
        handleIndicatorClick: h,
        handleMouseEnter: m,
        handleMouseLeave: v,
        setActiveItem: g,
        prev: y,
        next: w,
        throttledArrowClick: b,
        throttledIndicatorHover: C
      } = u5(o, n, RC), _ = ge("carousel"), k = E(() => {
        const T = [_.b(), _.m(o.direction)];
        return i(c) && T.push(_.m("card")), T;
      }), O = E(() => {
        const T = [_.e("indicators"), _.em("indicators", o.direction)];
        return i(a) && T.push(_.em("indicators", "labels")), (o.indicatorPosition === "outside" || i(c)) && T.push(_.em("indicators", "outside")), T;
      });
      return t({
        setActiveItem: g,
        prev: y,
        next: w
      }), (T, P) => (S(), V("div", {
        ref_key: "root",
        ref: r,
        class: $(i(k)),
        onMouseenter: P[6] || (P[6] = Ze((...A) => i(m) && i(m)(...A), ["stop"])),
        onMouseleave: P[7] || (P[7] = Ze((...A) => i(v) && i(v)(...A), ["stop"]))
      }, [
        H("div", {
          class: $(i(_).e("container")),
          style: Ke({ height: T.height })
        }, [
          i(l) ? (S(), ie(Qt, {
            key: 0,
            name: "carousel-arrow-left",
            persisted: ""
          }, {
            default: X(() => [
              ot(H("button", {
                type: "button",
                class: $([i(_).e("arrow"), i(_).em("arrow", "left")]),
                onMouseenter: P[0] || (P[0] = (A) => i(d)("left")),
                onMouseleave: P[1] || (P[1] = (...A) => i(p) && i(p)(...A)),
                onClick: P[2] || (P[2] = Ze((A) => i(b)(i(s) - 1), ["stop"]))
              }, [
                K(i(He), null, {
                  default: X(() => [
                    K(i(Br))
                  ]),
                  _: 1
                })
              ], 34), [
                [
                  $t,
                  (T.arrow === "always" || i(u)) && (o.loop || i(s) > 0)
                ]
              ])
            ]),
            _: 1
          })) : se("v-if", !0),
          i(l) ? (S(), ie(Qt, {
            key: 1,
            name: "carousel-arrow-right",
            persisted: ""
          }, {
            default: X(() => [
              ot(H("button", {
                type: "button",
                class: $([i(_).e("arrow"), i(_).em("arrow", "right")]),
                onMouseenter: P[3] || (P[3] = (A) => i(d)("right")),
                onMouseleave: P[4] || (P[4] = (...A) => i(p) && i(p)(...A)),
                onClick: P[5] || (P[5] = Ze((A) => i(b)(i(s) + 1), ["stop"]))
              }, [
                K(i(He), null, {
                  default: X(() => [
                    K(i(kn))
                  ]),
                  _: 1
                })
              ], 34), [
                [
                  $t,
                  (T.arrow === "always" || i(u)) && (o.loop || i(s) < i(f).length - 1)
                ]
              ])
            ]),
            _: 1
          })) : se("v-if", !0),
          he(T.$slots, "default")
        ], 6),
        T.indicatorPosition !== "none" ? (S(), V("ul", {
          key: 0,
          class: $(i(O))
        }, [
          (S(!0), V(ze, null, gt(i(f), (A, L) => (S(), V("li", {
            key: L,
            class: $([
              i(_).e("indicator"),
              i(_).em("indicator", T.direction),
              i(_).is("active", L === i(s))
            ]),
            onMouseenter: (D) => i(C)(L),
            onClick: Ze((D) => i(h)(L), ["stop"])
          }, [
            H("button", {
              class: $(i(_).e("button"))
            }, [
              i(a) ? (S(), V("span", d5, Ne(A.props.label), 1)) : se("v-if", !0)
            ], 2)
          ], 42, c5))), 128))
        ], 2)) : se("v-if", !0)
      ], 34));
    }
  });
  var h5 = /* @__PURE__ */ Me(p5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel.vue"]]);
  const v5 = Ie({
    name: { type: String, default: "" },
    label: {
      type: [String, Number],
      default: ""
    }
  }), m5 = (e, t) => {
    const n = Be(AC), o = it();
    n || yt(t, "usage: <el-carousel></el-carousel-item></el-carousel>"), o || yt(t, "compositional hook can only be invoked inside setups");
    const r = 0.83, s = I(!1), l = I(0), a = I(1), u = I(!1), c = I(!1), f = I(!1), d = I(!1), { isCardType: p, isVertical: h } = n;
    function m(b, C, _) {
      const k = _ - 1, O = C - 1, T = C + 1, P = _ / 2;
      return C === 0 && b === k ? -1 : C === k && b === 0 ? _ : b < O && C - b >= P ? _ + 1 : b > T && b - C >= P ? -2 : b;
    }
    function v(b, C) {
      var _;
      const k = ((_ = n.root.value) == null ? void 0 : _.offsetWidth) || 0;
      return f.value ? k * ((2 - r) * (b - C) + 1) / 4 : b < C ? -(1 + r) * k / 4 : (3 + r) * k / 4;
    }
    function g(b, C, _) {
      const k = n.root.value;
      return k ? ((_ ? k.offsetHeight : k.offsetWidth) || 0) * (b - C) : 0;
    }
    const y = (b, C, _) => {
      var k;
      const O = i(p), T = (k = n.items.value.length) != null ? k : Number.NaN, P = b === C;
      !O && !pn(_) && (d.value = P || b === _), !P && T > 2 && n.loop && (b = m(b, C, T));
      const A = i(h);
      u.value = P, O ? (A && yt("Carousel", "vertical direction is not supported for card mode"), f.value = Math.round(Math.abs(b - C)) <= 1, l.value = v(b, C), a.value = i(u) ? 1 : r) : l.value = g(b, C, A), c.value = !0;
    };
    function w() {
      if (n && i(p)) {
        const b = n.items.value.findIndex(({ uid: C }) => C === o.uid);
        n.setActiveItem(b);
      }
    }
    return st(() => {
      n.addItem({
        props: e,
        states: Tt({
          hover: s,
          translate: l,
          scale: a,
          active: u,
          ready: c,
          inStage: f,
          animating: d
        }),
        uid: o.uid,
        translateItem: y
      });
    }), Ur(() => {
      n.removeItem(o.uid);
    }), {
      active: u,
      animating: d,
      hover: s,
      inStage: f,
      isVertical: h,
      translate: l,
      isCardType: p,
      scale: a,
      ready: c,
      handleItemClick: w
    };
  }, g5 = "ElCarouselItem", y5 = G({
    name: "ElCarouselItem"
  }), b5 = /* @__PURE__ */ G({
    ...y5,
    props: v5,
    setup(e) {
      const t = e, n = ge("carousel"), {
        active: o,
        animating: r,
        hover: s,
        inStage: l,
        isVertical: a,
        translate: u,
        isCardType: c,
        scale: f,
        ready: d,
        handleItemClick: p
      } = m5(t, g5), h = E(() => {
        const v = `${`translate${i(a) ? "Y" : "X"}`}(${i(u)}px)`, g = `scale(${i(f)})`;
        return {
          transform: [v, g].join(" ")
        };
      });
      return (m, v) => ot((S(), V("div", {
        class: $([
          i(n).e("item"),
          i(n).is("active", i(o)),
          i(n).is("in-stage", i(l)),
          i(n).is("hover", i(s)),
          i(n).is("animating", i(r)),
          { [i(n).em("item", "card")]: i(c) }
        ]),
        style: Ke(i(h)),
        onClick: v[0] || (v[0] = (...g) => i(p) && i(p)(...g))
      }, [
        i(c) ? ot((S(), V("div", {
          key: 0,
          class: $(i(n).e("mask"))
        }, null, 2)), [
          [$t, !i(o)]
        ]) : se("v-if", !0),
        he(m.$slots, "default")
      ], 6)), [
        [$t, i(d)]
      ]);
    }
  });
  var xC = /* @__PURE__ */ Me(b5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel-item.vue"]]);
  const w5 = ut(h5, {
    CarouselItem: xC
  }), C5 = Gt(xC), DC = {
    modelValue: {
      type: [Number, String, Boolean],
      default: void 0
    },
    label: {
      type: [String, Boolean, Number, Object]
    },
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: {
      type: String,
      default: void 0
    },
    trueLabel: {
      type: [String, Number],
      default: void 0
    },
    falseLabel: {
      type: [String, Number],
      default: void 0
    },
    id: {
      type: String,
      default: void 0
    },
    controls: {
      type: String,
      default: void 0
    },
    border: Boolean,
    size: yn,
    tabindex: [String, Number],
    validateEvent: {
      type: Boolean,
      default: !0
    }
  }, LC = {
    [dt]: (e) => et(e) || Xe(e) || tn(e),
    change: (e) => et(e) || Xe(e) || tn(e)
  }, Wl = Symbol("checkboxGroupContextKey"), E5 = ({
    model: e,
    isChecked: t
  }) => {
    const n = Be(Wl, void 0), o = E(() => {
      var s, l;
      const a = (s = n == null ? void 0 : n.max) == null ? void 0 : s.value, u = (l = n == null ? void 0 : n.min) == null ? void 0 : l.value;
      return !pn(a) && e.value.length >= a && !t.value || !pn(u) && e.value.length <= u && t.value;
    });
    return {
      isDisabled: Fn(E(() => (n == null ? void 0 : n.disabled.value) || o.value)),
      isLimitDisabled: o
    };
  }, S5 = (e, {
    model: t,
    isLimitExceeded: n,
    hasOwnLabel: o,
    isDisabled: r,
    isLabeledByFormItem: s
  }) => {
    const l = Be(Wl, void 0), { formItem: a } = In(), { emit: u } = it();
    function c(m) {
      var v, g;
      return m === e.trueLabel || m === !0 ? (v = e.trueLabel) != null ? v : !0 : (g = e.falseLabel) != null ? g : !1;
    }
    function f(m, v) {
      u("change", c(m), v);
    }
    function d(m) {
      if (n.value)
        return;
      const v = m.target;
      u("change", c(v.checked), m);
    }
    async function p(m) {
      n.value || !o.value && !r.value && s.value && (m.composedPath().some((y) => y.tagName === "LABEL") || (t.value = c([!1, e.falseLabel].includes(t.value)), await Fe(), f(t.value, m)));
    }
    const h = E(() => (l == null ? void 0 : l.validateEvent) || e.validateEvent);
    return me(() => e.modelValue, () => {
      h.value && (a == null || a.validate("change").catch((m) => yt(m)));
    }), {
      handleChange: d,
      onClickRoot: p
    };
  }, _5 = (e) => {
    const t = I(!1), { emit: n } = it(), o = Be(Wl, void 0), r = E(() => pn(o) === !1), s = I(!1);
    return {
      model: E({
        get() {
          var a, u;
          return r.value ? (a = o == null ? void 0 : o.modelValue) == null ? void 0 : a.value : (u = e.modelValue) != null ? u : t.value;
        },
        set(a) {
          var u, c;
          r.value && De(a) ? (s.value = ((u = o == null ? void 0 : o.max) == null ? void 0 : u.value) !== void 0 && a.length > (o == null ? void 0 : o.max.value), s.value === !1 && ((c = o == null ? void 0 : o.changeEvent) == null || c.call(o, a))) : (n(dt, a), t.value = a);
        }
      }),
      isGroup: r,
      isLimitExceeded: s
    };
  }, k5 = (e, t, { model: n }) => {
    const o = Be(Wl, void 0), r = I(!1), s = E(() => {
      const c = n.value;
      return tn(c) ? c : De(c) ? rt(e.label) ? c.map(Ct).some((f) => qn(f, e.label)) : c.map(Ct).includes(e.label) : c != null ? c === e.trueLabel : !!c;
    }), l = on(E(() => {
      var c;
      return (c = o == null ? void 0 : o.size) == null ? void 0 : c.value;
    }), {
      prop: !0
    }), a = on(E(() => {
      var c;
      return (c = o == null ? void 0 : o.size) == null ? void 0 : c.value;
    })), u = E(() => !!(t.default || e.label));
    return {
      checkboxButtonSize: l,
      isChecked: s,
      isFocused: r,
      checkboxSize: a,
      hasOwnLabel: u
    };
  }, $5 = (e, { model: t }) => {
    function n() {
      De(t.value) && !t.value.includes(e.label) ? t.value.push(e.label) : t.value = e.trueLabel || !0;
    }
    e.checked && n();
  }, VC = (e, t) => {
    const { formItem: n } = In(), { model: o, isGroup: r, isLimitExceeded: s } = _5(e), {
      isFocused: l,
      isChecked: a,
      checkboxButtonSize: u,
      checkboxSize: c,
      hasOwnLabel: f
    } = k5(e, t, { model: o }), { isDisabled: d } = E5({ model: o, isChecked: a }), { inputId: p, isLabeledByFormItem: h } = Zr(e, {
      formItemContext: n,
      disableIdGeneration: f,
      disableIdManagement: r
    }), { handleChange: m, onClickRoot: v } = S5(e, {
      model: o,
      isLimitExceeded: s,
      hasOwnLabel: f,
      isDisabled: d,
      isLabeledByFormItem: h
    });
    return $5(e, { model: o }), {
      inputId: p,
      isLabeledByFormItem: h,
      isChecked: a,
      isDisabled: d,
      isFocused: l,
      checkboxButtonSize: u,
      checkboxSize: c,
      hasOwnLabel: f,
      model: o,
      handleChange: m,
      onClickRoot: v
    };
  }, N5 = ["tabindex", "role", "aria-checked"], T5 = ["id", "aria-hidden", "name", "tabindex", "disabled", "true-value", "false-value"], O5 = ["id", "aria-hidden", "disabled", "value", "name", "tabindex"], M5 = G({
    name: "ElCheckbox"
  }), I5 = /* @__PURE__ */ G({
    ...M5,
    props: DC,
    emits: LC,
    setup(e) {
      const t = e, n = hn(), {
        inputId: o,
        isLabeledByFormItem: r,
        isChecked: s,
        isDisabled: l,
        isFocused: a,
        checkboxSize: u,
        hasOwnLabel: c,
        model: f,
        handleChange: d,
        onClickRoot: p
      } = VC(t, n), h = ge("checkbox"), m = E(() => [
        h.b(),
        h.m(u.value),
        h.is("disabled", l.value),
        h.is("bordered", t.border),
        h.is("checked", s.value)
      ]), v = E(() => [
        h.e("input"),
        h.is("disabled", l.value),
        h.is("checked", s.value),
        h.is("indeterminate", t.indeterminate),
        h.is("focus", a.value)
      ]);
      return (g, y) => (S(), ie(vt(!i(c) && i(r) ? "span" : "label"), {
        class: $(i(m)),
        "aria-controls": g.indeterminate ? g.controls : null,
        onClick: i(p)
      }, {
        default: X(() => [
          H("span", {
            class: $(i(v)),
            tabindex: g.indeterminate ? 0 : void 0,
            role: g.indeterminate ? "checkbox" : void 0,
            "aria-checked": g.indeterminate ? "mixed" : void 0
          }, [
            g.trueLabel || g.falseLabel ? ot((S(), V("input", {
              key: 0,
              id: i(o),
              "onUpdate:modelValue": y[0] || (y[0] = (w) => Pt(f) ? f.value = w : null),
              class: $(i(h).e("original")),
              type: "checkbox",
              "aria-hidden": g.indeterminate ? "true" : "false",
              name: g.name,
              tabindex: g.tabindex,
              disabled: i(l),
              "true-value": g.trueLabel,
              "false-value": g.falseLabel,
              onChange: y[1] || (y[1] = (...w) => i(d) && i(d)(...w)),
              onFocus: y[2] || (y[2] = (w) => a.value = !0),
              onBlur: y[3] || (y[3] = (w) => a.value = !1)
            }, null, 42, T5)), [
              [qu, i(f)]
            ]) : ot((S(), V("input", {
              key: 1,
              id: i(o),
              "onUpdate:modelValue": y[4] || (y[4] = (w) => Pt(f) ? f.value = w : null),
              class: $(i(h).e("original")),
              type: "checkbox",
              "aria-hidden": g.indeterminate ? "true" : "false",
              disabled: i(l),
              value: g.label,
              name: g.name,
              tabindex: g.tabindex,
              onChange: y[5] || (y[5] = (...w) => i(d) && i(d)(...w)),
              onFocus: y[6] || (y[6] = (w) => a.value = !0),
              onBlur: y[7] || (y[7] = (w) => a.value = !1)
            }, null, 42, O5)), [
              [qu, i(f)]
            ]),
            H("span", {
              class: $(i(h).e("inner"))
            }, null, 2)
          ], 10, N5),
          i(c) ? (S(), V("span", {
            key: 0,
            class: $(i(h).e("label"))
          }, [
            he(g.$slots, "default"),
            g.$slots.default ? se("v-if", !0) : (S(), V(ze, { key: 0 }, [
              wt(Ne(g.label), 1)
            ], 64))
          ], 2)) : se("v-if", !0)
        ]),
        _: 3
      }, 8, ["class", "aria-controls", "onClick"]));
    }
  });
  var P5 = /* @__PURE__ */ Me(I5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
  const A5 = ["name", "tabindex", "disabled", "true-value", "false-value"], R5 = ["name", "tabindex", "disabled", "value"], x5 = G({
    name: "ElCheckboxButton"
  }), D5 = /* @__PURE__ */ G({
    ...x5,
    props: DC,
    emits: LC,
    setup(e) {
      const t = e, n = hn(), {
        isFocused: o,
        isChecked: r,
        isDisabled: s,
        checkboxButtonSize: l,
        model: a,
        handleChange: u
      } = VC(t, n), c = Be(Wl, void 0), f = ge("checkbox"), d = E(() => {
        var h, m, v, g;
        const y = (m = (h = c == null ? void 0 : c.fill) == null ? void 0 : h.value) != null ? m : "";
        return {
          backgroundColor: y,
          borderColor: y,
          color: (g = (v = c == null ? void 0 : c.textColor) == null ? void 0 : v.value) != null ? g : "",
          boxShadow: y ? `-1px 0 0 0 ${y}` : void 0
        };
      }), p = E(() => [
        f.b("button"),
        f.bm("button", l.value),
        f.is("disabled", s.value),
        f.is("checked", r.value),
        f.is("focus", o.value)
      ]);
      return (h, m) => (S(), V("label", {
        class: $(i(p))
      }, [
        h.trueLabel || h.falseLabel ? ot((S(), V("input", {
          key: 0,
          "onUpdate:modelValue": m[0] || (m[0] = (v) => Pt(a) ? a.value = v : null),
          class: $(i(f).be("button", "original")),
          type: "checkbox",
          name: h.name,
          tabindex: h.tabindex,
          disabled: i(s),
          "true-value": h.trueLabel,
          "false-value": h.falseLabel,
          onChange: m[1] || (m[1] = (...v) => i(u) && i(u)(...v)),
          onFocus: m[2] || (m[2] = (v) => o.value = !0),
          onBlur: m[3] || (m[3] = (v) => o.value = !1)
        }, null, 42, A5)), [
          [qu, i(a)]
        ]) : ot((S(), V("input", {
          key: 1,
          "onUpdate:modelValue": m[4] || (m[4] = (v) => Pt(a) ? a.value = v : null),
          class: $(i(f).be("button", "original")),
          type: "checkbox",
          name: h.name,
          tabindex: h.tabindex,
          disabled: i(s),
          value: h.label,
          onChange: m[5] || (m[5] = (...v) => i(u) && i(u)(...v)),
          onFocus: m[6] || (m[6] = (v) => o.value = !0),
          onBlur: m[7] || (m[7] = (v) => o.value = !1)
        }, null, 42, R5)), [
          [qu, i(a)]
        ]),
        h.$slots.default || h.label ? (S(), V("span", {
          key: 2,
          class: $(i(f).be("button", "inner")),
          style: Ke(i(r) ? i(d) : void 0)
        }, [
          he(h.$slots, "default", {}, () => [
            wt(Ne(h.label), 1)
          ])
        ], 6)) : se("v-if", !0)
      ], 2));
    }
  });
  var BC = /* @__PURE__ */ Me(D5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
  const L5 = Ie({
    modelValue: {
      type: le(Array),
      default: () => []
    },
    disabled: Boolean,
    min: Number,
    max: Number,
    size: yn,
    label: String,
    fill: String,
    textColor: String,
    tag: {
      type: String,
      default: "div"
    },
    validateEvent: {
      type: Boolean,
      default: !0
    }
  }), V5 = {
    [dt]: (e) => De(e),
    change: (e) => De(e)
  }, B5 = G({
    name: "ElCheckboxGroup"
  }), F5 = /* @__PURE__ */ G({
    ...B5,
    props: L5,
    emits: V5,
    setup(e, { emit: t }) {
      const n = e, o = ge("checkbox"), { formItem: r } = In(), { inputId: s, isLabeledByFormItem: l } = Zr(n, {
        formItemContext: r
      }), a = async (c) => {
        t(dt, c), await Fe(), t("change", c);
      }, u = E({
        get() {
          return n.modelValue;
        },
        set(c) {
          a(c);
        }
      });
      return pt(Wl, {
        ...tr(rn(n), [
          "size",
          "min",
          "max",
          "disabled",
          "validateEvent",
          "fill",
          "textColor"
        ]),
        modelValue: u,
        changeEvent: a
      }), me(() => n.modelValue, () => {
        n.validateEvent && (r == null || r.validate("change").catch((c) => yt(c)));
      }), (c, f) => {
        var d;
        return S(), ie(vt(c.tag), {
          id: i(s),
          class: $(i(o).b("group")),
          role: "group",
          "aria-label": i(l) ? void 0 : c.label || "checkbox-group",
          "aria-labelledby": i(l) ? (d = i(r)) == null ? void 0 : d.labelId : void 0
        }, {
          default: X(() => [
            he(c.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
      };
    }
  });
  var FC = /* @__PURE__ */ Me(F5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
  const co = ut(P5, {
    CheckboxButton: BC,
    CheckboxGroup: FC
  }), H5 = Gt(BC), HC = Gt(FC), zC = Ie({
    size: yn,
    disabled: Boolean,
    label: {
      type: [String, Number, Boolean],
      default: ""
    }
  }), z5 = Ie({
    ...zC,
    modelValue: {
      type: [String, Number, Boolean],
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    border: Boolean
  }), KC = {
    [dt]: (e) => et(e) || Xe(e) || tn(e),
    [Ft]: (e) => et(e) || Xe(e) || tn(e)
  }, jC = Symbol("radioGroupKey"), WC = (e, t) => {
    const n = I(), o = Be(jC, void 0), r = E(() => !!o), s = E({
      get() {
        return r.value ? o.modelValue : e.modelValue;
      },
      set(f) {
        r.value ? o.changeEvent(f) : t && t(dt, f), n.value.checked = e.modelValue === e.label;
      }
    }), l = on(E(() => o == null ? void 0 : o.size)), a = Fn(E(() => o == null ? void 0 : o.disabled)), u = I(!1), c = E(() => a.value || r.value && s.value !== e.label ? -1 : 0);
    return {
      radioRef: n,
      isGroup: r,
      radioGroup: o,
      focus: u,
      size: l,
      disabled: a,
      tabIndex: c,
      modelValue: s
    };
  }, K5 = ["value", "name", "disabled"], j5 = G({
    name: "ElRadio"
  }), W5 = /* @__PURE__ */ G({
    ...j5,
    props: z5,
    emits: KC,
    setup(e, { emit: t }) {
      const n = e, o = ge("radio"), { radioRef: r, radioGroup: s, focus: l, size: a, disabled: u, modelValue: c } = WC(n, t);
      function f() {
        Fe(() => t("change", c.value));
      }
      return (d, p) => {
        var h;
        return S(), V("label", {
          class: $([
            i(o).b(),
            i(o).is("disabled", i(u)),
            i(o).is("focus", i(l)),
            i(o).is("bordered", d.border),
            i(o).is("checked", i(c) === d.label),
            i(o).m(i(a))
          ])
        }, [
          H("span", {
            class: $([
              i(o).e("input"),
              i(o).is("disabled", i(u)),
              i(o).is("checked", i(c) === d.label)
            ])
          }, [
            ot(H("input", {
              ref_key: "radioRef",
              ref: r,
              "onUpdate:modelValue": p[0] || (p[0] = (m) => Pt(c) ? c.value = m : null),
              class: $(i(o).e("original")),
              value: d.label,
              name: d.name || ((h = i(s)) == null ? void 0 : h.name),
              disabled: i(u),
              type: "radio",
              onFocus: p[1] || (p[1] = (m) => l.value = !0),
              onBlur: p[2] || (p[2] = (m) => l.value = !1),
              onChange: f
            }, null, 42, K5), [
              [e1, i(c)]
            ]),
            H("span", {
              class: $(i(o).e("inner"))
            }, null, 2)
          ], 2),
          H("span", {
            class: $(i(o).e("label")),
            onKeydown: p[3] || (p[3] = Ze(() => {
            }, ["stop"]))
          }, [
            he(d.$slots, "default", {}, () => [
              wt(Ne(d.label), 1)
            ])
          ], 34)
        ], 2);
      };
    }
  });
  var U5 = /* @__PURE__ */ Me(W5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio.vue"]]);
  const q5 = Ie({
    ...zC,
    name: {
      type: String,
      default: ""
    }
  }), Y5 = ["value", "name", "disabled"], G5 = G({
    name: "ElRadioButton"
  }), X5 = /* @__PURE__ */ G({
    ...G5,
    props: q5,
    setup(e) {
      const t = e, n = ge("radio"), { radioRef: o, focus: r, size: s, disabled: l, modelValue: a, radioGroup: u } = WC(t), c = E(() => ({
        backgroundColor: (u == null ? void 0 : u.fill) || "",
        borderColor: (u == null ? void 0 : u.fill) || "",
        boxShadow: u != null && u.fill ? `-1px 0 0 0 ${u.fill}` : "",
        color: (u == null ? void 0 : u.textColor) || ""
      }));
      return (f, d) => {
        var p;
        return S(), V("label", {
          class: $([
            i(n).b("button"),
            i(n).is("active", i(a) === f.label),
            i(n).is("disabled", i(l)),
            i(n).is("focus", i(r)),
            i(n).bm("button", i(s))
          ])
        }, [
          ot(H("input", {
            ref_key: "radioRef",
            ref: o,
            "onUpdate:modelValue": d[0] || (d[0] = (h) => Pt(a) ? a.value = h : null),
            class: $(i(n).be("button", "original-radio")),
            value: f.label,
            type: "radio",
            name: f.name || ((p = i(u)) == null ? void 0 : p.name),
            disabled: i(l),
            onFocus: d[1] || (d[1] = (h) => r.value = !0),
            onBlur: d[2] || (d[2] = (h) => r.value = !1)
          }, null, 42, Y5), [
            [e1, i(a)]
          ]),
          H("span", {
            class: $(i(n).be("button", "inner")),
            style: Ke(i(a) === f.label ? i(c) : {}),
            onKeydown: d[3] || (d[3] = Ze(() => {
            }, ["stop"]))
          }, [
            he(f.$slots, "default", {}, () => [
              wt(Ne(f.label), 1)
            ])
          ], 38)
        ], 2);
      };
    }
  });
  var UC = /* @__PURE__ */ Me(X5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-button.vue"]]);
  const J5 = Ie({
    id: {
      type: String,
      default: void 0
    },
    size: yn,
    disabled: Boolean,
    modelValue: {
      type: [String, Number, Boolean],
      default: ""
    },
    fill: {
      type: String,
      default: ""
    },
    label: {
      type: String,
      default: void 0
    },
    textColor: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: void 0
    },
    validateEvent: {
      type: Boolean,
      default: !0
    }
  }), Z5 = KC, Q5 = ["id", "aria-label", "aria-labelledby"], eH = G({
    name: "ElRadioGroup"
  }), tH = /* @__PURE__ */ G({
    ...eH,
    props: J5,
    emits: Z5,
    setup(e, { emit: t }) {
      const n = e, o = ge("radio"), r = io(), s = I(), { formItem: l } = In(), { inputId: a, isLabeledByFormItem: u } = Zr(n, {
        formItemContext: l
      }), c = (d) => {
        t(dt, d), Fe(() => t("change", d));
      };
      st(() => {
        const d = s.value.querySelectorAll("[type=radio]"), p = d[0];
        !Array.from(d).some((h) => h.checked) && p && (p.tabIndex = 0);
      });
      const f = E(() => n.name || r.value);
      return pt(jC, Tt({
        ...rn(n),
        changeEvent: c,
        name: f
      })), me(() => n.modelValue, () => {
        n.validateEvent && (l == null || l.validate("change").catch((d) => yt(d)));
      }), (d, p) => (S(), V("div", {
        id: i(a),
        ref_key: "radioGroupRef",
        ref: s,
        class: $(i(o).b("group")),
        role: "radiogroup",
        "aria-label": i(u) ? void 0 : d.label || "radio-group",
        "aria-labelledby": i(u) ? i(l).labelId : void 0
      }, [
        he(d.$slots, "default")
      ], 10, Q5));
    }
  });
  var qC = /* @__PURE__ */ Me(tH, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-group.vue"]]);
  const YC = ut(U5, {
    RadioButton: UC,
    RadioGroup: qC
  }), nH = Gt(qC), oH = Gt(UC);
  var rH = G({
    name: "NodeContent",
    setup() {
      return {
        ns: ge("cascader-node")
      };
    },
    render() {
      const { ns: e } = this, { node: t, panel: n } = this.$parent, { data: o, label: r } = t, { renderLabelFn: s } = n;
      return je("span", { class: e.e("label") }, s ? s({ node: t, data: o }) : r);
    }
  });
  const Yh = Symbol(), sH = G({
    name: "ElCascaderNode",
    components: {
      ElCheckbox: co,
      ElRadio: YC,
      NodeContent: rH,
      ElIcon: He,
      Check: wi,
      Loading: Gr,
      ArrowRight: kn
    },
    props: {
      node: {
        type: Object,
        required: !0
      },
      menuId: String
    },
    emits: ["expand"],
    setup(e, { emit: t }) {
      const n = Be(Yh), o = ge("cascader-node"), r = E(() => n.isHoverMenu), s = E(() => n.config.multiple), l = E(() => n.config.checkStrictly), a = E(() => {
        var k;
        return (k = n.checkedNodes[0]) == null ? void 0 : k.uid;
      }), u = E(() => e.node.isDisabled), c = E(() => e.node.isLeaf), f = E(() => l.value && !c.value || !u.value), d = E(() => h(n.expandingNode)), p = E(() => l.value && n.checkedNodes.some(h)), h = (k) => {
        var O;
        const { level: T, uid: P } = e.node;
        return ((O = k == null ? void 0 : k.pathNodes[T - 1]) == null ? void 0 : O.uid) === P;
      }, m = () => {
        d.value || n.expandNode(e.node);
      }, v = (k) => {
        const { node: O } = e;
        k !== O.checked && n.handleCheckChange(O, k);
      }, g = () => {
        n.lazyLoad(e.node, () => {
          c.value || m();
        });
      }, y = (k) => {
        !r.value || (w(), !c.value && t("expand", k));
      }, w = () => {
        const { node: k } = e;
        !f.value || k.loading || (k.loaded ? m() : g());
      }, b = () => {
        r.value && !c.value || (c.value && !u.value && !l.value && !s.value ? _(!0) : w());
      }, C = (k) => {
        l.value ? (v(k), e.node.loaded && m()) : _(k);
      }, _ = (k) => {
        e.node.loaded ? (v(k), !l.value && m()) : g();
      };
      return {
        panel: n,
        isHoverMenu: r,
        multiple: s,
        checkStrictly: l,
        checkedNodeId: a,
        isDisabled: u,
        isLeaf: c,
        expandable: f,
        inExpandingPath: d,
        inCheckedPath: p,
        ns: o,
        handleHoverExpand: y,
        handleExpand: w,
        handleClick: b,
        handleCheck: _,
        handleSelectCheck: C
      };
    }
  }), lH = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"], aH = /* @__PURE__ */ H("span", null, null, -1);
  function iH(e, t, n, o, r, s) {
    const l = Qe("el-checkbox"), a = Qe("el-radio"), u = Qe("check"), c = Qe("el-icon"), f = Qe("node-content"), d = Qe("loading"), p = Qe("arrow-right");
    return S(), V("li", {
      id: `${e.menuId}-${e.node.uid}`,
      role: "menuitem",
      "aria-haspopup": !e.isLeaf,
      "aria-owns": e.isLeaf ? null : e.menuId,
      "aria-expanded": e.inExpandingPath,
      tabindex: e.expandable ? -1 : void 0,
      class: $([
        e.ns.b(),
        e.ns.is("selectable", e.checkStrictly),
        e.ns.is("active", e.node.checked),
        e.ns.is("disabled", !e.expandable),
        e.inExpandingPath && "in-active-path",
        e.inCheckedPath && "in-checked-path"
      ]),
      onMouseenter: t[2] || (t[2] = (...h) => e.handleHoverExpand && e.handleHoverExpand(...h)),
      onFocus: t[3] || (t[3] = (...h) => e.handleHoverExpand && e.handleHoverExpand(...h)),
      onClick: t[4] || (t[4] = (...h) => e.handleClick && e.handleClick(...h))
    }, [
      se(" prefix "),
      e.multiple ? (S(), ie(l, {
        key: 0,
        "model-value": e.node.checked,
        indeterminate: e.node.indeterminate,
        disabled: e.isDisabled,
        onClick: t[0] || (t[0] = Ze(() => {
        }, ["stop"])),
        "onUpdate:modelValue": e.handleSelectCheck
      }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : e.checkStrictly ? (S(), ie(a, {
        key: 1,
        "model-value": e.checkedNodeId,
        label: e.node.uid,
        disabled: e.isDisabled,
        "onUpdate:modelValue": e.handleSelectCheck,
        onClick: t[1] || (t[1] = Ze(() => {
        }, ["stop"]))
      }, {
        default: X(() => [
          se(`
        Add an empty element to avoid render label,
        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485
      `),
          aH
        ]),
        _: 1
      }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : e.isLeaf && e.node.checked ? (S(), ie(c, {
        key: 2,
        class: $(e.ns.e("prefix"))
      }, {
        default: X(() => [
          K(u)
        ]),
        _: 1
      }, 8, ["class"])) : se("v-if", !0),
      se(" content "),
      K(f),
      se(" postfix "),
      e.isLeaf ? se("v-if", !0) : (S(), V(ze, { key: 3 }, [
        e.node.loading ? (S(), ie(c, {
          key: 0,
          class: $([e.ns.is("loading"), e.ns.e("postfix")])
        }, {
          default: X(() => [
            K(d)
          ]),
          _: 1
        }, 8, ["class"])) : (S(), ie(c, {
          key: 1,
          class: $(["arrow-right", e.ns.e("postfix")])
        }, {
          default: X(() => [
            K(p)
          ]),
          _: 1
        }, 8, ["class"]))
      ], 64))
    ], 42, lH);
  }
  var uH = /* @__PURE__ */ Me(sH, [["render", iH], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/node.vue"]]);
  const cH = G({
    name: "ElCascaderMenu",
    components: {
      Loading: Gr,
      ElIcon: He,
      ElScrollbar: pr,
      ElCascaderNode: uH
    },
    props: {
      nodes: {
        type: Array,
        required: !0
      },
      index: {
        type: Number,
        required: !0
      }
    },
    setup(e) {
      const t = it(), n = ge("cascader-menu"), { t: o } = St(), r = Wc();
      let s = null, l = null;
      const a = Be(Yh), u = I(null), c = E(() => !e.nodes.length), f = E(() => !a.initialLoaded), d = E(() => `cascader-menu-${r}-${e.index}`), p = (g) => {
        s = g.target;
      }, h = (g) => {
        if (!(!a.isHoverMenu || !s || !u.value))
          if (s.contains(g.target)) {
            m();
            const y = t.vnode.el, { left: w } = y.getBoundingClientRect(), { offsetWidth: b, offsetHeight: C } = y, _ = g.clientX - w, k = s.offsetTop, O = k + s.offsetHeight;
            u.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${_} ${k} L${b} 0 V${k} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${_} ${O} L${b} ${C} V${O} Z" />
        `;
          } else
            l || (l = window.setTimeout(v, a.config.hoverThreshold));
      }, m = () => {
        !l || (clearTimeout(l), l = null);
      }, v = () => {
        !u.value || (u.value.innerHTML = "", m());
      };
      return {
        ns: n,
        panel: a,
        hoverZone: u,
        isEmpty: c,
        isLoading: f,
        menuId: d,
        t: o,
        handleExpand: p,
        handleMouseMove: h,
        clearHoverZone: v
      };
    }
  });
  function dH(e, t, n, o, r, s) {
    const l = Qe("el-cascader-node"), a = Qe("loading"), u = Qe("el-icon"), c = Qe("el-scrollbar");
    return S(), ie(c, {
      key: e.menuId,
      tag: "ul",
      role: "menu",
      class: $(e.ns.b()),
      "wrap-class": e.ns.e("wrap"),
      "view-class": [e.ns.e("list"), e.ns.is("empty", e.isEmpty)],
      onMousemove: e.handleMouseMove,
      onMouseleave: e.clearHoverZone
    }, {
      default: X(() => {
        var f;
        return [
          (S(!0), V(ze, null, gt(e.nodes, (d) => (S(), ie(l, {
            key: d.uid,
            node: d,
            "menu-id": e.menuId,
            onExpand: e.handleExpand
          }, null, 8, ["node", "menu-id", "onExpand"]))), 128)),
          e.isLoading ? (S(), V("div", {
            key: 0,
            class: $(e.ns.e("empty-text"))
          }, [
            K(u, {
              size: "14",
              class: $(e.ns.is("loading"))
            }, {
              default: X(() => [
                K(a)
              ]),
              _: 1
            }, 8, ["class"]),
            wt(" " + Ne(e.t("el.cascader.loading")), 1)
          ], 2)) : e.isEmpty ? (S(), V("div", {
            key: 1,
            class: $(e.ns.e("empty-text"))
          }, Ne(e.t("el.cascader.noData")), 3)) : (f = e.panel) != null && f.isHoverMenu ? (S(), V("svg", {
            key: 2,
            ref: "hoverZone",
            class: $(e.ns.e("hover-zone"))
          }, null, 2)) : se("v-if", !0)
        ];
      }),
      _: 1
    }, 8, ["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"]);
  }
  var fH = /* @__PURE__ */ Me(cH, [["render", dH], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/menu.vue"]]);
  let pH = 0;
  const hH = (e) => {
    const t = [e];
    let { parent: n } = e;
    for (; n; )
      t.unshift(n), n = n.parent;
    return t;
  };
  class Al {
    constructor(t, n, o, r = !1) {
      this.data = t, this.config = n, this.parent = o, this.root = r, this.uid = pH++, this.checked = !1, this.indeterminate = !1, this.loading = !1;
      const { value: s, label: l, children: a } = n, u = t[a], c = hH(this);
      this.level = r ? 0 : o ? o.level + 1 : 1, this.value = t[s], this.label = t[l], this.pathNodes = c, this.pathValues = c.map((f) => f.value), this.pathLabels = c.map((f) => f.label), this.childrenData = u, this.children = (u || []).map((f) => new Al(f, n, this)), this.loaded = !n.lazy || this.isLeaf || !Qn(u);
    }
    get isDisabled() {
      const { data: t, parent: n, config: o } = this, { disabled: r, checkStrictly: s } = o;
      return (Ge(r) ? r(t, this) : !!t[r]) || !s && (n == null ? void 0 : n.isDisabled);
    }
    get isLeaf() {
      const { data: t, config: n, childrenData: o, loaded: r } = this, { lazy: s, leaf: l } = n, a = Ge(l) ? l(t, this) : t[l];
      return pn(a) ? s && !r ? !1 : !(Array.isArray(o) && o.length) : !!a;
    }
    get valueByOption() {
      return this.config.emitPath ? this.pathValues : this.value;
    }
    appendChild(t) {
      const { childrenData: n, children: o } = this, r = new Al(t, this.config, this);
      return Array.isArray(n) ? n.push(t) : this.childrenData = [t], o.push(r), r;
    }
    calcText(t, n) {
      const o = t ? this.pathLabels.join(n) : this.label;
      return this.text = o, o;
    }
    broadcast(t, ...n) {
      const o = `onParent${Po(t)}`;
      this.children.forEach((r) => {
        r && (r.broadcast(t, ...n), r[o] && r[o](...n));
      });
    }
    emit(t, ...n) {
      const { parent: o } = this, r = `onChild${Po(t)}`;
      o && (o[r] && o[r](...n), o.emit(t, ...n));
    }
    onParentCheck(t) {
      this.isDisabled || this.setCheckState(t);
    }
    onChildCheck() {
      const { children: t } = this, n = t.filter((r) => !r.isDisabled), o = n.length ? n.every((r) => r.checked) : !1;
      this.setCheckState(o);
    }
    setCheckState(t) {
      const n = this.children.length, o = this.children.reduce((r, s) => {
        const l = s.checked ? 1 : s.indeterminate ? 0.5 : 0;
        return r + l;
      }, 0);
      this.checked = this.loaded && this.children.filter((r) => !r.isDisabled).every((r) => r.loaded && r.checked) && t, this.indeterminate = this.loaded && o !== n && o > 0;
    }
    doCheck(t) {
      if (this.checked === t)
        return;
      const { checkStrictly: n, multiple: o } = this.config;
      n || !o ? this.checked = t : (this.broadcast("check", t), this.setCheckState(t), this.emit("check"));
    }
  }
  const Qf = (e, t) => e.reduce((n, o) => (o.isLeaf ? n.push(o) : (!t && n.push(o), n = n.concat(Qf(o.children, t))), n), []);
  class dy {
    constructor(t, n) {
      this.config = n;
      const o = (t || []).map((r) => new Al(r, this.config));
      this.nodes = o, this.allNodes = Qf(o, !1), this.leafNodes = Qf(o, !0);
    }
    getNodes() {
      return this.nodes;
    }
    getFlattedNodes(t) {
      return t ? this.leafNodes : this.allNodes;
    }
    appendNode(t, n) {
      const o = n ? n.appendChild(t) : new Al(t, this.config);
      n || this.nodes.push(o), this.allNodes.push(o), o.isLeaf && this.leafNodes.push(o);
    }
    appendNodes(t, n) {
      t.forEach((o) => this.appendNode(o, n));
    }
    getNodeByValue(t, n = !1) {
      return !t && t !== 0 ? null : this.getFlattedNodes(n).find((r) => qn(r.value, t) || qn(r.pathValues, t)) || null;
    }
    getSameNode(t) {
      return t && this.getFlattedNodes(!1).find(({ value: o, level: r }) => qn(t.value, o) && t.level === r) || null;
    }
  }
  const GC = Ie({
    modelValue: {
      type: le([Number, String, Array])
    },
    options: {
      type: le(Array),
      default: () => []
    },
    props: {
      type: le(Object),
      default: () => ({})
    }
  }), vH = {
    expandTrigger: "click",
    multiple: !1,
    checkStrictly: !1,
    emitPath: !0,
    lazy: !1,
    lazyLoad: Nt,
    value: "value",
    label: "label",
    children: "children",
    leaf: "leaf",
    disabled: "disabled",
    hoverThreshold: 500
  }, mH = (e) => E(() => ({
    ...vH,
    ...e.props
  })), fy = (e) => {
    if (!e)
      return 0;
    const t = e.id.split("-");
    return Number(t[t.length - 2]);
  }, gH = (e) => {
    if (!e)
      return;
    const t = e.querySelector("input");
    t ? t.click() : s1(e) && e.click();
  }, yH = (e, t) => {
    const n = t.slice(0), o = n.map((s) => s.uid), r = e.reduce((s, l) => {
      const a = o.indexOf(l.uid);
      return a > -1 && (s.push(l), n.splice(a, 1), o.splice(a, 1)), s;
    }, []);
    return r.push(...n), r;
  }, bH = G({
    name: "ElCascaderPanel",
    components: {
      ElCascaderMenu: fH
    },
    props: {
      ...GC,
      border: {
        type: Boolean,
        default: !0
      },
      renderLabel: Function
    },
    emits: [dt, Ft, "close", "expand-change"],
    setup(e, { emit: t, slots: n }) {
      let o = !1;
      const r = ge("cascader"), s = mH(e);
      let l = null;
      const a = I(!0), u = I([]), c = I(null), f = I([]), d = I(null), p = I([]), h = E(() => s.value.expandTrigger === "hover"), m = E(() => e.renderLabel || n.default), v = () => {
        const { options: D } = e, B = s.value;
        o = !1, l = new dy(D, B), f.value = [l.getNodes()], B.lazy && Qn(e.options) ? (a.value = !1, g(void 0, (F) => {
          F && (l = new dy(F, B), f.value = [l.getNodes()]), a.value = !0, T(!1, !0);
        })) : T(!1, !0);
      }, g = (D, B) => {
        const F = s.value;
        D = D || new Al({}, F, void 0, !0), D.loading = !0;
        const W = (x) => {
          const N = D, R = N.root ? null : N;
          x && (l == null || l.appendNodes(x, R)), N.loading = !1, N.loaded = !0, N.childrenData = N.childrenData || [], B && B(x);
        };
        F.lazyLoad(D, W);
      }, y = (D, B) => {
        var F;
        const { level: W } = D, x = f.value.slice(0, W);
        let N;
        D.isLeaf ? N = D.pathNodes[W - 2] : (N = D, x.push(D.children)), ((F = d.value) == null ? void 0 : F.uid) !== (N == null ? void 0 : N.uid) && (d.value = D, f.value = x, !B && t("expand-change", (D == null ? void 0 : D.pathValues) || []));
      }, w = (D, B, F = !0) => {
        const { checkStrictly: W, multiple: x } = s.value, N = p.value[0];
        o = !0, !x && (N == null || N.doCheck(!1)), D.doCheck(B), O(), F && !x && !W && t("close"), !F && !x && !W && b(D);
      }, b = (D) => {
        !D || (D = D.parent, b(D), D && y(D));
      }, C = (D) => l == null ? void 0 : l.getFlattedNodes(D), _ = (D) => {
        var B;
        return (B = C(D)) == null ? void 0 : B.filter((F) => F.checked !== !1);
      }, k = () => {
        p.value.forEach((D) => D.doCheck(!1)), O(), f.value = f.value.slice(0, 1), d.value = null, t("expand-change", []);
      }, O = () => {
        var D;
        const { checkStrictly: B, multiple: F } = s.value, W = p.value, x = _(!B), N = yH(W, x), R = N.map((M) => M.valueByOption);
        p.value = N, c.value = F ? R : (D = R[0]) != null ? D : null;
      }, T = (D = !1, B = !1) => {
        const { modelValue: F } = e, { lazy: W, multiple: x, checkStrictly: N } = s.value, R = !N;
        if (!(!a.value || o || !B && qn(F, c.value)))
          if (W && !D) {
            const j = pg(wP(or(F))).map((te) => l == null ? void 0 : l.getNodeByValue(te)).filter((te) => !!te && !te.loaded && !te.loading);
            j.length ? j.forEach((te) => {
              g(te, () => T(!1, B));
            }) : T(!0, B);
          } else {
            const M = x ? or(F) : [F], j = pg(M.map((te) => l == null ? void 0 : l.getNodeByValue(te, R)));
            P(j, B), c.value = bh(F);
          }
      }, P = (D, B = !0) => {
        const { checkStrictly: F } = s.value, W = p.value, x = D.filter((M) => !!M && (F || M.isLeaf)), N = l == null ? void 0 : l.getSameNode(d.value), R = B && N || x[0];
        R ? R.pathNodes.forEach((M) => y(M, !0)) : d.value = null, W.forEach((M) => M.doCheck(!1)), x.forEach((M) => M.doCheck(!0)), p.value = x, Fe(A);
      }, A = () => {
        !bt || u.value.forEach((D) => {
          const B = D == null ? void 0 : D.$el;
          if (B) {
            const F = B.querySelector(`.${r.namespace.value}-scrollbar__wrap`), W = B.querySelector(`.${r.b("node")}.${r.is("active")}`) || B.querySelector(`.${r.b("node")}.in-active-path`);
            G1(F, W);
          }
        });
      }, L = (D) => {
        const B = D.target, { code: F } = D;
        switch (F) {
          case We.up:
          case We.down: {
            D.preventDefault();
            const W = F === We.up ? -1 : 1;
            au(l1(B, W, `.${r.b("node")}[tabindex="-1"]`));
            break;
          }
          case We.left: {
            D.preventDefault();
            const W = u.value[fy(B) - 1], x = W == null ? void 0 : W.$el.querySelector(`.${r.b("node")}[aria-expanded="true"]`);
            au(x);
            break;
          }
          case We.right: {
            D.preventDefault();
            const W = u.value[fy(B) + 1], x = W == null ? void 0 : W.$el.querySelector(`.${r.b("node")}[tabindex="-1"]`);
            au(x);
            break;
          }
          case We.enter:
            gH(B);
            break;
        }
      };
      return pt(Yh, Tt({
        config: s,
        expandingNode: d,
        checkedNodes: p,
        isHoverMenu: h,
        initialLoaded: a,
        renderLabelFn: m,
        lazyLoad: g,
        expandNode: y,
        handleCheckChange: w
      })), me([s, () => e.options], v, {
        deep: !0,
        immediate: !0
      }), me(() => e.modelValue, () => {
        o = !1, T();
      }, {
        deep: !0
      }), me(() => c.value, (D) => {
        qn(D, e.modelValue) || (t(dt, D), t(Ft, D));
      }), _0(() => u.value = []), st(() => !Qn(e.modelValue) && T()), {
        ns: r,
        menuList: u,
        menus: f,
        checkedNodes: p,
        handleKeyDown: L,
        handleCheckChange: w,
        getFlattedNodes: C,
        getCheckedNodes: _,
        clearCheckedNodes: k,
        calculateCheckedValue: O,
        scrollToExpandingNode: A
      };
    }
  });
  function wH(e, t, n, o, r, s) {
    const l = Qe("el-cascader-menu");
    return S(), V("div", {
      class: $([e.ns.b("panel"), e.ns.is("bordered", e.border)]),
      onKeydown: t[0] || (t[0] = (...a) => e.handleKeyDown && e.handleKeyDown(...a))
    }, [
      (S(!0), V(ze, null, gt(e.menus, (a, u) => (S(), ie(l, {
        key: u,
        ref_for: !0,
        ref: (c) => e.menuList[u] = c,
        index: u,
        nodes: [...a]
      }, null, 8, ["index", "nodes"]))), 128))
    ], 34);
  }
  var mu = /* @__PURE__ */ Me(bH, [["render", wH], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue"]]);
  mu.install = (e) => {
    e.component(mu.name, mu);
  };
  const XC = mu, CH = XC, Gh = Ie({
    closable: Boolean,
    type: {
      type: String,
      values: ["success", "info", "warning", "danger", ""],
      default: ""
    },
    hit: Boolean,
    disableTransitions: Boolean,
    color: {
      type: String,
      default: ""
    },
    size: {
      type: String,
      values: zo,
      default: ""
    },
    effect: {
      type: String,
      values: ["dark", "light", "plain"],
      default: "light"
    },
    round: Boolean
  }), EH = {
    close: (e) => e instanceof MouseEvent,
    click: (e) => e instanceof MouseEvent
  }, SH = G({
    name: "ElTag"
  }), _H = /* @__PURE__ */ G({
    ...SH,
    props: Gh,
    emits: EH,
    setup(e, { emit: t }) {
      const n = e, o = on(), r = ge("tag"), s = E(() => {
        const { type: u, hit: c, effect: f, closable: d, round: p } = n;
        return [
          r.b(),
          r.is("closable", d),
          r.m(u),
          r.m(o.value),
          r.m(f),
          r.is("hit", c),
          r.is("round", p)
        ];
      }), l = (u) => {
        t("close", u);
      }, a = (u) => {
        t("click", u);
      };
      return (u, c) => u.disableTransitions ? (S(), V("span", {
        key: 0,
        class: $(i(s)),
        style: Ke({ backgroundColor: u.color }),
        onClick: a
      }, [
        H("span", {
          class: $(i(r).e("content"))
        }, [
          he(u.$slots, "default")
        ], 2),
        u.closable ? (S(), ie(i(He), {
          key: 0,
          class: $(i(r).e("close")),
          onClick: Ze(l, ["stop"])
        }, {
          default: X(() => [
            K(i(_o))
          ]),
          _: 1
        }, 8, ["class", "onClick"])) : se("v-if", !0)
      ], 6)) : (S(), ie(Qt, {
        key: 1,
        name: `${i(r).namespace.value}-zoom-in-center`,
        appear: ""
      }, {
        default: X(() => [
          H("span", {
            class: $(i(s)),
            style: Ke({ backgroundColor: u.color }),
            onClick: a
          }, [
            H("span", {
              class: $(i(r).e("content"))
            }, [
              he(u.$slots, "default")
            ], 2),
            u.closable ? (S(), ie(i(He), {
              key: 0,
              class: $(i(r).e("close")),
              onClick: Ze(l, ["stop"])
            }, {
              default: X(() => [
                K(i(_o))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : se("v-if", !0)
          ], 6)
        ]),
        _: 3
      }, 8, ["name"]));
    }
  });
  var kH = /* @__PURE__ */ Me(_H, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
  const Xa = ut(kH), $H = Ie({
    ...GC,
    size: yn,
    placeholder: String,
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    filterMethod: {
      type: le(Function),
      default: (e, t) => e.text.includes(t)
    },
    separator: {
      type: String,
      default: " / "
    },
    showAllLevels: {
      type: Boolean,
      default: !0
    },
    collapseTags: Boolean,
    collapseTagsTooltip: {
      type: Boolean,
      default: !1
    },
    debounce: {
      type: Number,
      default: 300
    },
    beforeFilter: {
      type: le(Function),
      default: () => !0
    },
    popperClass: {
      type: String,
      default: ""
    },
    teleported: dn.teleported,
    tagType: { ...Gh.type, default: "info" },
    validateEvent: {
      type: Boolean,
      default: !0
    }
  }), NH = {
    [dt]: (e) => !!e || e === null,
    [Ft]: (e) => !!e || e === null,
    focus: (e) => e instanceof FocusEvent,
    blur: (e) => e instanceof FocusEvent,
    visibleChange: (e) => tn(e),
    expandChange: (e) => !!e,
    removeTag: (e) => !!e
  }, TH = { key: 0 }, OH = ["placeholder", "onKeydown"], MH = ["onClick"], IH = "ElCascader", PH = G({
    name: IH
  }), AH = /* @__PURE__ */ G({
    ...PH,
    props: $H,
    emits: NH,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = {
        modifiers: [
          {
            name: "arrowPosition",
            enabled: !0,
            phase: "main",
            fn: ({ state: ue }) => {
              const { modifiersData: q, placement: oe } = ue;
              ["right", "left", "bottom", "top"].includes(oe) || (q.arrow.x = 35);
            },
            requires: ["arrow"]
          }
        ]
      }, s = zl();
      let l = 0, a = 0;
      const u = ge("cascader"), c = ge("input"), { t: f } = St(), { form: d, formItem: p } = In(), h = I(null), m = I(null), v = I(null), g = I(null), y = I(null), w = I(!1), b = I(!1), C = I(!1), _ = I(!1), k = I(""), O = I(""), T = I([]), P = I([]), A = I([]), L = I(!1), D = E(() => s.style), B = E(() => o.disabled || (d == null ? void 0 : d.disabled)), F = E(() => o.placeholder || f("el.cascader.placeholder")), W = E(() => O.value || T.value.length > 0 || L.value ? "" : F.value), x = on(), N = E(() => ["small"].includes(x.value) ? "small" : "default"), R = E(() => !!o.props.multiple), M = E(() => !o.filterable || R.value), j = E(() => R.value ? O.value : k.value), te = E(() => {
        var ue;
        return ((ue = g.value) == null ? void 0 : ue.checkedNodes) || [];
      }), U = E(() => !o.clearable || B.value || C.value || !b.value ? !1 : !!te.value.length), Z = E(() => {
        const { showAllLevels: ue, separator: q } = o, oe = te.value;
        return oe.length ? R.value ? "" : oe[0].calcText(ue, q) : "";
      }), pe = E({
        get() {
          return bh(o.modelValue);
        },
        set(ue) {
          n(dt, ue), n(Ft, ue), o.validateEvent && (p == null || p.validate("change").catch((q) => yt(q)));
        }
      }), J = E(() => [
        u.b(),
        u.m(x.value),
        u.is("disabled", B.value),
        s.class
      ]), ee = E(() => [
        c.e("icon"),
        "icon-arrow-down",
        u.is("reverse", w.value)
      ]), ne = E(() => u.is("focus", w.value || _.value)), Y = E(() => {
        var ue, q;
        return (q = (ue = h.value) == null ? void 0 : ue.popperRef) == null ? void 0 : q.contentRef;
      }), re = (ue) => {
        var q, oe, be;
        B.value || (ue = ue != null ? ue : !w.value, ue !== w.value && (w.value = ue, (oe = (q = m.value) == null ? void 0 : q.input) == null || oe.setAttribute("aria-expanded", `${ue}`), ue ? (ce(), Fe((be = g.value) == null ? void 0 : be.scrollToExpandingNode)) : o.filterable && Re(), n("visibleChange", ue)));
      }, ce = () => {
        Fe(() => {
          var ue;
          (ue = h.value) == null || ue.updatePopper();
        });
      }, Te = () => {
        C.value = !1;
      }, Pe = (ue) => {
        const { showAllLevels: q, separator: oe } = o;
        return {
          node: ue,
          key: ue.uid,
          text: ue.calcText(q, oe),
          hitState: !1,
          closable: !B.value && !ue.isDisabled,
          isCollapseTag: !1
        };
      }, z = (ue) => {
        var q;
        const oe = ue.node;
        oe.doCheck(!1), (q = g.value) == null || q.calculateCheckedValue(), n("removeTag", oe.valueByOption);
      }, Q = () => {
        if (!R.value)
          return;
        const ue = te.value, q = [], oe = [];
        if (ue.forEach((be) => oe.push(Pe(be))), P.value = oe, ue.length) {
          const [be, ...xe] = ue, nt = xe.length;
          q.push(Pe(be)), nt && (o.collapseTags ? q.push({
            key: -1,
            text: `+ ${nt}`,
            closable: !1,
            isCollapseTag: !0
          }) : xe.forEach((ve) => q.push(Pe(ve))));
        }
        T.value = q;
      }, de = () => {
        var ue, q;
        const { filterMethod: oe, showAllLevels: be, separator: xe } = o, nt = (q = (ue = g.value) == null ? void 0 : ue.getFlattedNodes(!o.props.checkStrictly)) == null ? void 0 : q.filter((ve) => ve.isDisabled ? !1 : (ve.calcText(be, xe), oe(ve, j.value)));
        R.value && (T.value.forEach((ve) => {
          ve.hitState = !1;
        }), P.value.forEach((ve) => {
          ve.hitState = !1;
        })), C.value = !0, A.value = nt, ce();
      }, Oe = () => {
        var ue;
        let q;
        C.value && y.value ? q = y.value.$el.querySelector(`.${u.e("suggestion-item")}`) : q = (ue = g.value) == null ? void 0 : ue.$el.querySelector(`.${u.b("node")}[tabindex="-1"]`), q && (q.focus(), !C.value && q.click());
      }, ae = () => {
        var ue, q;
        const oe = (ue = m.value) == null ? void 0 : ue.input, be = v.value, xe = (q = y.value) == null ? void 0 : q.$el;
        if (!(!bt || !oe)) {
          if (xe) {
            const nt = xe.querySelector(`.${u.e("suggestion-list")}`);
            nt.style.minWidth = `${oe.offsetWidth}px`;
          }
          if (be) {
            const { offsetHeight: nt } = be, ve = T.value.length > 0 ? `${Math.max(nt + 6, l)}px` : `${l}px`;
            oe.style.height = ve, ce();
          }
        }
      }, Ee = (ue) => {
        var q;
        return (q = g.value) == null ? void 0 : q.getCheckedNodes(ue);
      }, we = (ue) => {
        ce(), n("expandChange", ue);
      }, Se = (ue) => {
        var q;
        const oe = (q = ue.target) == null ? void 0 : q.value;
        if (ue.type === "compositionend")
          L.value = !1, Fe(() => Ce(oe));
        else {
          const be = oe[oe.length - 1] || "";
          L.value = !Kc(be);
        }
      }, _e = (ue) => {
        if (!L.value)
          switch (ue.code) {
            case We.enter:
              re();
              break;
            case We.down:
              re(!0), Fe(Oe), ue.preventDefault();
              break;
            case We.esc:
              w.value === !0 && (ue.preventDefault(), ue.stopPropagation(), re(!1));
              break;
            case We.tab:
              re(!1);
              break;
          }
      }, ke = () => {
        var ue;
        (ue = g.value) == null || ue.clearCheckedNodes(), !w.value && o.filterable && Re(), re(!1);
      }, Re = () => {
        const { value: ue } = Z;
        k.value = ue, O.value = ue;
      }, fe = (ue) => {
        var q, oe;
        const { checked: be } = ue;
        R.value ? (q = g.value) == null || q.handleCheckChange(ue, !be, !1) : (!be && ((oe = g.value) == null || oe.handleCheckChange(ue, !0, !1)), re(!1));
      }, Ae = (ue) => {
        const q = ue.target, { code: oe } = ue;
        switch (oe) {
          case We.up:
          case We.down: {
            const be = oe === We.up ? -1 : 1;
            au(l1(q, be, `.${u.e("suggestion-item")}[tabindex="-1"]`));
            break;
          }
          case We.enter:
            q.click();
            break;
        }
      }, qe = () => {
        const ue = T.value, q = ue[ue.length - 1];
        a = O.value ? 0 : a + 1, !(!q || !a || o.collapseTags && ue.length > 1) && (q.hitState ? z(q) : q.hitState = !0);
      }, tt = (ue) => {
        const q = ue.target, oe = u.e("search-input");
        q.className === oe && (_.value = !0), n("focus", ue);
      }, Je = (ue) => {
        _.value = !1, n("blur", ue);
      }, ye = On(() => {
        const { value: ue } = j;
        if (!ue)
          return;
        const q = o.beforeFilter(ue);
        yl(q) ? q.then(de).catch(() => {
        }) : q !== !1 ? de() : Te();
      }, o.debounce), Ce = (ue, q) => {
        !w.value && re(!0), !(q != null && q.isComposing) && (ue ? ye() : Te());
      };
      return me(C, ce), me([te, B], Q), me(T, () => {
        Fe(() => ae());
      }), me(Z, Re, { immediate: !0 }), st(() => {
        const ue = m.value.input, q = Number.parseFloat(mN(c.cssVarName("input-height"), ue).value) - 2;
        l = ue.offsetHeight || q, Cn(ue, ae);
      }), t({
        getCheckedNodes: Ee,
        cascaderPanelRef: g,
        togglePopperVisible: re,
        contentRef: Y
      }), (ue, q) => (S(), ie(i(Mn), {
        ref_key: "tooltipRef",
        ref: h,
        visible: w.value,
        teleported: ue.teleported,
        "popper-class": [i(u).e("dropdown"), ue.popperClass],
        "popper-options": r,
        "fallback-placements": [
          "bottom-start",
          "bottom",
          "top-start",
          "top",
          "right",
          "left"
        ],
        "stop-popper-mouse-event": !1,
        "gpu-acceleration": !1,
        placement: "bottom-start",
        transition: `${i(u).namespace.value}-zoom-in-top`,
        effect: "light",
        pure: "",
        persistent: "",
        onHide: Te
      }, {
        default: X(() => [
          ot((S(), V("div", {
            class: $(i(J)),
            style: Ke(i(D)),
            onClick: q[5] || (q[5] = () => re(i(M) ? void 0 : !0)),
            onKeydown: _e,
            onMouseenter: q[6] || (q[6] = (oe) => b.value = !0),
            onMouseleave: q[7] || (q[7] = (oe) => b.value = !1)
          }, [
            K(i(wn), {
              ref_key: "input",
              ref: m,
              modelValue: k.value,
              "onUpdate:modelValue": q[1] || (q[1] = (oe) => k.value = oe),
              placeholder: i(W),
              readonly: i(M),
              disabled: i(B),
              "validate-event": !1,
              size: i(x),
              class: $(i(ne)),
              tabindex: i(R) && ue.filterable && !i(B) ? -1 : void 0,
              onCompositionstart: Se,
              onCompositionupdate: Se,
              onCompositionend: Se,
              onFocus: tt,
              onBlur: Je,
              onInput: Ce
            }, {
              suffix: X(() => [
                i(U) ? (S(), ie(i(He), {
                  key: "clear",
                  class: $([i(c).e("icon"), "icon-circle-close"]),
                  onClick: Ze(ke, ["stop"])
                }, {
                  default: X(() => [
                    K(i(Yr))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : (S(), ie(i(He), {
                  key: "arrow-down",
                  class: $(i(ee)),
                  onClick: q[0] || (q[0] = Ze((oe) => re(), ["stop"]))
                }, {
                  default: X(() => [
                    K(i(qr))
                  ]),
                  _: 1
                }, 8, ["class"]))
              ]),
              _: 1
            }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "tabindex"]),
            i(R) ? (S(), V("div", {
              key: 0,
              ref_key: "tagWrapper",
              ref: v,
              class: $(i(u).e("tags"))
            }, [
              (S(!0), V(ze, null, gt(T.value, (oe) => (S(), ie(i(Xa), {
                key: oe.key,
                type: ue.tagType,
                size: i(N),
                hit: oe.hitState,
                closable: oe.closable,
                "disable-transitions": "",
                onClose: (be) => z(oe)
              }, {
                default: X(() => [
                  oe.isCollapseTag === !1 ? (S(), V("span", TH, Ne(oe.text), 1)) : (S(), ie(i(Mn), {
                    key: 1,
                    disabled: w.value || !ue.collapseTagsTooltip,
                    "fallback-placements": ["bottom", "top", "right", "left"],
                    placement: "bottom",
                    effect: "light"
                  }, {
                    default: X(() => [
                      H("span", null, Ne(oe.text), 1)
                    ]),
                    content: X(() => [
                      H("div", {
                        class: $(i(u).e("collapse-tags"))
                      }, [
                        (S(!0), V(ze, null, gt(P.value.slice(1), (be, xe) => (S(), V("div", {
                          key: xe,
                          class: $(i(u).e("collapse-tag"))
                        }, [
                          (S(), ie(i(Xa), {
                            key: be.key,
                            class: "in-tooltip",
                            type: ue.tagType,
                            size: i(N),
                            hit: be.hitState,
                            closable: be.closable,
                            "disable-transitions": "",
                            onClose: (nt) => z(be)
                          }, {
                            default: X(() => [
                              H("span", null, Ne(be.text), 1)
                            ]),
                            _: 2
                          }, 1032, ["type", "size", "hit", "closable", "onClose"]))
                        ], 2))), 128))
                      ], 2)
                    ]),
                    _: 2
                  }, 1032, ["disabled"]))
                ]),
                _: 2
              }, 1032, ["type", "size", "hit", "closable", "onClose"]))), 128)),
              ue.filterable && !i(B) ? ot((S(), V("input", {
                key: 0,
                "onUpdate:modelValue": q[2] || (q[2] = (oe) => O.value = oe),
                type: "text",
                class: $(i(u).e("search-input")),
                placeholder: i(Z) ? "" : i(F),
                onInput: q[3] || (q[3] = (oe) => Ce(O.value, oe)),
                onClick: q[4] || (q[4] = Ze((oe) => re(!0), ["stop"])),
                onKeydown: Et(qe, ["delete"]),
                onCompositionstart: Se,
                onCompositionupdate: Se,
                onCompositionend: Se,
                onFocus: tt,
                onBlur: Je
              }, null, 42, OH)), [
                [th, O.value]
              ]) : se("v-if", !0)
            ], 2)) : se("v-if", !0)
          ], 38)), [
            [i(Kr), () => re(!1), i(Y)]
          ])
        ]),
        content: X(() => [
          ot(K(i(XC), {
            ref_key: "cascaderPanelRef",
            ref: g,
            modelValue: i(pe),
            "onUpdate:modelValue": q[8] || (q[8] = (oe) => Pt(pe) ? pe.value = oe : null),
            options: ue.options,
            props: o.props,
            border: !1,
            "render-label": ue.$slots.default,
            onExpandChange: we,
            onClose: q[9] || (q[9] = (oe) => ue.$nextTick(() => re(!1)))
          }, null, 8, ["modelValue", "options", "props", "render-label"]), [
            [$t, !C.value]
          ]),
          ue.filterable ? ot((S(), ie(i(pr), {
            key: 0,
            ref_key: "suggestionPanel",
            ref: y,
            tag: "ul",
            class: $(i(u).e("suggestion-panel")),
            "view-class": i(u).e("suggestion-list"),
            onKeydown: Ae
          }, {
            default: X(() => [
              A.value.length ? (S(!0), V(ze, { key: 0 }, gt(A.value, (oe) => (S(), V("li", {
                key: oe.uid,
                class: $([
                  i(u).e("suggestion-item"),
                  i(u).is("checked", oe.checked)
                ]),
                tabindex: -1,
                onClick: (be) => fe(oe)
              }, [
                H("span", null, Ne(oe.text), 1),
                oe.checked ? (S(), ie(i(He), { key: 0 }, {
                  default: X(() => [
                    K(i(wi))
                  ]),
                  _: 1
                })) : se("v-if", !0)
              ], 10, MH))), 128)) : he(ue.$slots, "empty", { key: 1 }, () => [
                H("li", {
                  class: $(i(u).e("empty-text"))
                }, Ne(i(f)("el.cascader.noMatch")), 3)
              ])
            ]),
            _: 3
          }, 8, ["class", "view-class"])), [
            [$t, C.value]
          ]) : se("v-if", !0)
        ]),
        _: 3
      }, 8, ["visible", "teleported", "popper-class", "transition"]));
    }
  });
  var gu = /* @__PURE__ */ Me(AH, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader/src/cascader.vue"]]);
  gu.install = (e) => {
    e.component(gu.name, gu);
  };
  const RH = gu, xH = RH, DH = Ie({
    checked: {
      type: Boolean,
      default: !1
    }
  }), LH = {
    "update:checked": (e) => tn(e),
    [Ft]: (e) => tn(e)
  }, VH = G({
    name: "ElCheckTag"
  }), BH = /* @__PURE__ */ G({
    ...VH,
    props: DH,
    emits: LH,
    setup(e, { emit: t }) {
      const n = e, o = ge("check-tag"), r = () => {
        const s = !n.checked;
        t(Ft, s), t("update:checked", s);
      };
      return (s, l) => (S(), V("span", {
        class: $([i(o).b(), i(o).is("checked", s.checked)]),
        onClick: r
      }, [
        he(s.$slots, "default")
      ], 2));
    }
  });
  var FH = /* @__PURE__ */ Me(BH, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/check-tag/src/check-tag.vue"]]);
  const HH = ut(FH), JC = Symbol("rowContextKey"), zH = [
    "start",
    "center",
    "end",
    "space-around",
    "space-between",
    "space-evenly"
  ], KH = ["top", "middle", "bottom"], jH = Ie({
    tag: {
      type: String,
      default: "div"
    },
    gutter: {
      type: Number,
      default: 0
    },
    justify: {
      type: String,
      values: zH,
      default: "start"
    },
    align: {
      type: String,
      values: KH,
      default: "top"
    }
  }), WH = G({
    name: "ElRow"
  }), UH = /* @__PURE__ */ G({
    ...WH,
    props: jH,
    setup(e) {
      const t = e, n = ge("row"), o = E(() => t.gutter);
      pt(JC, {
        gutter: o
      });
      const r = E(() => {
        const l = {};
        return t.gutter && (l.marginRight = l.marginLeft = `-${t.gutter / 2}px`), l;
      }), s = E(() => [
        n.b(),
        n.is(`justify-${t.justify}`, t.justify !== "start"),
        n.is(`align-${t.align}`, t.align !== "top")
      ]);
      return (l, a) => (S(), ie(vt(l.tag), {
        class: $(i(s)),
        style: Ke(i(r))
      }, {
        default: X(() => [
          he(l.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style"]));
    }
  });
  var qH = /* @__PURE__ */ Me(UH, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/row/src/row.vue"]]);
  const YH = ut(qH), GH = Ie({
    tag: {
      type: String,
      default: "div"
    },
    span: {
      type: Number,
      default: 24
    },
    offset: {
      type: Number,
      default: 0
    },
    pull: {
      type: Number,
      default: 0
    },
    push: {
      type: Number,
      default: 0
    },
    xs: {
      type: le([Number, Object]),
      default: () => jt({})
    },
    sm: {
      type: le([Number, Object]),
      default: () => jt({})
    },
    md: {
      type: le([Number, Object]),
      default: () => jt({})
    },
    lg: {
      type: le([Number, Object]),
      default: () => jt({})
    },
    xl: {
      type: le([Number, Object]),
      default: () => jt({})
    }
  }), XH = G({
    name: "ElCol"
  }), JH = /* @__PURE__ */ G({
    ...XH,
    props: GH,
    setup(e) {
      const t = e, { gutter: n } = Be(JC, { gutter: E(() => 0) }), o = ge("col"), r = E(() => {
        const l = {};
        return n.value && (l.paddingLeft = l.paddingRight = `${n.value / 2}px`), l;
      }), s = E(() => {
        const l = [];
        return ["span", "offset", "pull", "push"].forEach((c) => {
          const f = t[c];
          Xe(f) && (c === "span" ? l.push(o.b(`${t[c]}`)) : f > 0 && l.push(o.b(`${c}-${t[c]}`)));
        }), ["xs", "sm", "md", "lg", "xl"].forEach((c) => {
          Xe(t[c]) ? l.push(o.b(`${c}-${t[c]}`)) : rt(t[c]) && Object.entries(t[c]).forEach(([f, d]) => {
            l.push(f !== "span" ? o.b(`${c}-${f}-${d}`) : o.b(`${c}-${d}`));
          });
        }), n.value && l.push(o.is("guttered")), [o.b(), l];
      });
      return (l, a) => (S(), ie(vt(l.tag), {
        class: $(i(s)),
        style: Ke(i(r))
      }, {
        default: X(() => [
          he(l.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style"]));
    }
  });
  var ZH = /* @__PURE__ */ Me(JH, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/col/src/col.vue"]]);
  const QH = ut(ZH), py = (e) => typeof Xe(e), ez = Ie({
    accordion: Boolean,
    modelValue: {
      type: le([Array, String, Number]),
      default: () => jt([])
    }
  }), tz = {
    [dt]: py,
    [Ft]: py
  }, ZC = Symbol("collapseContextKey"), nz = (e, t) => {
    const n = I(kl(e.modelValue)), o = (s) => {
      n.value = s;
      const l = e.accordion ? n.value[0] : n.value;
      t(dt, l), t(Ft, l);
    }, r = (s) => {
      if (e.accordion)
        o([n.value[0] === s ? "" : s]);
      else {
        const l = [...n.value], a = l.indexOf(s);
        a > -1 ? l.splice(a, 1) : l.push(s), o(l);
      }
    };
    return me(() => e.modelValue, () => n.value = kl(e.modelValue), { deep: !0 }), pt(ZC, {
      activeNames: n,
      handleItemClick: r
    }), {
      activeNames: n,
      setActiveNames: o
    };
  }, oz = () => {
    const e = ge("collapse");
    return {
      rootKls: E(() => e.b())
    };
  }, rz = G({
    name: "ElCollapse"
  }), sz = /* @__PURE__ */ G({
    ...rz,
    props: ez,
    emits: tz,
    setup(e, { expose: t, emit: n }) {
      const o = e, { activeNames: r, setActiveNames: s } = nz(o, n), { rootKls: l } = oz();
      return t({
        activeNames: r,
        setActiveNames: s
      }), (a, u) => (S(), V("div", {
        class: $(i(l)),
        role: "tablist",
        "aria-multiselectable": "true"
      }, [
        he(a.$slots, "default")
      ], 2));
    }
  });
  var lz = /* @__PURE__ */ Me(sz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse.vue"]]);
  const az = G({
    name: "ElCollapseTransition"
  }), iz = /* @__PURE__ */ G({
    ...az,
    setup(e) {
      const t = ge("collapse-transition"), n = {
        beforeEnter(o) {
          o.dataset || (o.dataset = {}), o.dataset.oldPaddingTop = o.style.paddingTop, o.dataset.oldPaddingBottom = o.style.paddingBottom, o.style.maxHeight = 0, o.style.paddingTop = 0, o.style.paddingBottom = 0;
        },
        enter(o) {
          o.dataset.oldOverflow = o.style.overflow, o.scrollHeight !== 0 ? (o.style.maxHeight = `${o.scrollHeight}px`, o.style.paddingTop = o.dataset.oldPaddingTop, o.style.paddingBottom = o.dataset.oldPaddingBottom) : (o.style.maxHeight = 0, o.style.paddingTop = o.dataset.oldPaddingTop, o.style.paddingBottom = o.dataset.oldPaddingBottom), o.style.overflow = "hidden";
        },
        afterEnter(o) {
          o.style.maxHeight = "", o.style.overflow = o.dataset.oldOverflow;
        },
        beforeLeave(o) {
          o.dataset || (o.dataset = {}), o.dataset.oldPaddingTop = o.style.paddingTop, o.dataset.oldPaddingBottom = o.style.paddingBottom, o.dataset.oldOverflow = o.style.overflow, o.style.maxHeight = `${o.scrollHeight}px`, o.style.overflow = "hidden";
        },
        leave(o) {
          o.scrollHeight !== 0 && (o.style.maxHeight = 0, o.style.paddingTop = 0, o.style.paddingBottom = 0);
        },
        afterLeave(o) {
          o.style.maxHeight = "", o.style.overflow = o.dataset.oldOverflow, o.style.paddingTop = o.dataset.oldPaddingTop, o.style.paddingBottom = o.dataset.oldPaddingBottom;
        }
      };
      return (o, r) => (S(), ie(Qt, ft({
        name: i(t).b()
      }, bk(n)), {
        default: X(() => [
          he(o.$slots, "default")
        ]),
        _: 3
      }, 16, ["name"]));
    }
  });
  var yu = /* @__PURE__ */ Me(iz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);
  yu.install = (e) => {
    e.component(yu.name, yu);
  };
  const ed = yu, uz = ed, cz = Ie({
    title: {
      type: String,
      default: ""
    },
    name: {
      type: le([String, Number]),
      default: () => Wc()
    },
    disabled: Boolean
  }), dz = (e) => {
    const t = Be(ZC), n = I(!1), o = I(!1), r = I(Wc()), s = E(() => t == null ? void 0 : t.activeNames.value.includes(e.name));
    return {
      focusing: n,
      id: r,
      isActive: s,
      handleFocus: () => {
        setTimeout(() => {
          o.value ? o.value = !1 : n.value = !0;
        }, 50);
      },
      handleHeaderClick: () => {
        e.disabled || (t == null || t.handleItemClick(e.name), n.value = !1, o.value = !0);
      },
      handleEnterClick: () => {
        t == null || t.handleItemClick(e.name);
      }
    };
  }, fz = (e, { focusing: t, isActive: n, id: o }) => {
    const r = ge("collapse"), s = E(() => [
      r.b("item"),
      r.is("active", i(n)),
      r.is("disabled", e.disabled)
    ]), l = E(() => [
      r.be("item", "header"),
      r.is("active", i(n)),
      { focusing: i(t) && !e.disabled }
    ]), a = E(() => [
      r.be("item", "arrow"),
      r.is("active", i(n))
    ]), u = E(() => r.be("item", "wrap")), c = E(() => r.be("item", "content")), f = E(() => r.b(`content-${i(o)}`)), d = E(() => r.b(`head-${i(o)}`));
    return {
      arrowKls: a,
      headKls: l,
      rootKls: s,
      itemWrapperKls: u,
      itemContentKls: c,
      scopedContentId: f,
      scopedHeadId: d
    };
  }, pz = ["aria-expanded", "aria-controls", "aria-describedby"], hz = ["id", "tabindex"], vz = ["id", "aria-hidden", "aria-labelledby"], mz = G({
    name: "ElCollapseItem"
  }), gz = /* @__PURE__ */ G({
    ...mz,
    props: cz,
    setup(e, { expose: t }) {
      const n = e, {
        focusing: o,
        id: r,
        isActive: s,
        handleFocus: l,
        handleHeaderClick: a,
        handleEnterClick: u
      } = dz(n), {
        arrowKls: c,
        headKls: f,
        rootKls: d,
        itemWrapperKls: p,
        itemContentKls: h,
        scopedContentId: m,
        scopedHeadId: v
      } = fz(n, { focusing: o, isActive: s, id: r });
      return t({
        isActive: s
      }), (g, y) => (S(), V("div", {
        class: $(i(d))
      }, [
        H("div", {
          role: "tab",
          "aria-expanded": i(s),
          "aria-controls": i(m),
          "aria-describedby": i(m)
        }, [
          H("div", {
            id: i(v),
            class: $(i(f)),
            role: "button",
            tabindex: g.disabled ? -1 : 0,
            onClick: y[0] || (y[0] = (...w) => i(a) && i(a)(...w)),
            onKeypress: y[1] || (y[1] = Et(Ze((...w) => i(u) && i(u)(...w), ["stop", "prevent"]), ["space", "enter"])),
            onFocus: y[2] || (y[2] = (...w) => i(l) && i(l)(...w)),
            onBlur: y[3] || (y[3] = (w) => o.value = !1)
          }, [
            he(g.$slots, "title", {}, () => [
              wt(Ne(g.title), 1)
            ]),
            K(i(He), {
              class: $(i(c))
            }, {
              default: X(() => [
                K(i(kn))
              ]),
              _: 1
            }, 8, ["class"])
          ], 42, hz)
        ], 8, pz),
        K(i(ed), null, {
          default: X(() => [
            ot(H("div", {
              id: i(m),
              class: $(i(p)),
              role: "tabpanel",
              "aria-hidden": !i(s),
              "aria-labelledby": i(v)
            }, [
              H("div", {
                class: $(i(h))
              }, [
                he(g.$slots, "default")
              ], 2)
            ], 10, vz), [
              [$t, i(s)]
            ])
          ]),
          _: 3
        })
      ], 2));
    }
  });
  var QC = /* @__PURE__ */ Me(gz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse-item.vue"]]);
  const yz = ut(lz, {
    CollapseItem: QC
  }), bz = Gt(QC), wz = Ie({
    color: {
      type: le(Object),
      required: !0
    },
    vertical: {
      type: Boolean,
      default: !1
    }
  });
  let Dd = !1;
  function Ja(e, t) {
    if (!bt)
      return;
    const n = function(s) {
      var l;
      (l = t.drag) == null || l.call(t, s);
    }, o = function(s) {
      var l;
      document.removeEventListener("mousemove", n), document.removeEventListener("mouseup", o), document.removeEventListener("touchmove", n), document.removeEventListener("touchend", o), document.onselectstart = null, document.ondragstart = null, Dd = !1, (l = t.end) == null || l.call(t, s);
    }, r = function(s) {
      var l;
      Dd || (s.preventDefault(), document.onselectstart = () => !1, document.ondragstart = () => !1, document.addEventListener("mousemove", n), document.addEventListener("mouseup", o), document.addEventListener("touchmove", n), document.addEventListener("touchend", o), Dd = !0, (l = t.start) == null || l.call(t, s));
    };
    e.addEventListener("mousedown", r), e.addEventListener("touchstart", r);
  }
  const Cz = (e) => {
    const t = it(), n = xt(), o = xt();
    function r(l) {
      l.target !== n.value && s(l);
    }
    function s(l) {
      if (!o.value || !n.value)
        return;
      const u = t.vnode.el.getBoundingClientRect(), { clientX: c, clientY: f } = rh(l);
      if (e.vertical) {
        let d = f - u.top;
        d = Math.max(n.value.offsetHeight / 2, d), d = Math.min(d, u.height - n.value.offsetHeight / 2), e.color.set("alpha", Math.round((d - n.value.offsetHeight / 2) / (u.height - n.value.offsetHeight) * 100));
      } else {
        let d = c - u.left;
        d = Math.max(n.value.offsetWidth / 2, d), d = Math.min(d, u.width - n.value.offsetWidth / 2), e.color.set("alpha", Math.round((d - n.value.offsetWidth / 2) / (u.width - n.value.offsetWidth) * 100));
      }
    }
    return {
      thumb: n,
      bar: o,
      handleDrag: s,
      handleClick: r
    };
  }, Ez = (e, {
    bar: t,
    thumb: n,
    handleDrag: o
  }) => {
    const r = it(), s = ge("color-alpha-slider"), l = I(0), a = I(0), u = I();
    function c() {
      if (!n.value || e.vertical)
        return 0;
      const w = r.vnode.el, b = e.color.get("alpha");
      return w ? Math.round(b * (w.offsetWidth - n.value.offsetWidth / 2) / 100) : 0;
    }
    function f() {
      if (!n.value)
        return 0;
      const w = r.vnode.el;
      if (!e.vertical)
        return 0;
      const b = e.color.get("alpha");
      return w ? Math.round(b * (w.offsetHeight - n.value.offsetHeight / 2) / 100) : 0;
    }
    function d() {
      if (e.color && e.color.value) {
        const { r: w, g: b, b: C } = e.color.toRgb();
        return `linear-gradient(to right, rgba(${w}, ${b}, ${C}, 0) 0%, rgba(${w}, ${b}, ${C}, 1) 100%)`;
      }
      return "";
    }
    function p() {
      l.value = c(), a.value = f(), u.value = d();
    }
    st(() => {
      if (!t.value || !n.value)
        return;
      const w = {
        drag: (b) => {
          o(b);
        },
        end: (b) => {
          o(b);
        }
      };
      Ja(t.value, w), Ja(n.value, w), p();
    }), me(() => e.color.get("alpha"), () => p()), me(() => e.color.value, () => p());
    const h = E(() => [s.b(), s.is("vertical", e.vertical)]), m = E(() => s.e("bar")), v = E(() => s.e("thumb")), g = E(() => ({ background: u.value })), y = E(() => ({
      left: Jt(l.value),
      top: Jt(a.value)
    }));
    return { rootKls: h, barKls: m, barStyle: g, thumbKls: v, thumbStyle: y, update: p };
  }, Sz = "ElColorAlphaSlider", _z = G({
    name: Sz
  }), kz = /* @__PURE__ */ G({
    ..._z,
    props: wz,
    setup(e, { expose: t }) {
      const n = e, { bar: o, thumb: r, handleDrag: s, handleClick: l } = Cz(n), { rootKls: a, barKls: u, barStyle: c, thumbKls: f, thumbStyle: d, update: p } = Ez(n, {
        bar: o,
        thumb: r,
        handleDrag: s
      });
      return t({
        update: p,
        bar: o,
        thumb: r
      }), (h, m) => (S(), V("div", {
        class: $(i(a))
      }, [
        H("div", {
          ref_key: "bar",
          ref: o,
          class: $(i(u)),
          style: Ke(i(c)),
          onClick: m[0] || (m[0] = (...v) => i(l) && i(l)(...v))
        }, null, 6),
        H("div", {
          ref_key: "thumb",
          ref: r,
          class: $(i(f)),
          style: Ke(i(d))
        }, null, 6)
      ], 2));
    }
  });
  var $z = /* @__PURE__ */ Me(kz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/alpha-slider.vue"]]);
  const Nz = G({
    name: "ElColorHueSlider",
    props: {
      color: {
        type: Object,
        required: !0
      },
      vertical: Boolean
    },
    setup(e) {
      const t = ge("color-hue-slider"), n = it(), o = I(), r = I(), s = I(0), l = I(0), a = E(() => e.color.get("hue"));
      me(() => a.value, () => {
        p();
      });
      function u(h) {
        h.target !== o.value && c(h);
      }
      function c(h) {
        if (!r.value || !o.value)
          return;
        const v = n.vnode.el.getBoundingClientRect(), { clientX: g, clientY: y } = rh(h);
        let w;
        if (e.vertical) {
          let b = y - v.top;
          b = Math.min(b, v.height - o.value.offsetHeight / 2), b = Math.max(o.value.offsetHeight / 2, b), w = Math.round((b - o.value.offsetHeight / 2) / (v.height - o.value.offsetHeight) * 360);
        } else {
          let b = g - v.left;
          b = Math.min(b, v.width - o.value.offsetWidth / 2), b = Math.max(o.value.offsetWidth / 2, b), w = Math.round((b - o.value.offsetWidth / 2) / (v.width - o.value.offsetWidth) * 360);
        }
        e.color.set("hue", w);
      }
      function f() {
        if (!o.value)
          return 0;
        const h = n.vnode.el;
        if (e.vertical)
          return 0;
        const m = e.color.get("hue");
        return h ? Math.round(m * (h.offsetWidth - o.value.offsetWidth / 2) / 360) : 0;
      }
      function d() {
        if (!o.value)
          return 0;
        const h = n.vnode.el;
        if (!e.vertical)
          return 0;
        const m = e.color.get("hue");
        return h ? Math.round(m * (h.offsetHeight - o.value.offsetHeight / 2) / 360) : 0;
      }
      function p() {
        s.value = f(), l.value = d();
      }
      return st(() => {
        if (!r.value || !o.value)
          return;
        const h = {
          drag: (m) => {
            c(m);
          },
          end: (m) => {
            c(m);
          }
        };
        Ja(r.value, h), Ja(o.value, h), p();
      }), {
        bar: r,
        thumb: o,
        thumbLeft: s,
        thumbTop: l,
        hueValue: a,
        handleClick: u,
        update: p,
        ns: t
      };
    }
  });
  function Tz(e, t, n, o, r, s) {
    return S(), V("div", {
      class: $([e.ns.b(), e.ns.is("vertical", e.vertical)])
    }, [
      H("div", {
        ref: "bar",
        class: $(e.ns.e("bar")),
        onClick: t[0] || (t[0] = (...l) => e.handleClick && e.handleClick(...l))
      }, null, 2),
      H("div", {
        ref: "thumb",
        class: $(e.ns.e("thumb")),
        style: Ke({
          left: e.thumbLeft + "px",
          top: e.thumbTop + "px"
        })
      }, null, 6)
    ], 2);
  }
  var Oz = /* @__PURE__ */ Me(Nz, [["render", Tz], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/hue-slider.vue"]]);
  const Mz = Ie({
    modelValue: String,
    id: String,
    showAlpha: Boolean,
    colorFormat: String,
    disabled: Boolean,
    size: yn,
    popperClass: {
      type: String,
      default: ""
    },
    label: {
      type: String,
      default: void 0
    },
    tabindex: {
      type: [String, Number],
      default: 0
    },
    predefine: {
      type: le(Array)
    },
    validateEvent: {
      type: Boolean,
      default: !0
    }
  }), Iz = {
    [dt]: (e) => et(e) || nn(e),
    [Ft]: (e) => et(e) || nn(e),
    activeChange: (e) => et(e) || nn(e)
  }, eE = Symbol("colorPickerContextKey"), hy = function(e, t, n) {
    return [
      e,
      t * n / ((e = (2 - t) * n) < 1 ? e : 2 - e) || 0,
      e / 2
    ];
  }, Pz = function(e) {
    return typeof e == "string" && e.includes(".") && Number.parseFloat(e) === 1;
  }, Az = function(e) {
    return typeof e == "string" && e.includes("%");
  }, hl = function(e, t) {
    Pz(e) && (e = "100%");
    const n = Az(e);
    return e = Math.min(t, Math.max(0, Number.parseFloat(`${e}`))), n && (e = Number.parseInt(`${e * t}`, 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : e % t / Number.parseFloat(t);
  }, vy = {
    10: "A",
    11: "B",
    12: "C",
    13: "D",
    14: "E",
    15: "F"
  }, bu = (e) => {
    e = Math.min(Math.round(e), 255);
    const t = Math.floor(e / 16), n = e % 16;
    return `${vy[t] || t}${vy[n] || n}`;
  }, my = function({ r: e, g: t, b: n }) {
    return Number.isNaN(+e) || Number.isNaN(+t) || Number.isNaN(+n) ? "" : `#${bu(e)}${bu(t)}${bu(n)}`;
  }, Ld = {
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15
  }, os = function(e) {
    return e.length === 2 ? (Ld[e[0].toUpperCase()] || +e[0]) * 16 + (Ld[e[1].toUpperCase()] || +e[1]) : Ld[e[1].toUpperCase()] || +e[1];
  }, Rz = function(e, t, n) {
    t = t / 100, n = n / 100;
    let o = t;
    const r = Math.max(n, 0.01);
    n *= 2, t *= n <= 1 ? n : 2 - n, o *= r <= 1 ? r : 2 - r;
    const s = (n + t) / 2, l = n === 0 ? 2 * o / (r + o) : 2 * t / (n + t);
    return {
      h: e,
      s: l * 100,
      v: s * 100
    };
  }, gy = (e, t, n) => {
    e = hl(e, 255), t = hl(t, 255), n = hl(n, 255);
    const o = Math.max(e, t, n), r = Math.min(e, t, n);
    let s;
    const l = o, a = o - r, u = o === 0 ? 0 : a / o;
    if (o === r)
      s = 0;
    else {
      switch (o) {
        case e: {
          s = (t - n) / a + (t < n ? 6 : 0);
          break;
        }
        case t: {
          s = (n - e) / a + 2;
          break;
        }
        case n: {
          s = (e - t) / a + 4;
          break;
        }
      }
      s /= 6;
    }
    return { h: s * 360, s: u * 100, v: l * 100 };
  }, ea = function(e, t, n) {
    e = hl(e, 360) * 6, t = hl(t, 100), n = hl(n, 100);
    const o = Math.floor(e), r = e - o, s = n * (1 - t), l = n * (1 - r * t), a = n * (1 - (1 - r) * t), u = o % 6, c = [n, l, s, s, a, n][u], f = [a, n, n, l, s, s][u], d = [s, s, a, n, n, l][u];
    return {
      r: Math.round(c * 255),
      g: Math.round(f * 255),
      b: Math.round(d * 255)
    };
  };
  class ba {
    constructor(t = {}) {
      this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100, this.enableAlpha = !1, this.format = "hex", this.value = "";
      for (const n in t)
        ht(t, n) && (this[n] = t[n]);
      t.value ? this.fromString(t.value) : this.doOnChange();
    }
    set(t, n) {
      if (arguments.length === 1 && typeof t == "object") {
        for (const o in t)
          ht(t, o) && this.set(o, t[o]);
        return;
      }
      this[`_${t}`] = n, this.doOnChange();
    }
    get(t) {
      return t === "alpha" ? Math.floor(this[`_${t}`]) : this[`_${t}`];
    }
    toRgb() {
      return ea(this._hue, this._saturation, this._value);
    }
    fromString(t) {
      if (!t) {
        this._hue = 0, this._saturation = 100, this._value = 100, this.doOnChange();
        return;
      }
      const n = (o, r, s) => {
        this._hue = Math.max(0, Math.min(360, o)), this._saturation = Math.max(0, Math.min(100, r)), this._value = Math.max(0, Math.min(100, s)), this.doOnChange();
      };
      if (t.includes("hsl")) {
        const o = t.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((r) => r !== "").map((r, s) => s > 2 ? Number.parseFloat(r) : Number.parseInt(r, 10));
        if (o.length === 4 ? this._alpha = Number.parseFloat(o[3]) * 100 : o.length === 3 && (this._alpha = 100), o.length >= 3) {
          const { h: r, s, v: l } = Rz(o[0], o[1], o[2]);
          n(r, s, l);
        }
      } else if (t.includes("hsv")) {
        const o = t.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((r) => r !== "").map((r, s) => s > 2 ? Number.parseFloat(r) : Number.parseInt(r, 10));
        o.length === 4 ? this._alpha = Number.parseFloat(o[3]) * 100 : o.length === 3 && (this._alpha = 100), o.length >= 3 && n(o[0], o[1], o[2]);
      } else if (t.includes("rgb")) {
        const o = t.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((r) => r !== "").map((r, s) => s > 2 ? Number.parseFloat(r) : Number.parseInt(r, 10));
        if (o.length === 4 ? this._alpha = Number.parseFloat(o[3]) * 100 : o.length === 3 && (this._alpha = 100), o.length >= 3) {
          const { h: r, s, v: l } = gy(o[0], o[1], o[2]);
          n(r, s, l);
        }
      } else if (t.includes("#")) {
        const o = t.replace("#", "").trim();
        if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(o))
          return;
        let r, s, l;
        o.length === 3 ? (r = os(o[0] + o[0]), s = os(o[1] + o[1]), l = os(o[2] + o[2])) : (o.length === 6 || o.length === 8) && (r = os(o.slice(0, 2)), s = os(o.slice(2, 4)), l = os(o.slice(4, 6))), o.length === 8 ? this._alpha = os(o.slice(6)) / 255 * 100 : (o.length === 3 || o.length === 6) && (this._alpha = 100);
        const { h: a, s: u, v: c } = gy(r, s, l);
        n(a, u, c);
      }
    }
    compare(t) {
      return Math.abs(t._hue - this._hue) < 2 && Math.abs(t._saturation - this._saturation) < 1 && Math.abs(t._value - this._value) < 1 && Math.abs(t._alpha - this._alpha) < 1;
    }
    doOnChange() {
      const { _hue: t, _saturation: n, _value: o, _alpha: r, format: s } = this;
      if (this.enableAlpha)
        switch (s) {
          case "hsl": {
            const l = hy(t, n / 100, o / 100);
            this.value = `hsla(${t}, ${Math.round(l[1] * 100)}%, ${Math.round(l[2] * 100)}%, ${this.get("alpha") / 100})`;
            break;
          }
          case "hsv": {
            this.value = `hsva(${t}, ${Math.round(n)}%, ${Math.round(o)}%, ${this.get("alpha") / 100})`;
            break;
          }
          case "hex": {
            this.value = `${my(ea(t, n, o))}${bu(r * 255 / 100)}`;
            break;
          }
          default: {
            const { r: l, g: a, b: u } = ea(t, n, o);
            this.value = `rgba(${l}, ${a}, ${u}, ${this.get("alpha") / 100})`;
          }
        }
      else
        switch (s) {
          case "hsl": {
            const l = hy(t, n / 100, o / 100);
            this.value = `hsl(${t}, ${Math.round(l[1] * 100)}%, ${Math.round(l[2] * 100)}%)`;
            break;
          }
          case "hsv": {
            this.value = `hsv(${t}, ${Math.round(n)}%, ${Math.round(o)}%)`;
            break;
          }
          case "rgb": {
            const { r: l, g: a, b: u } = ea(t, n, o);
            this.value = `rgb(${l}, ${a}, ${u})`;
            break;
          }
          default:
            this.value = my(ea(t, n, o));
        }
    }
  }
  const xz = G({
    props: {
      colors: {
        type: Array,
        required: !0
      },
      color: {
        type: Object,
        required: !0
      }
    },
    setup(e) {
      const t = ge("color-predefine"), { currentColor: n } = Be(eE), o = I(s(e.colors, e.color));
      me(() => n.value, (l) => {
        const a = new ba();
        a.fromString(l), o.value.forEach((u) => {
          u.selected = a.compare(u);
        });
      }), xn(() => {
        o.value = s(e.colors, e.color);
      });
      function r(l) {
        e.color.fromString(e.colors[l]);
      }
      function s(l, a) {
        return l.map((u) => {
          const c = new ba();
          return c.enableAlpha = !0, c.format = "rgba", c.fromString(u), c.selected = c.value === a.value, c;
        });
      }
      return {
        rgbaColors: o,
        handleSelect: r,
        ns: t
      };
    }
  }), Dz = ["onClick"];
  function Lz(e, t, n, o, r, s) {
    return S(), V("div", {
      class: $(e.ns.b())
    }, [
      H("div", {
        class: $(e.ns.e("colors"))
      }, [
        (S(!0), V(ze, null, gt(e.rgbaColors, (l, a) => (S(), V("div", {
          key: e.colors[a],
          class: $([
            e.ns.e("color-selector"),
            e.ns.is("alpha", l._alpha < 100),
            { selected: l.selected }
          ]),
          onClick: (u) => e.handleSelect(a)
        }, [
          H("div", {
            style: Ke({ backgroundColor: l.value })
          }, null, 4)
        ], 10, Dz))), 128))
      ], 2)
    ], 2);
  }
  var Vz = /* @__PURE__ */ Me(xz, [["render", Lz], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/predefine.vue"]]);
  const Bz = G({
    name: "ElSlPanel",
    props: {
      color: {
        type: Object,
        required: !0
      }
    },
    setup(e) {
      const t = ge("color-svpanel"), n = it(), o = I(0), r = I(0), s = I("hsl(0, 100%, 50%)"), l = E(() => {
        const c = e.color.get("hue"), f = e.color.get("value");
        return { hue: c, value: f };
      });
      function a() {
        const c = e.color.get("saturation"), f = e.color.get("value"), d = n.vnode.el, { clientWidth: p, clientHeight: h } = d;
        r.value = c * p / 100, o.value = (100 - f) * h / 100, s.value = `hsl(${e.color.get("hue")}, 100%, 50%)`;
      }
      function u(c) {
        const d = n.vnode.el.getBoundingClientRect(), { clientX: p, clientY: h } = rh(c);
        let m = p - d.left, v = h - d.top;
        m = Math.max(0, m), m = Math.min(m, d.width), v = Math.max(0, v), v = Math.min(v, d.height), r.value = m, o.value = v, e.color.set({
          saturation: m / d.width * 100,
          value: 100 - v / d.height * 100
        });
      }
      return me(() => l.value, () => {
        a();
      }), st(() => {
        Ja(n.vnode.el, {
          drag: (c) => {
            u(c);
          },
          end: (c) => {
            u(c);
          }
        }), a();
      }), {
        cursorTop: o,
        cursorLeft: r,
        background: s,
        colorValue: l,
        handleDrag: u,
        update: a,
        ns: t
      };
    }
  }), Fz = /* @__PURE__ */ H("div", null, null, -1), Hz = [
    Fz
  ];
  function zz(e, t, n, o, r, s) {
    return S(), V("div", {
      class: $(e.ns.b()),
      style: Ke({
        backgroundColor: e.background
      })
    }, [
      H("div", {
        class: $(e.ns.e("white"))
      }, null, 2),
      H("div", {
        class: $(e.ns.e("black"))
      }, null, 2),
      H("div", {
        class: $(e.ns.e("cursor")),
        style: Ke({
          top: e.cursorTop + "px",
          left: e.cursorLeft + "px"
        })
      }, Hz, 6)
    ], 6);
  }
  var Kz = /* @__PURE__ */ Me(Bz, [["render", zz], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/sv-panel.vue"]]);
  const jz = ["id", "aria-label", "aria-labelledby", "aria-description", "tabindex", "onKeydown"], Wz = G({
    name: "ElColorPicker"
  }), Uz = /* @__PURE__ */ G({
    ...Wz,
    props: Mz,
    emits: Iz,
    setup(e, { expose: t, emit: n }) {
      const o = e, { t: r } = St(), s = ge("color"), { formItem: l } = In(), a = on(), u = Fn(), { inputId: c, isLabeledByFormItem: f } = Zr(o, {
        formItemContext: l
      }), d = I(), p = I(), h = I(), m = I();
      let v = !0;
      const g = Tt(new ba({
        enableAlpha: o.showAlpha,
        format: o.colorFormat || "",
        value: o.modelValue
      })), y = I(!1), w = I(!1), b = I(""), C = E(() => !o.modelValue && !w.value ? "transparent" : P(g, o.showAlpha)), _ = E(() => !o.modelValue && !w.value ? "" : g.value), k = E(() => f.value ? void 0 : o.label || r("el.colorpicker.defaultLabel")), O = E(() => f.value ? l == null ? void 0 : l.labelId : void 0), T = E(() => [
        s.b("picker"),
        s.is("disabled", u.value),
        s.bm("picker", a.value)
      ]);
      function P(M, j) {
        if (!(M instanceof ba))
          throw new TypeError("color should be instance of _color Class");
        const { r: te, g: U, b: Z } = M.toRgb();
        return j ? `rgba(${te}, ${U}, ${Z}, ${M.get("alpha") / 100})` : `rgb(${te}, ${U}, ${Z})`;
      }
      function A(M) {
        y.value = M;
      }
      const L = On(A, 100);
      function D() {
        u.value || A(!0);
      }
      function B() {
        L(!1), F();
      }
      function F() {
        Fe(() => {
          o.modelValue ? g.fromString(o.modelValue) : (g.value = "", Fe(() => {
            w.value = !1;
          }));
        });
      }
      function W() {
        u.value || L(!y.value);
      }
      function x() {
        g.fromString(b.value);
      }
      function N() {
        const M = g.value;
        n(dt, M), n("change", M), o.validateEvent && (l == null || l.validate("change").catch((j) => yt(j))), L(!1), Fe(() => {
          const j = new ba({
            enableAlpha: o.showAlpha,
            format: o.colorFormat || "",
            value: o.modelValue
          });
          g.compare(j) || F();
        });
      }
      function R() {
        L(!1), n(dt, null), n("change", null), o.modelValue !== null && o.validateEvent && (l == null || l.validate("change").catch((M) => yt(M))), F();
      }
      return st(() => {
        o.modelValue && (b.value = _.value);
      }), me(() => o.modelValue, (M) => {
        M ? M && M !== g.value && (v = !1, g.fromString(M)) : w.value = !1;
      }), me(() => _.value, (M) => {
        b.value = M, v && n("activeChange", M), v = !0;
      }), me(() => g.value, () => {
        !o.modelValue && !w.value && (w.value = !0);
      }), me(() => y.value, () => {
        Fe(() => {
          var M, j, te;
          (M = d.value) == null || M.update(), (j = p.value) == null || j.update(), (te = h.value) == null || te.update();
        });
      }), pt(eE, {
        currentColor: _
      }), t({
        color: g,
        show: D,
        hide: B
      }), (M, j) => (S(), ie(i(Mn), {
        ref_key: "popper",
        ref: m,
        visible: y.value,
        "show-arrow": !1,
        "fallback-placements": ["bottom", "top", "right", "left"],
        offset: 0,
        "gpu-acceleration": !1,
        "popper-class": [i(s).be("picker", "panel"), i(s).b("dropdown"), M.popperClass],
        "stop-popper-mouse-event": !1,
        effect: "light",
        trigger: "click",
        transition: `${i(s).namespace.value}-zoom-in-top`,
        persistent: ""
      }, {
        content: X(() => [
          ot((S(), V("div", null, [
            H("div", {
              class: $(i(s).be("dropdown", "main-wrapper"))
            }, [
              K(Oz, {
                ref_key: "hue",
                ref: d,
                class: "hue-slider",
                color: i(g),
                vertical: ""
              }, null, 8, ["color"]),
              K(Kz, {
                ref: "svPanel",
                color: i(g)
              }, null, 8, ["color"])
            ], 2),
            M.showAlpha ? (S(), ie($z, {
              key: 0,
              ref_key: "alpha",
              ref: h,
              color: i(g)
            }, null, 8, ["color"])) : se("v-if", !0),
            M.predefine ? (S(), ie(Vz, {
              key: 1,
              ref: "predefine",
              color: i(g),
              colors: M.predefine
            }, null, 8, ["color", "colors"])) : se("v-if", !0),
            H("div", {
              class: $(i(s).be("dropdown", "btns"))
            }, [
              H("span", {
                class: $(i(s).be("dropdown", "value"))
              }, [
                K(i(wn), {
                  modelValue: b.value,
                  "onUpdate:modelValue": j[0] || (j[0] = (te) => b.value = te),
                  "validate-event": !1,
                  size: "small",
                  onKeyup: Et(x, ["enter"]),
                  onBlur: x
                }, null, 8, ["modelValue", "onKeyup"])
              ], 2),
              K(i(gn), {
                class: $(i(s).be("dropdown", "link-btn")),
                text: "",
                size: "small",
                onClick: R
              }, {
                default: X(() => [
                  wt(Ne(i(r)("el.colorpicker.clear")), 1)
                ]),
                _: 1
              }, 8, ["class"]),
              K(i(gn), {
                plain: "",
                size: "small",
                class: $(i(s).be("dropdown", "btn")),
                onClick: N
              }, {
                default: X(() => [
                  wt(Ne(i(r)("el.colorpicker.confirm")), 1)
                ]),
                _: 1
              }, 8, ["class"])
            ], 2)
          ])), [
            [i(Kr), B]
          ])
        ]),
        default: X(() => [
          H("div", {
            id: i(c),
            class: $(i(T)),
            role: "button",
            "aria-label": i(k),
            "aria-labelledby": i(O),
            "aria-description": i(r)("el.colorpicker.description", { color: M.modelValue || "" }),
            tabindex: M.tabindex,
            onKeydown: Et(W, ["enter"])
          }, [
            i(u) ? (S(), V("div", {
              key: 0,
              class: $(i(s).be("picker", "mask"))
            }, null, 2)) : se("v-if", !0),
            H("div", {
              class: $(i(s).be("picker", "trigger")),
              onClick: W
            }, [
              H("span", {
                class: $([i(s).be("picker", "color"), i(s).is("alpha", M.showAlpha)])
              }, [
                H("span", {
                  class: $(i(s).be("picker", "color-inner")),
                  style: Ke({
                    backgroundColor: i(C)
                  })
                }, [
                  ot(K(i(He), {
                    class: $([i(s).be("picker", "icon"), i(s).is("icon-arrow-down")])
                  }, {
                    default: X(() => [
                      K(i(qr))
                    ]),
                    _: 1
                  }, 8, ["class"]), [
                    [$t, M.modelValue || w.value]
                  ]),
                  !M.modelValue && !w.value ? (S(), ie(i(He), {
                    key: 0,
                    class: $([i(s).be("picker", "empty"), i(s).is("icon-close")])
                  }, {
                    default: X(() => [
                      K(i(_o))
                    ]),
                    _: 1
                  }, 8, ["class"])) : se("v-if", !0)
                ], 6)
              ], 2)
            ], 2)
          ], 42, jz)
        ]),
        _: 1
      }, 8, ["visible", "popper-class", "transition"]));
    }
  });
  var qz = /* @__PURE__ */ Me(Uz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/color-picker.vue"]]);
  const Yz = ut(qz), Gz = G({
    name: "ElContainer"
  }), Xz = /* @__PURE__ */ G({
    ...Gz,
    props: {
      direction: {
        type: String
      }
    },
    setup(e) {
      const t = e, n = hn(), o = ge("container"), r = E(() => t.direction === "vertical" ? !0 : t.direction === "horizontal" ? !1 : n && n.default ? n.default().some((l) => {
        const a = l.type.name;
        return a === "ElHeader" || a === "ElFooter";
      }) : !1);
      return (s, l) => (S(), V("section", {
        class: $([i(o).b(), i(o).is("vertical", i(r))])
      }, [
        he(s.$slots, "default")
      ], 2));
    }
  });
  var Jz = /* @__PURE__ */ Me(Xz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);
  const Zz = G({
    name: "ElAside"
  }), Qz = /* @__PURE__ */ G({
    ...Zz,
    props: {
      width: {
        type: String,
        default: null
      }
    },
    setup(e) {
      const t = e, n = ge("aside"), o = E(() => t.width ? n.cssVarBlock({ width: t.width }) : {});
      return (r, s) => (S(), V("aside", {
        class: $(i(n).b()),
        style: Ke(i(o))
      }, [
        he(r.$slots, "default")
      ], 6));
    }
  });
  var tE = /* @__PURE__ */ Me(Qz, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);
  const eK = G({
    name: "ElFooter"
  }), tK = /* @__PURE__ */ G({
    ...eK,
    props: {
      height: {
        type: String,
        default: null
      }
    },
    setup(e) {
      const t = e, n = ge("footer"), o = E(() => t.height ? n.cssVarBlock({ height: t.height }) : {});
      return (r, s) => (S(), V("footer", {
        class: $(i(n).b()),
        style: Ke(i(o))
      }, [
        he(r.$slots, "default")
      ], 6));
    }
  });
  var nE = /* @__PURE__ */ Me(tK, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);
  const nK = G({
    name: "ElHeader"
  }), oK = /* @__PURE__ */ G({
    ...nK,
    props: {
      height: {
        type: String,
        default: null
      }
    },
    setup(e) {
      const t = e, n = ge("header"), o = E(() => t.height ? n.cssVarBlock({
        height: t.height
      }) : {});
      return (r, s) => (S(), V("header", {
        class: $(i(n).b()),
        style: Ke(i(o))
      }, [
        he(r.$slots, "default")
      ], 6));
    }
  });
  var oE = /* @__PURE__ */ Me(oK, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);
  const rK = G({
    name: "ElMain"
  }), sK = /* @__PURE__ */ G({
    ...rK,
    setup(e) {
      const t = ge("main");
      return (n, o) => (S(), V("main", {
        class: $(i(t).b())
      }, [
        he(n.$slots, "default")
      ], 2));
    }
  });
  var rE = /* @__PURE__ */ Me(sK, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);
  const lK = ut(Jz, {
    Aside: tE,
    Footer: nE,
    Header: oE,
    Main: rE
  }), aK = Gt(tE), iK = Gt(nE), uK = Gt(oE), cK = Gt(rE);
  var sE = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(hr, function() {
      return function(n, o) {
        var r = o.prototype, s = r.format;
        r.format = function(l) {
          var a = this, u = this.$locale();
          if (!this.isValid())
            return s.bind(this)(l);
          var c = this.$utils(), f = (l || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(d) {
            switch (d) {
              case "Q":
                return Math.ceil((a.$M + 1) / 3);
              case "Do":
                return u.ordinal(a.$D);
              case "gggg":
                return a.weekYear();
              case "GGGG":
                return a.isoWeekYear();
              case "wo":
                return u.ordinal(a.week(), "W");
              case "w":
              case "ww":
                return c.s(a.week(), d === "w" ? 1 : 2, "0");
              case "W":
              case "WW":
                return c.s(a.isoWeek(), d === "W" ? 1 : 2, "0");
              case "k":
              case "kk":
                return c.s(String(a.$H === 0 ? 24 : a.$H), d === "k" ? 1 : 2, "0");
              case "X":
                return Math.floor(a.$d.getTime() / 1e3);
              case "x":
                return a.$d.getTime();
              case "z":
                return "[" + a.offsetName() + "]";
              case "zzz":
                return "[" + a.offsetName("long") + "]";
              default:
                return d;
            }
          });
          return s.bind(this)(f);
        };
      };
    });
  })(sE);
  const dK = sE.exports;
  var lE = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(hr, function() {
      var n = "week", o = "year";
      return function(r, s, l) {
        var a = s.prototype;
        a.week = function(u) {
          if (u === void 0 && (u = null), u !== null)
            return this.add(7 * (u - this.week()), "day");
          var c = this.$locale().yearStart || 1;
          if (this.month() === 11 && this.date() > 25) {
            var f = l(this).startOf(o).add(1, o).date(c), d = l(this).endOf(n);
            if (f.isBefore(d))
              return 1;
          }
          var p = l(this).startOf(o).date(c).startOf(n).subtract(1, "millisecond"), h = this.diff(p, n, !0);
          return h < 0 ? l(this).startOf("week").week() : Math.ceil(h);
        }, a.weeks = function(u) {
          return u === void 0 && (u = null), this.week(u);
        };
      };
    });
  })(lE);
  const fK = lE.exports;
  var aE = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(hr, function() {
      return function(n, o) {
        o.prototype.weekYear = function() {
          var r = this.month(), s = this.week(), l = this.year();
          return s === 1 && r === 11 ? l + 1 : r === 0 && s >= 52 ? l - 1 : l;
        };
      };
    });
  })(aE);
  const pK = aE.exports;
  var iE = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(hr, function() {
      return function(n, o, r) {
        o.prototype.dayOfYear = function(s) {
          var l = Math.round((r(this).startOf("day") - r(this).startOf("year")) / 864e5) + 1;
          return s == null ? l : this.add(s - l, "day");
        };
      };
    });
  })(iE);
  const hK = iE.exports;
  var uE = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(hr, function() {
      return function(n, o) {
        o.prototype.isSameOrAfter = function(r, s) {
          return this.isSame(r, s) || this.isAfter(r, s);
        };
      };
    });
  })(uE);
  const vK = uE.exports;
  var cE = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(hr, function() {
      return function(n, o) {
        o.prototype.isSameOrBefore = function(r, s) {
          return this.isSame(r, s) || this.isBefore(r, s);
        };
      };
    });
  })(cE);
  const mK = cE.exports, Xh = Symbol(), gK = Ie({
    type: {
      type: le(String),
      default: "date"
    }
  }), yK = ["date", "dates", "year", "month", "week", "range"], Jh = Ie({
    disabledDate: {
      type: le(Function)
    },
    date: {
      type: le(Object),
      required: !0
    },
    minDate: {
      type: le(Object)
    },
    maxDate: {
      type: le(Object)
    },
    parsedValue: {
      type: le([Object, Array])
    },
    rangeState: {
      type: le(Object),
      default: () => ({
        endDate: null,
        selecting: !1
      })
    }
  }), dE = Ie({
    type: {
      type: le(String),
      required: !0,
      values: iD
    }
  }), fE = Ie({
    unlinkPanels: Boolean,
    parsedValue: {
      type: le(Array)
    }
  }), pE = (e) => ({
    type: String,
    values: yK,
    default: e
  }), bK = Ie({
    ...dE,
    parsedValue: {
      type: le([Object, Array])
    },
    visible: {
      type: Boolean
    },
    format: {
      type: String,
      default: ""
    }
  }), wK = Ie({
    ...Jh,
    cellClassName: {
      type: le(Function)
    },
    showWeekNumber: Boolean,
    selectionMode: pE("date")
  }), ep = (e) => {
    if (!De(e))
      return !1;
    const [t, n] = e;
    return at.isDayjs(t) && at.isDayjs(n) && t.isSameOrBefore(n);
  }, hE = (e, { lang: t, unit: n, unlinkPanels: o }) => {
    let r;
    if (De(e)) {
      let [s, l] = e.map((a) => at(a).locale(t));
      return o || (l = s.add(1, n)), [s, l];
    } else
      e ? r = at(e) : r = at();
    return r = r.locale(t), [r, r.add(1, n)];
  }, CK = (e, t, {
    columnIndexOffset: n,
    startDate: o,
    nextEndDate: r,
    now: s,
    unit: l,
    relativeDateGetter: a,
    setCellMetadata: u,
    setRowMetadata: c
  }) => {
    for (let f = 0; f < e.row; f++) {
      const d = t[f];
      for (let p = 0; p < e.column; p++) {
        let h = d[p + n];
        h || (h = {
          row: f,
          column: p,
          type: "normal",
          inRange: !1,
          start: !1,
          end: !1
        });
        const m = f * e.column + p, v = a(m);
        h.dayjs = v, h.date = v.toDate(), h.timestamp = v.valueOf(), h.type = "normal", h.inRange = !!(o && v.isSameOrAfter(o, l) && r && v.isSameOrBefore(r, l)) || !!(o && v.isSameOrBefore(o, l) && r && v.isSameOrAfter(r, l)), o != null && o.isSameOrAfter(r) ? (h.start = !!r && v.isSame(r, l), h.end = o && v.isSame(o, l)) : (h.start = !!o && v.isSame(o, l), h.end = !!r && v.isSame(r, l)), v.isSame(s, l) && (h.type = "today"), u == null || u(h, { rowIndex: f, columnIndex: p }), d[p + n] = h;
      }
      c == null || c(d);
    }
  }, EK = Ie({
    cell: {
      type: le(Object)
    }
  });
  var SK = G({
    name: "ElDatePickerCell",
    props: EK,
    setup(e) {
      const t = ge("date-table-cell"), {
        slots: n
      } = Be(Xh);
      return () => {
        const {
          cell: o
        } = e;
        if (n.default) {
          const r = n.default(o).filter((s) => s.patchFlag !== -2 && s.type.toString() !== "Symbol(Comment)");
          if (r.length)
            return r;
        }
        return K("div", {
          class: t.b()
        }, [K("span", {
          class: t.e("text")
        }, [o == null ? void 0 : o.text])]);
      };
    }
  });
  const _K = ["aria-label", "onMousedown"], kK = {
    key: 0,
    scope: "col"
  }, $K = ["aria-label"], NK = ["aria-current", "aria-selected", "tabindex"], TK = /* @__PURE__ */ G({
    __name: "basic-date-table",
    props: wK,
    emits: ["changerange", "pick", "select"],
    setup(e, { expose: t, emit: n }) {
      const o = e, r = ge("date-table"), { t: s, lang: l } = St(), a = I(), u = I(), c = I(), f = I(), d = I([[], [], [], [], [], []]);
      let p = !1;
      const h = o.date.$locale().weekStart || 7, m = o.date.locale("en").localeData().weekdaysShort().map((U) => U.toLowerCase()), v = E(() => h > 3 ? 7 - h : -h), g = E(() => {
        const U = o.date.startOf("month");
        return U.subtract(U.day() || 7, "day");
      }), y = E(() => m.concat(m).slice(h, h + 7)), w = E(() => S1(T.value).some((U) => U.isCurrent)), b = E(() => {
        const U = o.date.startOf("month"), Z = U.day() || 7, pe = U.daysInMonth(), J = U.subtract(1, "month").daysInMonth();
        return {
          startOfMonthDay: Z,
          dateCountOfMonth: pe,
          dateCountOfLastMonth: J
        };
      }), C = E(() => o.selectionMode === "dates" ? or(o.parsedValue) : []), _ = (U, {
        count: Z,
        rowIndex: pe,
        columnIndex: J
      }) => {
        const { startOfMonthDay: ee, dateCountOfMonth: ne, dateCountOfLastMonth: Y } = i(b), re = i(v);
        if (pe >= 0 && pe <= 1) {
          const ce = ee + re < 0 ? 7 + ee + re : ee + re;
          if (J + pe * 7 >= ce)
            return U.text = Z, !0;
          U.text = Y - (ce - J % 7) + 1 + pe * 7, U.type = "prev-month";
        } else
          return Z <= ne ? U.text = Z : (U.text = Z - ne, U.type = "next-month"), !0;
        return !1;
      }, k = (U, {
        columnIndex: Z,
        rowIndex: pe
      }, J) => {
        const { disabledDate: ee, cellClassName: ne } = o, Y = i(C), re = _(U, { count: J, rowIndex: pe, columnIndex: Z }), ce = U.dayjs.toDate();
        return U.selected = Y.find((Te) => Te.valueOf() === U.dayjs.valueOf()), U.isSelected = !!U.selected, U.isCurrent = L(U), U.disabled = ee == null ? void 0 : ee(ce), U.customClass = ne == null ? void 0 : ne(ce), re;
      }, O = (U) => {
        if (o.selectionMode === "week") {
          const [Z, pe] = o.showWeekNumber ? [1, 7] : [0, 6], J = te(U[Z + 1]);
          U[Z].inRange = J, U[Z].start = J, U[pe].inRange = J, U[pe].end = J;
        }
      }, T = E(() => {
        const { minDate: U, maxDate: Z, rangeState: pe, showWeekNumber: J } = o, ee = v.value, ne = d.value, Y = "day";
        let re = 1;
        if (J)
          for (let ce = 0; ce < 6; ce++)
            ne[ce][0] || (ne[ce][0] = {
              type: "week",
              text: g.value.add(ce * 7 + 1, Y).week()
            });
        return CK({ row: 6, column: 7 }, ne, {
          startDate: U,
          columnIndexOffset: J ? 1 : 0,
          nextEndDate: pe.endDate || Z || pe.selecting && U || null,
          now: at().locale(i(l)).startOf(Y),
          unit: Y,
          relativeDateGetter: (ce) => g.value.add(ce - ee, Y),
          setCellMetadata: (...ce) => {
            k(...ce, re) && (re += 1);
          },
          setRowMetadata: O
        }), ne;
      });
      me(() => o.date, async () => {
        var U, Z;
        (U = a.value) != null && U.contains(document.activeElement) && (await Fe(), (Z = u.value) == null || Z.focus());
      });
      const P = async () => {
        var U;
        (U = u.value) == null || U.focus();
      }, A = (U = "") => ["normal", "today"].includes(U), L = (U) => o.selectionMode === "date" && A(U.type) && D(U, o.parsedValue), D = (U, Z) => Z ? at(Z).locale(l.value).isSame(o.date.date(Number(U.text)), "day") : !1, B = (U) => {
        const Z = [];
        return A(U.type) && !U.disabled ? (Z.push("available"), U.type === "today" && Z.push("today")) : Z.push(U.type), L(U) && Z.push("current"), U.inRange && (A(U.type) || o.selectionMode === "week") && (Z.push("in-range"), U.start && Z.push("start-date"), U.end && Z.push("end-date")), U.disabled && Z.push("disabled"), U.selected && Z.push("selected"), U.customClass && Z.push(U.customClass), Z.join(" ");
      }, F = (U, Z) => {
        const pe = U * 7 + (Z - (o.showWeekNumber ? 1 : 0)) - v.value;
        return g.value.add(pe, "day");
      }, W = (U) => {
        var Z;
        if (!o.rangeState.selecting)
          return;
        let pe = U.target;
        if (pe.tagName === "SPAN" && (pe = (Z = pe.parentNode) == null ? void 0 : Z.parentNode), pe.tagName === "DIV" && (pe = pe.parentNode), pe.tagName !== "TD")
          return;
        const J = pe.parentNode.rowIndex - 1, ee = pe.cellIndex;
        T.value[J][ee].disabled || (J !== c.value || ee !== f.value) && (c.value = J, f.value = ee, n("changerange", {
          selecting: !0,
          endDate: F(J, ee)
        }));
      }, x = (U) => !w.value && (U == null ? void 0 : U.text) === 1 && U.type === "normal" || U.isCurrent, N = (U) => {
        p || w.value || o.selectionMode !== "date" || j(U, !0);
      }, R = (U) => {
        !U.target.closest("td") || (p = !0);
      }, M = (U) => {
        !U.target.closest("td") || (p = !1);
      }, j = (U, Z = !1) => {
        const pe = U.target.closest("td");
        if (!pe)
          return;
        const J = pe.parentNode.rowIndex - 1, ee = pe.cellIndex, ne = T.value[J][ee];
        if (ne.disabled || ne.type === "week")
          return;
        const Y = F(J, ee);
        if (o.selectionMode === "range")
          !o.rangeState.selecting || !o.minDate ? (n("pick", { minDate: Y, maxDate: null }), n("select", !0)) : (Y >= o.minDate ? n("pick", { minDate: o.minDate, maxDate: Y }) : n("pick", { minDate: Y, maxDate: o.minDate }), n("select", !1));
        else if (o.selectionMode === "date")
          n("pick", Y, Z);
        else if (o.selectionMode === "week") {
          const re = Y.week(), ce = `${Y.year()}w${re}`;
          n("pick", {
            year: Y.year(),
            week: re,
            value: ce,
            date: Y.startOf("week")
          });
        } else if (o.selectionMode === "dates") {
          const re = ne.selected ? or(o.parsedValue).filter((ce) => (ce == null ? void 0 : ce.valueOf()) !== Y.valueOf()) : or(o.parsedValue).concat([Y]);
          n("pick", re);
        }
      }, te = (U) => {
        if (o.selectionMode !== "week")
          return !1;
        let Z = o.date.startOf("day");
        if (U.type === "prev-month" && (Z = Z.subtract(1, "month")), U.type === "next-month" && (Z = Z.add(1, "month")), Z = Z.date(Number.parseInt(U.text, 10)), o.parsedValue && !Array.isArray(o.parsedValue)) {
          const pe = (o.parsedValue.day() - h + 7) % 7 - 1;
          return o.parsedValue.subtract(pe, "day").isSame(Z, "day");
        }
        return !1;
      };
      return t({
        focus: P
      }), (U, Z) => (S(), V("table", {
        role: "grid",
        "aria-label": i(s)("el.datepicker.dateTablePrompt"),
        cellspacing: "0",
        cellpadding: "0",
        class: $([i(r).b(), { "is-week-mode": U.selectionMode === "week" }]),
        onClick: j,
        onMousemove: W,
        onMousedown: Ze(R, ["prevent"]),
        onMouseup: M
      }, [
        H("tbody", {
          ref_key: "tbodyRef",
          ref: a
        }, [
          H("tr", null, [
            U.showWeekNumber ? (S(), V("th", kK, Ne(i(s)("el.datepicker.week")), 1)) : se("v-if", !0),
            (S(!0), V(ze, null, gt(i(y), (pe, J) => (S(), V("th", {
              key: J,
              scope: "col",
              "aria-label": i(s)("el.datepicker.weeksFull." + pe)
            }, Ne(i(s)("el.datepicker.weeks." + pe)), 9, $K))), 128))
          ]),
          (S(!0), V(ze, null, gt(i(T), (pe, J) => (S(), V("tr", {
            key: J,
            class: $([i(r).e("row"), { current: te(pe[1]) }])
          }, [
            (S(!0), V(ze, null, gt(pe, (ee, ne) => (S(), V("td", {
              key: `${J}.${ne}`,
              ref_for: !0,
              ref: (Y) => x(ee) && (u.value = Y),
              class: $(B(ee)),
              "aria-current": ee.isCurrent ? "date" : void 0,
              "aria-selected": ee.isCurrent,
              tabindex: x(ee) ? 0 : -1,
              onFocus: N
            }, [
              K(i(SK), { cell: ee }, null, 8, ["cell"])
            ], 42, NK))), 128))
          ], 2))), 128))
        ], 512)
      ], 42, _K));
    }
  });
  var tp = /* @__PURE__ */ Me(TK, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-date-table.vue"]]);
  const OK = Ie({
    ...Jh,
    selectionMode: pE("month")
  }), MK = ["aria-label"], IK = ["aria-selected", "aria-label", "tabindex", "onKeydown"], PK = { class: "cell" }, AK = /* @__PURE__ */ G({
    __name: "basic-month-table",
    props: OK,
    emits: ["changerange", "pick", "select"],
    setup(e, { expose: t, emit: n }) {
      const o = e, r = (C, _, k) => {
        const O = at().locale(k).startOf("month").month(_).year(C), T = O.daysInMonth();
        return Rr(T).map((P) => O.add(P, "day").toDate());
      }, s = ge("month-table"), { t: l, lang: a } = St(), u = I(), c = I(), f = I(o.date.locale("en").localeData().monthsShort().map((C) => C.toLowerCase())), d = I([
        [],
        [],
        []
      ]), p = I(), h = I(), m = E(() => {
        var C, _;
        const k = d.value, O = at().locale(a.value).startOf("month");
        for (let T = 0; T < 3; T++) {
          const P = k[T];
          for (let A = 0; A < 4; A++) {
            const L = P[A] || (P[A] = {
              row: T,
              column: A,
              type: "normal",
              inRange: !1,
              start: !1,
              end: !1,
              text: -1,
              disabled: !1
            });
            L.type = "normal";
            const D = T * 4 + A, B = o.date.startOf("year").month(D), F = o.rangeState.endDate || o.maxDate || o.rangeState.selecting && o.minDate || null;
            L.inRange = !!(o.minDate && B.isSameOrAfter(o.minDate, "month") && F && B.isSameOrBefore(F, "month")) || !!(o.minDate && B.isSameOrBefore(o.minDate, "month") && F && B.isSameOrAfter(F, "month")), (C = o.minDate) != null && C.isSameOrAfter(F) ? (L.start = !!(F && B.isSame(F, "month")), L.end = o.minDate && B.isSame(o.minDate, "month")) : (L.start = !!(o.minDate && B.isSame(o.minDate, "month")), L.end = !!(F && B.isSame(F, "month"))), O.isSame(B) && (L.type = "today"), L.text = D, L.disabled = ((_ = o.disabledDate) == null ? void 0 : _.call(o, B.toDate())) || !1;
          }
        }
        return k;
      }), v = () => {
        var C;
        (C = c.value) == null || C.focus();
      }, g = (C) => {
        const _ = {}, k = o.date.year(), O = new Date(), T = C.text;
        return _.disabled = o.disabledDate ? r(k, T, a.value).every(o.disabledDate) : !1, _.current = or(o.parsedValue).findIndex((P) => at.isDayjs(P) && P.year() === k && P.month() === T) >= 0, _.today = O.getFullYear() === k && O.getMonth() === T, C.inRange && (_["in-range"] = !0, C.start && (_["start-date"] = !0), C.end && (_["end-date"] = !0)), _;
      }, y = (C) => {
        const _ = o.date.year(), k = C.text;
        return or(o.date).findIndex((O) => O.year() === _ && O.month() === k) >= 0;
      }, w = (C) => {
        var _;
        if (!o.rangeState.selecting)
          return;
        let k = C.target;
        if (k.tagName === "A" && (k = (_ = k.parentNode) == null ? void 0 : _.parentNode), k.tagName === "DIV" && (k = k.parentNode), k.tagName !== "TD")
          return;
        const O = k.parentNode.rowIndex, T = k.cellIndex;
        m.value[O][T].disabled || (O !== p.value || T !== h.value) && (p.value = O, h.value = T, n("changerange", {
          selecting: !0,
          endDate: o.date.startOf("year").month(O * 4 + T)
        }));
      }, b = (C) => {
        var _;
        const k = (_ = C.target) == null ? void 0 : _.closest("td");
        if ((k == null ? void 0 : k.tagName) !== "TD" || Co(k, "disabled"))
          return;
        const O = k.cellIndex, P = k.parentNode.rowIndex * 4 + O, A = o.date.startOf("year").month(P);
        o.selectionMode === "range" ? o.rangeState.selecting ? (o.minDate && A >= o.minDate ? n("pick", { minDate: o.minDate, maxDate: A }) : n("pick", { minDate: A, maxDate: o.minDate }), n("select", !1)) : (n("pick", { minDate: A, maxDate: null }), n("select", !0)) : n("pick", P);
      };
      return me(() => o.date, async () => {
        var C, _;
        (C = u.value) != null && C.contains(document.activeElement) && (await Fe(), (_ = c.value) == null || _.focus());
      }), t({
        focus: v
      }), (C, _) => (S(), V("table", {
        role: "grid",
        "aria-label": i(l)("el.datepicker.monthTablePrompt"),
        class: $(i(s).b()),
        onClick: b,
        onMousemove: w
      }, [
        H("tbody", {
          ref_key: "tbodyRef",
          ref: u
        }, [
          (S(!0), V(ze, null, gt(i(m), (k, O) => (S(), V("tr", { key: O }, [
            (S(!0), V(ze, null, gt(k, (T, P) => (S(), V("td", {
              key: P,
              ref_for: !0,
              ref: (A) => y(T) && (c.value = A),
              class: $(g(T)),
              "aria-selected": `${y(T)}`,
              "aria-label": i(l)(`el.datepicker.month${+T.text + 1}`),
              tabindex: y(T) ? 0 : -1,
              onKeydown: [
                Et(Ze(b, ["prevent", "stop"]), ["space"]),
                Et(Ze(b, ["prevent", "stop"]), ["enter"])
              ]
            }, [
              H("div", null, [
                H("span", PK, Ne(i(l)("el.datepicker.months." + f.value[T.text])), 1)
              ])
            ], 42, IK))), 128))
          ]))), 128))
        ], 512)
      ], 42, MK));
    }
  });
  var np = /* @__PURE__ */ Me(AK, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-month-table.vue"]]);
  const { date: RK, disabledDate: xK, parsedValue: DK } = Jh, LK = Ie({
    date: RK,
    disabledDate: xK,
    parsedValue: DK
  }), VK = ["aria-label"], BK = ["aria-selected", "tabindex", "onKeydown"], FK = { class: "cell" }, HK = { key: 1 }, zK = /* @__PURE__ */ G({
    __name: "basic-year-table",
    props: LK,
    emits: ["pick"],
    setup(e, { expose: t, emit: n }) {
      const o = e, r = (v, g) => {
        const y = at(String(v)).locale(g).startOf("year"), b = y.endOf("year").dayOfYear();
        return Rr(b).map((C) => y.add(C, "day").toDate());
      }, s = ge("year-table"), { t: l, lang: a } = St(), u = I(), c = I(), f = E(() => Math.floor(o.date.year() / 10) * 10), d = () => {
        var v;
        (v = c.value) == null || v.focus();
      }, p = (v) => {
        const g = {}, y = at().locale(a.value);
        return g.disabled = o.disabledDate ? r(v, a.value).every(o.disabledDate) : !1, g.current = or(o.parsedValue).findIndex((w) => w.year() === v) >= 0, g.today = y.year() === v, g;
      }, h = (v) => v === f.value && o.date.year() < f.value && o.date.year() > f.value + 9 || or(o.date).findIndex((g) => g.year() === v) >= 0, m = (v) => {
        const y = v.target.closest("td");
        if (y && y.textContent) {
          if (Co(y, "disabled"))
            return;
          const w = y.textContent || y.innerText;
          n("pick", Number(w));
        }
      };
      return me(() => o.date, async () => {
        var v, g;
        (v = u.value) != null && v.contains(document.activeElement) && (await Fe(), (g = c.value) == null || g.focus());
      }), t({
        focus: d
      }), (v, g) => (S(), V("table", {
        role: "grid",
        "aria-label": i(l)("el.datepicker.yearTablePrompt"),
        class: $(i(s).b()),
        onClick: m
      }, [
        H("tbody", {
          ref_key: "tbodyRef",
          ref: u
        }, [
          (S(), V(ze, null, gt(3, (y, w) => H("tr", { key: w }, [
            (S(), V(ze, null, gt(4, (b, C) => (S(), V(ze, {
              key: w + "_" + C
            }, [
              w * 4 + C < 10 ? (S(), V("td", {
                key: 0,
                ref_for: !0,
                ref: (_) => h(i(f) + w * 4 + C) && (c.value = _),
                class: $(["available", p(i(f) + w * 4 + C)]),
                "aria-selected": `${h(i(f) + w * 4 + C)}`,
                tabindex: h(i(f) + w * 4 + C) ? 0 : -1,
                onKeydown: [
                  Et(Ze(m, ["prevent", "stop"]), ["space"]),
                  Et(Ze(m, ["prevent", "stop"]), ["enter"])
                ]
              }, [
                H("span", FK, Ne(i(f) + w * 4 + C), 1)
              ], 42, BK)) : (S(), V("td", HK))
            ], 64))), 64))
          ])), 64))
        ], 512)
      ], 10, VK));
    }
  });
  var KK = /* @__PURE__ */ Me(zK, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-year-table.vue"]]);
  const jK = ["onClick"], WK = ["aria-label"], UK = ["aria-label"], qK = ["aria-label"], YK = ["aria-label"], GK = /* @__PURE__ */ G({
    __name: "panel-date-pick",
    props: bK,
    emits: ["pick", "set-picker-option", "panel-change"],
    setup(e, { emit: t }) {
      const n = e, o = (ye, Ce, ue) => !0, r = ge("picker-panel"), s = ge("date-picker"), l = zl(), a = hn(), { t: u, lang: c } = St(), f = Be("EP_PICKER_BASE"), d = Be(Qc), { shortcuts: p, disabledDate: h, cellClassName: m, defaultTime: v, arrowControl: g } = f.props, y = Ht(f.props, "defaultValue"), w = I(), b = I(at().locale(c.value)), C = I(!1), _ = E(() => at(v).locale(c.value)), k = E(() => b.value.month()), O = E(() => b.value.year()), T = I([]), P = I(null), A = I(null), L = (ye) => T.value.length > 0 ? o(ye, T.value, n.format || "HH:mm:ss") : !0, D = (ye) => v && !Pe.value && !C.value ? _.value.year(ye.year()).month(ye.month()).date(ye.date()) : ee.value ? ye.millisecond(0) : ye.startOf("day"), B = (ye, ...Ce) => {
        if (!ye)
          t("pick", ye, ...Ce);
        else if (De(ye)) {
          const ue = ye.map(D);
          t("pick", ue, ...Ce);
        } else
          t("pick", D(ye), ...Ce);
        P.value = null, A.value = null, C.value = !1;
      }, F = (ye, Ce) => {
        if (j.value === "date") {
          ye = ye;
          let ue = n.parsedValue ? n.parsedValue.year(ye.year()).month(ye.month()).date(ye.date()) : ye;
          L(ue) || (ue = T.value[0][0].year(ye.year()).month(ye.month()).date(ye.date())), b.value = ue, B(ue, ee.value || Ce);
        } else
          j.value === "week" ? B(ye.date) : j.value === "dates" && B(ye, !0);
      }, W = (ye) => {
        const Ce = ye ? "add" : "subtract";
        b.value = b.value[Ce](1, "month"), Je("month");
      }, x = (ye) => {
        const Ce = b.value, ue = ye ? "add" : "subtract";
        b.value = N.value === "year" ? Ce[ue](10, "year") : Ce[ue](1, "year"), Je("year");
      }, N = I("date"), R = E(() => {
        const ye = u("el.datepicker.year");
        if (N.value === "year") {
          const Ce = Math.floor(O.value / 10) * 10;
          return ye ? `${Ce} ${ye} - ${Ce + 9} ${ye}` : `${Ce} - ${Ce + 9}`;
        }
        return `${O.value} ${ye}`;
      }), M = (ye) => {
        const Ce = Ge(ye.value) ? ye.value() : ye.value;
        if (Ce) {
          B(at(Ce).locale(c.value));
          return;
        }
        ye.onClick && ye.onClick({
          attrs: l,
          slots: a,
          emit: t
        });
      }, j = E(() => {
        const { type: ye } = n;
        return ["week", "month", "year", "dates"].includes(ye) ? ye : "date";
      }), te = E(() => j.value === "date" ? N.value : j.value), U = E(() => !!p.length), Z = async (ye) => {
        b.value = b.value.startOf("month").month(ye), j.value === "month" ? B(b.value, !1) : (N.value = "date", ["month", "year", "date", "week"].includes(j.value) && (B(b.value, !0), await Fe(), Ae())), Je("month");
      }, pe = async (ye) => {
        j.value === "year" ? (b.value = b.value.startOf("year").year(ye), B(b.value, !1)) : (b.value = b.value.year(ye), N.value = "month", ["month", "year", "date", "week"].includes(j.value) && (B(b.value, !0), await Fe(), Ae())), Je("year");
      }, J = async (ye) => {
        N.value = ye, await Fe(), Ae();
      }, ee = E(() => n.type === "datetime" || n.type === "datetimerange"), ne = E(() => ee.value || j.value === "dates"), Y = () => {
        if (j.value === "dates")
          B(n.parsedValue);
        else {
          let ye = n.parsedValue;
          if (!ye) {
            const Ce = at(v).locale(c.value), ue = fe();
            ye = Ce.year(ue.year()).month(ue.month()).date(ue.date());
          }
          b.value = ye, B(ye);
        }
      }, re = () => {
        const Ce = at().locale(c.value).toDate();
        C.value = !0, (!h || !h(Ce)) && L(Ce) && (b.value = at().locale(c.value), B(b.value));
      }, ce = E(() => vC(n.format)), Te = E(() => hC(n.format)), Pe = E(() => {
        if (A.value)
          return A.value;
        if (!(!n.parsedValue && !y.value))
          return (n.parsedValue || b.value).format(ce.value);
      }), z = E(() => {
        if (P.value)
          return P.value;
        if (!(!n.parsedValue && !y.value))
          return (n.parsedValue || b.value).format(Te.value);
      }), Q = I(!1), de = () => {
        Q.value = !0;
      }, Oe = () => {
        Q.value = !1;
      }, ae = (ye) => ({
        hour: ye.hour(),
        minute: ye.minute(),
        second: ye.second(),
        year: ye.year(),
        month: ye.month(),
        date: ye.date()
      }), Ee = (ye, Ce, ue) => {
        const { hour: q, minute: oe, second: be } = ae(ye), xe = n.parsedValue ? n.parsedValue.hour(q).minute(oe).second(be) : ye;
        b.value = xe, B(b.value, !0), ue || (Q.value = Ce);
      }, we = (ye) => {
        const Ce = at(ye, ce.value).locale(c.value);
        if (Ce.isValid() && L(Ce)) {
          const { year: ue, month: q, date: oe } = ae(b.value);
          b.value = Ce.year(ue).month(q).date(oe), A.value = null, Q.value = !1, B(b.value, !0);
        }
      }, Se = (ye) => {
        const Ce = at(ye, Te.value).locale(c.value);
        if (Ce.isValid()) {
          if (h && h(Ce.toDate()))
            return;
          const { hour: ue, minute: q, second: oe } = ae(b.value);
          b.value = Ce.hour(ue).minute(q).second(oe), P.value = null, B(b.value, !0);
        }
      }, _e = (ye) => at.isDayjs(ye) && ye.isValid() && (h ? !h(ye.toDate()) : !0), ke = (ye) => j.value === "dates" ? ye.map((Ce) => Ce.format(n.format)) : ye.format(n.format), Re = (ye) => at(ye, n.format).locale(c.value), fe = () => {
        const ye = at(y.value).locale(c.value);
        if (!y.value) {
          const Ce = _.value;
          return at().hour(Ce.hour()).minute(Ce.minute()).second(Ce.second()).locale(c.value);
        }
        return ye;
      }, Ae = async () => {
        var ye;
        ["week", "month", "year", "date"].includes(j.value) && ((ye = w.value) == null || ye.focus(), j.value === "week" && tt(We.down));
      }, qe = (ye) => {
        const { code: Ce } = ye;
        [
          We.up,
          We.down,
          We.left,
          We.right,
          We.home,
          We.end,
          We.pageUp,
          We.pageDown
        ].includes(Ce) && (tt(Ce), ye.stopPropagation(), ye.preventDefault()), [We.enter, We.space, We.numpadEnter].includes(Ce) && P.value === null && A.value === null && (ye.preventDefault(), B(b.value, !1));
      }, tt = (ye) => {
        var Ce;
        const { up: ue, down: q, left: oe, right: be, home: xe, end: nt, pageUp: ve, pageDown: Le } = We, lt = {
          year: {
            [ue]: -4,
            [q]: 4,
            [oe]: -1,
            [be]: 1,
            offset: (mt, Mt) => mt.setFullYear(mt.getFullYear() + Mt)
          },
          month: {
            [ue]: -4,
            [q]: 4,
            [oe]: -1,
            [be]: 1,
            offset: (mt, Mt) => mt.setMonth(mt.getMonth() + Mt)
          },
          week: {
            [ue]: -1,
            [q]: 1,
            [oe]: -1,
            [be]: 1,
            offset: (mt, Mt) => mt.setDate(mt.getDate() + Mt * 7)
          },
          date: {
            [ue]: -7,
            [q]: 7,
            [oe]: -1,
            [be]: 1,
            [xe]: (mt) => -mt.getDay(),
            [nt]: (mt) => -mt.getDay() + 6,
            [ve]: (mt) => -new Date(mt.getFullYear(), mt.getMonth(), 0).getDate(),
            [Le]: (mt) => new Date(mt.getFullYear(), mt.getMonth() + 1, 0).getDate(),
            offset: (mt, Mt) => mt.setDate(mt.getDate() + Mt)
          }
        }, ct = b.value.toDate();
        for (; Math.abs(b.value.diff(ct, "year", !0)) < 1; ) {
          const mt = lt[te.value];
          if (!mt)
            return;
          if (mt.offset(ct, Ge(mt[ye]) ? mt[ye](ct) : (Ce = mt[ye]) != null ? Ce : 0), h && h(ct))
            break;
          const Mt = at(ct).locale(c.value);
          b.value = Mt, t("pick", Mt, !0);
          break;
        }
      }, Je = (ye) => {
        t("panel-change", b.value.toDate(), ye, N.value);
      };
      return me(() => j.value, (ye) => {
        if (["month", "year"].includes(ye)) {
          N.value = ye;
          return;
        }
        N.value = "date";
      }, { immediate: !0 }), me(() => N.value, () => {
        d == null || d.updatePopper();
      }), me(() => y.value, (ye) => {
        ye && (b.value = fe());
      }, { immediate: !0 }), me(() => n.parsedValue, (ye) => {
        if (ye) {
          if (j.value === "dates" || Array.isArray(ye))
            return;
          b.value = ye;
        } else
          b.value = fe();
      }, { immediate: !0 }), t("set-picker-option", ["isValidValue", _e]), t("set-picker-option", ["formatToString", ke]), t("set-picker-option", ["parseUserInput", Re]), t("set-picker-option", ["handleFocusPicker", Ae]), (ye, Ce) => (S(), V("div", {
        class: $([
          i(r).b(),
          i(s).b(),
          {
            "has-sidebar": ye.$slots.sidebar || i(U),
            "has-time": i(ee)
          }
        ])
      }, [
        H("div", {
          class: $(i(r).e("body-wrapper"))
        }, [
          he(ye.$slots, "sidebar", {
            class: $(i(r).e("sidebar"))
          }),
          i(U) ? (S(), V("div", {
            key: 0,
            class: $(i(r).e("sidebar"))
          }, [
            (S(!0), V(ze, null, gt(i(p), (ue, q) => (S(), V("button", {
              key: q,
              type: "button",
              class: $(i(r).e("shortcut")),
              onClick: (oe) => M(ue)
            }, Ne(ue.text), 11, jK))), 128))
          ], 2)) : se("v-if", !0),
          H("div", {
            class: $(i(r).e("body"))
          }, [
            i(ee) ? (S(), V("div", {
              key: 0,
              class: $(i(s).e("time-header"))
            }, [
              H("span", {
                class: $(i(s).e("editor-wrap"))
              }, [
                K(i(wn), {
                  placeholder: i(u)("el.datepicker.selectDate"),
                  "model-value": i(z),
                  size: "small",
                  "validate-event": !1,
                  onInput: Ce[0] || (Ce[0] = (ue) => P.value = ue),
                  onChange: Se
                }, null, 8, ["placeholder", "model-value"])
              ], 2),
              ot((S(), V("span", {
                class: $(i(s).e("editor-wrap"))
              }, [
                K(i(wn), {
                  placeholder: i(u)("el.datepicker.selectTime"),
                  "model-value": i(Pe),
                  size: "small",
                  "validate-event": !1,
                  onFocus: de,
                  onInput: Ce[1] || (Ce[1] = (ue) => A.value = ue),
                  onChange: we
                }, null, 8, ["placeholder", "model-value"]),
                K(i(nc), {
                  visible: Q.value,
                  format: i(ce),
                  "time-arrow-control": i(g),
                  "parsed-value": b.value,
                  onPick: Ee
                }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
              ], 2)), [
                [i(Kr), Oe]
              ])
            ], 2)) : se("v-if", !0),
            ot(H("div", {
              class: $([
                i(s).e("header"),
                (N.value === "year" || N.value === "month") && i(s).e("header--bordered")
              ])
            }, [
              H("span", {
                class: $(i(s).e("prev-btn"))
              }, [
                H("button", {
                  type: "button",
                  "aria-label": i(u)("el.datepicker.prevYear"),
                  class: $(["d-arrow-left", i(r).e("icon-btn")]),
                  onClick: Ce[2] || (Ce[2] = (ue) => x(!1))
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i($l))
                    ]),
                    _: 1
                  })
                ], 10, WK),
                ot(H("button", {
                  type: "button",
                  "aria-label": i(u)("el.datepicker.prevMonth"),
                  class: $([i(r).e("icon-btn"), "arrow-left"]),
                  onClick: Ce[3] || (Ce[3] = (ue) => W(!1))
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i(Br))
                    ]),
                    _: 1
                  })
                ], 10, UK), [
                  [$t, N.value === "date"]
                ])
              ], 2),
              H("span", {
                role: "button",
                class: $(i(s).e("header-label")),
                "aria-live": "polite",
                tabindex: "0",
                onKeydown: Ce[4] || (Ce[4] = Et((ue) => J("year"), ["enter"])),
                onClick: Ce[5] || (Ce[5] = (ue) => J("year"))
              }, Ne(i(R)), 35),
              ot(H("span", {
                role: "button",
                "aria-live": "polite",
                tabindex: "0",
                class: $([
                  i(s).e("header-label"),
                  { active: N.value === "month" }
                ]),
                onKeydown: Ce[6] || (Ce[6] = Et((ue) => J("month"), ["enter"])),
                onClick: Ce[7] || (Ce[7] = (ue) => J("month"))
              }, Ne(i(u)(`el.datepicker.month${i(k) + 1}`)), 35), [
                [$t, N.value === "date"]
              ]),
              H("span", {
                class: $(i(s).e("next-btn"))
              }, [
                ot(H("button", {
                  type: "button",
                  "aria-label": i(u)("el.datepicker.nextMonth"),
                  class: $([i(r).e("icon-btn"), "arrow-right"]),
                  onClick: Ce[8] || (Ce[8] = (ue) => W(!0))
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i(kn))
                    ]),
                    _: 1
                  })
                ], 10, qK), [
                  [$t, N.value === "date"]
                ]),
                H("button", {
                  type: "button",
                  "aria-label": i(u)("el.datepicker.nextYear"),
                  class: $([i(r).e("icon-btn"), "d-arrow-right"]),
                  onClick: Ce[9] || (Ce[9] = (ue) => x(!0))
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i(Nl))
                    ]),
                    _: 1
                  })
                ], 10, YK)
              ], 2)
            ], 2), [
              [$t, N.value !== "time"]
            ]),
            H("div", {
              class: $(i(r).e("content")),
              onKeydown: qe
            }, [
              N.value === "date" ? (S(), ie(tp, {
                key: 0,
                ref_key: "currentViewRef",
                ref: w,
                "selection-mode": i(j),
                date: b.value,
                "parsed-value": ye.parsedValue,
                "disabled-date": i(h),
                "cell-class-name": i(m),
                onPick: F
              }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "cell-class-name"])) : se("v-if", !0),
              N.value === "year" ? (S(), ie(KK, {
                key: 1,
                ref_key: "currentViewRef",
                ref: w,
                date: b.value,
                "disabled-date": i(h),
                "parsed-value": ye.parsedValue,
                onPick: pe
              }, null, 8, ["date", "disabled-date", "parsed-value"])) : se("v-if", !0),
              N.value === "month" ? (S(), ie(np, {
                key: 2,
                ref_key: "currentViewRef",
                ref: w,
                date: b.value,
                "parsed-value": ye.parsedValue,
                "disabled-date": i(h),
                onPick: Z
              }, null, 8, ["date", "parsed-value", "disabled-date"])) : se("v-if", !0)
            ], 34)
          ], 2)
        ], 2),
        ot(H("div", {
          class: $(i(r).e("footer"))
        }, [
          ot(K(i(gn), {
            text: "",
            size: "small",
            class: $(i(r).e("link-btn")),
            onClick: re
          }, {
            default: X(() => [
              wt(Ne(i(u)("el.datepicker.now")), 1)
            ]),
            _: 1
          }, 8, ["class"]), [
            [$t, i(j) !== "dates"]
          ]),
          K(i(gn), {
            plain: "",
            size: "small",
            class: $(i(r).e("link-btn")),
            onClick: Y
          }, {
            default: X(() => [
              wt(Ne(i(u)("el.datepicker.confirm")), 1)
            ]),
            _: 1
          }, 8, ["class"])
        ], 2), [
          [$t, i(ne) && N.value === "date"]
        ])
      ], 2));
    }
  });
  var XK = /* @__PURE__ */ Me(GK, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-pick.vue"]]);
  const JK = Ie({
    ...dE,
    ...fE
  }), ZK = (e) => {
    const { emit: t } = it(), n = zl(), o = hn();
    return (s) => {
      const l = Ge(s.value) ? s.value() : s.value;
      if (l) {
        t("pick", [
          at(l[0]).locale(e.value),
          at(l[1]).locale(e.value)
        ]);
        return;
      }
      s.onClick && s.onClick({
        attrs: n,
        slots: o,
        emit: t
      });
    };
  }, vE = (e, {
    defaultValue: t,
    leftDate: n,
    rightDate: o,
    unit: r,
    onParsedValueChanged: s
  }) => {
    const { emit: l } = it(), { pickerNs: a } = Be(Xh), u = ge("date-range-picker"), { t: c, lang: f } = St(), d = ZK(f), p = I(), h = I(), m = I({
      endDate: null,
      selecting: !1
    }), v = (b) => {
      m.value = b;
    }, g = (b = !1) => {
      const C = i(p), _ = i(h);
      ep([C, _]) && l("pick", [C, _], b);
    }, y = (b) => {
      m.value.selecting = b, b || (m.value.endDate = null);
    }, w = () => {
      const [b, C] = hE(i(t), {
        lang: i(f),
        unit: r,
        unlinkPanels: e.unlinkPanels
      });
      p.value = void 0, h.value = void 0, n.value = b, o.value = C;
    };
    return me(t, (b) => {
      b && w();
    }, { immediate: !0 }), me(() => e.parsedValue, (b) => {
      if (De(b) && b.length === 2) {
        const [C, _] = b;
        p.value = C, n.value = C, h.value = _, s(i(p), i(h));
      } else
        w();
    }, { immediate: !0 }), {
      minDate: p,
      maxDate: h,
      rangeState: m,
      lang: f,
      ppNs: a,
      drpNs: u,
      handleChangeRange: v,
      handleRangeConfirm: g,
      handleShortcutClick: d,
      onSelect: y,
      t: c
    };
  }, QK = ["onClick"], e9 = ["disabled"], t9 = ["disabled"], n9 = ["disabled"], o9 = ["disabled"], Gi = "month", r9 = /* @__PURE__ */ G({
    __name: "panel-date-range",
    props: JK,
    emits: [
      "pick",
      "set-picker-option",
      "calendar-change",
      "panel-change"
    ],
    setup(e, { emit: t }) {
      const n = e, o = Be("EP_PICKER_BASE"), {
        disabledDate: r,
        cellClassName: s,
        format: l,
        defaultTime: a,
        arrowControl: u,
        clearable: c
      } = o.props, f = Ht(o.props, "shortcuts"), d = Ht(o.props, "defaultValue"), { lang: p } = St(), h = I(at().locale(p.value)), m = I(at().locale(p.value).add(1, Gi)), {
        minDate: v,
        maxDate: g,
        rangeState: y,
        ppNs: w,
        drpNs: b,
        handleChangeRange: C,
        handleRangeConfirm: _,
        handleShortcutClick: k,
        onSelect: O,
        t: T
      } = vE(n, {
        defaultValue: d,
        leftDate: h,
        rightDate: m,
        unit: Gi,
        onParsedValueChanged: q
      }), P = I({
        min: null,
        max: null
      }), A = I({
        min: null,
        max: null
      }), L = E(() => `${h.value.year()} ${T("el.datepicker.year")} ${T(`el.datepicker.month${h.value.month() + 1}`)}`), D = E(() => `${m.value.year()} ${T("el.datepicker.year")} ${T(`el.datepicker.month${m.value.month() + 1}`)}`), B = E(() => h.value.year()), F = E(() => h.value.month()), W = E(() => m.value.year()), x = E(() => m.value.month()), N = E(() => !!f.value.length), R = E(() => P.value.min !== null ? P.value.min : v.value ? v.value.format(Z.value) : ""), M = E(() => P.value.max !== null ? P.value.max : g.value || v.value ? (g.value || v.value).format(Z.value) : ""), j = E(() => A.value.min !== null ? A.value.min : v.value ? v.value.format(U.value) : ""), te = E(() => A.value.max !== null ? A.value.max : g.value || v.value ? (g.value || v.value).format(U.value) : ""), U = E(() => vC(l)), Z = E(() => hC(l)), pe = () => {
        h.value = h.value.subtract(1, "year"), n.unlinkPanels || (m.value = h.value.add(1, "month")), Pe("year");
      }, J = () => {
        h.value = h.value.subtract(1, "month"), n.unlinkPanels || (m.value = h.value.add(1, "month")), Pe("month");
      }, ee = () => {
        n.unlinkPanels ? m.value = m.value.add(1, "year") : (h.value = h.value.add(1, "year"), m.value = h.value.add(1, "month")), Pe("year");
      }, ne = () => {
        n.unlinkPanels ? m.value = m.value.add(1, "month") : (h.value = h.value.add(1, "month"), m.value = h.value.add(1, "month")), Pe("month");
      }, Y = () => {
        h.value = h.value.add(1, "year"), Pe("year");
      }, re = () => {
        h.value = h.value.add(1, "month"), Pe("month");
      }, ce = () => {
        m.value = m.value.subtract(1, "year"), Pe("year");
      }, Te = () => {
        m.value = m.value.subtract(1, "month"), Pe("month");
      }, Pe = (oe) => {
        t("panel-change", [h.value.toDate(), m.value.toDate()], oe);
      }, z = E(() => {
        const oe = (F.value + 1) % 12, be = F.value + 1 >= 12 ? 1 : 0;
        return n.unlinkPanels && new Date(B.value + be, oe) < new Date(W.value, x.value);
      }), Q = E(() => n.unlinkPanels && W.value * 12 + x.value - (B.value * 12 + F.value + 1) >= 12), de = E(() => !(v.value && g.value && !y.value.selecting && ep([v.value, g.value]))), Oe = E(() => n.type === "datetime" || n.type === "datetimerange"), ae = (oe, be) => {
        if (!!oe)
          return a ? at(a[be] || a).locale(p.value).year(oe.year()).month(oe.month()).date(oe.date()) : oe;
      }, Ee = (oe, be = !0) => {
        const xe = oe.minDate, nt = oe.maxDate, ve = ae(xe, 0), Le = ae(nt, 1);
        g.value === Le && v.value === ve || (t("calendar-change", [xe.toDate(), nt && nt.toDate()]), g.value = Le, v.value = ve, !(!be || Oe.value) && _());
      }, we = I(!1), Se = I(!1), _e = () => {
        we.value = !1;
      }, ke = () => {
        Se.value = !1;
      }, Re = (oe, be) => {
        P.value[be] = oe;
        const xe = at(oe, Z.value).locale(p.value);
        if (xe.isValid()) {
          if (r && r(xe.toDate()))
            return;
          be === "min" ? (h.value = xe, v.value = (v.value || h.value).year(xe.year()).month(xe.month()).date(xe.date()), n.unlinkPanels || (m.value = xe.add(1, "month"), g.value = v.value.add(1, "month"))) : (m.value = xe, g.value = (g.value || m.value).year(xe.year()).month(xe.month()).date(xe.date()), n.unlinkPanels || (h.value = xe.subtract(1, "month"), v.value = g.value.subtract(1, "month")));
        }
      }, fe = (oe, be) => {
        P.value[be] = null;
      }, Ae = (oe, be) => {
        A.value[be] = oe;
        const xe = at(oe, U.value).locale(p.value);
        xe.isValid() && (be === "min" ? (we.value = !0, v.value = (v.value || h.value).hour(xe.hour()).minute(xe.minute()).second(xe.second()), (!g.value || g.value.isBefore(v.value)) && (g.value = v.value)) : (Se.value = !0, g.value = (g.value || m.value).hour(xe.hour()).minute(xe.minute()).second(xe.second()), m.value = g.value, g.value && g.value.isBefore(v.value) && (v.value = g.value)));
      }, qe = (oe, be) => {
        A.value[be] = null, be === "min" ? (h.value = v.value, we.value = !1) : (m.value = g.value, Se.value = !1);
      }, tt = (oe, be, xe) => {
        A.value.min || (oe && (h.value = oe, v.value = (v.value || h.value).hour(oe.hour()).minute(oe.minute()).second(oe.second())), xe || (we.value = be), (!g.value || g.value.isBefore(v.value)) && (g.value = v.value, m.value = oe));
      }, Je = (oe, be, xe) => {
        A.value.max || (oe && (m.value = oe, g.value = (g.value || m.value).hour(oe.hour()).minute(oe.minute()).second(oe.second())), xe || (Se.value = be), g.value && g.value.isBefore(v.value) && (v.value = g.value));
      }, ye = () => {
        h.value = hE(i(d), {
          lang: i(p),
          unit: "month",
          unlinkPanels: n.unlinkPanels
        })[0], m.value = h.value.add(1, "month"), t("pick", null);
      }, Ce = (oe) => De(oe) ? oe.map((be) => be.format(l)) : oe.format(l), ue = (oe) => De(oe) ? oe.map((be) => at(be, l).locale(p.value)) : at(oe, l).locale(p.value);
      function q(oe, be) {
        if (n.unlinkPanels && be) {
          const xe = (oe == null ? void 0 : oe.year()) || 0, nt = (oe == null ? void 0 : oe.month()) || 0, ve = be.year(), Le = be.month();
          m.value = xe === ve && nt === Le ? be.add(1, Gi) : be;
        } else
          m.value = h.value.add(1, Gi), be && (m.value = m.value.hour(be.hour()).minute(be.minute()).second(be.second()));
      }
      return t("set-picker-option", ["isValidValue", ep]), t("set-picker-option", ["parseUserInput", ue]), t("set-picker-option", ["formatToString", Ce]), t("set-picker-option", ["handleClear", ye]), (oe, be) => (S(), V("div", {
        class: $([
          i(w).b(),
          i(b).b(),
          {
            "has-sidebar": oe.$slots.sidebar || i(N),
            "has-time": i(Oe)
          }
        ])
      }, [
        H("div", {
          class: $(i(w).e("body-wrapper"))
        }, [
          he(oe.$slots, "sidebar", {
            class: $(i(w).e("sidebar"))
          }),
          i(N) ? (S(), V("div", {
            key: 0,
            class: $(i(w).e("sidebar"))
          }, [
            (S(!0), V(ze, null, gt(i(f), (xe, nt) => (S(), V("button", {
              key: nt,
              type: "button",
              class: $(i(w).e("shortcut")),
              onClick: (ve) => i(k)(xe)
            }, Ne(xe.text), 11, QK))), 128))
          ], 2)) : se("v-if", !0),
          H("div", {
            class: $(i(w).e("body"))
          }, [
            i(Oe) ? (S(), V("div", {
              key: 0,
              class: $(i(b).e("time-header"))
            }, [
              H("span", {
                class: $(i(b).e("editors-wrap"))
              }, [
                H("span", {
                  class: $(i(b).e("time-picker-wrap"))
                }, [
                  K(i(wn), {
                    size: "small",
                    disabled: i(y).selecting,
                    placeholder: i(T)("el.datepicker.startDate"),
                    class: $(i(b).e("editor")),
                    "model-value": i(R),
                    "validate-event": !1,
                    onInput: be[0] || (be[0] = (xe) => Re(xe, "min")),
                    onChange: be[1] || (be[1] = (xe) => fe(xe, "min"))
                  }, null, 8, ["disabled", "placeholder", "class", "model-value"])
                ], 2),
                ot((S(), V("span", {
                  class: $(i(b).e("time-picker-wrap"))
                }, [
                  K(i(wn), {
                    size: "small",
                    class: $(i(b).e("editor")),
                    disabled: i(y).selecting,
                    placeholder: i(T)("el.datepicker.startTime"),
                    "model-value": i(j),
                    "validate-event": !1,
                    onFocus: be[2] || (be[2] = (xe) => we.value = !0),
                    onInput: be[3] || (be[3] = (xe) => Ae(xe, "min")),
                    onChange: be[4] || (be[4] = (xe) => qe(xe, "min"))
                  }, null, 8, ["class", "disabled", "placeholder", "model-value"]),
                  K(i(nc), {
                    visible: we.value,
                    format: i(U),
                    "datetime-role": "start",
                    "time-arrow-control": i(u),
                    "parsed-value": h.value,
                    onPick: tt
                  }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
                ], 2)), [
                  [i(Kr), _e]
                ])
              ], 2),
              H("span", null, [
                K(i(He), null, {
                  default: X(() => [
                    K(i(kn))
                  ]),
                  _: 1
                })
              ]),
              H("span", {
                class: $([i(b).e("editors-wrap"), "is-right"])
              }, [
                H("span", {
                  class: $(i(b).e("time-picker-wrap"))
                }, [
                  K(i(wn), {
                    size: "small",
                    class: $(i(b).e("editor")),
                    disabled: i(y).selecting,
                    placeholder: i(T)("el.datepicker.endDate"),
                    "model-value": i(M),
                    readonly: !i(v),
                    "validate-event": !1,
                    onInput: be[5] || (be[5] = (xe) => Re(xe, "max")),
                    onChange: be[6] || (be[6] = (xe) => fe(xe, "max"))
                  }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"])
                ], 2),
                ot((S(), V("span", {
                  class: $(i(b).e("time-picker-wrap"))
                }, [
                  K(i(wn), {
                    size: "small",
                    class: $(i(b).e("editor")),
                    disabled: i(y).selecting,
                    placeholder: i(T)("el.datepicker.endTime"),
                    "model-value": i(te),
                    readonly: !i(v),
                    "validate-event": !1,
                    onFocus: be[7] || (be[7] = (xe) => i(v) && (Se.value = !0)),
                    onInput: be[8] || (be[8] = (xe) => Ae(xe, "max")),
                    onChange: be[9] || (be[9] = (xe) => qe(xe, "max"))
                  }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"]),
                  K(i(nc), {
                    "datetime-role": "end",
                    visible: Se.value,
                    format: i(U),
                    "time-arrow-control": i(u),
                    "parsed-value": m.value,
                    onPick: Je
                  }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
                ], 2)), [
                  [i(Kr), ke]
                ])
              ], 2)
            ], 2)) : se("v-if", !0),
            H("div", {
              class: $([[i(w).e("content"), i(b).e("content")], "is-left"])
            }, [
              H("div", {
                class: $(i(b).e("header"))
              }, [
                H("button", {
                  type: "button",
                  class: $([i(w).e("icon-btn"), "d-arrow-left"]),
                  onClick: pe
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i($l))
                    ]),
                    _: 1
                  })
                ], 2),
                H("button", {
                  type: "button",
                  class: $([i(w).e("icon-btn"), "arrow-left"]),
                  onClick: J
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i(Br))
                    ]),
                    _: 1
                  })
                ], 2),
                oe.unlinkPanels ? (S(), V("button", {
                  key: 0,
                  type: "button",
                  disabled: !i(Q),
                  class: $([[i(w).e("icon-btn"), { "is-disabled": !i(Q) }], "d-arrow-right"]),
                  onClick: Y
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i(Nl))
                    ]),
                    _: 1
                  })
                ], 10, e9)) : se("v-if", !0),
                oe.unlinkPanels ? (S(), V("button", {
                  key: 1,
                  type: "button",
                  disabled: !i(z),
                  class: $([[
                    i(w).e("icon-btn"),
                    { "is-disabled": !i(z) }
                  ], "arrow-right"]),
                  onClick: re
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i(kn))
                    ]),
                    _: 1
                  })
                ], 10, t9)) : se("v-if", !0),
                H("div", null, Ne(i(L)), 1)
              ], 2),
              K(tp, {
                "selection-mode": "range",
                date: h.value,
                "min-date": i(v),
                "max-date": i(g),
                "range-state": i(y),
                "disabled-date": i(r),
                "cell-class-name": i(s),
                onChangerange: i(C),
                onPick: Ee,
                onSelect: i(O)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])
            ], 2),
            H("div", {
              class: $([[i(w).e("content"), i(b).e("content")], "is-right"])
            }, [
              H("div", {
                class: $(i(b).e("header"))
              }, [
                oe.unlinkPanels ? (S(), V("button", {
                  key: 0,
                  type: "button",
                  disabled: !i(Q),
                  class: $([[i(w).e("icon-btn"), { "is-disabled": !i(Q) }], "d-arrow-left"]),
                  onClick: ce
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i($l))
                    ]),
                    _: 1
                  })
                ], 10, n9)) : se("v-if", !0),
                oe.unlinkPanels ? (S(), V("button", {
                  key: 1,
                  type: "button",
                  disabled: !i(z),
                  class: $([[
                    i(w).e("icon-btn"),
                    { "is-disabled": !i(z) }
                  ], "arrow-left"]),
                  onClick: Te
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i(Br))
                    ]),
                    _: 1
                  })
                ], 10, o9)) : se("v-if", !0),
                H("button", {
                  type: "button",
                  class: $([i(w).e("icon-btn"), "d-arrow-right"]),
                  onClick: ee
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i(Nl))
                    ]),
                    _: 1
                  })
                ], 2),
                H("button", {
                  type: "button",
                  class: $([i(w).e("icon-btn"), "arrow-right"]),
                  onClick: ne
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i(kn))
                    ]),
                    _: 1
                  })
                ], 2),
                H("div", null, Ne(i(D)), 1)
              ], 2),
              K(tp, {
                "selection-mode": "range",
                date: m.value,
                "min-date": i(v),
                "max-date": i(g),
                "range-state": i(y),
                "disabled-date": i(r),
                "cell-class-name": i(s),
                onChangerange: i(C),
                onPick: Ee,
                onSelect: i(O)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])
            ], 2)
          ], 2)
        ], 2),
        i(Oe) ? (S(), V("div", {
          key: 0,
          class: $(i(w).e("footer"))
        }, [
          i(c) ? (S(), ie(i(gn), {
            key: 0,
            text: "",
            size: "small",
            class: $(i(w).e("link-btn")),
            onClick: ye
          }, {
            default: X(() => [
              wt(Ne(i(T)("el.datepicker.clear")), 1)
            ]),
            _: 1
          }, 8, ["class"])) : se("v-if", !0),
          K(i(gn), {
            plain: "",
            size: "small",
            class: $(i(w).e("link-btn")),
            disabled: i(de),
            onClick: be[10] || (be[10] = (xe) => i(_)(!1))
          }, {
            default: X(() => [
              wt(Ne(i(T)("el.datepicker.confirm")), 1)
            ]),
            _: 1
          }, 8, ["class", "disabled"])
        ], 2)) : se("v-if", !0)
      ], 2));
    }
  });
  var s9 = /* @__PURE__ */ Me(r9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-range.vue"]]);
  const l9 = Ie({
    ...fE
  }), a9 = ["pick", "set-picker-option"], i9 = ({
    unlinkPanels: e,
    leftDate: t,
    rightDate: n
  }) => {
    const { t: o } = St(), r = () => {
      t.value = t.value.subtract(1, "year"), e.value || (n.value = n.value.subtract(1, "year"));
    }, s = () => {
      e.value || (t.value = t.value.add(1, "year")), n.value = n.value.add(1, "year");
    }, l = () => {
      t.value = t.value.add(1, "year");
    }, a = () => {
      n.value = n.value.subtract(1, "year");
    }, u = E(() => `${t.value.year()} ${o("el.datepicker.year")}`), c = E(() => `${n.value.year()} ${o("el.datepicker.year")}`), f = E(() => t.value.year()), d = E(() => n.value.year() === t.value.year() ? t.value.year() + 1 : n.value.year());
    return {
      leftPrevYear: r,
      rightNextYear: s,
      leftNextYear: l,
      rightPrevYear: a,
      leftLabel: u,
      rightLabel: c,
      leftYear: f,
      rightYear: d
    };
  }, u9 = ["onClick"], c9 = ["disabled"], d9 = ["disabled"], Xi = "year", f9 = G({
    name: "DatePickerMonthRange"
  }), p9 = /* @__PURE__ */ G({
    ...f9,
    props: l9,
    emits: a9,
    setup(e, { emit: t }) {
      const n = e, { lang: o } = St(), r = Be("EP_PICKER_BASE"), { shortcuts: s, disabledDate: l, format: a } = r.props, u = Ht(r.props, "defaultValue"), c = I(at().locale(o.value)), f = I(at().locale(o.value).add(1, Xi)), {
        minDate: d,
        maxDate: p,
        rangeState: h,
        ppNs: m,
        drpNs: v,
        handleChangeRange: g,
        handleRangeConfirm: y,
        handleShortcutClick: w,
        onSelect: b
      } = vE(n, {
        defaultValue: u,
        leftDate: c,
        rightDate: f,
        unit: Xi,
        onParsedValueChanged: x
      }), C = E(() => !!s.length), {
        leftPrevYear: _,
        rightNextYear: k,
        leftNextYear: O,
        rightPrevYear: T,
        leftLabel: P,
        rightLabel: A,
        leftYear: L,
        rightYear: D
      } = i9({
        unlinkPanels: Ht(n, "unlinkPanels"),
        leftDate: c,
        rightDate: f
      }), B = E(() => n.unlinkPanels && D.value > L.value + 1), F = (N, R = !0) => {
        const M = N.minDate, j = N.maxDate;
        p.value === j && d.value === M || (p.value = j, d.value = M, R && y());
      }, W = (N) => N.map((R) => R.format(a));
      function x(N, R) {
        if (n.unlinkPanels && R) {
          const M = (N == null ? void 0 : N.year()) || 0, j = R.year();
          f.value = M === j ? R.add(1, Xi) : R;
        } else
          f.value = c.value.add(1, Xi);
      }
      return t("set-picker-option", ["formatToString", W]), (N, R) => (S(), V("div", {
        class: $([
          i(m).b(),
          i(v).b(),
          {
            "has-sidebar": Boolean(N.$slots.sidebar) || i(C)
          }
        ])
      }, [
        H("div", {
          class: $(i(m).e("body-wrapper"))
        }, [
          he(N.$slots, "sidebar", {
            class: $(i(m).e("sidebar"))
          }),
          i(C) ? (S(), V("div", {
            key: 0,
            class: $(i(m).e("sidebar"))
          }, [
            (S(!0), V(ze, null, gt(i(s), (M, j) => (S(), V("button", {
              key: j,
              type: "button",
              class: $(i(m).e("shortcut")),
              onClick: (te) => i(w)(M)
            }, Ne(M.text), 11, u9))), 128))
          ], 2)) : se("v-if", !0),
          H("div", {
            class: $(i(m).e("body"))
          }, [
            H("div", {
              class: $([[i(m).e("content"), i(v).e("content")], "is-left"])
            }, [
              H("div", {
                class: $(i(v).e("header"))
              }, [
                H("button", {
                  type: "button",
                  class: $([i(m).e("icon-btn"), "d-arrow-left"]),
                  onClick: R[0] || (R[0] = (...M) => i(_) && i(_)(...M))
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i($l))
                    ]),
                    _: 1
                  })
                ], 2),
                N.unlinkPanels ? (S(), V("button", {
                  key: 0,
                  type: "button",
                  disabled: !i(B),
                  class: $([[
                    i(m).e("icon-btn"),
                    { [i(m).is("disabled")]: !i(B) }
                  ], "d-arrow-right"]),
                  onClick: R[1] || (R[1] = (...M) => i(O) && i(O)(...M))
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i(Nl))
                    ]),
                    _: 1
                  })
                ], 10, c9)) : se("v-if", !0),
                H("div", null, Ne(i(P)), 1)
              ], 2),
              K(np, {
                "selection-mode": "range",
                date: c.value,
                "min-date": i(d),
                "max-date": i(p),
                "range-state": i(h),
                "disabled-date": i(l),
                onChangerange: i(g),
                onPick: F,
                onSelect: i(b)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
            ], 2),
            H("div", {
              class: $([[i(m).e("content"), i(v).e("content")], "is-right"])
            }, [
              H("div", {
                class: $(i(v).e("header"))
              }, [
                N.unlinkPanels ? (S(), V("button", {
                  key: 0,
                  type: "button",
                  disabled: !i(B),
                  class: $([[i(m).e("icon-btn"), { "is-disabled": !i(B) }], "d-arrow-left"]),
                  onClick: R[2] || (R[2] = (...M) => i(T) && i(T)(...M))
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i($l))
                    ]),
                    _: 1
                  })
                ], 10, d9)) : se("v-if", !0),
                H("button", {
                  type: "button",
                  class: $([i(m).e("icon-btn"), "d-arrow-right"]),
                  onClick: R[3] || (R[3] = (...M) => i(k) && i(k)(...M))
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i(Nl))
                    ]),
                    _: 1
                  })
                ], 2),
                H("div", null, Ne(i(A)), 1)
              ], 2),
              K(np, {
                "selection-mode": "range",
                date: f.value,
                "min-date": i(d),
                "max-date": i(p),
                "range-state": i(h),
                "disabled-date": i(l),
                onChangerange: i(g),
                onPick: F,
                onSelect: i(b)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
            ], 2)
          ], 2)
        ], 2)
      ], 2));
    }
  });
  var h9 = /* @__PURE__ */ Me(p9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-month-range.vue"]]);
  const v9 = function(e) {
    switch (e) {
      case "daterange":
      case "datetimerange":
        return s9;
      case "monthrange":
        return h9;
      default:
        return XK;
    }
  };
  at.extend(IC);
  at.extend(dK);
  at.extend(Uh);
  at.extend(fK);
  at.extend(pK);
  at.extend(hK);
  at.extend(vK);
  at.extend(mK);
  var m9 = G({
    name: "ElDatePicker",
    install: null,
    props: {
      ...qh,
      ...gK
    },
    emits: ["update:modelValue"],
    setup(e, {
      expose: t,
      emit: n,
      slots: o
    }) {
      const r = ge("picker-panel");
      pt("ElPopperOptions", Tt(Ht(e, "popperOptions"))), pt(Xh, {
        slots: o,
        pickerNs: r
      });
      const s = I();
      t({
        focus: (u = !0) => {
          var c;
          (c = s.value) == null || c.focus(u);
        },
        handleOpen: () => {
          var u;
          (u = s.value) == null || u.handleOpen();
        },
        handleClose: () => {
          var u;
          (u = s.value) == null || u.handleClose();
        }
      });
      const a = (u) => {
        n("update:modelValue", u);
      };
      return () => {
        var u;
        const c = (u = e.format) != null ? u : uF[e.type] || Js, f = v9(e.type);
        return K(yC, ft(e, {
          format: c,
          type: e.type,
          ref: s,
          "onUpdate:modelValue": a
        }), {
          default: (d) => K(f, d, null),
          "range-separator": o["range-separator"]
        });
      };
    }
  });
  const wu = m9;
  wu.install = (e) => {
    e.component(wu.name, wu);
  };
  const g9 = wu, Zh = Symbol("elDescriptions");
  var ta = G({
    name: "ElDescriptionsCell",
    props: {
      cell: {
        type: Object
      },
      tag: {
        type: String
      },
      type: {
        type: String
      }
    },
    setup() {
      return {
        descriptions: Be(Zh, {})
      };
    },
    render() {
      var e, t, n, o, r, s;
      const l = hD(this.cell), { border: a, direction: u } = this.descriptions, c = u === "vertical", f = ((n = (t = (e = this.cell) == null ? void 0 : e.children) == null ? void 0 : t.label) == null ? void 0 : n.call(t)) || l.label, d = (s = (r = (o = this.cell) == null ? void 0 : o.children) == null ? void 0 : r.default) == null ? void 0 : s.call(r), p = l.span, h = l.align ? `is-${l.align}` : "", m = l.labelAlign ? `is-${l.labelAlign}` : h, v = l.className, g = l.labelClassName, y = {
        width: Jt(l.width),
        minWidth: Jt(l.minWidth)
      }, w = ge("descriptions");
      switch (this.type) {
        case "label":
          return je(this.tag, {
            style: y,
            class: [
              w.e("cell"),
              w.e("label"),
              w.is("bordered-label", a),
              w.is("vertical-label", c),
              m,
              g
            ],
            colSpan: c ? p : 1
          }, f);
        case "content":
          return je(this.tag, {
            style: y,
            class: [
              w.e("cell"),
              w.e("content"),
              w.is("bordered-content", a),
              w.is("vertical-content", c),
              h,
              v
            ],
            colSpan: c ? p : p * 2 - 1
          }, d);
        default:
          return je("td", {
            style: y,
            class: [w.e("cell"), h],
            colSpan: p
          }, [
            nn(f) ? void 0 : je("span", {
              class: [w.e("label"), g]
            }, f),
            je("span", {
              class: [w.e("content"), v]
            }, d)
          ]);
      }
    }
  });
  const y9 = Ie({
    row: {
      type: Array,
      default: () => []
    }
  }), b9 = { key: 1 }, w9 = G({
    name: "ElDescriptionsRow"
  }), C9 = /* @__PURE__ */ G({
    ...w9,
    props: y9,
    setup(e) {
      const t = Be(Zh, {});
      return (n, o) => i(t).direction === "vertical" ? (S(), V(ze, { key: 0 }, [
        H("tr", null, [
          (S(!0), V(ze, null, gt(n.row, (r, s) => (S(), ie(i(ta), {
            key: `tr1-${s}`,
            cell: r,
            tag: "th",
            type: "label"
          }, null, 8, ["cell"]))), 128))
        ]),
        H("tr", null, [
          (S(!0), V(ze, null, gt(n.row, (r, s) => (S(), ie(i(ta), {
            key: `tr2-${s}`,
            cell: r,
            tag: "td",
            type: "content"
          }, null, 8, ["cell"]))), 128))
        ])
      ], 64)) : (S(), V("tr", b9, [
        (S(!0), V(ze, null, gt(n.row, (r, s) => (S(), V(ze, {
          key: `tr3-${s}`
        }, [
          i(t).border ? (S(), V(ze, { key: 0 }, [
            K(i(ta), {
              cell: r,
              tag: "td",
              type: "label"
            }, null, 8, ["cell"]),
            K(i(ta), {
              cell: r,
              tag: "td",
              type: "content"
            }, null, 8, ["cell"])
          ], 64)) : (S(), ie(i(ta), {
            key: 1,
            cell: r,
            tag: "td",
            type: "both"
          }, null, 8, ["cell"]))
        ], 64))), 128))
      ]));
    }
  });
  var E9 = /* @__PURE__ */ Me(C9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/descriptions-row.vue"]]);
  const S9 = Ie({
    border: {
      type: Boolean,
      default: !1
    },
    column: {
      type: Number,
      default: 3
    },
    direction: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "horizontal"
    },
    size: yn,
    title: {
      type: String,
      default: ""
    },
    extra: {
      type: String,
      default: ""
    }
  }), _9 = G({
    name: "ElDescriptions"
  }), k9 = /* @__PURE__ */ G({
    ..._9,
    props: S9,
    setup(e) {
      const t = e, n = ge("descriptions"), o = on(), r = hn();
      pt(Zh, t);
      const s = E(() => [n.b(), n.m(o.value)]), l = (u, c, f, d = !1) => (u.props || (u.props = {}), c > f && (u.props.span = f), d && (u.props.span = c), u), a = () => {
        var u;
        const c = dl((u = r.default) == null ? void 0 : u.call(r)).filter((m) => {
          var v;
          return ((v = m == null ? void 0 : m.type) == null ? void 0 : v.name) === "ElDescriptionsItem";
        }), f = [];
        let d = [], p = t.column, h = 0;
        return c.forEach((m, v) => {
          var g;
          const y = ((g = m.props) == null ? void 0 : g.span) || 1;
          if (v < c.length - 1 && (h += y > p ? p : y), v === c.length - 1) {
            const w = t.column - h % t.column;
            d.push(l(m, w, p, !0)), f.push(d);
            return;
          }
          y < p ? (p -= y, d.push(m)) : (d.push(l(m, y, p)), f.push(d), p = t.column, d = []);
        }), f;
      };
      return (u, c) => (S(), V("div", {
        class: $(i(s))
      }, [
        u.title || u.extra || u.$slots.title || u.$slots.extra ? (S(), V("div", {
          key: 0,
          class: $(i(n).e("header"))
        }, [
          H("div", {
            class: $(i(n).e("title"))
          }, [
            he(u.$slots, "title", {}, () => [
              wt(Ne(u.title), 1)
            ])
          ], 2),
          H("div", {
            class: $(i(n).e("extra"))
          }, [
            he(u.$slots, "extra", {}, () => [
              wt(Ne(u.extra), 1)
            ])
          ], 2)
        ], 2)) : se("v-if", !0),
        H("div", {
          class: $(i(n).e("body"))
        }, [
          H("table", {
            class: $([i(n).e("table"), i(n).is("bordered", u.border)])
          }, [
            H("tbody", null, [
              (S(!0), V(ze, null, gt(a(), (f, d) => (S(), ie(E9, {
                key: d,
                row: f
              }, null, 8, ["row"]))), 128))
            ])
          ], 2)
        ], 2)
      ], 2));
    }
  });
  var $9 = /* @__PURE__ */ Me(k9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/description.vue"]]), mE = G({
    name: "ElDescriptionsItem",
    props: {
      label: {
        type: String,
        default: ""
      },
      span: {
        type: Number,
        default: 1
      },
      width: {
        type: [String, Number],
        default: ""
      },
      minWidth: {
        type: [String, Number],
        default: ""
      },
      align: {
        type: String,
        default: "left"
      },
      labelAlign: {
        type: String,
        default: ""
      },
      className: {
        type: String,
        default: ""
      },
      labelClassName: {
        type: String,
        default: ""
      }
    }
  });
  const N9 = ut($9, {
    DescriptionsItem: mE
  }), T9 = Gt(mE), O9 = Ie({
    mask: {
      type: Boolean,
      default: !0
    },
    customMaskEvent: {
      type: Boolean,
      default: !1
    },
    overlayClass: {
      type: le([
        String,
        Array,
        Object
      ])
    },
    zIndex: {
      type: le([String, Number])
    }
  }), M9 = {
    click: (e) => e instanceof MouseEvent
  }, I9 = "overlay";
  var P9 = G({
    name: "ElOverlay",
    props: O9,
    emits: M9,
    setup(e, { slots: t, emit: n }) {
      const o = ge(I9), r = (u) => {
        n("click", u);
      }, { onClick: s, onMousedown: l, onMouseup: a } = xh(e.customMaskEvent ? void 0 : r);
      return () => e.mask ? K("div", {
        class: [o.b(), e.overlayClass],
        style: {
          zIndex: e.zIndex
        },
        onClick: s,
        onMousedown: l,
        onMouseup: a
      }, [he(t, "default")], Zn.STYLE | Zn.CLASS | Zn.PROPS, ["onClick", "onMouseup", "onMousedown"]) : je("div", {
        class: e.overlayClass,
        style: {
          zIndex: e.zIndex,
          position: "fixed",
          top: "0px",
          right: "0px",
          bottom: "0px",
          left: "0px"
        }
      }, [he(t, "default")]);
    }
  });
  const Qh = P9, gE = Symbol("dialogInjectionKey"), yE = Ie({
    center: {
      type: Boolean,
      default: !1
    },
    alignCenter: {
      type: Boolean,
      default: !1
    },
    closeIcon: {
      type: Vt
    },
    customClass: {
      type: String,
      default: ""
    },
    draggable: {
      type: Boolean,
      default: !1
    },
    fullscreen: {
      type: Boolean,
      default: !1
    },
    showClose: {
      type: Boolean,
      default: !0
    },
    title: {
      type: String,
      default: ""
    }
  }), A9 = {
    close: () => !0
  }, R9 = ["aria-label"], x9 = ["id"], D9 = G({ name: "ElDialogContent" }), L9 = /* @__PURE__ */ G({
    ...D9,
    props: yE,
    emits: A9,
    setup(e) {
      const t = e, { t: n } = St(), { Close: o } = nw, { dialogRef: r, headerRef: s, bodyId: l, ns: a, style: u } = Be(gE), { focusTrapRef: c } = Be(Kh), f = Hc(c, r), d = E(() => t.draggable);
      return lw(r, s, d), (p, h) => (S(), V("div", {
        ref: i(f),
        class: $([
          i(a).b(),
          i(a).is("fullscreen", p.fullscreen),
          i(a).is("draggable", i(d)),
          i(a).is("align-center", p.alignCenter),
          { [i(a).m("center")]: p.center },
          p.customClass
        ]),
        style: Ke(i(u)),
        tabindex: "-1"
      }, [
        H("header", {
          ref_key: "headerRef",
          ref: s,
          class: $(i(a).e("header"))
        }, [
          he(p.$slots, "header", {}, () => [
            H("span", {
              role: "heading",
              class: $(i(a).e("title"))
            }, Ne(p.title), 3)
          ]),
          p.showClose ? (S(), V("button", {
            key: 0,
            "aria-label": i(n)("el.dialog.close"),
            class: $(i(a).e("headerbtn")),
            type: "button",
            onClick: h[0] || (h[0] = (m) => p.$emit("close"))
          }, [
            K(i(He), {
              class: $(i(a).e("close"))
            }, {
              default: X(() => [
                (S(), ie(vt(p.closeIcon || i(o))))
              ]),
              _: 1
            }, 8, ["class"])
          ], 10, R9)) : se("v-if", !0)
        ], 2),
        H("div", {
          id: i(l),
          class: $(i(a).e("body"))
        }, [
          he(p.$slots, "default")
        ], 10, x9),
        p.$slots.footer ? (S(), V("footer", {
          key: 0,
          class: $(i(a).e("footer"))
        }, [
          he(p.$slots, "footer")
        ], 2)) : se("v-if", !0)
      ], 6));
    }
  });
  var V9 = /* @__PURE__ */ Me(L9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);
  const bE = Ie({
    ...yE,
    appendToBody: {
      type: Boolean,
      default: !1
    },
    beforeClose: {
      type: le(Function)
    },
    destroyOnClose: {
      type: Boolean,
      default: !1
    },
    closeOnClickModal: {
      type: Boolean,
      default: !0
    },
    closeOnPressEscape: {
      type: Boolean,
      default: !0
    },
    lockScroll: {
      type: Boolean,
      default: !0
    },
    modal: {
      type: Boolean,
      default: !0
    },
    openDelay: {
      type: Number,
      default: 0
    },
    closeDelay: {
      type: Number,
      default: 0
    },
    top: {
      type: String
    },
    modelValue: {
      type: Boolean,
      default: !1
    },
    modalClass: String,
    width: {
      type: [String, Number]
    },
    zIndex: {
      type: Number
    },
    trapFocus: {
      type: Boolean,
      default: !1
    }
  }), wE = {
    open: () => !0,
    opened: () => !0,
    close: () => !0,
    closed: () => !0,
    [dt]: (e) => tn(e),
    openAutoFocus: () => !0,
    closeAutoFocus: () => !0
  }, CE = (e, t) => {
    const o = it().emit, { nextZIndex: r } = Fs();
    let s = "";
    const l = io(), a = io(), u = I(!1), c = I(!1), f = I(!1), d = I(e.zIndex || r());
    let p, h;
    const m = Gc("namespace", Ju), v = E(() => {
      const F = {}, W = `--${m.value}-dialog`;
      return e.fullscreen || (e.top && (F[`${W}-margin-top`] = e.top), e.width && (F[`${W}-width`] = Jt(e.width))), F;
    }), g = E(() => e.alignCenter ? { display: "flex" } : {});
    function y() {
      o("opened");
    }
    function w() {
      o("closed"), o(dt, !1), e.destroyOnClose && (f.value = !1);
    }
    function b() {
      o("close");
    }
    function C() {
      h == null || h(), p == null || p(), e.openDelay && e.openDelay > 0 ? { stop: p } = Os(() => T(), e.openDelay) : T();
    }
    function _() {
      p == null || p(), h == null || h(), e.closeDelay && e.closeDelay > 0 ? { stop: h } = Os(() => P(), e.closeDelay) : P();
    }
    function k() {
      function F(W) {
        W || (c.value = !0, u.value = !1);
      }
      e.beforeClose ? e.beforeClose(F) : _();
    }
    function O() {
      e.closeOnClickModal && k();
    }
    function T() {
      !bt || (u.value = !0);
    }
    function P() {
      u.value = !1;
    }
    function A() {
      o("openAutoFocus");
    }
    function L() {
      o("closeAutoFocus");
    }
    function D(F) {
      var W;
      ((W = F.detail) == null ? void 0 : W.focusReason) === "pointer" && F.preventDefault();
    }
    e.lockScroll && uw(u);
    function B() {
      e.closeOnPressEscape && k();
    }
    return me(() => e.modelValue, (F) => {
      F ? (c.value = !1, C(), f.value = !0, d.value = e.zIndex ? d.value++ : r(), Fe(() => {
        o("open"), t.value && (t.value.scrollTop = 0);
      })) : u.value && _();
    }), me(() => e.fullscreen, (F) => {
      !t.value || (F ? (s = t.value.style.transform, t.value.style.transform = "") : t.value.style.transform = s);
    }), st(() => {
      e.modelValue && (u.value = !0, f.value = !0, C());
    }), {
      afterEnter: y,
      afterLeave: w,
      beforeLeave: b,
      handleClose: k,
      onModalClick: O,
      close: _,
      doClose: P,
      onOpenAutoFocus: A,
      onCloseAutoFocus: L,
      onCloseRequested: B,
      onFocusoutPrevented: D,
      titleId: l,
      bodyId: a,
      closed: c,
      style: v,
      overlayDialogStyle: g,
      rendered: f,
      visible: u,
      zIndex: d
    };
  }, B9 = ["aria-label", "aria-labelledby", "aria-describedby"], F9 = G({
    name: "ElDialog",
    inheritAttrs: !1
  }), H9 = /* @__PURE__ */ G({
    ...F9,
    props: bE,
    emits: wE,
    setup(e, { expose: t }) {
      const n = e, o = hn();
      Vo({
        scope: "el-dialog",
        from: "the title slot",
        replacement: "the header slot",
        version: "3.0.0",
        ref: "https://element-plus.org/en-US/component/dialog.html#slots"
      }, E(() => !!o.title)), Vo({
        scope: "el-dialog",
        from: "custom-class",
        replacement: "class",
        version: "2.3.0",
        ref: "https://element-plus.org/en-US/component/dialog.html#attributes",
        type: "Attribute"
      }, E(() => !!n.customClass));
      const r = ge("dialog"), s = I(), l = I(), a = I(), {
        visible: u,
        titleId: c,
        bodyId: f,
        style: d,
        overlayDialogStyle: p,
        rendered: h,
        zIndex: m,
        afterEnter: v,
        afterLeave: g,
        beforeLeave: y,
        handleClose: w,
        onModalClick: b,
        onOpenAutoFocus: C,
        onCloseAutoFocus: _,
        onCloseRequested: k,
        onFocusoutPrevented: O
      } = CE(n, s);
      pt(gE, {
        dialogRef: s,
        headerRef: l,
        bodyId: f,
        ns: r,
        rendered: h,
        style: d
      });
      const T = xh(b), P = E(() => n.draggable && !n.fullscreen);
      return t({
        visible: u,
        dialogContentRef: a
      }), (A, L) => (S(), ie(pi, {
        to: "body",
        disabled: !A.appendToBody
      }, [
        K(Qt, {
          name: "dialog-fade",
          onAfterEnter: i(v),
          onAfterLeave: i(g),
          onBeforeLeave: i(y),
          persisted: ""
        }, {
          default: X(() => [
            ot(K(i(Qh), {
              "custom-mask-event": "",
              mask: A.modal,
              "overlay-class": A.modalClass,
              "z-index": i(m)
            }, {
              default: X(() => [
                H("div", {
                  role: "dialog",
                  "aria-modal": "true",
                  "aria-label": A.title || void 0,
                  "aria-labelledby": A.title ? void 0 : i(c),
                  "aria-describedby": i(f),
                  class: $(`${i(r).namespace.value}-overlay-dialog`),
                  style: Ke(i(p)),
                  onClick: L[0] || (L[0] = (...D) => i(T).onClick && i(T).onClick(...D)),
                  onMousedown: L[1] || (L[1] = (...D) => i(T).onMousedown && i(T).onMousedown(...D)),
                  onMouseup: L[2] || (L[2] = (...D) => i(T).onMouseup && i(T).onMouseup(...D))
                }, [
                  K(i(Zc), {
                    loop: "",
                    trapped: i(u),
                    "focus-start-el": "container",
                    onFocusAfterTrapped: i(C),
                    onFocusAfterReleased: i(_),
                    onFocusoutPrevented: i(O),
                    onReleaseRequested: i(k)
                  }, {
                    default: X(() => [
                      i(h) ? (S(), ie(V9, ft({
                        key: 0,
                        ref_key: "dialogContentRef",
                        ref: a
                      }, A.$attrs, {
                        "custom-class": A.customClass,
                        center: A.center,
                        "align-center": A.alignCenter,
                        "close-icon": A.closeIcon,
                        draggable: i(P),
                        fullscreen: A.fullscreen,
                        "show-close": A.showClose,
                        title: A.title,
                        onClose: i(w)
                      }), lr({
                        header: X(() => [
                          A.$slots.title ? he(A.$slots, "title", { key: 1 }) : he(A.$slots, "header", {
                            key: 0,
                            close: i(w),
                            titleId: i(c),
                            titleClass: i(r).e("title")
                          })
                        ]),
                        default: X(() => [
                          he(A.$slots, "default")
                        ]),
                        _: 2
                      }, [
                        A.$slots.footer ? {
                          name: "footer",
                          fn: X(() => [
                            he(A.$slots, "footer")
                          ])
                        } : void 0
                      ]), 1040, ["custom-class", "center", "align-center", "close-icon", "draggable", "fullscreen", "show-close", "title", "onClose"])) : se("v-if", !0)
                    ]),
                    _: 3
                  }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                ], 46, B9)
              ]),
              _: 3
            }, 8, ["mask", "overlay-class", "z-index"]), [
              [$t, i(u)]
            ])
          ]),
          _: 3
        }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
      ], 8, ["disabled"]));
    }
  });
  var z9 = /* @__PURE__ */ Me(H9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);
  const K9 = ut(z9), j9 = Ie({
    direction: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "horizontal"
    },
    contentPosition: {
      type: String,
      values: ["left", "center", "right"],
      default: "center"
    },
    borderStyle: {
      type: le(String),
      default: "solid"
    }
  }), W9 = G({
    name: "ElDivider"
  }), U9 = /* @__PURE__ */ G({
    ...W9,
    props: j9,
    setup(e) {
      const t = e, n = ge("divider"), o = E(() => n.cssVar({
        "border-style": t.borderStyle
      }));
      return (r, s) => (S(), V("div", {
        class: $([i(n).b(), i(n).m(r.direction)]),
        style: Ke(i(o)),
        role: "separator"
      }, [
        r.$slots.default && r.direction !== "vertical" ? (S(), V("div", {
          key: 0,
          class: $([i(n).e("text"), i(n).is(r.contentPosition)])
        }, [
          he(r.$slots, "default")
        ], 2)) : se("v-if", !0)
      ], 6));
    }
  });
  var q9 = /* @__PURE__ */ Me(U9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/divider/src/divider.vue"]]);
  const EE = ut(q9), Y9 = Ie({
    ...bE,
    direction: {
      type: String,
      default: "rtl",
      values: ["ltr", "rtl", "ttb", "btt"]
    },
    size: {
      type: [String, Number],
      default: "30%"
    },
    withHeader: {
      type: Boolean,
      default: !0
    },
    modalFade: {
      type: Boolean,
      default: !0
    }
  }), G9 = wE, X9 = G({
    name: "ElDrawer",
    components: {
      ElOverlay: Qh,
      ElFocusTrap: Zc,
      ElIcon: He,
      Close: _o
    },
    inheritAttrs: !1,
    props: Y9,
    emits: G9,
    setup(e, { slots: t }) {
      Vo({
        scope: "el-drawer",
        from: "the title slot",
        replacement: "the header slot",
        version: "3.0.0",
        ref: "https://element-plus.org/en-US/component/drawer.html#slots"
      }, E(() => !!t.title)), Vo({
        scope: "el-drawer",
        from: "custom-class",
        replacement: "class",
        version: "2.3.0",
        ref: "https://element-plus.org/en-US/component/drawer.html#attributes",
        type: "Attribute"
      }, E(() => !!e.customClass));
      const n = I(), o = I(), r = ge("drawer"), { t: s } = St(), l = E(() => e.direction === "rtl" || e.direction === "ltr"), a = E(() => Jt(e.size));
      return {
        ...CE(e, n),
        drawerRef: n,
        focusStartRef: o,
        isHorizontal: l,
        drawerSize: a,
        ns: r,
        t: s
      };
    }
  }), J9 = ["aria-label", "aria-labelledby", "aria-describedby"], Z9 = ["id"], Q9 = ["aria-label"], ej = ["id"];
  function tj(e, t, n, o, r, s) {
    const l = Qe("close"), a = Qe("el-icon"), u = Qe("el-focus-trap"), c = Qe("el-overlay");
    return S(), ie(pi, {
      to: "body",
      disabled: !e.appendToBody
    }, [
      K(Qt, {
        name: e.ns.b("fade"),
        onAfterEnter: e.afterEnter,
        onAfterLeave: e.afterLeave,
        onBeforeLeave: e.beforeLeave,
        persisted: ""
      }, {
        default: X(() => [
          ot(K(c, {
            mask: e.modal,
            "overlay-class": e.modalClass,
            "z-index": e.zIndex,
            onClick: e.onModalClick
          }, {
            default: X(() => [
              K(u, {
                loop: "",
                trapped: e.visible,
                "focus-trap-el": e.drawerRef,
                "focus-start-el": e.focusStartRef,
                onReleaseRequested: e.onCloseRequested
              }, {
                default: X(() => [
                  H("div", ft({
                    ref: "drawerRef",
                    "aria-modal": "true",
                    "aria-label": e.title || void 0,
                    "aria-labelledby": e.title ? void 0 : e.titleId,
                    "aria-describedby": e.bodyId
                  }, e.$attrs, {
                    class: [e.ns.b(), e.direction, e.visible && "open", e.customClass],
                    style: e.isHorizontal ? "width: " + e.drawerSize : "height: " + e.drawerSize,
                    role: "dialog",
                    onClick: t[1] || (t[1] = Ze(() => {
                    }, ["stop"]))
                  }), [
                    H("span", {
                      ref: "focusStartRef",
                      class: $(e.ns.e("sr-focus")),
                      tabindex: "-1"
                    }, null, 2),
                    e.withHeader ? (S(), V("header", {
                      key: 0,
                      class: $(e.ns.e("header"))
                    }, [
                      e.$slots.title ? he(e.$slots, "title", { key: 1 }, () => [
                        se(" DEPRECATED SLOT ")
                      ]) : he(e.$slots, "header", {
                        key: 0,
                        close: e.handleClose,
                        titleId: e.titleId,
                        titleClass: e.ns.e("title")
                      }, () => [
                        e.$slots.title ? se("v-if", !0) : (S(), V("span", {
                          key: 0,
                          id: e.titleId,
                          role: "heading",
                          class: $(e.ns.e("title"))
                        }, Ne(e.title), 11, Z9))
                      ]),
                      e.showClose ? (S(), V("button", {
                        key: 2,
                        "aria-label": e.t("el.drawer.close"),
                        class: $(e.ns.e("close-btn")),
                        type: "button",
                        onClick: t[0] || (t[0] = (...f) => e.handleClose && e.handleClose(...f))
                      }, [
                        K(a, {
                          class: $(e.ns.e("close"))
                        }, {
                          default: X(() => [
                            K(l)
                          ]),
                          _: 1
                        }, 8, ["class"])
                      ], 10, Q9)) : se("v-if", !0)
                    ], 2)) : se("v-if", !0),
                    e.rendered ? (S(), V("div", {
                      key: 1,
                      id: e.bodyId,
                      class: $(e.ns.e("body"))
                    }, [
                      he(e.$slots, "default")
                    ], 10, ej)) : se("v-if", !0),
                    e.$slots.footer ? (S(), V("div", {
                      key: 2,
                      class: $(e.ns.e("footer"))
                    }, [
                      he(e.$slots, "footer")
                    ], 2)) : se("v-if", !0)
                  ], 16, J9)
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
            ]),
            _: 3
          }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
            [$t, e.visible]
          ])
        ]),
        _: 3
      }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])
    ], 8, ["disabled"]);
  }
  var nj = /* @__PURE__ */ Me(X9, [["render", tj], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/drawer/src/drawer.vue"]]);
  const oj = ut(nj), rj = /* @__PURE__ */ G({
    inheritAttrs: !1
  });
  function sj(e, t, n, o, r, s) {
    return he(e.$slots, "default");
  }
  var lj = /* @__PURE__ */ Me(rj, [["render", sj], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
  const aj = /* @__PURE__ */ G({
    name: "ElCollectionItem",
    inheritAttrs: !1
  });
  function ij(e, t, n, o, r, s) {
    return he(e.$slots, "default");
  }
  var uj = /* @__PURE__ */ Me(aj, [["render", ij], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
  const SE = "data-el-collection-item", _E = (e) => {
    const t = `El${e}Collection`, n = `${t}Item`, o = Symbol(t), r = Symbol(n), s = {
      ...lj,
      name: t,
      setup() {
        const a = I(null), u = /* @__PURE__ */ new Map();
        pt(o, {
          itemMap: u,
          getItems: () => {
            const f = i(a);
            if (!f)
              return [];
            const d = Array.from(f.querySelectorAll(`[${SE}]`));
            return [...u.values()].sort((h, m) => d.indexOf(h.ref) - d.indexOf(m.ref));
          },
          collectionRef: a
        });
      }
    }, l = {
      ...uj,
      name: n,
      setup(a, { attrs: u }) {
        const c = I(null), f = Be(o, void 0);
        pt(r, {
          collectionItemRef: c
        }), st(() => {
          const d = i(c);
          d && f.itemMap.set(d, {
            ref: d,
            ...u
          });
        }), zt(() => {
          const d = i(c);
          f.itemMap.delete(d);
        });
      }
    };
    return {
      COLLECTION_INJECTION_KEY: o,
      COLLECTION_ITEM_INJECTION_KEY: r,
      ElCollection: s,
      ElCollectionItem: l
    };
  }, cj = Ie({
    style: { type: le([String, Array, Object]) },
    currentTabId: {
      type: le(String)
    },
    defaultCurrentTabId: String,
    loop: Boolean,
    dir: {
      type: String,
      values: ["ltr", "rtl"],
      default: "ltr"
    },
    orientation: {
      type: le(String)
    },
    onBlur: Function,
    onFocus: Function,
    onMousedown: Function
  }), {
    ElCollection: dj,
    ElCollectionItem: fj,
    COLLECTION_INJECTION_KEY: ev,
    COLLECTION_ITEM_INJECTION_KEY: pj
  } = _E("RovingFocusGroup"), tv = Symbol("elRovingFocusGroup"), kE = Symbol("elRovingFocusGroupItem"), hj = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  }, vj = (e, t) => {
    if (t !== "rtl")
      return e;
    switch (e) {
      case We.right:
        return We.left;
      case We.left:
        return We.right;
      default:
        return e;
    }
  }, mj = (e, t, n) => {
    const o = vj(e.key, n);
    if (!(t === "vertical" && [We.left, We.right].includes(o)) && !(t === "horizontal" && [We.up, We.down].includes(o)))
      return hj[o];
  }, gj = (e, t) => e.map((n, o) => e[(o + t) % e.length]), nv = (e) => {
    const { activeElement: t } = document;
    for (const n of e)
      if (n === t || (n.focus(), t !== document.activeElement))
        return;
  }, yy = "currentTabIdChange", by = "rovingFocusGroup.entryFocus", yj = { bubbles: !1, cancelable: !0 }, bj = G({
    name: "ElRovingFocusGroupImpl",
    inheritAttrs: !1,
    props: cj,
    emits: [yy, "entryFocus"],
    setup(e, { emit: t }) {
      var n;
      const o = I((n = e.currentTabId || e.defaultCurrentTabId) != null ? n : null), r = I(!1), s = I(!1), l = I(null), { getItems: a } = Be(ev, void 0), u = E(() => [
        {
          outline: "none"
        },
        e.style
      ]), c = (v) => {
        t(yy, v);
      }, f = () => {
        r.value = !0;
      }, d = qt((v) => {
        var g;
        (g = e.onMousedown) == null || g.call(e, v);
      }, () => {
        s.value = !0;
      }), p = qt((v) => {
        var g;
        (g = e.onFocus) == null || g.call(e, v);
      }, (v) => {
        const g = !i(s), { target: y, currentTarget: w } = v;
        if (y === w && g && !i(r)) {
          const b = new Event(by, yj);
          if (w == null || w.dispatchEvent(b), !b.defaultPrevented) {
            const C = a().filter((P) => P.focusable), _ = C.find((P) => P.active), k = C.find((P) => P.id === i(o)), T = [_, k, ...C].filter(Boolean).map((P) => P.ref);
            nv(T);
          }
        }
        s.value = !1;
      }), h = qt((v) => {
        var g;
        (g = e.onBlur) == null || g.call(e, v);
      }, () => {
        r.value = !1;
      }), m = (...v) => {
        t("entryFocus", ...v);
      };
      pt(tv, {
        currentTabbedId: Fl(o),
        loop: Ht(e, "loop"),
        tabIndex: E(() => i(r) ? -1 : 0),
        rovingFocusGroupRef: l,
        rovingFocusGroupRootStyle: u,
        orientation: Ht(e, "orientation"),
        dir: Ht(e, "dir"),
        onItemFocus: c,
        onItemShiftTab: f,
        onBlur: h,
        onFocus: p,
        onMousedown: d
      }), me(() => e.currentTabId, (v) => {
        o.value = v != null ? v : null;
      }), Wt(l, by, m);
    }
  });
  function wj(e, t, n, o, r, s) {
    return he(e.$slots, "default");
  }
  var Cj = /* @__PURE__ */ Me(bj, [["render", wj], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group-impl.vue"]]);
  const Ej = G({
    name: "ElRovingFocusGroup",
    components: {
      ElFocusGroupCollection: dj,
      ElRovingFocusGroupImpl: Cj
    }
  });
  function Sj(e, t, n, o, r, s) {
    const l = Qe("el-roving-focus-group-impl"), a = Qe("el-focus-group-collection");
    return S(), ie(a, null, {
      default: X(() => [
        K(l, mo(Nc(e.$attrs)), {
          default: X(() => [
            he(e.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    });
  }
  var _j = /* @__PURE__ */ Me(Ej, [["render", Sj], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group.vue"]]);
  const kj = G({
    components: {
      ElRovingFocusCollectionItem: fj
    },
    props: {
      focusable: {
        type: Boolean,
        default: !0
      },
      active: {
        type: Boolean,
        default: !1
      }
    },
    emits: ["mousedown", "focus", "keydown"],
    setup(e, { emit: t }) {
      const { currentTabbedId: n, loop: o, onItemFocus: r, onItemShiftTab: s } = Be(tv, void 0), { getItems: l } = Be(ev, void 0), a = io(), u = I(null), c = qt((h) => {
        t("mousedown", h);
      }, (h) => {
        e.focusable ? r(i(a)) : h.preventDefault();
      }), f = qt((h) => {
        t("focus", h);
      }, () => {
        r(i(a));
      }), d = qt((h) => {
        t("keydown", h);
      }, (h) => {
        const { key: m, shiftKey: v, target: g, currentTarget: y } = h;
        if (m === We.tab && v) {
          s();
          return;
        }
        if (g !== y)
          return;
        const w = mj(h);
        if (w) {
          h.preventDefault();
          let C = l().filter((_) => _.focusable).map((_) => _.ref);
          switch (w) {
            case "last": {
              C.reverse();
              break;
            }
            case "prev":
            case "next": {
              w === "prev" && C.reverse();
              const _ = C.indexOf(y);
              C = o.value ? gj(C, _ + 1) : C.slice(_ + 1);
              break;
            }
          }
          Fe(() => {
            nv(C);
          });
        }
      }), p = E(() => n.value === i(a));
      return pt(kE, {
        rovingFocusGroupItemRef: u,
        tabIndex: E(() => i(p) ? 0 : -1),
        handleMousedown: c,
        handleFocus: f,
        handleKeydown: d
      }), {
        id: a,
        handleKeydown: d,
        handleFocus: f,
        handleMousedown: c
      };
    }
  });
  function $j(e, t, n, o, r, s) {
    const l = Qe("el-roving-focus-collection-item");
    return S(), ie(l, {
      id: e.id,
      focusable: e.focusable,
      active: e.active
    }, {
      default: X(() => [
        he(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "focusable", "active"]);
  }
  var Nj = /* @__PURE__ */ Me(kj, [["render", $j], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-item.vue"]]);
  const Cu = Ie({
    trigger: Ga.trigger,
    effect: {
      ...dn.effect,
      default: "light"
    },
    type: {
      type: le(String)
    },
    placement: {
      type: le(String),
      default: "bottom"
    },
    popperOptions: {
      type: le(Object),
      default: () => ({})
    },
    id: String,
    size: {
      type: String,
      default: ""
    },
    splitButton: Boolean,
    hideOnClick: {
      type: Boolean,
      default: !0
    },
    loop: {
      type: Boolean,
      default: !0
    },
    showTimeout: {
      type: Number,
      default: 150
    },
    hideTimeout: {
      type: Number,
      default: 150
    },
    tabindex: {
      type: le([Number, String]),
      default: 0
    },
    maxHeight: {
      type: le([Number, String]),
      default: ""
    },
    popperClass: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    role: {
      type: String,
      default: "menu"
    },
    buttonProps: {
      type: le(Object)
    },
    teleported: dn.teleported
  }), $E = Ie({
    command: {
      type: [Object, String, Number],
      default: () => ({})
    },
    disabled: Boolean,
    divided: Boolean,
    textValue: String,
    icon: {
      type: Vt
    }
  }), Tj = Ie({
    onKeydown: { type: le(Function) }
  }), Oj = [
    We.down,
    We.pageDown,
    We.home
  ], NE = [We.up, We.pageUp, We.end], Mj = [...Oj, ...NE], {
    ElCollection: Ij,
    ElCollectionItem: Pj,
    COLLECTION_INJECTION_KEY: Aj,
    COLLECTION_ITEM_INJECTION_KEY: Rj
  } = _E("Dropdown"), td = Symbol("elDropdown"), { ButtonGroup: xj } = gn, Dj = G({
    name: "ElDropdown",
    components: {
      ElButton: gn,
      ElButtonGroup: xj,
      ElScrollbar: pr,
      ElDropdownCollection: Ij,
      ElTooltip: Mn,
      ElRovingFocusGroup: _j,
      ElOnlyChild: Xw,
      ElIcon: He,
      ArrowDown: qr
    },
    props: Cu,
    emits: ["visible-change", "click", "command"],
    setup(e, { emit: t }) {
      const n = it(), o = ge("dropdown"), { t: r } = St(), s = I(), l = I(), a = I(null), u = I(null), c = I(null), f = I(null), d = I(!1), p = [We.enter, We.space, We.down], h = E(() => ({
        maxHeight: Jt(e.maxHeight)
      })), m = E(() => [o.m(C.value)]), v = io().value, g = E(() => e.id || v);
      me([s, Ht(e, "trigger")], ([x, N], [R]) => {
        var M, j, te;
        const U = De(N) ? N : [N];
        (M = R == null ? void 0 : R.$el) != null && M.removeEventListener && R.$el.removeEventListener("pointerenter", k), (j = x == null ? void 0 : x.$el) != null && j.removeEventListener && x.$el.removeEventListener("pointerenter", k), ((te = x == null ? void 0 : x.$el) == null ? void 0 : te.addEventListener) && U.includes("hover") && x.$el.addEventListener("pointerenter", k);
      }, { immediate: !0 }), zt(() => {
        var x, N;
        (N = (x = s.value) == null ? void 0 : x.$el) != null && N.removeEventListener && s.value.$el.removeEventListener("pointerenter", k);
      });
      function y() {
        w();
      }
      function w() {
        var x;
        (x = a.value) == null || x.onClose();
      }
      function b() {
        var x;
        (x = a.value) == null || x.onOpen();
      }
      const C = on();
      function _(...x) {
        t("command", ...x);
      }
      function k() {
        var x, N;
        (N = (x = s.value) == null ? void 0 : x.$el) == null || N.focus();
      }
      function O() {
      }
      function T() {
        const x = i(u);
        x == null || x.focus(), f.value = null;
      }
      function P(x) {
        f.value = x;
      }
      function A(x) {
        d.value || (x.preventDefault(), x.stopImmediatePropagation());
      }
      function L() {
        t("visible-change", !0);
      }
      function D(x) {
        (x == null ? void 0 : x.type) === "keydown" && u.value.focus();
      }
      function B() {
        t("visible-change", !1);
      }
      return pt(td, {
        contentRef: u,
        role: E(() => e.role),
        triggerId: g,
        isUsingKeyboard: d,
        onItemEnter: O,
        onItemLeave: T
      }), pt("elDropdown", {
        instance: n,
        dropdownSize: C,
        handleClick: y,
        commandHandler: _,
        trigger: Ht(e, "trigger"),
        hideOnClick: Ht(e, "hideOnClick")
      }), {
        t: r,
        ns: o,
        scrollbar: c,
        wrapStyle: h,
        dropdownTriggerKls: m,
        dropdownSize: C,
        triggerId: g,
        triggerKeys: p,
        currentTabId: f,
        handleCurrentTabIdChange: P,
        handlerMainButtonClick: (x) => {
          t("click", x);
        },
        handleEntryFocus: A,
        handleClose: w,
        handleOpen: b,
        handleBeforeShowTooltip: L,
        handleShowTooltip: D,
        handleBeforeHideTooltip: B,
        onFocusAfterTrapped: (x) => {
          var N, R;
          x.preventDefault(), (R = (N = u.value) == null ? void 0 : N.focus) == null || R.call(N, {
            preventScroll: !0
          });
        },
        popperRef: a,
        contentRef: u,
        triggeringElementRef: s,
        referenceElementRef: l
      };
    }
  });
  function Lj(e, t, n, o, r, s) {
    var l;
    const a = Qe("el-dropdown-collection"), u = Qe("el-roving-focus-group"), c = Qe("el-scrollbar"), f = Qe("el-only-child"), d = Qe("el-tooltip"), p = Qe("el-button"), h = Qe("arrow-down"), m = Qe("el-icon"), v = Qe("el-button-group");
    return S(), V("div", {
      class: $([e.ns.b(), e.ns.is("disabled", e.disabled)])
    }, [
      K(d, {
        ref: "popperRef",
        role: e.role,
        effect: e.effect,
        "fallback-placements": ["bottom", "top"],
        "popper-options": e.popperOptions,
        "gpu-acceleration": !1,
        "hide-after": e.trigger === "hover" ? e.hideTimeout : 0,
        "manual-mode": !0,
        placement: e.placement,
        "popper-class": [e.ns.e("popper"), e.popperClass],
        "reference-element": (l = e.referenceElementRef) == null ? void 0 : l.$el,
        trigger: e.trigger,
        "trigger-keys": e.triggerKeys,
        "trigger-target-el": e.contentRef,
        "show-after": e.trigger === "hover" ? e.showTimeout : 0,
        "stop-popper-mouse-event": !1,
        "virtual-ref": e.triggeringElementRef,
        "virtual-triggering": e.splitButton,
        disabled: e.disabled,
        transition: `${e.ns.namespace.value}-zoom-in-top`,
        teleported: e.teleported,
        pure: "",
        persistent: "",
        onBeforeShow: e.handleBeforeShowTooltip,
        onShow: e.handleShowTooltip,
        onBeforeHide: e.handleBeforeHideTooltip
      }, lr({
        content: X(() => [
          K(c, {
            ref: "scrollbar",
            "wrap-style": e.wrapStyle,
            tag: "div",
            "view-class": e.ns.e("list")
          }, {
            default: X(() => [
              K(u, {
                loop: e.loop,
                "current-tab-id": e.currentTabId,
                orientation: "horizontal",
                onCurrentTabIdChange: e.handleCurrentTabIdChange,
                onEntryFocus: e.handleEntryFocus
              }, {
                default: X(() => [
                  K(a, null, {
                    default: X(() => [
                      he(e.$slots, "dropdown")
                    ]),
                    _: 3
                  })
                ]),
                _: 3
              }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])
            ]),
            _: 3
          }, 8, ["wrap-style", "view-class"])
        ]),
        _: 2
      }, [
        e.splitButton ? void 0 : {
          name: "default",
          fn: X(() => [
            K(f, {
              id: e.triggerId,
              ref: "triggeringElementRef",
              role: "button",
              tabindex: e.tabindex
            }, {
              default: X(() => [
                he(e.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "tabindex"])
          ])
        }
      ]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "onBeforeShow", "onShow", "onBeforeHide"]),
      e.splitButton ? (S(), ie(v, { key: 0 }, {
        default: X(() => [
          K(p, ft({ ref: "referenceElementRef" }, e.buttonProps, {
            size: e.dropdownSize,
            type: e.type,
            disabled: e.disabled,
            tabindex: e.tabindex,
            onClick: e.handlerMainButtonClick
          }), {
            default: X(() => [
              he(e.$slots, "default")
            ]),
            _: 3
          }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
          K(p, ft({
            id: e.triggerId,
            ref: "triggeringElementRef"
          }, e.buttonProps, {
            role: "button",
            size: e.dropdownSize,
            type: e.type,
            class: e.ns.e("caret-button"),
            disabled: e.disabled,
            tabindex: e.tabindex,
            "aria-label": e.t("el.dropdown.toggleDropdown")
          }), {
            default: X(() => [
              K(m, {
                class: $(e.ns.e("icon"))
              }, {
                default: X(() => [
                  K(h)
                ]),
                _: 1
              }, 8, ["class"])
            ]),
            _: 1
          }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
        ]),
        _: 3
      })) : se("v-if", !0)
    ], 2);
  }
  var Vj = /* @__PURE__ */ Me(Dj, [["render", Lj], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown.vue"]]);
  const Bj = G({
    name: "DropdownItemImpl",
    components: {
      ElIcon: He
    },
    props: $E,
    emits: ["pointermove", "pointerleave", "click", "clickimpl"],
    setup(e, { emit: t }) {
      const n = ge("dropdown"), { role: o } = Be(td, void 0), { collectionItemRef: r } = Be(Rj, void 0), { collectionItemRef: s } = Be(pj, void 0), {
        rovingFocusGroupItemRef: l,
        tabIndex: a,
        handleFocus: u,
        handleKeydown: c,
        handleMousedown: f
      } = Be(kE, void 0), d = Hc(r, s, l), p = E(() => o.value === "menu" ? "menuitem" : o.value === "navigation" ? "link" : "button"), h = qt((m) => {
        const { code: v } = m;
        if (v === We.enter || v === We.space)
          return m.preventDefault(), m.stopImmediatePropagation(), t("clickimpl", m), !0;
      }, c);
      return {
        ns: n,
        itemRef: d,
        dataset: {
          [SE]: ""
        },
        role: p,
        tabIndex: a,
        handleFocus: u,
        handleKeydown: h,
        handleMousedown: f
      };
    }
  }), Fj = ["aria-disabled", "tabindex", "role"];
  function Hj(e, t, n, o, r, s) {
    const l = Qe("el-icon");
    return S(), V(ze, null, [
      e.divided ? (S(), V("li", ft({
        key: 0,
        role: "separator",
        class: e.ns.bem("menu", "item", "divided")
      }, e.$attrs), null, 16)) : se("v-if", !0),
      H("li", ft({ ref: e.itemRef }, { ...e.dataset, ...e.$attrs }, {
        "aria-disabled": e.disabled,
        class: [e.ns.be("menu", "item"), e.ns.is("disabled", e.disabled)],
        tabindex: e.tabIndex,
        role: e.role,
        onClick: t[0] || (t[0] = (a) => e.$emit("clickimpl", a)),
        onFocus: t[1] || (t[1] = (...a) => e.handleFocus && e.handleFocus(...a)),
        onKeydown: t[2] || (t[2] = Ze((...a) => e.handleKeydown && e.handleKeydown(...a), ["self"])),
        onMousedown: t[3] || (t[3] = (...a) => e.handleMousedown && e.handleMousedown(...a)),
        onPointermove: t[4] || (t[4] = (a) => e.$emit("pointermove", a)),
        onPointerleave: t[5] || (t[5] = (a) => e.$emit("pointerleave", a))
      }), [
        e.icon ? (S(), ie(l, { key: 0 }, {
          default: X(() => [
            (S(), ie(vt(e.icon)))
          ]),
          _: 1
        })) : se("v-if", !0),
        he(e.$slots, "default")
      ], 16, Fj)
    ], 64);
  }
  var zj = /* @__PURE__ */ Me(Bj, [["render", Hj], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item-impl.vue"]]);
  const TE = () => {
    const e = Be("elDropdown", {}), t = E(() => e == null ? void 0 : e.dropdownSize);
    return {
      elDropdown: e,
      _elDropdownSize: t
    };
  }, Kj = G({
    name: "ElDropdownItem",
    components: {
      ElDropdownCollectionItem: Pj,
      ElRovingFocusItem: Nj,
      ElDropdownItemImpl: zj
    },
    inheritAttrs: !1,
    props: $E,
    emits: ["pointermove", "pointerleave", "click"],
    setup(e, { emit: t, attrs: n }) {
      const { elDropdown: o } = TE(), r = it(), s = I(null), l = E(() => {
        var h, m;
        return (m = (h = i(s)) == null ? void 0 : h.textContent) != null ? m : "";
      }), { onItemEnter: a, onItemLeave: u } = Be(td, void 0), c = qt((h) => (t("pointermove", h), h.defaultPrevented), Em((h) => {
        if (e.disabled) {
          u(h);
          return;
        }
        const m = h.currentTarget;
        m === document.activeElement || m.contains(document.activeElement) || (a(h), h.defaultPrevented || m == null || m.focus());
      })), f = qt((h) => (t("pointerleave", h), h.defaultPrevented), Em((h) => {
        u(h);
      })), d = qt((h) => {
        if (!e.disabled)
          return t("click", h), h.type !== "keydown" && h.defaultPrevented;
      }, (h) => {
        var m, v, g;
        if (e.disabled) {
          h.stopImmediatePropagation();
          return;
        }
        (m = o == null ? void 0 : o.hideOnClick) != null && m.value && ((v = o.handleClick) == null || v.call(o)), (g = o.commandHandler) == null || g.call(o, e.command, r, h);
      }), p = E(() => ({ ...e, ...n }));
      return {
        handleClick: d,
        handlePointerMove: c,
        handlePointerLeave: f,
        textContent: l,
        propsAndAttrs: p
      };
    }
  });
  function jj(e, t, n, o, r, s) {
    var l;
    const a = Qe("el-dropdown-item-impl"), u = Qe("el-roving-focus-item"), c = Qe("el-dropdown-collection-item");
    return S(), ie(c, {
      disabled: e.disabled,
      "text-value": (l = e.textValue) != null ? l : e.textContent
    }, {
      default: X(() => [
        K(u, {
          focusable: !e.disabled
        }, {
          default: X(() => [
            K(a, ft(e.propsAndAttrs, {
              onPointerleave: e.handlePointerLeave,
              onPointermove: e.handlePointerMove,
              onClickimpl: e.handleClick
            }), {
              default: X(() => [
                he(e.$slots, "default")
              ]),
              _: 3
            }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
          ]),
          _: 3
        }, 8, ["focusable"])
      ]),
      _: 3
    }, 8, ["disabled", "text-value"]);
  }
  var OE = /* @__PURE__ */ Me(Kj, [["render", jj], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item.vue"]]);
  const Wj = G({
    name: "ElDropdownMenu",
    props: Tj,
    setup(e) {
      const t = ge("dropdown"), { _elDropdownSize: n } = TE(), o = n.value, { focusTrapRef: r, onKeydown: s } = Be(Kh, void 0), { contentRef: l, role: a, triggerId: u } = Be(td, void 0), { collectionRef: c, getItems: f } = Be(Aj, void 0), {
        rovingFocusGroupRef: d,
        rovingFocusGroupRootStyle: p,
        tabIndex: h,
        onBlur: m,
        onFocus: v,
        onMousedown: g
      } = Be(tv, void 0), { collectionRef: y } = Be(ev, void 0), w = E(() => [t.b("menu"), t.bm("menu", o == null ? void 0 : o.value)]), b = Hc(l, c, r, d, y), C = qt((k) => {
        var O;
        (O = e.onKeydown) == null || O.call(e, k);
      }, (k) => {
        const { currentTarget: O, code: T, target: P } = k;
        if (O.contains(P), We.tab === T && k.stopImmediatePropagation(), k.preventDefault(), P !== i(l) || !Mj.includes(T))
          return;
        const L = f().filter((D) => !D.disabled).map((D) => D.ref);
        NE.includes(T) && L.reverse(), nv(L);
      });
      return {
        size: o,
        rovingFocusGroupRootStyle: p,
        tabIndex: h,
        dropdownKls: w,
        role: a,
        triggerId: u,
        dropdownListWrapperRef: b,
        handleKeydown: (k) => {
          C(k), s(k);
        },
        onBlur: m,
        onFocus: v,
        onMousedown: g
      };
    }
  }), Uj = ["role", "aria-labelledby"];
  function qj(e, t, n, o, r, s) {
    return S(), V("ul", {
      ref: e.dropdownListWrapperRef,
      class: $(e.dropdownKls),
      style: Ke(e.rovingFocusGroupRootStyle),
      tabindex: -1,
      role: e.role,
      "aria-labelledby": e.triggerId,
      onBlur: t[0] || (t[0] = (...l) => e.onBlur && e.onBlur(...l)),
      onFocus: t[1] || (t[1] = (...l) => e.onFocus && e.onFocus(...l)),
      onKeydown: t[2] || (t[2] = Ze((...l) => e.handleKeydown && e.handleKeydown(...l), ["self"])),
      onMousedown: t[3] || (t[3] = Ze((...l) => e.onMousedown && e.onMousedown(...l), ["self"]))
    }, [
      he(e.$slots, "default")
    ], 46, Uj);
  }
  var ME = /* @__PURE__ */ Me(Wj, [["render", qj], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-menu.vue"]]);
  const Yj = ut(Vj, {
    DropdownItem: OE,
    DropdownMenu: ME
  }), Gj = Gt(OE), Xj = Gt(ME), Jj = {
    viewBox: "0 0 79 86",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink"
  }, Zj = ["id"], Qj = ["stop-color"], eW = ["stop-color"], tW = ["id"], nW = ["stop-color"], oW = ["stop-color"], rW = ["id"], sW = {
    id: "Illustrations",
    stroke: "none",
    "stroke-width": "1",
    fill: "none",
    "fill-rule": "evenodd"
  }, lW = {
    id: "B-type",
    transform: "translate(-1268.000000, -535.000000)"
  }, aW = {
    id: "Group-2",
    transform: "translate(1268.000000, 535.000000)"
  }, iW = ["fill"], uW = ["fill"], cW = {
    id: "Group-Copy",
    transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"
  }, dW = ["fill"], fW = ["fill"], pW = ["fill"], hW = ["fill"], vW = ["fill"], mW = {
    id: "Rectangle-Copy-17",
    transform: "translate(53.000000, 45.000000)"
  }, gW = ["fill", "xlink:href"], yW = ["fill", "mask"], bW = ["fill"], wW = G({
    name: "ImgEmpty"
  }), CW = /* @__PURE__ */ G({
    ...wW,
    setup(e) {
      const t = ge("empty"), n = io();
      return (o, r) => (S(), V("svg", Jj, [
        H("defs", null, [
          H("linearGradient", {
            id: `linearGradient-1-${i(n)}`,
            x1: "38.8503086%",
            y1: "0%",
            x2: "61.1496914%",
            y2: "100%"
          }, [
            H("stop", {
              "stop-color": `var(${i(t).cssVarBlockName("fill-color-1")})`,
              offset: "0%"
            }, null, 8, Qj),
            H("stop", {
              "stop-color": `var(${i(t).cssVarBlockName("fill-color-4")})`,
              offset: "100%"
            }, null, 8, eW)
          ], 8, Zj),
          H("linearGradient", {
            id: `linearGradient-2-${i(n)}`,
            x1: "0%",
            y1: "9.5%",
            x2: "100%",
            y2: "90.5%"
          }, [
            H("stop", {
              "stop-color": `var(${i(t).cssVarBlockName("fill-color-1")})`,
              offset: "0%"
            }, null, 8, nW),
            H("stop", {
              "stop-color": `var(${i(t).cssVarBlockName("fill-color-6")})`,
              offset: "100%"
            }, null, 8, oW)
          ], 8, tW),
          H("rect", {
            id: `path-3-${i(n)}`,
            x: "0",
            y: "0",
            width: "17",
            height: "36"
          }, null, 8, rW)
        ]),
        H("g", sW, [
          H("g", lW, [
            H("g", aW, [
              H("path", {
                id: "Oval-Copy-2",
                d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
                fill: `var(${i(t).cssVarBlockName("fill-color-3")})`
              }, null, 8, iW),
              H("polygon", {
                id: "Rectangle-Copy-14",
                fill: `var(${i(t).cssVarBlockName("fill-color-7")})`,
                transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
                points: "13 58 53 58 42 45 2 45"
              }, null, 8, uW),
              H("g", cW, [
                H("polygon", {
                  id: "Rectangle-Copy-10",
                  fill: `var(${i(t).cssVarBlockName("fill-color-7")})`,
                  transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
                  points: "2.84078316e-14 3 18 3 23 7 5 7"
                }, null, 8, dW),
                H("polygon", {
                  id: "Rectangle-Copy-11",
                  fill: `var(${i(t).cssVarBlockName("fill-color-5")})`,
                  points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
                }, null, 8, fW),
                H("rect", {
                  id: "Rectangle-Copy-12",
                  fill: `url(#linearGradient-1-${i(n)})`,
                  transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
                  x: "38",
                  y: "7",
                  width: "17",
                  height: "36"
                }, null, 8, pW),
                H("polygon", {
                  id: "Rectangle-Copy-13",
                  fill: `var(${i(t).cssVarBlockName("fill-color-2")})`,
                  transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
                  points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
                }, null, 8, hW)
              ]),
              H("rect", {
                id: "Rectangle-Copy-15",
                fill: `url(#linearGradient-2-${i(n)})`,
                x: "13",
                y: "45",
                width: "40",
                height: "36"
              }, null, 8, vW),
              H("g", mW, [
                H("use", {
                  id: "Mask",
                  fill: `var(${i(t).cssVarBlockName("fill-color-8")})`,
                  transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
                  "xlink:href": `#path-3-${i(n)}`
                }, null, 8, gW),
                H("polygon", {
                  id: "Rectangle-Copy",
                  fill: `var(${i(t).cssVarBlockName("fill-color-9")})`,
                  mask: `url(#mask-4-${i(n)})`,
                  transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
                  points: "7 0 24 0 20 18 7 16.5"
                }, null, 8, yW)
              ]),
              H("polygon", {
                id: "Rectangle-Copy-18",
                fill: `var(${i(t).cssVarBlockName("fill-color-2")})`,
                transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
                points: "62 45 79 45 70 58 53 58"
              }, null, 8, bW)
            ])
          ])
        ])
      ]));
    }
  });
  var EW = /* @__PURE__ */ Me(CW, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/img-empty.vue"]]);
  const SW = Ie({
    image: {
      type: String,
      default: ""
    },
    imageSize: Number,
    description: {
      type: String,
      default: ""
    }
  }), _W = ["src"], kW = { key: 1 }, $W = G({
    name: "ElEmpty"
  }), NW = /* @__PURE__ */ G({
    ...$W,
    props: SW,
    setup(e) {
      const t = e, { t: n } = St(), o = ge("empty"), r = E(() => t.description || n("el.table.emptyText")), s = E(() => ({
        width: Jt(t.imageSize)
      }));
      return (l, a) => (S(), V("div", {
        class: $(i(o).b())
      }, [
        H("div", {
          class: $(i(o).e("image")),
          style: Ke(i(s))
        }, [
          l.image ? (S(), V("img", {
            key: 0,
            src: l.image,
            ondragstart: "return false"
          }, null, 8, _W)) : he(l.$slots, "image", { key: 1 }, () => [
            K(EW)
          ])
        ], 6),
        H("div", {
          class: $(i(o).e("description"))
        }, [
          l.$slots.description ? he(l.$slots, "description", { key: 0 }) : (S(), V("p", kW, Ne(i(r)), 1))
        ], 2),
        l.$slots.default ? (S(), V("div", {
          key: 0,
          class: $(i(o).e("bottom"))
        }, [
          he(l.$slots, "default")
        ], 2)) : se("v-if", !0)
      ], 2));
    }
  });
  var TW = /* @__PURE__ */ Me(NW, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/empty.vue"]]);
  const IE = ut(TW), OW = Ie({
    urlList: {
      type: le(Array),
      default: () => jt([])
    },
    zIndex: {
      type: Number
    },
    initialIndex: {
      type: Number,
      default: 0
    },
    infinite: {
      type: Boolean,
      default: !0
    },
    hideOnClickModal: {
      type: Boolean,
      default: !1
    },
    teleported: {
      type: Boolean,
      default: !1
    },
    closeOnPressEscape: {
      type: Boolean,
      default: !0
    },
    zoomRate: {
      type: Number,
      default: 1.2
    }
  }), MW = {
    close: () => !0,
    switch: (e) => Xe(e)
  }, IW = ["src"], PW = G({
    name: "ElImageViewer"
  }), AW = /* @__PURE__ */ G({
    ...PW,
    props: OW,
    emits: MW,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = {
        CONTAIN: {
          name: "contain",
          icon: ws(zA)
        },
        ORIGINAL: {
          name: "original",
          icon: ws(ox)
        }
      }, { t: s } = St(), l = ge("image-viewer"), { nextZIndex: a } = Fs(), u = I(), c = I([]), f = e2(), d = I(!0), p = I(o.initialIndex), h = xt(r.CONTAIN), m = I({
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: !1
      }), v = E(() => {
        const { urlList: N } = o;
        return N.length <= 1;
      }), g = E(() => p.value === 0), y = E(() => p.value === o.urlList.length - 1), w = E(() => o.urlList[p.value]), b = E(() => {
        const { scale: N, deg: R, offsetX: M, offsetY: j, enableTransition: te } = m.value;
        let U = M / N, Z = j / N;
        switch (R % 360) {
          case 90:
          case -270:
            [U, Z] = [Z, -U];
            break;
          case 180:
          case -180:
            [U, Z] = [-U, -Z];
            break;
          case 270:
          case -90:
            [U, Z] = [-Z, U];
            break;
        }
        const pe = {
          transform: `scale(${N}) rotate(${R}deg) translate(${U}px, ${Z}px)`,
          transition: te ? "transform .3s" : ""
        };
        return h.value.name === r.CONTAIN.name && (pe.maxWidth = pe.maxHeight = "100%"), pe;
      }), C = E(() => Xe(o.zIndex) ? o.zIndex : a());
      function _() {
        O(), n("close");
      }
      function k() {
        const N = Ss((M) => {
          switch (M.code) {
            case We.esc:
              o.closeOnPressEscape && _();
              break;
            case We.space:
              D();
              break;
            case We.left:
              F();
              break;
            case We.up:
              x("zoomIn");
              break;
            case We.right:
              W();
              break;
            case We.down:
              x("zoomOut");
              break;
          }
        }), R = Ss((M) => {
          const j = M.deltaY || M.deltaX;
          x(j < 0 ? "zoomIn" : "zoomOut", {
            zoomRate: o.zoomRate,
            enableTransition: !1
          });
        });
        f.run(() => {
          Wt(document, "keydown", N), Wt(document, "wheel", R);
        });
      }
      function O() {
        f.stop();
      }
      function T() {
        d.value = !1;
      }
      function P(N) {
        d.value = !1, N.target.alt = s("el.image.error");
      }
      function A(N) {
        if (d.value || N.button !== 0 || !u.value)
          return;
        m.value.enableTransition = !1;
        const { offsetX: R, offsetY: M } = m.value, j = N.pageX, te = N.pageY, U = Ss((pe) => {
          m.value = {
            ...m.value,
            offsetX: R + pe.pageX - j,
            offsetY: M + pe.pageY - te
          };
        }), Z = Wt(document, "mousemove", U);
        Wt(document, "mouseup", () => {
          Z();
        }), N.preventDefault();
      }
      function L() {
        m.value = {
          scale: 1,
          deg: 0,
          offsetX: 0,
          offsetY: 0,
          enableTransition: !1
        };
      }
      function D() {
        if (d.value)
          return;
        const N = za(r), R = Object.values(r), M = h.value.name, te = (R.findIndex((U) => U.name === M) + 1) % N.length;
        h.value = r[N[te]], L();
      }
      function B(N) {
        const R = o.urlList.length;
        p.value = (N + R) % R;
      }
      function F() {
        g.value && !o.infinite || B(p.value - 1);
      }
      function W() {
        y.value && !o.infinite || B(p.value + 1);
      }
      function x(N, R = {}) {
        if (d.value)
          return;
        const { zoomRate: M, rotateDeg: j, enableTransition: te } = {
          zoomRate: o.zoomRate,
          rotateDeg: 90,
          enableTransition: !0,
          ...R
        };
        switch (N) {
          case "zoomOut":
            m.value.scale > 0.2 && (m.value.scale = Number.parseFloat((m.value.scale / M).toFixed(3)));
            break;
          case "zoomIn":
            m.value.scale < 7 && (m.value.scale = Number.parseFloat((m.value.scale * M).toFixed(3)));
            break;
          case "clockwise":
            m.value.deg += j;
            break;
          case "anticlockwise":
            m.value.deg -= j;
            break;
        }
        m.value.enableTransition = te;
      }
      return me(w, () => {
        Fe(() => {
          const N = c.value[0];
          N != null && N.complete || (d.value = !0);
        });
      }), me(p, (N) => {
        L(), n("switch", N);
      }), st(() => {
        var N, R;
        k(), (R = (N = u.value) == null ? void 0 : N.focus) == null || R.call(N);
      }), t({
        setActiveItem: B
      }), (N, R) => (S(), ie(pi, {
        to: "body",
        disabled: !N.teleported
      }, [
        K(Qt, {
          name: "viewer-fade",
          appear: ""
        }, {
          default: X(() => [
            H("div", {
              ref_key: "wrapper",
              ref: u,
              tabindex: -1,
              class: $(i(l).e("wrapper")),
              style: Ke({ zIndex: i(C) })
            }, [
              H("div", {
                class: $(i(l).e("mask")),
                onClick: R[0] || (R[0] = Ze((M) => N.hideOnClickModal && _(), ["self"]))
              }, null, 2),
              se(" CLOSE "),
              H("span", {
                class: $([i(l).e("btn"), i(l).e("close")]),
                onClick: _
              }, [
                K(i(He), null, {
                  default: X(() => [
                    K(i(_o))
                  ]),
                  _: 1
                })
              ], 2),
              se(" ARROW "),
              i(v) ? se("v-if", !0) : (S(), V(ze, { key: 0 }, [
                H("span", {
                  class: $([
                    i(l).e("btn"),
                    i(l).e("prev"),
                    i(l).is("disabled", !N.infinite && i(g))
                  ]),
                  onClick: F
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i(Br))
                    ]),
                    _: 1
                  })
                ], 2),
                H("span", {
                  class: $([
                    i(l).e("btn"),
                    i(l).e("next"),
                    i(l).is("disabled", !N.infinite && i(y))
                  ]),
                  onClick: W
                }, [
                  K(i(He), null, {
                    default: X(() => [
                      K(i(kn))
                    ]),
                    _: 1
                  })
                ], 2)
              ], 64)),
              se(" ACTIONS "),
              H("div", {
                class: $([i(l).e("btn"), i(l).e("actions")])
              }, [
                H("div", {
                  class: $(i(l).e("actions__inner"))
                }, [
                  K(i(He), {
                    onClick: R[1] || (R[1] = (M) => x("zoomOut"))
                  }, {
                    default: X(() => [
                      K(i(sD))
                    ]),
                    _: 1
                  }),
                  K(i(He), {
                    onClick: R[2] || (R[2] = (M) => x("zoomIn"))
                  }, {
                    default: X(() => [
                      K(i(ew))
                    ]),
                    _: 1
                  }),
                  H("i", {
                    class: $(i(l).e("actions__divider"))
                  }, null, 2),
                  K(i(He), { onClick: D }, {
                    default: X(() => [
                      (S(), ie(vt(i(h).icon)))
                    ]),
                    _: 1
                  }),
                  H("i", {
                    class: $(i(l).e("actions__divider"))
                  }, null, 2),
                  K(i(He), {
                    onClick: R[3] || (R[3] = (M) => x("anticlockwise"))
                  }, {
                    default: X(() => [
                      K(i(WR))
                    ]),
                    _: 1
                  }),
                  K(i(He), {
                    onClick: R[4] || (R[4] = (M) => x("clockwise"))
                  }, {
                    default: X(() => [
                      K(i(JR))
                    ]),
                    _: 1
                  })
                ], 2)
              ], 2),
              se(" CANVAS "),
              H("div", {
                class: $(i(l).e("canvas"))
              }, [
                (S(!0), V(ze, null, gt(N.urlList, (M, j) => ot((S(), V("img", {
                  ref_for: !0,
                  ref: (te) => c.value[j] = te,
                  key: M,
                  src: M,
                  style: Ke(i(b)),
                  class: $(i(l).e("img")),
                  onLoad: T,
                  onError: P,
                  onMousedown: A
                }, null, 46, IW)), [
                  [$t, j === p.value]
                ])), 128))
              ], 2),
              he(N.$slots, "default")
            ], 6)
          ]),
          _: 3
        })
      ], 8, ["disabled"]));
    }
  });
  var RW = /* @__PURE__ */ Me(AW, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]);
  const PE = ut(RW), xW = Ie({
    hideOnClickModal: {
      type: Boolean,
      default: !1
    },
    src: {
      type: String,
      default: ""
    },
    fit: {
      type: String,
      values: ["", "contain", "cover", "fill", "none", "scale-down"],
      default: ""
    },
    loading: {
      type: String,
      values: ["eager", "lazy"]
    },
    lazy: {
      type: Boolean,
      default: !1
    },
    scrollContainer: {
      type: le([String, Object])
    },
    previewSrcList: {
      type: le(Array),
      default: () => jt([])
    },
    previewTeleported: {
      type: Boolean,
      default: !1
    },
    zIndex: {
      type: Number
    },
    initialIndex: {
      type: Number,
      default: 0
    },
    infinite: {
      type: Boolean,
      default: !0
    },
    closeOnPressEscape: {
      type: Boolean,
      default: !0
    },
    zoomRate: {
      type: Number,
      default: 1.2
    }
  }), DW = {
    load: (e) => e instanceof Event,
    error: (e) => e instanceof Event,
    switch: (e) => Xe(e),
    close: () => !0,
    show: () => !0
  }, LW = ["src", "loading"], VW = { key: 0 }, BW = G({
    name: "ElImage",
    inheritAttrs: !1
  }), FW = /* @__PURE__ */ G({
    ...BW,
    props: xW,
    emits: DW,
    setup(e, { emit: t }) {
      const n = e;
      let o = "";
      const { t: r } = St(), s = ge("image"), l = zl(), a = $h(), u = I(), c = I(!1), f = I(!0), d = I(!1), p = I(), h = I(), m = bt && "loading" in HTMLImageElement.prototype;
      let v, g;
      const y = E(() => l.style), w = E(() => {
        const { fit: N } = n;
        return bt && N ? { objectFit: N } : {};
      }), b = E(() => {
        const { previewSrcList: N } = n;
        return Array.isArray(N) && N.length > 0;
      }), C = E(() => {
        const { previewSrcList: N, initialIndex: R } = n;
        let M = R;
        return R > N.length - 1 && (M = 0), M;
      }), _ = E(() => n.loading === "eager" ? !1 : !m && n.loading === "lazy" || n.lazy), k = () => {
        !bt || (f.value = !0, c.value = !1, u.value = n.src);
      };
      function O(N) {
        f.value = !1, c.value = !1, t("load", N);
      }
      function T(N) {
        f.value = !1, c.value = !0, t("error", N);
      }
      function P() {
        ON(p.value, h.value) && (k(), D());
      }
      const A = u1(P, 200);
      async function L() {
        var N;
        if (!bt)
          return;
        await Fe();
        const { scrollContainer: R } = n;
        So(R) ? h.value = R : et(R) && R !== "" ? h.value = (N = document.querySelector(R)) != null ? N : void 0 : p.value && (h.value = Ch(p.value)), h.value && (v = Wt(h, "scroll", A), setTimeout(() => P(), 100));
      }
      function D() {
        !bt || !h.value || !A || (v == null || v(), h.value = void 0);
      }
      function B(N) {
        if (!!N.ctrlKey) {
          if (N.deltaY < 0)
            return N.preventDefault(), !1;
          if (N.deltaY > 0)
            return N.preventDefault(), !1;
        }
      }
      function F() {
        !b.value || (g = Wt("wheel", B, {
          passive: !1
        }), o = document.body.style.overflow, document.body.style.overflow = "hidden", d.value = !0, t("show"));
      }
      function W() {
        g == null || g(), document.body.style.overflow = o, d.value = !1, t("close");
      }
      function x(N) {
        t("switch", N);
      }
      return me(() => n.src, () => {
        _.value ? (f.value = !0, c.value = !1, D(), L()) : k();
      }), st(() => {
        _.value ? L() : k();
      }), (N, R) => (S(), V("div", {
        ref_key: "container",
        ref: p,
        class: $([i(s).b(), N.$attrs.class]),
        style: Ke(i(y))
      }, [
        u.value !== void 0 && !c.value ? (S(), V("img", ft({ key: 0 }, i(a), {
          src: u.value,
          loading: N.loading,
          style: i(w),
          class: [
            i(s).e("inner"),
            i(b) && i(s).e("preview"),
            f.value && i(s).is("loading")
          ],
          onClick: F,
          onLoad: O,
          onError: T
        }), null, 16, LW)) : se("v-if", !0),
        f.value || c.value ? (S(), V("div", {
          key: 1,
          class: $(i(s).e("wrapper"))
        }, [
          f.value ? he(N.$slots, "placeholder", { key: 0 }, () => [
            H("div", {
              class: $(i(s).e("placeholder"))
            }, null, 2)
          ]) : c.value ? he(N.$slots, "error", { key: 1 }, () => [
            H("div", {
              class: $(i(s).e("error"))
            }, Ne(i(r)("el.image.error")), 3)
          ]) : se("v-if", !0)
        ], 2)) : se("v-if", !0),
        i(b) ? (S(), V(ze, { key: 2 }, [
          d.value ? (S(), ie(i(PE), {
            key: 0,
            "z-index": N.zIndex,
            "initial-index": i(C),
            infinite: N.infinite,
            "zoom-rate": N.zoomRate,
            "url-list": N.previewSrcList,
            "hide-on-click-modal": N.hideOnClickModal,
            teleported: N.previewTeleported,
            "close-on-press-escape": N.closeOnPressEscape,
            onClose: W,
            onSwitch: x
          }, {
            default: X(() => [
              N.$slots.viewer ? (S(), V("div", VW, [
                he(N.$slots, "viewer")
              ])) : se("v-if", !0)
            ]),
            _: 3
          }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : se("v-if", !0)
        ], 64)) : se("v-if", !0)
      ], 6));
    }
  });
  var HW = /* @__PURE__ */ Me(FW, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image/src/image.vue"]]);
  const zW = ut(HW), KW = Ie({
    id: {
      type: String,
      default: void 0
    },
    step: {
      type: Number,
      default: 1
    },
    stepStrictly: Boolean,
    max: {
      type: Number,
      default: Number.POSITIVE_INFINITY
    },
    min: {
      type: Number,
      default: Number.NEGATIVE_INFINITY
    },
    modelValue: Number,
    readonly: Boolean,
    disabled: Boolean,
    size: yn,
    controls: {
      type: Boolean,
      default: !0
    },
    controlsPosition: {
      type: String,
      default: "",
      values: ["", "right"]
    },
    valueOnClear: {
      type: [String, Number, null],
      validator: (e) => e === null || Xe(e) || ["min", "max"].includes(e),
      default: null
    },
    name: String,
    label: String,
    placeholder: String,
    precision: {
      type: Number,
      validator: (e) => e >= 0 && e === Number.parseInt(`${e}`, 10)
    },
    validateEvent: {
      type: Boolean,
      default: !0
    }
  }), jW = {
    [Ft]: (e, t) => t !== e,
    blur: (e) => e instanceof FocusEvent,
    focus: (e) => e instanceof FocusEvent,
    [$n]: (e) => Xe(e) || nn(e),
    [dt]: (e) => Xe(e) || nn(e)
  }, WW = ["aria-label", "onKeydown"], UW = ["aria-label", "onKeydown"], qW = G({
    name: "ElInputNumber"
  }), YW = /* @__PURE__ */ G({
    ...qW,
    props: KW,
    emits: jW,
    setup(e, { expose: t, emit: n }) {
      const o = e, { t: r } = St(), s = ge("input-number"), l = I(), a = Tt({
        currentValue: o.modelValue,
        userInput: null
      }), { formItem: u } = In(), c = E(() => Xe(o.modelValue) && o.modelValue <= o.min), f = E(() => Xe(o.modelValue) && o.modelValue >= o.max), d = E(() => {
        const B = y(o.step);
        return pn(o.precision) ? Math.max(y(o.modelValue), B) : (B > o.precision && yt("InputNumber", "precision should not be less than the decimal places of step"), o.precision);
      }), p = E(() => o.controls && o.controlsPosition === "right"), h = on(), m = Fn(), v = E(() => {
        if (a.userInput !== null)
          return a.userInput;
        let B = a.currentValue;
        if (nn(B))
          return "";
        if (Xe(B)) {
          if (Number.isNaN(B))
            return "";
          pn(o.precision) || (B = B.toFixed(o.precision));
        }
        return B;
      }), g = (B, F) => {
        if (pn(F) && (F = d.value), F === 0)
          return Math.round(B);
        let W = String(B);
        const x = W.indexOf(".");
        if (x === -1 || !W.replace(".", "").split("")[x + F])
          return B;
        const M = W.length;
        return W.charAt(M - 1) === "5" && (W = `${W.slice(0, Math.max(0, M - 1))}6`), Number.parseFloat(Number(W).toFixed(F));
      }, y = (B) => {
        if (nn(B))
          return 0;
        const F = B.toString(), W = F.indexOf(".");
        let x = 0;
        return W !== -1 && (x = F.length - W - 1), x;
      }, w = (B, F = 1) => Xe(B) ? g(B + o.step * F) : a.currentValue, b = () => {
        if (o.readonly || m.value || f.value)
          return;
        const B = Number(v.value) || 0, F = w(B);
        k(F), n($n, a.currentValue);
      }, C = () => {
        if (o.readonly || m.value || c.value)
          return;
        const B = Number(v.value) || 0, F = w(B, -1);
        k(F), n($n, a.currentValue);
      }, _ = (B, F) => {
        const { max: W, min: x, step: N, precision: R, stepStrictly: M, valueOnClear: j } = o;
        let te = Number(B);
        if (nn(B) || Number.isNaN(te))
          return null;
        if (B === "") {
          if (j === null)
            return null;
          te = et(j) ? { min: x, max: W }[j] : j;
        }
        return M && (te = g(Math.round(te / N) * N, R)), pn(R) || (te = g(te, R)), (te > W || te < x) && (te = te > W ? W : x, F && n(dt, te)), te;
      }, k = (B, F = !0) => {
        var W;
        const x = a.currentValue, N = _(B);
        if (!F) {
          n(dt, N);
          return;
        }
        x !== N && (a.userInput = null, n(dt, N), n(Ft, N, x), o.validateEvent && ((W = u == null ? void 0 : u.validate) == null || W.call(u, "change").catch((R) => yt(R))), a.currentValue = N);
      }, O = (B) => {
        a.userInput = B;
        const F = B === "" ? null : Number(B);
        n($n, F), k(F, !1);
      }, T = (B) => {
        const F = B !== "" ? Number(B) : "";
        (Xe(F) && !Number.isNaN(F) || B === "") && k(F), a.userInput = null;
      }, P = () => {
        var B, F;
        (F = (B = l.value) == null ? void 0 : B.focus) == null || F.call(B);
      }, A = () => {
        var B, F;
        (F = (B = l.value) == null ? void 0 : B.blur) == null || F.call(B);
      }, L = (B) => {
        n("focus", B);
      }, D = (B) => {
        var F;
        n("blur", B), o.validateEvent && ((F = u == null ? void 0 : u.validate) == null || F.call(u, "blur").catch((W) => yt(W)));
      };
      return me(() => o.modelValue, (B) => {
        const F = _(a.userInput), W = _(B, !0);
        !Xe(F) && (!F || F !== W) && (a.currentValue = W, a.userInput = null);
      }, { immediate: !0 }), st(() => {
        var B;
        const { min: F, max: W, modelValue: x } = o, N = (B = l.value) == null ? void 0 : B.input;
        if (N.setAttribute("role", "spinbutton"), Number.isFinite(W) ? N.setAttribute("aria-valuemax", String(W)) : N.removeAttribute("aria-valuemax"), Number.isFinite(F) ? N.setAttribute("aria-valuemin", String(F)) : N.removeAttribute("aria-valuemin"), N.setAttribute("aria-valuenow", String(a.currentValue)), N.setAttribute("aria-disabled", String(m.value)), !Xe(x) && x != null) {
          let R = Number(x);
          Number.isNaN(R) && (R = null), n(dt, R);
        }
      }), cr(() => {
        var B;
        const F = (B = l.value) == null ? void 0 : B.input;
        F == null || F.setAttribute("aria-valuenow", `${a.currentValue}`);
      }), t({
        focus: P,
        blur: A
      }), (B, F) => (S(), V("div", {
        class: $([
          i(s).b(),
          i(s).m(i(h)),
          i(s).is("disabled", i(m)),
          i(s).is("without-controls", !B.controls),
          i(s).is("controls-right", i(p))
        ]),
        onDragstart: F[1] || (F[1] = Ze(() => {
        }, ["prevent"]))
      }, [
        B.controls ? ot((S(), V("span", {
          key: 0,
          role: "button",
          "aria-label": i(r)("el.inputNumber.decrease"),
          class: $([i(s).e("decrease"), i(s).is("disabled", i(c))]),
          onKeydown: Et(C, ["enter"])
        }, [
          K(i(He), null, {
            default: X(() => [
              i(p) ? (S(), ie(i(qr), { key: 0 })) : (S(), ie(i(dR), { key: 1 }))
            ]),
            _: 1
          })
        ], 42, WW)), [
          [i(tc), C]
        ]) : se("v-if", !0),
        B.controls ? ot((S(), V("span", {
          key: 1,
          role: "button",
          "aria-label": i(r)("el.inputNumber.increase"),
          class: $([i(s).e("increase"), i(s).is("disabled", i(f))]),
          onKeydown: Et(b, ["enter"])
        }, [
          K(i(He), null, {
            default: X(() => [
              i(p) ? (S(), ie(i(Bc), { key: 0 })) : (S(), ie(i(Z1), { key: 1 }))
            ]),
            _: 1
          })
        ], 42, UW)), [
          [i(tc), b]
        ]) : se("v-if", !0),
        K(i(wn), {
          id: B.id,
          ref_key: "input",
          ref: l,
          type: "number",
          step: B.step,
          "model-value": i(v),
          placeholder: B.placeholder,
          readonly: B.readonly,
          disabled: i(m),
          size: i(h),
          max: B.max,
          min: B.min,
          name: B.name,
          label: B.label,
          "validate-event": !1,
          onWheel: F[0] || (F[0] = Ze(() => {
          }, ["prevent"])),
          onKeydown: [
            Et(Ze(b, ["prevent"]), ["up"]),
            Et(Ze(C, ["prevent"]), ["down"])
          ],
          onBlur: D,
          onFocus: L,
          onInput: O,
          onChange: T
        }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
      ], 34));
    }
  });
  var GW = /* @__PURE__ */ Me(YW, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);
  const AE = ut(GW), XW = Ie({
    type: {
      type: String,
      values: ["primary", "success", "warning", "info", "danger", "default"],
      default: "default"
    },
    underline: {
      type: Boolean,
      default: !0
    },
    disabled: { type: Boolean, default: !1 },
    href: { type: String, default: "" },
    icon: {
      type: Vt
    }
  }), JW = {
    click: (e) => e instanceof MouseEvent
  }, ZW = ["href"], QW = G({
    name: "ElLink"
  }), e7 = /* @__PURE__ */ G({
    ...QW,
    props: XW,
    emits: JW,
    setup(e, { emit: t }) {
      const n = e, o = ge("link"), r = E(() => [
        o.b(),
        o.m(n.type),
        o.is("disabled", n.disabled),
        o.is("underline", n.underline && !n.disabled)
      ]);
      function s(l) {
        n.disabled || t("click", l);
      }
      return (l, a) => (S(), V("a", {
        class: $(i(r)),
        href: l.disabled || !l.href ? void 0 : l.href,
        onClick: s
      }, [
        l.icon ? (S(), ie(i(He), { key: 0 }, {
          default: X(() => [
            (S(), ie(vt(l.icon)))
          ]),
          _: 1
        })) : se("v-if", !0),
        l.$slots.default ? (S(), V("span", {
          key: 1,
          class: $(i(o).e("inner"))
        }, [
          he(l.$slots, "default")
        ], 2)) : se("v-if", !0),
        l.$slots.icon ? he(l.$slots, "icon", { key: 2 }) : se("v-if", !0)
      ], 10, ZW));
    }
  });
  var t7 = /* @__PURE__ */ Me(e7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/link/src/link.vue"]]);
  const n7 = ut(t7);
  class o7 {
    constructor(t, n) {
      this.parent = t, this.domNode = n, this.subIndex = 0, this.subIndex = 0, this.init();
    }
    init() {
      this.subMenuItems = this.domNode.querySelectorAll("li"), this.addListeners();
    }
    gotoSubIndex(t) {
      t === this.subMenuItems.length ? t = 0 : t < 0 && (t = this.subMenuItems.length - 1), this.subMenuItems[t].focus(), this.subIndex = t;
    }
    addListeners() {
      const t = this.parent.domNode;
      Array.prototype.forEach.call(this.subMenuItems, (n) => {
        n.addEventListener("keydown", (o) => {
          let r = !1;
          switch (o.code) {
            case We.down: {
              this.gotoSubIndex(this.subIndex + 1), r = !0;
              break;
            }
            case We.up: {
              this.gotoSubIndex(this.subIndex - 1), r = !0;
              break;
            }
            case We.tab: {
              lu(t, "mouseleave");
              break;
            }
            case We.enter:
            case We.space: {
              r = !0, o.currentTarget.click();
              break;
            }
          }
          return r && (o.preventDefault(), o.stopPropagation()), !1;
        });
      });
    }
  }
  class r7 {
    constructor(t, n) {
      this.domNode = t, this.submenu = null, this.submenu = null, this.init(n);
    }
    init(t) {
      this.domNode.setAttribute("tabindex", "0");
      const n = this.domNode.querySelector(`.${t}-menu`);
      n && (this.submenu = new o7(this, n)), this.addListeners();
    }
    addListeners() {
      this.domNode.addEventListener("keydown", (t) => {
        let n = !1;
        switch (t.code) {
          case We.down: {
            lu(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(0), n = !0;
            break;
          }
          case We.up: {
            lu(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1), n = !0;
            break;
          }
          case We.tab: {
            lu(t.currentTarget, "mouseleave");
            break;
          }
          case We.enter:
          case We.space: {
            n = !0, t.currentTarget.click();
            break;
          }
        }
        n && t.preventDefault();
      });
    }
  }
  class s7 {
    constructor(t, n) {
      this.domNode = t, this.init(n);
    }
    init(t) {
      const n = this.domNode.childNodes;
      Array.from(n).forEach((o) => {
        o.nodeType === 1 && new r7(o, t);
      });
    }
  }
  const l7 = G({
    name: "ElMenuCollapseTransition",
    setup() {
      const e = ge("menu");
      return {
        listeners: {
          onBeforeEnter: (n) => n.style.opacity = "0.2",
          onEnter(n, o) {
            Ao(n, `${e.namespace.value}-opacity-transition`), n.style.opacity = "1", o();
          },
          onAfterEnter(n) {
            Dn(n, `${e.namespace.value}-opacity-transition`), n.style.opacity = "";
          },
          onBeforeLeave(n) {
            n.dataset || (n.dataset = {}), Co(n, e.m("collapse")) ? (Dn(n, e.m("collapse")), n.dataset.oldOverflow = n.style.overflow, n.dataset.scrollWidth = n.clientWidth.toString(), Ao(n, e.m("collapse"))) : (Ao(n, e.m("collapse")), n.dataset.oldOverflow = n.style.overflow, n.dataset.scrollWidth = n.clientWidth.toString(), Dn(n, e.m("collapse"))), n.style.width = `${n.scrollWidth}px`, n.style.overflow = "hidden";
          },
          onLeave(n) {
            Ao(n, "horizontal-collapse-transition"), n.style.width = `${n.dataset.scrollWidth}px`;
          }
        }
      };
    }
  });
  function a7(e, t, n, o, r, s) {
    return S(), ie(Qt, ft({ mode: "out-in" }, e.listeners), {
      default: X(() => [
        he(e.$slots, "default")
      ]),
      _: 3
    }, 16);
  }
  var i7 = /* @__PURE__ */ Me(l7, [["render", a7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-collapse-transition.vue"]]);
  function RE(e, t) {
    const n = E(() => {
      let r = e.parent;
      const s = [t.value];
      for (; r.type.name !== "ElMenu"; )
        r.props.index && s.unshift(r.props.index), r = r.parent;
      return s;
    });
    return {
      parentMenu: E(() => {
        let r = e.parent;
        for (; r && !["ElMenu", "ElSubMenu"].includes(r.type.name); )
          r = r.parent;
        return r;
      }),
      indexPath: n
    };
  }
  function u7(e) {
    return E(() => {
      const n = e.backgroundColor;
      return n ? new uC(n).shade(20).toString() : "";
    });
  }
  const xE = (e, t) => {
    const n = ge("menu");
    return E(() => n.cssVarBlock({
      "text-color": e.textColor || "",
      "hover-text-color": e.textColor || "",
      "bg-color": e.backgroundColor || "",
      "hover-bg-color": u7(e).value || "",
      "active-color": e.activeTextColor || "",
      level: `${t}`
    }));
  }, c7 = Ie({
    index: {
      type: String,
      required: !0
    },
    showTimeout: {
      type: Number,
      default: 300
    },
    hideTimeout: {
      type: Number,
      default: 300
    },
    popperClass: String,
    disabled: Boolean,
    popperAppendToBody: {
      type: Boolean,
      default: void 0
    },
    teleported: {
      type: Boolean,
      default: void 0
    },
    popperOffset: {
      type: Number,
      default: 6
    },
    expandCloseIcon: {
      type: Vt
    },
    expandOpenIcon: {
      type: Vt
    },
    collapseCloseIcon: {
      type: Vt
    },
    collapseOpenIcon: {
      type: Vt
    }
  }), Ji = "ElSubMenu";
  var ov = G({
    name: Ji,
    props: c7,
    setup(e, { slots: t, expose: n }) {
      Vo({
        from: "popper-append-to-body",
        replacement: "teleported",
        scope: Ji,
        version: "2.3.0",
        ref: "https://element-plus.org/en-US/component/menu.html#submenu-attributes"
      }, E(() => e.popperAppendToBody !== void 0));
      const o = it(), { indexPath: r, parentMenu: s } = RE(o, E(() => e.index)), l = ge("menu"), a = ge("sub-menu"), u = Be("rootMenu");
      u || Yt(Ji, "can not inject root menu");
      const c = Be(`subMenu:${s.value.uid}`);
      c || Yt(Ji, "can not inject sub menu");
      const f = I({}), d = I({});
      let p;
      const h = I(!1), m = I(), v = I(null), g = E(() => L.value === "horizontal" && w.value ? "bottom-start" : "right-start"), y = E(() => L.value === "horizontal" && w.value || L.value === "vertical" && !u.props.collapse ? e.expandCloseIcon && e.expandOpenIcon ? k.value ? e.expandOpenIcon : e.expandCloseIcon : qr : e.collapseCloseIcon && e.collapseOpenIcon ? k.value ? e.collapseOpenIcon : e.collapseCloseIcon : kn), w = E(() => c.level === 0), b = E(() => {
        var M;
        const j = (M = e.teleported) != null ? M : e.popperAppendToBody;
        return j === void 0 ? w.value : j;
      }), C = E(() => u.props.collapse ? `${l.namespace.value}-zoom-in-left` : `${l.namespace.value}-zoom-in-top`), _ = E(() => L.value === "horizontal" && w.value ? [
        "bottom-start",
        "bottom-end",
        "top-start",
        "top-end",
        "right-start",
        "left-start"
      ] : [
        "right-start",
        "left-start",
        "bottom-start",
        "bottom-end",
        "top-start",
        "top-end"
      ]), k = E(() => u.openedMenus.includes(e.index)), O = E(() => {
        let M = !1;
        return Object.values(f.value).forEach((j) => {
          j.active && (M = !0);
        }), Object.values(d.value).forEach((j) => {
          j.active && (M = !0);
        }), M;
      }), T = E(() => u.props.backgroundColor || ""), P = E(() => u.props.activeTextColor || ""), A = E(() => u.props.textColor || ""), L = E(() => u.props.mode), D = Tt({
        index: e.index,
        indexPath: r,
        active: O
      }), B = E(() => L.value !== "horizontal" ? {
        color: A.value
      } : {
        borderBottomColor: O.value ? u.props.activeTextColor ? P.value : "" : "transparent",
        color: O.value ? P.value : A.value
      }), F = () => {
        var M, j, te;
        return (te = (j = (M = v.value) == null ? void 0 : M.popperRef) == null ? void 0 : j.popperInstanceRef) == null ? void 0 : te.destroy();
      }, W = (M) => {
        M || F();
      }, x = () => {
        u.props.menuTrigger === "hover" && u.props.mode === "horizontal" || u.props.collapse && u.props.mode === "vertical" || e.disabled || u.handleSubMenuClick({
          index: e.index,
          indexPath: r.value,
          active: O.value
        });
      }, N = (M, j = e.showTimeout) => {
        var te;
        M.type !== "focus" && (u.props.menuTrigger === "click" && u.props.mode === "horizontal" || !u.props.collapse && u.props.mode === "vertical" || e.disabled || (c.mouseInChild.value = !0, p == null || p(), { stop: p } = Os(() => {
          u.openMenu(e.index, r.value);
        }, j), b.value && ((te = s.value.vnode.el) == null || te.dispatchEvent(new MouseEvent("mouseenter")))));
      }, R = (M = !1) => {
        var j, te;
        u.props.menuTrigger === "click" && u.props.mode === "horizontal" || !u.props.collapse && u.props.mode === "vertical" || (p == null || p(), c.mouseInChild.value = !1, { stop: p } = Os(() => !h.value && u.closeMenu(e.index, r.value), e.hideTimeout), b.value && M && ((j = o.parent) == null ? void 0 : j.type.name) === "ElSubMenu" && ((te = c.handleMouseleave) == null || te.call(c, !0)));
      };
      me(() => u.props.collapse, (M) => W(Boolean(M)));
      {
        const M = (te) => {
          d.value[te.index] = te;
        }, j = (te) => {
          delete d.value[te.index];
        };
        pt(`subMenu:${o.uid}`, {
          addSubMenu: M,
          removeSubMenu: j,
          handleMouseleave: R,
          mouseInChild: h,
          level: c.level + 1
        });
      }
      return n({
        opened: k
      }), st(() => {
        u.addSubMenu(D), c.addSubMenu(D);
      }), zt(() => {
        c.removeSubMenu(D), u.removeSubMenu(D);
      }), () => {
        var M;
        const j = [
          (M = t.title) == null ? void 0 : M.call(t),
          je(He, {
            class: a.e("icon-arrow"),
            style: {
              transform: k.value ? e.expandCloseIcon && e.expandOpenIcon || e.collapseCloseIcon && e.collapseOpenIcon && u.props.collapse ? "none" : "rotateZ(180deg)" : "none"
            }
          }, {
            default: () => et(y.value) ? je(o.appContext.components[y.value]) : je(y.value)
          })
        ], te = xE(u.props, c.level + 1), U = u.isMenuPopup ? je(Mn, {
          ref: v,
          visible: k.value,
          effect: "light",
          pure: !0,
          offset: e.popperOffset,
          showArrow: !1,
          persistent: !0,
          popperClass: e.popperClass,
          placement: g.value,
          teleported: b.value,
          fallbackPlacements: _.value,
          transition: C.value,
          gpuAcceleration: !1
        }, {
          content: () => {
            var Z;
            return je("div", {
              class: [
                l.m(L.value),
                l.m("popup-container"),
                e.popperClass
              ],
              onMouseenter: (pe) => N(pe, 100),
              onMouseleave: () => R(!0),
              onFocus: (pe) => N(pe, 100)
            }, [
              je("ul", {
                class: [
                  l.b(),
                  l.m("popup"),
                  l.m(`popup-${g.value}`)
                ],
                style: te.value
              }, [(Z = t.default) == null ? void 0 : Z.call(t)])
            ]);
          },
          default: () => je("div", {
            class: a.e("title"),
            style: [
              B.value,
              { backgroundColor: T.value }
            ],
            onClick: x
          }, j)
        }) : je(ze, {}, [
          je("div", {
            class: a.e("title"),
            style: [
              B.value,
              { backgroundColor: T.value }
            ],
            ref: m,
            onClick: x
          }, j),
          je(ed, {}, {
            default: () => {
              var Z;
              return ot(je("ul", {
                role: "menu",
                class: [l.b(), l.m("inline")],
                style: te.value
              }, [(Z = t.default) == null ? void 0 : Z.call(t)]), [[$t, k.value]]);
            }
          })
        ]);
        return je("li", {
          class: [
            a.b(),
            a.is("active", O.value),
            a.is("opened", k.value),
            a.is("disabled", e.disabled)
          ],
          role: "menuitem",
          ariaHaspopup: !0,
          ariaExpanded: k.value,
          onMouseenter: N,
          onMouseleave: () => R(!0),
          onFocus: N
        }, [U]);
      };
    }
  });
  const d7 = Ie({
    mode: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "vertical"
    },
    defaultActive: {
      type: String,
      default: ""
    },
    defaultOpeneds: {
      type: le(Array),
      default: () => jt([])
    },
    uniqueOpened: Boolean,
    router: Boolean,
    menuTrigger: {
      type: String,
      values: ["hover", "click"],
      default: "hover"
    },
    collapse: Boolean,
    backgroundColor: String,
    textColor: String,
    activeTextColor: String,
    collapseTransition: {
      type: Boolean,
      default: !0
    },
    ellipsis: {
      type: Boolean,
      default: !0
    },
    popperEffect: {
      type: String,
      values: ["dark", "light"],
      default: "dark"
    }
  }), Vd = (e) => Array.isArray(e) && e.every((t) => et(t)), f7 = {
    close: (e, t) => et(e) && Vd(t),
    open: (e, t) => et(e) && Vd(t),
    select: (e, t, n, o) => et(e) && Vd(t) && rt(n) && (o === void 0 || o instanceof Promise)
  };
  var p7 = G({
    name: "ElMenu",
    props: d7,
    emits: f7,
    setup(e, { emit: t, slots: n, expose: o }) {
      const r = it(), s = r.appContext.config.globalProperties.$router, l = I(), a = ge("menu"), u = ge("sub-menu"), c = I(-1), f = I(e.defaultOpeneds && !e.collapse ? e.defaultOpeneds.slice(0) : []), d = I(e.defaultActive), p = I({}), h = I({}), m = E(() => e.mode === "horizontal" || e.mode === "vertical" && e.collapse), v = () => {
        const L = d.value && p.value[d.value];
        if (!L || e.mode === "horizontal" || e.collapse)
          return;
        L.indexPath.forEach((B) => {
          const F = h.value[B];
          F && g(B, F.indexPath);
        });
      }, g = (L, D) => {
        f.value.includes(L) || (e.uniqueOpened && (f.value = f.value.filter((B) => D.includes(B))), f.value.push(L), t("open", L, D));
      }, y = (L) => {
        const D = f.value.indexOf(L);
        D !== -1 && f.value.splice(D, 1);
      }, w = (L, D) => {
        y(L), t("close", L, D);
      }, b = ({
        index: L,
        indexPath: D
      }) => {
        f.value.includes(L) ? w(L, D) : g(L, D);
      }, C = (L) => {
        (e.mode === "horizontal" || e.collapse) && (f.value = []);
        const { index: D, indexPath: B } = L;
        if (!(nn(D) || nn(B)))
          if (e.router && s) {
            const F = L.route || D, W = s.push(F).then((x) => (x || (d.value = D), x));
            t("select", D, B, { index: D, indexPath: B, route: F }, W);
          } else
            d.value = D, t("select", D, B, { index: D, indexPath: B });
      }, _ = (L) => {
        const D = p.value, B = D[L] || d.value && D[d.value] || D[e.defaultActive];
        B ? d.value = B.index : d.value = L;
      }, k = () => {
        var L, D;
        if (!l.value)
          return -1;
        const B = Array.from((D = (L = l.value) == null ? void 0 : L.childNodes) != null ? D : []).filter((j) => j.nodeName !== "#text" || j.nodeValue), F = 64, W = Number.parseInt(getComputedStyle(l.value).paddingLeft, 10), x = Number.parseInt(getComputedStyle(l.value).paddingRight, 10), N = l.value.clientWidth - W - x;
        let R = 0, M = 0;
        return B.forEach((j, te) => {
          R += j.offsetWidth || 0, R <= N - F && (M = te + 1);
        }), M === B.length ? -1 : M;
      }, O = (L, D = 33.34) => {
        let B;
        return () => {
          B && clearTimeout(B), B = setTimeout(() => {
            L();
          }, D);
        };
      };
      let T = !0;
      const P = () => {
        const L = () => {
          c.value = -1, Fe(() => {
            c.value = k();
          });
        };
        T ? L() : O(L)(), T = !1;
      };
      me(() => e.defaultActive, (L) => {
        p.value[L] || (d.value = ""), _(L);
      }), me(() => e.collapse, (L) => {
        L && (f.value = []);
      }), me(p.value, v);
      let A;
      xn(() => {
        e.mode === "horizontal" && e.ellipsis ? A = Cn(l, P).stop : A == null || A();
      });
      {
        const L = (W) => {
          h.value[W.index] = W;
        }, D = (W) => {
          delete h.value[W.index];
        };
        pt("rootMenu", Tt({
          props: e,
          openedMenus: f,
          items: p,
          subMenus: h,
          activeIndex: d,
          isMenuPopup: m,
          addMenuItem: (W) => {
            p.value[W.index] = W;
          },
          removeMenuItem: (W) => {
            delete p.value[W.index];
          },
          addSubMenu: L,
          removeSubMenu: D,
          openMenu: g,
          closeMenu: w,
          handleMenuItemClick: C,
          handleSubMenuClick: b
        })), pt(`subMenu:${r.uid}`, {
          addSubMenu: L,
          removeSubMenu: D,
          mouseInChild: I(!1),
          level: 0
        });
      }
      return st(() => {
        e.mode === "horizontal" && new s7(r.vnode.el, a.namespace.value);
      }), o({
        open: (D) => {
          const { indexPath: B } = h.value[D];
          B.forEach((F) => g(F, B));
        },
        close: y,
        handleResize: P
      }), () => {
        var L, D;
        let B = (D = (L = n.default) == null ? void 0 : L.call(n)) != null ? D : [];
        const F = [];
        if (e.mode === "horizontal" && l.value) {
          const N = dl(B), R = c.value === -1 ? N : N.slice(0, c.value), M = c.value === -1 ? [] : N.slice(c.value);
          (M == null ? void 0 : M.length) && e.ellipsis && (B = R, F.push(je(ov, {
            index: "sub-menu-more",
            class: u.e("hide-arrow")
          }, {
            title: () => je(He, {
              class: u.e("icon-more")
            }, { default: () => je(ER) }),
            default: () => M
          })));
        }
        const W = xE(e, 0), x = je("ul", {
          key: String(e.collapse),
          role: "menubar",
          ref: l,
          style: W.value,
          class: {
            [a.b()]: !0,
            [a.m(e.mode)]: !0,
            [a.m("collapse")]: e.collapse
          }
        }, [...B, ...F]);
        return e.collapseTransition && e.mode === "vertical" ? je(i7, () => x) : x;
      };
    }
  });
  const h7 = Ie({
    index: {
      type: le([String, null]),
      default: null
    },
    route: {
      type: le([String, Object])
    },
    disabled: Boolean
  }), v7 = {
    click: (e) => et(e.index) && Array.isArray(e.indexPath)
  }, Bd = "ElMenuItem", m7 = G({
    name: Bd,
    components: {
      ElTooltip: Mn
    },
    props: h7,
    emits: v7,
    setup(e, { emit: t }) {
      const n = it(), o = Be("rootMenu"), r = ge("menu"), s = ge("menu-item");
      o || Yt(Bd, "can not inject root menu");
      const { parentMenu: l, indexPath: a } = RE(n, Ht(e, "index")), u = Be(`subMenu:${l.value.uid}`);
      u || Yt(Bd, "can not inject sub menu");
      const c = E(() => e.index === o.activeIndex), f = Tt({
        index: e.index,
        indexPath: a,
        active: c
      }), d = () => {
        e.disabled || (o.handleMenuItemClick({
          index: e.index,
          indexPath: a.value,
          route: e.route
        }), t("click", f));
      };
      return st(() => {
        u.addSubMenu(f), o.addMenuItem(f);
      }), zt(() => {
        u.removeSubMenu(f), o.removeMenuItem(f);
      }), {
        parentMenu: l,
        rootMenu: o,
        active: c,
        nsMenu: r,
        nsMenuItem: s,
        handleClick: d
      };
    }
  });
  function g7(e, t, n, o, r, s) {
    const l = Qe("el-tooltip");
    return S(), V("li", {
      class: $([
        e.nsMenuItem.b(),
        e.nsMenuItem.is("active", e.active),
        e.nsMenuItem.is("disabled", e.disabled)
      ]),
      role: "menuitem",
      tabindex: "-1",
      onClick: t[0] || (t[0] = (...a) => e.handleClick && e.handleClick(...a))
    }, [
      e.parentMenu.type.name === "ElMenu" && e.rootMenu.props.collapse && e.$slots.title ? (S(), ie(l, {
        key: 0,
        effect: e.rootMenu.props.popperEffect,
        placement: "right",
        "fallback-placements": ["left"],
        persistent: ""
      }, {
        content: X(() => [
          he(e.$slots, "title")
        ]),
        default: X(() => [
          H("div", {
            class: $(e.nsMenu.be("tooltip", "trigger"))
          }, [
            he(e.$slots, "default")
          ], 2)
        ]),
        _: 3
      }, 8, ["effect"])) : (S(), V(ze, { key: 1 }, [
        he(e.$slots, "default"),
        he(e.$slots, "title")
      ], 64))
    ], 2);
  }
  var DE = /* @__PURE__ */ Me(m7, [["render", g7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item.vue"]]);
  const y7 = {
    title: String
  }, b7 = "ElMenuItemGroup", w7 = G({
    name: b7,
    props: y7,
    setup() {
      return {
        ns: ge("menu-item-group")
      };
    }
  });
  function C7(e, t, n, o, r, s) {
    return S(), V("li", {
      class: $(e.ns.b())
    }, [
      H("div", {
        class: $(e.ns.e("title"))
      }, [
        e.$slots.title ? he(e.$slots, "title", { key: 1 }) : (S(), V(ze, { key: 0 }, [
          wt(Ne(e.title), 1)
        ], 64))
      ], 2),
      H("ul", null, [
        he(e.$slots, "default")
      ])
    ], 2);
  }
  var LE = /* @__PURE__ */ Me(w7, [["render", C7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item-group.vue"]]);
  const E7 = ut(p7, {
    MenuItem: DE,
    MenuItemGroup: LE,
    SubMenu: ov
  }), S7 = Gt(DE), _7 = Gt(LE), k7 = Gt(ov), $7 = Ie({
    icon: {
      type: Vt,
      default: () => d3
    },
    title: String,
    content: {
      type: String,
      default: ""
    }
  }), N7 = {
    back: () => !0
  }, T7 = ["aria-label"], O7 = G({
    name: "ElPageHeader"
  }), M7 = /* @__PURE__ */ G({
    ...O7,
    props: $7,
    emits: N7,
    setup(e, { emit: t }) {
      const n = hn(), { t: o } = St(), r = ge("page-header"), s = E(() => [
        r.b(),
        {
          [r.m("has-breadcrumb")]: !!n.breadcrumb,
          [r.m("has-extra")]: !!n.extra,
          [r.is("contentful")]: !!n.default
        }
      ]);
      function l() {
        t("back");
      }
      return (a, u) => (S(), V("div", {
        class: $(i(s))
      }, [
        a.$slots.breadcrumb ? (S(), V("div", {
          key: 0,
          class: $(i(r).e("breadcrumb"))
        }, [
          he(a.$slots, "breadcrumb")
        ], 2)) : se("v-if", !0),
        H("div", {
          class: $(i(r).e("header"))
        }, [
          H("div", {
            class: $(i(r).e("left"))
          }, [
            H("div", {
              class: $(i(r).e("back")),
              role: "button",
              tabindex: "0",
              onClick: l
            }, [
              a.icon || a.$slots.icon ? (S(), V("div", {
                key: 0,
                "aria-label": a.title || i(o)("el.pageHeader.title"),
                class: $(i(r).e("icon"))
              }, [
                he(a.$slots, "icon", {}, () => [
                  a.icon ? (S(), ie(i(He), { key: 0 }, {
                    default: X(() => [
                      (S(), ie(vt(a.icon)))
                    ]),
                    _: 1
                  })) : se("v-if", !0)
                ])
              ], 10, T7)) : se("v-if", !0),
              H("div", {
                class: $(i(r).e("title"))
              }, [
                he(a.$slots, "title", {}, () => [
                  wt(Ne(a.title || i(o)("el.pageHeader.title")), 1)
                ])
              ], 2)
            ], 2),
            K(i(EE), { direction: "vertical" }),
            H("div", {
              class: $(i(r).e("content"))
            }, [
              he(a.$slots, "content", {}, () => [
                wt(Ne(a.content), 1)
              ])
            ], 2)
          ], 2),
          a.$slots.extra ? (S(), V("div", {
            key: 0,
            class: $(i(r).e("extra"))
          }, [
            he(a.$slots, "extra")
          ], 2)) : se("v-if", !0)
        ], 2),
        a.$slots.default ? (S(), V("div", {
          key: 1,
          class: $(i(r).e("main"))
        }, [
          he(a.$slots, "default")
        ], 2)) : se("v-if", !0)
      ], 2));
    }
  });
  var I7 = /* @__PURE__ */ Me(M7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/page-header/src/page-header.vue"]]);
  const P7 = ut(I7), VE = Symbol("elPaginationKey"), A7 = Ie({
    disabled: Boolean,
    currentPage: {
      type: Number,
      default: 1
    },
    prevText: {
      type: String
    },
    prevIcon: {
      type: Vt
    }
  }), R7 = {
    click: (e) => e instanceof MouseEvent
  }, x7 = ["disabled", "aria-label", "aria-disabled"], D7 = { key: 0 }, L7 = G({
    name: "ElPaginationPrev"
  }), V7 = /* @__PURE__ */ G({
    ...L7,
    props: A7,
    emits: R7,
    setup(e) {
      const t = e, { t: n } = St(), o = E(() => t.disabled || t.currentPage <= 1);
      return (r, s) => (S(), V("button", {
        type: "button",
        class: "btn-prev",
        disabled: i(o),
        "aria-label": r.prevText || i(n)("el.pagination.prev"),
        "aria-disabled": i(o),
        onClick: s[0] || (s[0] = (l) => r.$emit("click", l))
      }, [
        r.prevText ? (S(), V("span", D7, Ne(r.prevText), 1)) : (S(), ie(i(He), { key: 1 }, {
          default: X(() => [
            (S(), ie(vt(r.prevIcon)))
          ]),
          _: 1
        }))
      ], 8, x7));
    }
  });
  var B7 = /* @__PURE__ */ Me(V7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/prev.vue"]]);
  const F7 = Ie({
    disabled: Boolean,
    currentPage: {
      type: Number,
      default: 1
    },
    pageCount: {
      type: Number,
      default: 50
    },
    nextText: {
      type: String
    },
    nextIcon: {
      type: Vt
    }
  }), H7 = ["disabled", "aria-label", "aria-disabled"], z7 = { key: 0 }, K7 = G({
    name: "ElPaginationNext"
  }), j7 = /* @__PURE__ */ G({
    ...K7,
    props: F7,
    emits: ["click"],
    setup(e) {
      const t = e, { t: n } = St(), o = E(() => t.disabled || t.currentPage === t.pageCount || t.pageCount === 0);
      return (r, s) => (S(), V("button", {
        type: "button",
        class: "btn-next",
        disabled: i(o),
        "aria-label": r.nextText || i(n)("el.pagination.next"),
        "aria-disabled": i(o),
        onClick: s[0] || (s[0] = (l) => r.$emit("click", l))
      }, [
        r.nextText ? (S(), V("span", z7, Ne(r.nextText), 1)) : (S(), ie(i(He), { key: 1 }, {
          default: X(() => [
            (S(), ie(vt(r.nextIcon)))
          ]),
          _: 1
        }))
      ], 8, H7));
    }
  });
  var W7 = /* @__PURE__ */ Me(j7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/next.vue"]]);
  const BE = Symbol("ElSelectGroup"), ki = Symbol("ElSelect");
  function U7(e, t) {
    const n = Be(ki), o = Be(BE, { disabled: !1 }), r = E(() => Object.prototype.toString.call(e.value).toLowerCase() === "[object object]"), s = E(() => n.props.multiple ? d(n.props.modelValue, e.value) : p(e.value, n.props.modelValue)), l = E(() => {
      if (n.props.multiple) {
        const v = n.props.modelValue || [];
        return !s.value && v.length >= n.props.multipleLimit && n.props.multipleLimit > 0;
      } else
        return !1;
    }), a = E(() => e.label || (r.value ? "" : e.value)), u = E(() => e.value || e.label || ""), c = E(() => e.disabled || t.groupDisabled || l.value), f = it(), d = (v = [], g) => {
      if (r.value) {
        const y = n.props.valueKey;
        return v && v.some((w) => Ct(Kt(w, y)) === Kt(g, y));
      } else
        return v && v.includes(g);
    }, p = (v, g) => {
      if (r.value) {
        const { valueKey: y } = n.props;
        return Kt(v, y) === Kt(g, y);
      } else
        return v === g;
    }, h = () => {
      !e.disabled && !o.disabled && (n.hoverIndex = n.optionsArray.indexOf(f.proxy));
    };
    me(() => a.value, () => {
      !e.created && !n.props.remote && n.setSelected();
    }), me(() => e.value, (v, g) => {
      const { remote: y, valueKey: w } = n.props;
      if (Object.is(v, g) || (n.onOptionDestroy(g, f.proxy), n.onOptionCreate(f.proxy)), !e.created && !y) {
        if (w && typeof v == "object" && typeof g == "object" && v[w] === g[w])
          return;
        n.setSelected();
      }
    }), me(() => o.disabled, () => {
      t.groupDisabled = o.disabled;
    }, { immediate: !0 });
    const { queryChange: m } = Ct(n);
    return me(m, (v) => {
      const { query: g } = i(v), y = new RegExp(W1(g), "i");
      t.visible = y.test(a.value) || e.created, t.visible || n.filteredOptionsCount--;
    }, { immediate: !0 }), {
      select: n,
      currentLabel: a,
      currentValue: u,
      itemSelected: s,
      isDisabled: c,
      hoverItem: h
    };
  }
  const q7 = G({
    name: "ElOption",
    componentName: "ElOption",
    props: {
      value: {
        required: !0,
        type: [String, Number, Boolean, Object]
      },
      label: [String, Number],
      created: Boolean,
      disabled: {
        type: Boolean,
        default: !1
      }
    },
    setup(e) {
      const t = ge("select"), n = Tt({
        index: -1,
        groupDisabled: !1,
        visible: !0,
        hitState: !1,
        hover: !1
      }), { currentLabel: o, itemSelected: r, isDisabled: s, select: l, hoverItem: a } = U7(e, n), { visible: u, hover: c } = rn(n), f = it().proxy;
      l.onOptionCreate(f), zt(() => {
        const p = f.value, { selected: h } = l, v = (l.props.multiple ? h : [h]).some((g) => g.value === f.value);
        Fe(() => {
          l.cachedOptions.get(p) === f && !v && l.cachedOptions.delete(p);
        }), l.onOptionDestroy(p, f);
      });
      function d() {
        e.disabled !== !0 && n.groupDisabled !== !0 && l.handleOptionSelect(f, !0);
      }
      return {
        ns: t,
        currentLabel: o,
        itemSelected: r,
        isDisabled: s,
        select: l,
        hoverItem: a,
        visible: u,
        hover: c,
        selectOptionClick: d,
        states: n
      };
    }
  });
  function Y7(e, t, n, o, r, s) {
    return ot((S(), V("li", {
      class: $([
        e.ns.be("dropdown", "item"),
        e.ns.is("disabled", e.isDisabled),
        {
          selected: e.itemSelected,
          hover: e.hover
        }
      ]),
      onMouseenter: t[0] || (t[0] = (...l) => e.hoverItem && e.hoverItem(...l)),
      onClick: t[1] || (t[1] = Ze((...l) => e.selectOptionClick && e.selectOptionClick(...l), ["stop"]))
    }, [
      he(e.$slots, "default", {}, () => [
        H("span", null, Ne(e.currentLabel), 1)
      ])
    ], 34)), [
      [$t, e.visible]
    ]);
  }
  var rv = /* @__PURE__ */ Me(q7, [["render", Y7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
  const G7 = G({
    name: "ElSelectDropdown",
    componentName: "ElSelectDropdown",
    setup() {
      const e = Be(ki), t = ge("select"), n = E(() => e.props.popperClass), o = E(() => e.props.multiple), r = E(() => e.props.fitInputWidth), s = I("");
      function l() {
        var a;
        s.value = `${(a = e.selectWrapper) == null ? void 0 : a.offsetWidth}px`;
      }
      return st(() => {
        l(), Cn(e.selectWrapper, l);
      }), {
        ns: t,
        minWidth: s,
        popperClass: n,
        isMultiple: o,
        isFitInputWidth: r
      };
    }
  });
  function X7(e, t, n, o, r, s) {
    return S(), V("div", {
      class: $([e.ns.b("dropdown"), e.ns.is("multiple", e.isMultiple), e.popperClass]),
      style: Ke({ [e.isFitInputWidth ? "width" : "minWidth"]: e.minWidth })
    }, [
      he(e.$slots, "default")
    ], 6);
  }
  var J7 = /* @__PURE__ */ Me(G7, [["render", X7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
  function Z7(e) {
    const { t } = St();
    return Tt({
      options: /* @__PURE__ */ new Map(),
      cachedOptions: /* @__PURE__ */ new Map(),
      createdLabel: null,
      createdSelected: !1,
      selected: e.multiple ? [] : {},
      inputLength: 20,
      inputWidth: 0,
      optionsCount: 0,
      filteredOptionsCount: 0,
      visible: !1,
      softFocus: !1,
      selectedLabel: "",
      hoverIndex: -1,
      query: "",
      previousQuery: null,
      inputHovering: !1,
      cachedPlaceHolder: "",
      currentPlaceholder: t("el.select.placeholder"),
      menuVisibleOnFocus: !1,
      isOnComposition: !1,
      isSilentBlur: !1,
      prefixWidth: 11,
      tagInMultiLine: !1,
      mouseEnter: !1
    });
  }
  const Q7 = (e, t, n) => {
    const { t: o } = St(), r = ge("select");
    Vo({
      from: "suffixTransition",
      replacement: "override style scheme",
      version: "2.3.0",
      scope: "props",
      ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
    }, E(() => e.suffixTransition === !1));
    const s = I(null), l = I(null), a = I(null), u = I(null), c = I(null), f = I(null), d = I(null), p = I(-1), h = xt({ query: "" }), m = xt(""), v = I([]);
    let g = 0;
    const { form: y, formItem: w } = In(), b = E(() => !e.filterable || e.multiple || !t.visible), C = E(() => e.disabled || (y == null ? void 0 : y.disabled)), _ = E(() => {
      const ve = e.multiple ? Array.isArray(e.modelValue) && e.modelValue.length > 0 : e.modelValue !== void 0 && e.modelValue !== null && e.modelValue !== "";
      return e.clearable && !C.value && t.inputHovering && ve;
    }), k = E(() => e.remote && e.filterable && !e.remoteShowSuffix ? "" : e.suffixIcon), O = E(() => r.is("reverse", k.value && t.visible && e.suffixTransition)), T = E(() => e.remote ? 300 : 0), P = E(() => e.loading ? e.loadingText || o("el.select.loading") : e.remote && t.query === "" && t.options.size === 0 ? !1 : e.filterable && t.query && t.options.size > 0 && t.filteredOptionsCount === 0 ? e.noMatchText || o("el.select.noMatch") : t.options.size === 0 ? e.noDataText || o("el.select.noData") : null), A = E(() => {
      const ve = Array.from(t.options.values()), Le = [];
      return v.value.forEach((lt) => {
        const ct = ve.findIndex((mt) => mt.currentLabel === lt);
        ct > -1 && Le.push(ve[ct]);
      }), Le.length ? Le : ve;
    }), L = E(() => Array.from(t.cachedOptions.values())), D = E(() => {
      const ve = A.value.filter((Le) => !Le.created).some((Le) => Le.currentLabel === t.query);
      return e.filterable && e.allowCreate && t.query !== "" && !ve;
    }), B = on(), F = E(() => ["small"].includes(B.value) ? "small" : "default"), W = E({
      get() {
        return t.visible && P.value !== !1;
      },
      set(ve) {
        t.visible = ve;
      }
    });
    me([() => C.value, () => B.value, () => y == null ? void 0 : y.size], () => {
      Fe(() => {
        x();
      });
    }), me(() => e.placeholder, (ve) => {
      t.cachedPlaceHolder = t.currentPlaceholder = ve;
    }), me(() => e.modelValue, (ve, Le) => {
      e.multiple && (x(), ve && ve.length > 0 || l.value && t.query !== "" ? t.currentPlaceholder = "" : t.currentPlaceholder = t.cachedPlaceHolder, e.filterable && !e.reserveKeyword && (t.query = "", N(t.query))), j(), e.filterable && !e.multiple && (t.inputLength = 20), !qn(ve, Le) && e.validateEvent && (w == null || w.validate("change").catch((lt) => yt(lt)));
    }, {
      flush: "post",
      deep: !0
    }), me(() => t.visible, (ve) => {
      var Le, lt, ct, mt, Mt;
      ve ? ((lt = (Le = u.value) == null ? void 0 : Le.updatePopper) == null || lt.call(Le), e.filterable && (t.filteredOptionsCount = t.optionsCount, t.query = e.remote ? "" : t.selectedLabel, (mt = (ct = a.value) == null ? void 0 : ct.focus) == null || mt.call(ct), e.multiple ? (Mt = l.value) == null || Mt.focus() : t.selectedLabel && (t.currentPlaceholder = `${t.selectedLabel}`, t.selectedLabel = ""), N(t.query), !e.multiple && !e.remote && (h.value.query = "", Yl(h), Yl(m)))) : (e.filterable && (Ge(e.filterMethod) && e.filterMethod(""), Ge(e.remoteMethod) && e.remoteMethod("")), l.value && l.value.blur(), t.query = "", t.previousQuery = null, t.selectedLabel = "", t.inputLength = 20, t.menuVisibleOnFocus = !1, U(), Fe(() => {
        l.value && l.value.value === "" && t.selected.length === 0 && (t.currentPlaceholder = t.cachedPlaceHolder);
      }), e.multiple || (t.selected && (e.filterable && e.allowCreate && t.createdSelected && t.createdLabel ? t.selectedLabel = t.createdLabel : t.selectedLabel = t.selected.currentLabel, e.filterable && (t.query = t.selectedLabel)), e.filterable && (t.currentPlaceholder = t.cachedPlaceHolder))), n.emit("visible-change", ve);
    }), me(() => t.options.entries(), () => {
      var ve, Le, lt;
      if (!bt)
        return;
      (Le = (ve = u.value) == null ? void 0 : ve.updatePopper) == null || Le.call(ve), e.multiple && x();
      const ct = ((lt = f.value) == null ? void 0 : lt.querySelectorAll("input")) || [];
      Array.from(ct).includes(document.activeElement) || j(), e.defaultFirstOption && (e.filterable || e.remote) && t.filteredOptionsCount && M();
    }, {
      flush: "post"
    }), me(() => t.hoverIndex, (ve) => {
      Xe(ve) && ve > -1 ? p.value = A.value[ve] || {} : p.value = {}, A.value.forEach((Le) => {
        Le.hover = p.value === Le;
      });
    });
    const x = () => {
      Fe(() => {
        var ve, Le;
        if (!s.value)
          return;
        const lt = s.value.$el.querySelector("input");
        g = g || (lt.clientHeight > 0 ? lt.clientHeight + 2 : 0);
        const ct = c.value, mt = cD(B.value || (y == null ? void 0 : y.size)), Mt = mt === g || g <= 0 ? mt : g;
        !(lt.offsetParent === null) && (lt.style.height = `${(t.selected.length === 0 ? Mt : Math.max(ct ? ct.clientHeight + (ct.clientHeight > Mt ? 6 : 0) : 0, Mt)) - 2}px`), t.tagInMultiLine = Number.parseFloat(lt.style.height) >= Mt, t.visible && P.value !== !1 && ((Le = (ve = u.value) == null ? void 0 : ve.updatePopper) == null || Le.call(ve));
      });
    }, N = async (ve) => {
      if (!(t.previousQuery === ve || t.isOnComposition)) {
        if (t.previousQuery === null && (Ge(e.filterMethod) || Ge(e.remoteMethod))) {
          t.previousQuery = ve;
          return;
        }
        t.previousQuery = ve, Fe(() => {
          var Le, lt;
          t.visible && ((lt = (Le = u.value) == null ? void 0 : Le.updatePopper) == null || lt.call(Le));
        }), t.hoverIndex = -1, e.multiple && e.filterable && Fe(() => {
          const Le = l.value.value.length * 15 + 20;
          t.inputLength = e.collapseTags ? Math.min(50, Le) : Le, R(), x();
        }), e.remote && Ge(e.remoteMethod) ? (t.hoverIndex = -1, e.remoteMethod(ve)) : Ge(e.filterMethod) ? (e.filterMethod(ve), Yl(m)) : (t.filteredOptionsCount = t.optionsCount, h.value.query = ve, Yl(h), Yl(m)), e.defaultFirstOption && (e.filterable || e.remote) && t.filteredOptionsCount && (await Fe(), M());
      }
    }, R = () => {
      t.currentPlaceholder !== "" && (t.currentPlaceholder = l.value.value ? "" : t.cachedPlaceHolder);
    }, M = () => {
      const ve = A.value.filter((ct) => ct.visible && !ct.disabled && !ct.states.groupDisabled), Le = ve.find((ct) => ct.created), lt = ve[0];
      t.hoverIndex = z(A.value, Le || lt);
    }, j = () => {
      var ve;
      if (e.multiple)
        t.selectedLabel = "";
      else {
        const lt = te(e.modelValue);
        (ve = lt.props) != null && ve.created ? (t.createdLabel = lt.props.value, t.createdSelected = !0) : t.createdSelected = !1, t.selectedLabel = lt.currentLabel, t.selected = lt, e.filterable && (t.query = t.selectedLabel);
        return;
      }
      const Le = [];
      Array.isArray(e.modelValue) && e.modelValue.forEach((lt) => {
        Le.push(te(lt));
      }), t.selected = Le, Fe(() => {
        x();
      });
    }, te = (ve) => {
      let Le;
      const lt = al(ve).toLowerCase() === "object", ct = al(ve).toLowerCase() === "null", mt = al(ve).toLowerCase() === "undefined";
      for (let $e = t.cachedOptions.size - 1; $e >= 0; $e--) {
        const Ye = L.value[$e];
        if (lt ? Kt(Ye.value, e.valueKey) === Kt(ve, e.valueKey) : Ye.value === ve) {
          Le = {
            value: ve,
            currentLabel: Ye.currentLabel,
            isDisabled: Ye.isDisabled
          };
          break;
        }
      }
      if (Le)
        return Le;
      const Mt = lt ? ve.label : !ct && !mt ? ve : "", ln = {
        value: ve,
        currentLabel: Mt
      };
      return e.multiple && (ln.hitState = !1), ln;
    }, U = () => {
      setTimeout(() => {
        const ve = e.valueKey;
        e.multiple ? t.selected.length > 0 ? t.hoverIndex = Math.min.apply(null, t.selected.map((Le) => A.value.findIndex((lt) => Kt(lt, ve) === Kt(Le, ve)))) : t.hoverIndex = -1 : t.hoverIndex = A.value.findIndex((Le) => Ce(Le) === Ce(t.selected));
      }, 300);
    }, Z = () => {
      var ve, Le;
      pe(), (Le = (ve = u.value) == null ? void 0 : ve.updatePopper) == null || Le.call(ve), e.multiple && x();
    }, pe = () => {
      var ve;
      t.inputWidth = (ve = s.value) == null ? void 0 : ve.$el.offsetWidth;
    }, J = () => {
      e.filterable && t.query !== t.selectedLabel && (t.query = t.selectedLabel, N(t.query));
    }, ee = On(() => {
      J();
    }, T.value), ne = On((ve) => {
      N(ve.target.value);
    }, T.value), Y = (ve) => {
      qn(e.modelValue, ve) || n.emit(Ft, ve);
    }, re = (ve) => {
      if (ve.target.value.length <= 0 && !we()) {
        const Le = e.modelValue.slice();
        Le.pop(), n.emit(dt, Le), Y(Le);
      }
      ve.target.value.length === 1 && e.modelValue.length === 0 && (t.currentPlaceholder = t.cachedPlaceHolder);
    }, ce = (ve, Le) => {
      const lt = t.selected.indexOf(Le);
      if (lt > -1 && !C.value) {
        const ct = e.modelValue.slice();
        ct.splice(lt, 1), n.emit(dt, ct), Y(ct), n.emit("remove-tag", Le.value);
      }
      ve.stopPropagation();
    }, Te = (ve) => {
      ve.stopPropagation();
      const Le = e.multiple ? [] : "";
      if (!et(Le))
        for (const lt of t.selected)
          lt.isDisabled && Le.push(lt.value);
      n.emit(dt, Le), Y(Le), t.hoverIndex = -1, t.visible = !1, n.emit("clear");
    }, Pe = (ve, Le) => {
      var lt;
      if (e.multiple) {
        const ct = (e.modelValue || []).slice(), mt = z(ct, ve.value);
        mt > -1 ? ct.splice(mt, 1) : (e.multipleLimit <= 0 || ct.length < e.multipleLimit) && ct.push(ve.value), n.emit(dt, ct), Y(ct), ve.created && (t.query = "", N(""), t.inputLength = 20), e.filterable && ((lt = l.value) == null || lt.focus());
      } else
        n.emit(dt, ve.value), Y(ve.value), t.visible = !1;
      t.isSilentBlur = Le, Q(), !t.visible && Fe(() => {
        de(ve);
      });
    }, z = (ve = [], Le) => {
      if (!rt(Le))
        return ve.indexOf(Le);
      const lt = e.valueKey;
      let ct = -1;
      return ve.some((mt, Mt) => Ct(Kt(mt, lt)) === Kt(Le, lt) ? (ct = Mt, !0) : !1), ct;
    }, Q = () => {
      t.softFocus = !0;
      const ve = l.value || s.value;
      ve && (ve == null || ve.focus());
    }, de = (ve) => {
      var Le, lt, ct, mt, Mt;
      const ln = Array.isArray(ve) ? ve[0] : ve;
      let $e = null;
      if (ln != null && ln.value) {
        const Ye = A.value.filter((_t) => _t.value === ln.value);
        Ye.length > 0 && ($e = Ye[0].$el);
      }
      if (u.value && $e) {
        const Ye = (mt = (ct = (lt = (Le = u.value) == null ? void 0 : Le.popperRef) == null ? void 0 : lt.contentRef) == null ? void 0 : ct.querySelector) == null ? void 0 : mt.call(ct, `.${r.be("dropdown", "wrap")}`);
        Ye && G1(Ye, $e);
      }
      (Mt = d.value) == null || Mt.handleScroll();
    }, Oe = (ve) => {
      t.optionsCount++, t.filteredOptionsCount++, t.options.set(ve.value, ve), t.cachedOptions.set(ve.value, ve);
    }, ae = (ve, Le) => {
      t.options.get(ve) === Le && (t.optionsCount--, t.filteredOptionsCount--, t.options.delete(ve));
    }, Ee = (ve) => {
      ve.code !== We.backspace && we(!1), t.inputLength = l.value.value.length * 15 + 20, x();
    }, we = (ve) => {
      if (!Array.isArray(t.selected))
        return;
      const Le = t.selected[t.selected.length - 1];
      if (!!Le)
        return ve === !0 || ve === !1 ? (Le.hitState = ve, ve) : (Le.hitState = !Le.hitState, Le.hitState);
    }, Se = (ve) => {
      const Le = ve.target.value;
      if (ve.type === "compositionend")
        t.isOnComposition = !1, Fe(() => N(Le));
      else {
        const lt = Le[Le.length - 1] || "";
        t.isOnComposition = !Kc(lt);
      }
    }, _e = () => {
      Fe(() => de(t.selected));
    }, ke = (ve) => {
      t.softFocus ? t.softFocus = !1 : ((e.automaticDropdown || e.filterable) && (e.filterable && !t.visible && (t.menuVisibleOnFocus = !0), t.visible = !0), n.emit("focus", ve));
    }, Re = () => {
      var ve, Le, lt;
      t.visible = !1, (ve = s.value) == null || ve.blur(), (lt = (Le = a.value) == null ? void 0 : Le.blur) == null || lt.call(Le);
    }, fe = (ve) => {
      Fe(() => {
        t.isSilentBlur ? t.isSilentBlur = !1 : n.emit("blur", ve);
      }), t.softFocus = !1;
    }, Ae = (ve) => {
      Te(ve);
    }, qe = () => {
      t.visible = !1;
    }, tt = (ve) => {
      t.visible && (ve.preventDefault(), ve.stopPropagation(), t.visible = !1);
    }, Je = (ve) => {
      var Le;
      ve && !t.mouseEnter || C.value || (t.menuVisibleOnFocus ? t.menuVisibleOnFocus = !1 : (!u.value || !u.value.isFocusInsideContent()) && (t.visible = !t.visible), t.visible && ((Le = l.value || s.value) == null || Le.focus()));
    }, ye = () => {
      t.visible ? A.value[t.hoverIndex] && Pe(A.value[t.hoverIndex], void 0) : Je();
    }, Ce = (ve) => rt(ve.value) ? Kt(ve.value, e.valueKey) : ve.value, ue = E(() => A.value.filter((ve) => ve.visible).every((ve) => ve.disabled)), q = E(() => t.selected.slice(0, e.maxCollapseTags)), oe = E(() => t.selected.slice(e.maxCollapseTags)), be = (ve) => {
      if (!t.visible) {
        t.visible = !0;
        return;
      }
      if (!(t.options.size === 0 || t.filteredOptionsCount === 0) && !t.isOnComposition && !ue.value) {
        ve === "next" ? (t.hoverIndex++, t.hoverIndex === t.options.size && (t.hoverIndex = 0)) : ve === "prev" && (t.hoverIndex--, t.hoverIndex < 0 && (t.hoverIndex = t.options.size - 1));
        const Le = A.value[t.hoverIndex];
        (Le.disabled === !0 || Le.states.groupDisabled === !0 || !Le.visible) && be(ve), Fe(() => de(p.value));
      }
    };
    return {
      optionList: v,
      optionsArray: A,
      selectSize: B,
      handleResize: Z,
      debouncedOnInputChange: ee,
      debouncedQueryChange: ne,
      deletePrevTag: re,
      deleteTag: ce,
      deleteSelected: Te,
      handleOptionSelect: Pe,
      scrollToOption: de,
      readonly: b,
      resetInputHeight: x,
      showClose: _,
      iconComponent: k,
      iconReverse: O,
      showNewOption: D,
      collapseTagSize: F,
      setSelected: j,
      managePlaceholder: R,
      selectDisabled: C,
      emptyText: P,
      toggleLastOptionHitState: we,
      resetInputState: Ee,
      handleComposition: Se,
      onOptionCreate: Oe,
      onOptionDestroy: ae,
      handleMenuEnter: _e,
      handleFocus: ke,
      blur: Re,
      handleBlur: fe,
      handleClearClick: Ae,
      handleClose: qe,
      handleKeydownEscape: tt,
      toggleMenu: Je,
      selectOption: ye,
      getValueKey: Ce,
      navigateOptions: be,
      dropMenuVisible: W,
      queryChange: h,
      groupQueryChange: m,
      showTagList: q,
      collapseTagList: oe,
      reference: s,
      input: l,
      iOSInput: a,
      tooltipRef: u,
      tags: c,
      selectWrapper: f,
      scrollbar: d,
      handleMouseEnter: () => {
        t.mouseEnter = !0;
      },
      handleMouseLeave: () => {
        t.mouseEnter = !1;
      }
    };
  };
  var eU = G({
    name: "ElOptions",
    emits: ["update-options"],
    setup(e, { slots: t, emit: n }) {
      let o = [];
      function r(s, l) {
        if (s.length !== l.length)
          return !1;
        for (const [a] of s.entries())
          if (s[a] != l[a])
            return !1;
        return !0;
      }
      return () => {
        var s, l;
        const a = (s = t.default) == null ? void 0 : s.call(t), u = [];
        function c(f) {
          !Array.isArray(f) || f.forEach((d) => {
            var p, h, m, v;
            const g = (p = (d == null ? void 0 : d.type) || {}) == null ? void 0 : p.name;
            g === "ElOptionGroup" ? c(!et(d.children) && !Array.isArray(d.children) && Ge((h = d.children) == null ? void 0 : h.default) ? (m = d.children) == null ? void 0 : m.default() : d.children) : g === "ElOption" ? u.push((v = d.props) == null ? void 0 : v.label) : Array.isArray(d.children) && c(d.children);
          });
        }
        return a.length && c((l = a[0]) == null ? void 0 : l.children), r(u, o) || (o = u, n("update-options", u)), a;
      };
    }
  });
  const wy = "ElSelect", tU = G({
    name: wy,
    componentName: wy,
    components: {
      ElInput: wn,
      ElSelectMenu: J7,
      ElOption: rv,
      ElOptions: eU,
      ElTag: Xa,
      ElScrollbar: pr,
      ElTooltip: Mn,
      ElIcon: He
    },
    directives: { ClickOutside: Kr },
    props: {
      name: String,
      id: String,
      modelValue: {
        type: [Array, String, Number, Boolean, Object],
        default: void 0
      },
      autocomplete: {
        type: String,
        default: "off"
      },
      automaticDropdown: Boolean,
      size: {
        type: String,
        validator: zc
      },
      effect: {
        type: String,
        default: "light"
      },
      disabled: Boolean,
      clearable: Boolean,
      filterable: Boolean,
      allowCreate: Boolean,
      loading: Boolean,
      popperClass: {
        type: String,
        default: ""
      },
      popperOptions: {
        type: Object,
        default: () => ({})
      },
      remote: Boolean,
      loadingText: String,
      noMatchText: String,
      noDataText: String,
      remoteMethod: Function,
      filterMethod: Function,
      multiple: Boolean,
      multipleLimit: {
        type: Number,
        default: 0
      },
      placeholder: {
        type: String
      },
      defaultFirstOption: Boolean,
      reserveKeyword: {
        type: Boolean,
        default: !0
      },
      valueKey: {
        type: String,
        default: "value"
      },
      collapseTags: Boolean,
      collapseTagsTooltip: {
        type: Boolean,
        default: !1
      },
      maxCollapseTags: {
        type: Number,
        default: 1
      },
      teleported: dn.teleported,
      persistent: {
        type: Boolean,
        default: !0
      },
      clearIcon: {
        type: Vt,
        default: Yr
      },
      fitInputWidth: {
        type: Boolean,
        default: !1
      },
      suffixIcon: {
        type: Vt,
        default: qr
      },
      tagType: { ...Gh.type, default: "info" },
      validateEvent: {
        type: Boolean,
        default: !0
      },
      remoteShowSuffix: {
        type: Boolean,
        default: !1
      },
      suffixTransition: {
        type: Boolean,
        default: !0
      },
      placement: {
        type: String,
        values: Bs,
        default: "bottom-start"
      }
    },
    emits: [
      dt,
      Ft,
      "remove-tag",
      "clear",
      "visible-change",
      "focus",
      "blur"
    ],
    setup(e, t) {
      const n = ge("select"), o = ge("input"), { t: r } = St(), s = Z7(e), {
        optionList: l,
        optionsArray: a,
        selectSize: u,
        readonly: c,
        handleResize: f,
        collapseTagSize: d,
        debouncedOnInputChange: p,
        debouncedQueryChange: h,
        deletePrevTag: m,
        deleteTag: v,
        deleteSelected: g,
        handleOptionSelect: y,
        scrollToOption: w,
        setSelected: b,
        resetInputHeight: C,
        managePlaceholder: _,
        showClose: k,
        selectDisabled: O,
        iconComponent: T,
        iconReverse: P,
        showNewOption: A,
        emptyText: L,
        toggleLastOptionHitState: D,
        resetInputState: B,
        handleComposition: F,
        onOptionCreate: W,
        onOptionDestroy: x,
        handleMenuEnter: N,
        handleFocus: R,
        blur: M,
        handleBlur: j,
        handleClearClick: te,
        handleClose: U,
        handleKeydownEscape: Z,
        toggleMenu: pe,
        selectOption: J,
        getValueKey: ee,
        navigateOptions: ne,
        dropMenuVisible: Y,
        reference: re,
        input: ce,
        iOSInput: Te,
        tooltipRef: Pe,
        tags: z,
        selectWrapper: Q,
        scrollbar: de,
        queryChange: Oe,
        groupQueryChange: ae,
        handleMouseEnter: Ee,
        handleMouseLeave: we,
        showTagList: Se,
        collapseTagList: _e
      } = Q7(e, s, t), { focus: ke } = yD(re), {
        inputWidth: Re,
        selected: fe,
        inputLength: Ae,
        filteredOptionsCount: qe,
        visible: tt,
        softFocus: Je,
        selectedLabel: ye,
        hoverIndex: Ce,
        query: ue,
        inputHovering: q,
        currentPlaceholder: oe,
        menuVisibleOnFocus: be,
        isOnComposition: xe,
        isSilentBlur: nt,
        options: ve,
        cachedOptions: Le,
        optionsCount: lt,
        prefixWidth: ct,
        tagInMultiLine: mt
      } = rn(s), Mt = E(() => {
        const kt = [n.b()], cn = i(u);
        return cn && kt.push(n.m(cn)), e.disabled && kt.push(n.m("disabled")), kt;
      }), ln = E(() => ({
        maxWidth: `${i(Re) - 32}px`,
        width: "100%"
      })), $e = E(() => ({ maxWidth: `${i(Re) > 123 ? i(Re) - 123 : i(Re) - 75}px` }));
      pt(ki, Tt({
        props: e,
        options: ve,
        optionsArray: a,
        cachedOptions: Le,
        optionsCount: lt,
        filteredOptionsCount: qe,
        hoverIndex: Ce,
        handleOptionSelect: y,
        onOptionCreate: W,
        onOptionDestroy: x,
        selectWrapper: Q,
        selected: fe,
        setSelected: b,
        queryChange: Oe,
        groupQueryChange: ae
      })), st(() => {
        s.cachedPlaceHolder = oe.value = e.placeholder || (() => r("el.select.placeholder")), e.multiple && Array.isArray(e.modelValue) && e.modelValue.length > 0 && (oe.value = ""), Cn(Q, f), e.remote && e.multiple && C(), Fe(() => {
          const kt = re.value && re.value.$el;
          if (!!kt && (Re.value = kt.getBoundingClientRect().width, t.slots.prefix)) {
            const cn = kt.querySelector(`.${o.e("prefix")}`);
            ct.value = Math.max(cn.getBoundingClientRect().width + 5, 30);
          }
        }), b();
      }), e.multiple && !Array.isArray(e.modelValue) && t.emit(dt, []), !e.multiple && Array.isArray(e.modelValue) && t.emit(dt, "");
      const Ye = E(() => {
        var kt, cn;
        return (cn = (kt = Pe.value) == null ? void 0 : kt.popperRef) == null ? void 0 : cn.contentRef;
      });
      return {
        isIOS: a1,
        onOptionsRendered: (kt) => {
          l.value = kt;
        },
        tagInMultiLine: mt,
        prefixWidth: ct,
        selectSize: u,
        readonly: c,
        handleResize: f,
        collapseTagSize: d,
        debouncedOnInputChange: p,
        debouncedQueryChange: h,
        deletePrevTag: m,
        deleteTag: v,
        deleteSelected: g,
        handleOptionSelect: y,
        scrollToOption: w,
        inputWidth: Re,
        selected: fe,
        inputLength: Ae,
        filteredOptionsCount: qe,
        visible: tt,
        softFocus: Je,
        selectedLabel: ye,
        hoverIndex: Ce,
        query: ue,
        inputHovering: q,
        currentPlaceholder: oe,
        menuVisibleOnFocus: be,
        isOnComposition: xe,
        isSilentBlur: nt,
        options: ve,
        resetInputHeight: C,
        managePlaceholder: _,
        showClose: k,
        selectDisabled: O,
        iconComponent: T,
        iconReverse: P,
        showNewOption: A,
        emptyText: L,
        toggleLastOptionHitState: D,
        resetInputState: B,
        handleComposition: F,
        handleMenuEnter: N,
        handleFocus: R,
        blur: M,
        handleBlur: j,
        handleClearClick: te,
        handleClose: U,
        handleKeydownEscape: Z,
        toggleMenu: pe,
        selectOption: J,
        getValueKey: ee,
        navigateOptions: ne,
        dropMenuVisible: Y,
        focus: ke,
        reference: re,
        input: ce,
        iOSInput: Te,
        tooltipRef: Pe,
        popperPaneRef: Ye,
        tags: z,
        selectWrapper: Q,
        scrollbar: de,
        wrapperKls: Mt,
        selectTagsStyle: ln,
        nsSelect: n,
        tagTextStyle: $e,
        handleMouseEnter: Ee,
        handleMouseLeave: we,
        showTagList: Se,
        collapseTagList: _e
      };
    }
  }), nU = ["disabled", "autocomplete"], oU = ["disabled"], rU = { style: { height: "100%", display: "flex", "justify-content": "center", "align-items": "center" } };
  function sU(e, t, n, o, r, s) {
    const l = Qe("el-tag"), a = Qe("el-tooltip"), u = Qe("el-icon"), c = Qe("el-input"), f = Qe("el-option"), d = Qe("el-options"), p = Qe("el-scrollbar"), h = Qe("el-select-menu"), m = Aa("click-outside");
    return ot((S(), V("div", {
      ref: "selectWrapper",
      class: $(e.wrapperKls),
      onMouseenter: t[21] || (t[21] = (...v) => e.handleMouseEnter && e.handleMouseEnter(...v)),
      onMouseleave: t[22] || (t[22] = (...v) => e.handleMouseLeave && e.handleMouseLeave(...v)),
      onClick: t[23] || (t[23] = Ze((...v) => e.toggleMenu && e.toggleMenu(...v), ["stop"]))
    }, [
      K(a, {
        ref: "tooltipRef",
        visible: e.dropMenuVisible,
        placement: e.placement,
        teleported: e.teleported,
        "popper-class": [e.nsSelect.e("popper"), e.popperClass],
        "popper-options": e.popperOptions,
        "fallback-placements": ["bottom-start", "top-start", "right", "left"],
        effect: e.effect,
        pure: "",
        trigger: "click",
        transition: `${e.nsSelect.namespace.value}-zoom-in-top`,
        "stop-popper-mouse-event": !1,
        "gpu-acceleration": !1,
        persistent: e.persistent,
        onShow: e.handleMenuEnter
      }, {
        default: X(() => [
          H("div", {
            class: "select-trigger",
            onMouseenter: t[19] || (t[19] = (v) => e.inputHovering = !0),
            onMouseleave: t[20] || (t[20] = (v) => e.inputHovering = !1)
          }, [
            e.multiple ? (S(), V("div", {
              key: 0,
              ref: "tags",
              class: $([
                e.nsSelect.e("tags"),
                e.nsSelect.is("disabled", e.selectDisabled)
              ]),
              style: Ke(e.selectTagsStyle)
            }, [
              e.collapseTags && e.selected.length ? (S(), ie(Qt, {
                key: 0,
                onAfterLeave: e.resetInputHeight
              }, {
                default: X(() => [
                  H("span", {
                    class: $([
                      e.nsSelect.b("tags-wrapper"),
                      { "has-prefix": e.prefixWidth && e.selected.length }
                    ])
                  }, [
                    (S(!0), V(ze, null, gt(e.showTagList, (v) => (S(), ie(l, {
                      key: e.getValueKey(v),
                      closable: !e.selectDisabled && !v.isDisabled,
                      size: e.collapseTagSize,
                      hit: v.hitState,
                      type: e.tagType,
                      "disable-transitions": "",
                      onClose: (g) => e.deleteTag(g, v)
                    }, {
                      default: X(() => [
                        H("span", {
                          class: $(e.nsSelect.e("tags-text")),
                          style: Ke(e.tagTextStyle)
                        }, Ne(v.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128)),
                    e.selected.length > e.maxCollapseTags ? (S(), ie(l, {
                      key: 0,
                      closable: !1,
                      size: e.collapseTagSize,
                      type: e.tagType,
                      "disable-transitions": ""
                    }, {
                      default: X(() => [
                        e.collapseTagsTooltip ? (S(), ie(a, {
                          key: 0,
                          disabled: e.dropMenuVisible,
                          "fallback-placements": ["bottom", "top", "right", "left"],
                          effect: e.effect,
                          placement: "bottom",
                          teleported: e.teleported
                        }, {
                          default: X(() => [
                            H("span", {
                              class: $(e.nsSelect.e("tags-text"))
                            }, "+ " + Ne(e.selected.length - e.maxCollapseTags), 3)
                          ]),
                          content: X(() => [
                            H("div", {
                              class: $(e.nsSelect.e("collapse-tags"))
                            }, [
                              (S(!0), V(ze, null, gt(e.collapseTagList, (v) => (S(), V("div", {
                                key: e.getValueKey(v),
                                class: $(e.nsSelect.e("collapse-tag"))
                              }, [
                                K(l, {
                                  class: "in-tooltip",
                                  closable: !e.selectDisabled && !v.isDisabled,
                                  size: e.collapseTagSize,
                                  hit: v.hitState,
                                  type: e.tagType,
                                  "disable-transitions": "",
                                  style: { margin: "2px" },
                                  onClose: (g) => e.deleteTag(g, v)
                                }, {
                                  default: X(() => [
                                    H("span", {
                                      class: $(e.nsSelect.e("tags-text")),
                                      style: Ke({
                                        maxWidth: e.inputWidth - 75 + "px"
                                      })
                                    }, Ne(v.currentLabel), 7)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "hit", "type", "onClose"])
                              ], 2))), 128))
                            ], 2)
                          ]),
                          _: 1
                        }, 8, ["disabled", "effect", "teleported"])) : (S(), V("span", {
                          key: 1,
                          class: $(e.nsSelect.e("tags-text"))
                        }, "+ " + Ne(e.selected.length - e.maxCollapseTags), 3))
                      ]),
                      _: 1
                    }, 8, ["size", "type"])) : se("v-if", !0)
                  ], 2)
                ]),
                _: 1
              }, 8, ["onAfterLeave"])) : se("v-if", !0),
              e.collapseTags ? se("v-if", !0) : (S(), ie(Qt, {
                key: 1,
                onAfterLeave: e.resetInputHeight
              }, {
                default: X(() => [
                  H("span", {
                    class: $([
                      e.nsSelect.b("tags-wrapper"),
                      { "has-prefix": e.prefixWidth && e.selected.length }
                    ])
                  }, [
                    (S(!0), V(ze, null, gt(e.selected, (v) => (S(), ie(l, {
                      key: e.getValueKey(v),
                      closable: !e.selectDisabled && !v.isDisabled,
                      size: e.collapseTagSize,
                      hit: v.hitState,
                      type: e.tagType,
                      "disable-transitions": "",
                      onClose: (g) => e.deleteTag(g, v)
                    }, {
                      default: X(() => [
                        H("span", {
                          class: $(e.nsSelect.e("tags-text")),
                          style: Ke({ maxWidth: e.inputWidth - 75 + "px" })
                        }, Ne(v.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128))
                  ], 2)
                ]),
                _: 1
              }, 8, ["onAfterLeave"])),
              e.filterable ? ot((S(), V("input", {
                key: 2,
                ref: "input",
                "onUpdate:modelValue": t[0] || (t[0] = (v) => e.query = v),
                type: "text",
                class: $([
                  e.nsSelect.e("input"),
                  e.nsSelect.is(e.selectSize),
                  e.nsSelect.is("disabled", e.selectDisabled)
                ]),
                disabled: e.selectDisabled,
                autocomplete: e.autocomplete,
                style: Ke({
                  marginLeft: e.prefixWidth && !e.selected.length || e.tagInMultiLine ? `${e.prefixWidth}px` : "",
                  flexGrow: 1,
                  width: `${e.inputLength / (e.inputWidth - 32)}%`,
                  maxWidth: `${e.inputWidth - 42}px`
                }),
                onFocus: t[1] || (t[1] = (...v) => e.handleFocus && e.handleFocus(...v)),
                onBlur: t[2] || (t[2] = (...v) => e.handleBlur && e.handleBlur(...v)),
                onKeyup: t[3] || (t[3] = (...v) => e.managePlaceholder && e.managePlaceholder(...v)),
                onKeydown: [
                  t[4] || (t[4] = (...v) => e.resetInputState && e.resetInputState(...v)),
                  t[5] || (t[5] = Et(Ze((v) => e.navigateOptions("next"), ["prevent"]), ["down"])),
                  t[6] || (t[6] = Et(Ze((v) => e.navigateOptions("prev"), ["prevent"]), ["up"])),
                  t[7] || (t[7] = Et((...v) => e.handleKeydownEscape && e.handleKeydownEscape(...v), ["esc"])),
                  t[8] || (t[8] = Et(Ze((...v) => e.selectOption && e.selectOption(...v), ["stop", "prevent"]), ["enter"])),
                  t[9] || (t[9] = Et((...v) => e.deletePrevTag && e.deletePrevTag(...v), ["delete"])),
                  t[10] || (t[10] = Et((v) => e.visible = !1, ["tab"]))
                ],
                onCompositionstart: t[11] || (t[11] = (...v) => e.handleComposition && e.handleComposition(...v)),
                onCompositionupdate: t[12] || (t[12] = (...v) => e.handleComposition && e.handleComposition(...v)),
                onCompositionend: t[13] || (t[13] = (...v) => e.handleComposition && e.handleComposition(...v)),
                onInput: t[14] || (t[14] = (...v) => e.debouncedQueryChange && e.debouncedQueryChange(...v))
              }, null, 46, nU)), [
                [th, e.query]
              ]) : se("v-if", !0)
            ], 6)) : se("v-if", !0),
            se(" fix: https://github.com/element-plus/element-plus/issues/11415 "),
            e.isIOS && !e.multiple && e.filterable && e.readonly ? (S(), V("input", {
              key: 1,
              ref: "iOSInput",
              class: $([
                e.nsSelect.e("input"),
                e.nsSelect.is(e.selectSize),
                e.nsSelect.em("input", "iOS")
              ]),
              disabled: e.selectDisabled,
              type: "text"
            }, null, 10, oU)) : se("v-if", !0),
            K(c, {
              id: e.id,
              ref: "reference",
              modelValue: e.selectedLabel,
              "onUpdate:modelValue": t[15] || (t[15] = (v) => e.selectedLabel = v),
              type: "text",
              placeholder: typeof e.currentPlaceholder == "function" ? e.currentPlaceholder() : e.currentPlaceholder,
              name: e.name,
              autocomplete: e.autocomplete,
              size: e.selectSize,
              disabled: e.selectDisabled,
              readonly: e.readonly,
              "validate-event": !1,
              class: $([e.nsSelect.is("focus", e.visible)]),
              tabindex: e.multiple && e.filterable ? -1 : void 0,
              onFocus: e.handleFocus,
              onBlur: e.handleBlur,
              onInput: e.debouncedOnInputChange,
              onPaste: e.debouncedOnInputChange,
              onCompositionstart: e.handleComposition,
              onCompositionupdate: e.handleComposition,
              onCompositionend: e.handleComposition,
              onKeydown: [
                t[16] || (t[16] = Et(Ze((v) => e.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                t[17] || (t[17] = Et(Ze((v) => e.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                Et(Ze(e.selectOption, ["stop", "prevent"]), ["enter"]),
                Et(e.handleKeydownEscape, ["esc"]),
                t[18] || (t[18] = Et((v) => e.visible = !1, ["tab"]))
              ]
            }, lr({
              suffix: X(() => [
                e.iconComponent && !e.showClose ? (S(), ie(u, {
                  key: 0,
                  class: $([e.nsSelect.e("caret"), e.nsSelect.e("icon"), e.iconReverse])
                }, {
                  default: X(() => [
                    (S(), ie(vt(e.iconComponent)))
                  ]),
                  _: 1
                }, 8, ["class"])) : se("v-if", !0),
                e.showClose && e.clearIcon ? (S(), ie(u, {
                  key: 1,
                  class: $([e.nsSelect.e("caret"), e.nsSelect.e("icon")]),
                  onClick: e.handleClearClick
                }, {
                  default: X(() => [
                    (S(), ie(vt(e.clearIcon)))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : se("v-if", !0)
              ]),
              _: 2
            }, [
              e.$slots.prefix ? {
                name: "prefix",
                fn: X(() => [
                  H("div", rU, [
                    he(e.$slots, "prefix")
                  ])
                ])
              } : void 0
            ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
          ], 32)
        ]),
        content: X(() => [
          K(h, null, {
            default: X(() => [
              ot(K(p, {
                ref: "scrollbar",
                tag: "ul",
                "wrap-class": e.nsSelect.be("dropdown", "wrap"),
                "view-class": e.nsSelect.be("dropdown", "list"),
                class: $([
                  e.nsSelect.is("empty", !e.allowCreate && Boolean(e.query) && e.filteredOptionsCount === 0)
                ])
              }, {
                default: X(() => [
                  e.showNewOption ? (S(), ie(f, {
                    key: 0,
                    value: e.query,
                    created: !0
                  }, null, 8, ["value"])) : se("v-if", !0),
                  K(d, { onUpdateOptions: e.onOptionsRendered }, {
                    default: X(() => [
                      he(e.$slots, "default")
                    ]),
                    _: 3
                  }, 8, ["onUpdateOptions"])
                ]),
                _: 3
              }, 8, ["wrap-class", "view-class", "class"]), [
                [$t, e.options.size > 0 && !e.loading]
              ]),
              e.emptyText && (!e.allowCreate || e.loading || e.allowCreate && e.options.size === 0) ? (S(), V(ze, { key: 0 }, [
                e.$slots.empty ? he(e.$slots, "empty", { key: 0 }) : (S(), V("p", {
                  key: 1,
                  class: $(e.nsSelect.be("dropdown", "empty"))
                }, Ne(e.emptyText), 3))
              ], 64)) : se("v-if", !0)
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onShow"])
    ], 34)), [
      [m, e.handleClose, e.popperPaneRef]
    ]);
  }
  var lU = /* @__PURE__ */ Me(tU, [["render", sU], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
  const aU = G({
    name: "ElOptionGroup",
    componentName: "ElOptionGroup",
    props: {
      label: String,
      disabled: {
        type: Boolean,
        default: !1
      }
    },
    setup(e) {
      const t = ge("select"), n = I(!0), o = it(), r = I([]);
      pt(BE, Tt({
        ...rn(e)
      }));
      const s = Be(ki);
      st(() => {
        r.value = l(o.subTree);
      });
      const l = (u) => {
        const c = [];
        return Array.isArray(u.children) && u.children.forEach((f) => {
          var d;
          f.type && f.type.name === "ElOption" && f.component && f.component.proxy ? c.push(f.component.proxy) : (d = f.children) != null && d.length && c.push(...l(f));
        }), c;
      }, { groupQueryChange: a } = Ct(s);
      return me(a, () => {
        n.value = r.value.some((u) => u.visible === !0);
      }, { flush: "post" }), {
        visible: n,
        ns: t
      };
    }
  });
  function iU(e, t, n, o, r, s) {
    return ot((S(), V("ul", {
      class: $(e.ns.be("group", "wrap"))
    }, [
      H("li", {
        class: $(e.ns.be("group", "title"))
      }, Ne(e.label), 3),
      H("li", null, [
        H("ul", {
          class: $(e.ns.b("group"))
        }, [
          he(e.$slots, "default")
        ], 2)
      ])
    ], 2)), [
      [$t, e.visible]
    ]);
  }
  var FE = /* @__PURE__ */ Me(aU, [["render", iU], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
  const Ps = ut(lU, {
    Option: rv,
    OptionGroup: FE
  }), oc = Gt(rv), uU = Gt(FE), sv = () => Be(VE, {}), cU = Ie({
    pageSize: {
      type: Number,
      required: !0
    },
    pageSizes: {
      type: le(Array),
      default: () => jt([10, 20, 30, 40, 50, 100])
    },
    popperClass: {
      type: String
    },
    disabled: Boolean,
    size: {
      type: String,
      values: zo
    }
  }), dU = G({
    name: "ElPaginationSizes"
  }), fU = /* @__PURE__ */ G({
    ...dU,
    props: cU,
    emits: ["page-size-change"],
    setup(e, { emit: t }) {
      const n = e, { t: o } = St(), r = ge("pagination"), s = sv(), l = I(n.pageSize);
      me(() => n.pageSizes, (c, f) => {
        if (!qn(c, f) && Array.isArray(c)) {
          const d = c.includes(n.pageSize) ? n.pageSize : n.pageSizes[0];
          t("page-size-change", d);
        }
      }), me(() => n.pageSize, (c) => {
        l.value = c;
      });
      const a = E(() => n.pageSizes);
      function u(c) {
        var f;
        c !== l.value && (l.value = c, (f = s.handleSizeChange) == null || f.call(s, Number(c)));
      }
      return (c, f) => (S(), V("span", {
        class: $(i(r).e("sizes"))
      }, [
        K(i(Ps), {
          "model-value": l.value,
          disabled: c.disabled,
          "popper-class": c.popperClass,
          size: c.size,
          "validate-event": !1,
          onChange: u
        }, {
          default: X(() => [
            (S(!0), V(ze, null, gt(i(a), (d) => (S(), ie(i(oc), {
              key: d,
              value: d,
              label: d + i(o)("el.pagination.pagesize")
            }, null, 8, ["value", "label"]))), 128))
          ]),
          _: 1
        }, 8, ["model-value", "disabled", "popper-class", "size"])
      ], 2));
    }
  });
  var pU = /* @__PURE__ */ Me(fU, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/sizes.vue"]]);
  const hU = Ie({
    size: {
      type: String,
      values: zo
    }
  }), vU = ["disabled"], mU = G({
    name: "ElPaginationJumper"
  }), gU = /* @__PURE__ */ G({
    ...mU,
    props: hU,
    setup(e) {
      const { t } = St(), n = ge("pagination"), { pageCount: o, disabled: r, currentPage: s, changeEvent: l } = sv(), a = I(), u = E(() => {
        var d;
        return (d = a.value) != null ? d : s == null ? void 0 : s.value;
      });
      function c(d) {
        a.value = d ? +d : "";
      }
      function f(d) {
        d = Math.trunc(+d), l == null || l(d), a.value = void 0;
      }
      return (d, p) => (S(), V("span", {
        class: $(i(n).e("jump")),
        disabled: i(r)
      }, [
        H("span", {
          class: $([i(n).e("goto")])
        }, Ne(i(t)("el.pagination.goto")), 3),
        K(i(wn), {
          size: d.size,
          class: $([i(n).e("editor"), i(n).is("in-pagination")]),
          min: 1,
          max: i(o),
          disabled: i(r),
          "model-value": i(u),
          "validate-event": !1,
          label: i(t)("el.pagination.page"),
          type: "number",
          "onUpdate:modelValue": c,
          onChange: f
        }, null, 8, ["size", "class", "max", "disabled", "model-value", "label"]),
        H("span", {
          class: $([i(n).e("classifier")])
        }, Ne(i(t)("el.pagination.pageClassifier")), 3)
      ], 10, vU));
    }
  });
  var yU = /* @__PURE__ */ Me(gU, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/jumper.vue"]]);
  const bU = Ie({
    total: {
      type: Number,
      default: 1e3
    }
  }), wU = ["disabled"], CU = G({
    name: "ElPaginationTotal"
  }), EU = /* @__PURE__ */ G({
    ...CU,
    props: bU,
    setup(e) {
      const { t } = St(), n = ge("pagination"), { disabled: o } = sv();
      return (r, s) => (S(), V("span", {
        class: $(i(n).e("total")),
        disabled: i(o)
      }, Ne(i(t)("el.pagination.total", {
        total: r.total
      })), 11, wU));
    }
  });
  var SU = /* @__PURE__ */ Me(EU, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/total.vue"]]);
  const _U = Ie({
    currentPage: {
      type: Number,
      default: 1
    },
    pageCount: {
      type: Number,
      required: !0
    },
    pagerCount: {
      type: Number,
      default: 7
    },
    disabled: Boolean
  }), kU = ["onKeyup"], $U = ["aria-current", "aria-label", "tabindex"], NU = ["tabindex", "aria-label"], TU = ["aria-current", "aria-label", "tabindex"], OU = ["tabindex", "aria-label"], MU = ["aria-current", "aria-label", "tabindex"], IU = G({
    name: "ElPaginationPager"
  }), PU = /* @__PURE__ */ G({
    ...IU,
    props: _U,
    emits: ["change"],
    setup(e, { emit: t }) {
      const n = e, o = ge("pager"), r = ge("icon"), { t: s } = St(), l = I(!1), a = I(!1), u = I(!1), c = I(!1), f = I(!1), d = I(!1), p = E(() => {
        const w = n.pagerCount, b = (w - 1) / 2, C = Number(n.currentPage), _ = Number(n.pageCount);
        let k = !1, O = !1;
        _ > w && (C > w - b && (k = !0), C < _ - b && (O = !0));
        const T = [];
        if (k && !O) {
          const P = _ - (w - 2);
          for (let A = P; A < _; A++)
            T.push(A);
        } else if (!k && O)
          for (let P = 2; P < w; P++)
            T.push(P);
        else if (k && O) {
          const P = Math.floor(w / 2) - 1;
          for (let A = C - P; A <= C + P; A++)
            T.push(A);
        } else
          for (let P = 2; P < _; P++)
            T.push(P);
        return T;
      }), h = E(() => n.disabled ? -1 : 0);
      xn(() => {
        const w = (n.pagerCount - 1) / 2;
        l.value = !1, a.value = !1, n.pageCount > n.pagerCount && (n.currentPage > n.pagerCount - w && (l.value = !0), n.currentPage < n.pageCount - w && (a.value = !0));
      });
      function m(w = !1) {
        n.disabled || (w ? u.value = !0 : c.value = !0);
      }
      function v(w = !1) {
        w ? f.value = !0 : d.value = !0;
      }
      function g(w) {
        const b = w.target;
        if (b.tagName.toLowerCase() === "li" && Array.from(b.classList).includes("number")) {
          const C = Number(b.textContent);
          C !== n.currentPage && t("change", C);
        } else
          b.tagName.toLowerCase() === "li" && Array.from(b.classList).includes("more") && y(w);
      }
      function y(w) {
        const b = w.target;
        if (b.tagName.toLowerCase() === "ul" || n.disabled)
          return;
        let C = Number(b.textContent);
        const _ = n.pageCount, k = n.currentPage, O = n.pagerCount - 2;
        b.className.includes("more") && (b.className.includes("quickprev") ? C = k - O : b.className.includes("quicknext") && (C = k + O)), Number.isNaN(+C) || (C < 1 && (C = 1), C > _ && (C = _)), C !== k && t("change", C);
      }
      return (w, b) => (S(), V("ul", {
        class: $(i(o).b()),
        onClick: y,
        onKeyup: Et(g, ["enter"])
      }, [
        w.pageCount > 0 ? (S(), V("li", {
          key: 0,
          class: $([[
            i(o).is("active", w.currentPage === 1),
            i(o).is("disabled", w.disabled)
          ], "number"]),
          "aria-current": w.currentPage === 1,
          "aria-label": i(s)("el.pagination.currentPage", { pager: 1 }),
          tabindex: i(h)
        }, " 1 ", 10, $U)) : se("v-if", !0),
        l.value ? (S(), V("li", {
          key: 1,
          class: $([
            "more",
            "btn-quickprev",
            i(r).b(),
            i(o).is("disabled", w.disabled)
          ]),
          tabindex: i(h),
          "aria-label": i(s)("el.pagination.prevPages", { pager: w.pagerCount - 2 }),
          onMouseenter: b[0] || (b[0] = (C) => m(!0)),
          onMouseleave: b[1] || (b[1] = (C) => u.value = !1),
          onFocus: b[2] || (b[2] = (C) => v(!0)),
          onBlur: b[3] || (b[3] = (C) => f.value = !1)
        }, [
          (u.value || f.value) && !w.disabled ? (S(), ie(i($l), { key: 0 })) : (S(), ie(i(dg), { key: 1 }))
        ], 42, NU)) : se("v-if", !0),
        (S(!0), V(ze, null, gt(i(p), (C) => (S(), V("li", {
          key: C,
          class: $([[
            i(o).is("active", w.currentPage === C),
            i(o).is("disabled", w.disabled)
          ], "number"]),
          "aria-current": w.currentPage === C,
          "aria-label": i(s)("el.pagination.currentPage", { pager: C }),
          tabindex: i(h)
        }, Ne(C), 11, TU))), 128)),
        a.value ? (S(), V("li", {
          key: 2,
          class: $([
            "more",
            "btn-quicknext",
            i(r).b(),
            i(o).is("disabled", w.disabled)
          ]),
          tabindex: i(h),
          "aria-label": i(s)("el.pagination.nextPages", { pager: w.pagerCount - 2 }),
          onMouseenter: b[4] || (b[4] = (C) => m()),
          onMouseleave: b[5] || (b[5] = (C) => c.value = !1),
          onFocus: b[6] || (b[6] = (C) => v()),
          onBlur: b[7] || (b[7] = (C) => d.value = !1)
        }, [
          (c.value || d.value) && !w.disabled ? (S(), ie(i(Nl), { key: 0 })) : (S(), ie(i(dg), { key: 1 }))
        ], 42, OU)) : se("v-if", !0),
        w.pageCount > 1 ? (S(), V("li", {
          key: 3,
          class: $([[
            i(o).is("active", w.currentPage === w.pageCount),
            i(o).is("disabled", w.disabled)
          ], "number"]),
          "aria-current": w.currentPage === w.pageCount,
          "aria-label": i(s)("el.pagination.currentPage", { pager: w.pageCount }),
          tabindex: i(h)
        }, Ne(w.pageCount), 11, MU)) : se("v-if", !0)
      ], 42, kU));
    }
  });
  var AU = /* @__PURE__ */ Me(PU, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/pager.vue"]]);
  const En = (e) => typeof e != "number", RU = Ie({
    total: Number,
    pageSize: Number,
    defaultPageSize: Number,
    currentPage: Number,
    defaultCurrentPage: Number,
    pageCount: Number,
    pagerCount: {
      type: Number,
      validator: (e) => Xe(e) && Math.trunc(e) === e && e > 4 && e < 22 && e % 2 === 1,
      default: 7
    },
    layout: {
      type: String,
      default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
    },
    pageSizes: {
      type: le(Array),
      default: () => jt([10, 20, 30, 40, 50, 100])
    },
    popperClass: {
      type: String,
      default: ""
    },
    prevText: {
      type: String,
      default: ""
    },
    prevIcon: {
      type: Vt,
      default: () => Br
    },
    nextText: {
      type: String,
      default: ""
    },
    nextIcon: {
      type: Vt,
      default: () => kn
    },
    small: Boolean,
    background: Boolean,
    disabled: Boolean,
    hideOnSinglePage: Boolean
  }), xU = {
    "update:current-page": (e) => Xe(e),
    "update:page-size": (e) => Xe(e),
    "size-change": (e) => Xe(e),
    "current-change": (e) => Xe(e),
    "prev-click": (e) => Xe(e),
    "next-click": (e) => Xe(e)
  }, Cy = "ElPagination";
  var DU = G({
    name: Cy,
    props: RU,
    emits: xU,
    setup(e, { emit: t, slots: n }) {
      const { t: o } = St(), r = ge("pagination"), s = it().vnode.props || {}, l = "onUpdate:currentPage" in s || "onUpdate:current-page" in s || "onCurrentChange" in s, a = "onUpdate:pageSize" in s || "onUpdate:page-size" in s || "onSizeChange" in s, u = E(() => {
        if (En(e.total) && En(e.pageCount) || !En(e.currentPage) && !l)
          return !1;
        if (e.layout.includes("sizes")) {
          if (En(e.pageCount)) {
            if (!En(e.total) && !En(e.pageSize) && !a)
              return !1;
          } else if (!a)
            return !1;
        }
        return !0;
      }), c = I(En(e.defaultPageSize) ? 10 : e.defaultPageSize), f = I(En(e.defaultCurrentPage) ? 1 : e.defaultCurrentPage), d = E({
        get() {
          return En(e.pageSize) ? c.value : e.pageSize;
        },
        set(b) {
          En(e.pageSize) && (c.value = b), a && (t("update:page-size", b), t("size-change", b));
        }
      }), p = E(() => {
        let b = 0;
        return En(e.pageCount) ? En(e.total) || (b = Math.max(1, Math.ceil(e.total / d.value))) : b = e.pageCount, b;
      }), h = E({
        get() {
          return En(e.currentPage) ? f.value : e.currentPage;
        },
        set(b) {
          let C = b;
          b < 1 ? C = 1 : b > p.value && (C = p.value), En(e.currentPage) && (f.value = C), l && (t("update:current-page", C), t("current-change", C));
        }
      });
      me(p, (b) => {
        h.value > b && (h.value = b);
      });
      function m(b) {
        h.value = b;
      }
      function v(b) {
        d.value = b;
        const C = p.value;
        h.value > C && (h.value = C);
      }
      function g() {
        e.disabled || (h.value -= 1, t("prev-click", h.value));
      }
      function y() {
        e.disabled || (h.value += 1, t("next-click", h.value));
      }
      function w(b, C) {
        b && (b.props || (b.props = {}), b.props.class = [b.props.class, C].join(" "));
      }
      return pt(VE, {
        pageCount: p,
        disabled: E(() => e.disabled),
        currentPage: h,
        changeEvent: m,
        handleSizeChange: v
      }), () => {
        var b, C;
        if (!u.value)
          return yt(Cy, o("el.pagination.deprecationWarning")), null;
        if (!e.layout || e.hideOnSinglePage && p.value <= 1)
          return null;
        const _ = [], k = [], O = je("div", { class: r.e("rightwrapper") }, k), T = {
          prev: je(B7, {
            disabled: e.disabled,
            currentPage: h.value,
            prevText: e.prevText,
            prevIcon: e.prevIcon,
            onClick: g
          }),
          jumper: je(yU, {
            size: e.small ? "small" : "default"
          }),
          pager: je(AU, {
            currentPage: h.value,
            pageCount: p.value,
            pagerCount: e.pagerCount,
            onChange: m,
            disabled: e.disabled
          }),
          next: je(W7, {
            disabled: e.disabled,
            currentPage: h.value,
            pageCount: p.value,
            nextText: e.nextText,
            nextIcon: e.nextIcon,
            onClick: y
          }),
          sizes: je(pU, {
            pageSize: d.value,
            pageSizes: e.pageSizes,
            popperClass: e.popperClass,
            disabled: e.disabled,
            size: e.small ? "small" : "default"
          }),
          slot: (C = (b = n == null ? void 0 : n.default) == null ? void 0 : b.call(n)) != null ? C : null,
          total: je(SU, { total: En(e.total) ? 0 : e.total })
        }, P = e.layout.split(",").map((L) => L.trim());
        let A = !1;
        return P.forEach((L) => {
          if (L === "->") {
            A = !0;
            return;
          }
          A ? k.push(T[L]) : _.push(T[L]);
        }), w(_[0], r.is("first")), w(_[_.length - 1], r.is("last")), A && k.length > 0 && (w(k[0], r.is("first")), w(k[k.length - 1], r.is("last")), _.push(O)), je("div", {
          class: [
            r.b(),
            r.is("background", e.background),
            {
              [r.m("small")]: e.small
            }
          ]
        }, _);
      };
    }
  });
  const LU = ut(DU), VU = Ie({
    title: String,
    confirmButtonText: String,
    cancelButtonText: String,
    confirmButtonType: {
      type: String,
      values: Bf,
      default: "primary"
    },
    cancelButtonType: {
      type: String,
      values: Bf,
      default: "text"
    },
    icon: {
      type: Vt,
      default: () => BR
    },
    iconColor: {
      type: String,
      default: "#f90"
    },
    hideIcon: {
      type: Boolean,
      default: !1
    },
    hideAfter: {
      type: Number,
      default: 200
    },
    teleported: dn.teleported,
    persistent: dn.persistent,
    width: {
      type: [String, Number],
      default: 150
    }
  }), BU = {
    confirm: (e) => e instanceof MouseEvent,
    cancel: (e) => e instanceof MouseEvent
  }, FU = G({
    name: "ElPopconfirm"
  }), HU = /* @__PURE__ */ G({
    ...FU,
    props: VU,
    emits: BU,
    setup(e, { emit: t }) {
      const n = e, { t: o } = St(), r = ge("popconfirm"), s = I(), l = () => {
        var p, h;
        (h = (p = s.value) == null ? void 0 : p.onClose) == null || h.call(p);
      }, a = E(() => ({
        width: Jt(n.width)
      })), u = (p) => {
        t("confirm", p), l();
      }, c = (p) => {
        t("cancel", p), l();
      }, f = E(() => n.confirmButtonText || o("el.popconfirm.confirmButtonText")), d = E(() => n.cancelButtonText || o("el.popconfirm.cancelButtonText"));
      return (p, h) => (S(), ie(i(Mn), ft({
        ref_key: "tooltipRef",
        ref: s,
        trigger: "click",
        effect: "light"
      }, p.$attrs, {
        "popper-class": `${i(r).namespace.value}-popover`,
        "popper-style": i(a),
        teleported: p.teleported,
        "fallback-placements": ["bottom", "top", "right", "left"],
        "hide-after": p.hideAfter,
        persistent: p.persistent
      }), {
        content: X(() => [
          H("div", {
            class: $(i(r).b())
          }, [
            H("div", {
              class: $(i(r).e("main"))
            }, [
              !p.hideIcon && p.icon ? (S(), ie(i(He), {
                key: 0,
                class: $(i(r).e("icon")),
                style: Ke({ color: p.iconColor })
              }, {
                default: X(() => [
                  (S(), ie(vt(p.icon)))
                ]),
                _: 1
              }, 8, ["class", "style"])) : se("v-if", !0),
              wt(" " + Ne(p.title), 1)
            ], 2),
            H("div", {
              class: $(i(r).e("action"))
            }, [
              K(i(gn), {
                size: "small",
                type: p.cancelButtonType === "text" ? "" : p.cancelButtonType,
                text: p.cancelButtonType === "text",
                onClick: c
              }, {
                default: X(() => [
                  wt(Ne(i(d)), 1)
                ]),
                _: 1
              }, 8, ["type", "text"]),
              K(i(gn), {
                size: "small",
                type: p.confirmButtonType === "text" ? "" : p.confirmButtonType,
                text: p.confirmButtonType === "text",
                onClick: u
              }, {
                default: X(() => [
                  wt(Ne(i(f)), 1)
                ]),
                _: 1
              }, 8, ["type", "text"])
            ], 2)
          ], 2)
        ]),
        default: X(() => [
          p.$slots.reference ? he(p.$slots, "reference", { key: 0 }) : se("v-if", !0)
        ]),
        _: 3
      }, 16, ["popper-class", "popper-style", "teleported", "hide-after", "persistent"]));
    }
  });
  var zU = /* @__PURE__ */ Me(HU, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popconfirm/src/popconfirm.vue"]]);
  const KU = ut(zU), jU = Ie({
    trigger: Ga.trigger,
    placement: Cu.placement,
    disabled: Ga.disabled,
    visible: dn.visible,
    transition: dn.transition,
    popperOptions: Cu.popperOptions,
    tabindex: Cu.tabindex,
    content: dn.content,
    popperStyle: dn.popperStyle,
    popperClass: dn.popperClass,
    enterable: {
      ...dn.enterable,
      default: !0
    },
    effect: {
      ...dn.effect,
      default: "light"
    },
    teleported: dn.teleported,
    title: String,
    width: {
      type: [String, Number],
      default: 150
    },
    offset: {
      type: Number,
      default: void 0
    },
    showAfter: {
      type: Number,
      default: 0
    },
    hideAfter: {
      type: Number,
      default: 200
    },
    autoClose: {
      type: Number,
      default: 0
    },
    showArrow: {
      type: Boolean,
      default: !0
    },
    persistent: {
      type: Boolean,
      default: !0
    },
    "onUpdate:visible": {
      type: Function
    }
  }), WU = {
    "update:visible": (e) => tn(e),
    "before-enter": () => !0,
    "before-leave": () => !0,
    "after-enter": () => !0,
    "after-leave": () => !0
  }, UU = "onUpdate:visible", qU = G({
    name: "ElPopover"
  }), YU = /* @__PURE__ */ G({
    ...qU,
    props: jU,
    emits: WU,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = E(() => o[UU]), s = ge("popover"), l = I(), a = E(() => {
        var g;
        return (g = i(l)) == null ? void 0 : g.popperRef;
      }), u = E(() => [
        {
          width: Jt(o.width)
        },
        o.popperStyle
      ]), c = E(() => [s.b(), o.popperClass, { [s.m("plain")]: !!o.content }]), f = E(() => o.transition === `${s.namespace.value}-fade-in-linear`), d = () => {
        var g;
        (g = l.value) == null || g.hide();
      }, p = () => {
        n("before-enter");
      }, h = () => {
        n("before-leave");
      }, m = () => {
        n("after-enter");
      }, v = () => {
        n("update:visible", !1), n("after-leave");
      };
      return t({
        popperRef: a,
        hide: d
      }), (g, y) => (S(), ie(i(Mn), ft({
        ref_key: "tooltipRef",
        ref: l
      }, g.$attrs, {
        trigger: g.trigger,
        placement: g.placement,
        disabled: g.disabled,
        visible: g.visible,
        transition: g.transition,
        "popper-options": g.popperOptions,
        tabindex: g.tabindex,
        content: g.content,
        offset: g.offset,
        "show-after": g.showAfter,
        "hide-after": g.hideAfter,
        "auto-close": g.autoClose,
        "show-arrow": g.showArrow,
        "aria-label": g.title,
        effect: g.effect,
        enterable: g.enterable,
        "popper-class": i(c),
        "popper-style": i(u),
        teleported: g.teleported,
        persistent: g.persistent,
        "gpu-acceleration": i(f),
        "onUpdate:visible": i(r),
        onBeforeShow: p,
        onBeforeHide: h,
        onShow: m,
        onHide: v
      }), {
        content: X(() => [
          g.title ? (S(), V("div", {
            key: 0,
            class: $(i(s).e("title")),
            role: "title"
          }, Ne(g.title), 3)) : se("v-if", !0),
          he(g.$slots, "default", {}, () => [
            wt(Ne(g.content), 1)
          ])
        ]),
        default: X(() => [
          g.$slots.reference ? he(g.$slots, "reference", { key: 0 }) : se("v-if", !0)
        ]),
        _: 3
      }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]));
    }
  });
  var GU = /* @__PURE__ */ Me(YU, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
  const Ey = (e, t) => {
    const n = t.arg || t.value, o = n == null ? void 0 : n.popperRef;
    o && (o.triggerRef = e);
  };
  var XU = {
    mounted(e, t) {
      Ey(e, t);
    },
    updated(e, t) {
      Ey(e, t);
    }
  };
  const JU = "popover", HE = aD(XU, JU), ZU = ut(GU, {
    directive: HE
  }), QU = Ie({
    type: {
      type: String,
      default: "line",
      values: ["line", "circle", "dashboard"]
    },
    percentage: {
      type: Number,
      default: 0,
      validator: (e) => e >= 0 && e <= 100
    },
    status: {
      type: String,
      default: "",
      values: ["", "success", "exception", "warning"]
    },
    indeterminate: {
      type: Boolean,
      default: !1
    },
    duration: {
      type: Number,
      default: 3
    },
    strokeWidth: {
      type: Number,
      default: 6
    },
    strokeLinecap: {
      type: le(String),
      default: "round"
    },
    textInside: {
      type: Boolean,
      default: !1
    },
    width: {
      type: Number,
      default: 126
    },
    showText: {
      type: Boolean,
      default: !0
    },
    color: {
      type: le([
        String,
        Array,
        Function
      ]),
      default: ""
    },
    format: {
      type: le(Function),
      default: (e) => `${e}%`
    }
  }), eq = ["aria-valuenow"], tq = { viewBox: "0 0 100 100" }, nq = ["d", "stroke", "stroke-width"], oq = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"], rq = { key: 0 }, sq = G({
    name: "ElProgress"
  }), lq = /* @__PURE__ */ G({
    ...sq,
    props: QU,
    setup(e) {
      const t = e, n = {
        success: "#13ce66",
        exception: "#ff4949",
        warning: "#e6a23c",
        default: "#20a0ff"
      }, o = ge("progress"), r = E(() => ({
        width: `${t.percentage}%`,
        animationDuration: `${t.duration}s`,
        backgroundColor: w(t.percentage)
      })), s = E(() => (t.strokeWidth / t.width * 100).toFixed(1)), l = E(() => ["circle", "dashboard"].includes(t.type) ? Number.parseInt(`${50 - Number.parseFloat(s.value) / 2}`, 10) : 0), a = E(() => {
        const b = l.value, C = t.type === "dashboard";
        return `
          M 50 50
          m 0 ${C ? "" : "-"}${b}
          a ${b} ${b} 0 1 1 0 ${C ? "-" : ""}${b * 2}
          a ${b} ${b} 0 1 1 0 ${C ? "" : "-"}${b * 2}
          `;
      }), u = E(() => 2 * Math.PI * l.value), c = E(() => t.type === "dashboard" ? 0.75 : 1), f = E(() => `${-1 * u.value * (1 - c.value) / 2}px`), d = E(() => ({
        strokeDasharray: `${u.value * c.value}px, ${u.value}px`,
        strokeDashoffset: f.value
      })), p = E(() => ({
        strokeDasharray: `${u.value * c.value * (t.percentage / 100)}px, ${u.value}px`,
        strokeDashoffset: f.value,
        transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
      })), h = E(() => {
        let b;
        return t.color ? b = w(t.percentage) : b = n[t.status] || n.default, b;
      }), m = E(() => t.status === "warning" ? Fc : t.type === "line" ? t.status === "success" ? Eh : Yr : t.status === "success" ? wi : _o), v = E(() => t.type === "line" ? 12 + t.strokeWidth * 0.4 : t.width * 0.111111 + 2), g = E(() => t.format(t.percentage));
      function y(b) {
        const C = 100 / b.length;
        return b.map((k, O) => et(k) ? {
          color: k,
          percentage: (O + 1) * C
        } : k).sort((k, O) => k.percentage - O.percentage);
      }
      const w = (b) => {
        var C;
        const { color: _ } = t;
        if (Ge(_))
          return _(b);
        if (et(_))
          return _;
        {
          const k = y(_);
          for (const O of k)
            if (O.percentage > b)
              return O.color;
          return (C = k[k.length - 1]) == null ? void 0 : C.color;
        }
      };
      return (b, C) => (S(), V("div", {
        class: $([
          i(o).b(),
          i(o).m(b.type),
          i(o).is(b.status),
          {
            [i(o).m("without-text")]: !b.showText,
            [i(o).m("text-inside")]: b.textInside
          }
        ]),
        role: "progressbar",
        "aria-valuenow": b.percentage,
        "aria-valuemin": "0",
        "aria-valuemax": "100"
      }, [
        b.type === "line" ? (S(), V("div", {
          key: 0,
          class: $(i(o).b("bar"))
        }, [
          H("div", {
            class: $(i(o).be("bar", "outer")),
            style: Ke({ height: `${b.strokeWidth}px` })
          }, [
            H("div", {
              class: $([
                i(o).be("bar", "inner"),
                { [i(o).bem("bar", "inner", "indeterminate")]: b.indeterminate }
              ]),
              style: Ke(i(r))
            }, [
              (b.showText || b.$slots.default) && b.textInside ? (S(), V("div", {
                key: 0,
                class: $(i(o).be("bar", "innerText"))
              }, [
                he(b.$slots, "default", { percentage: b.percentage }, () => [
                  H("span", null, Ne(i(g)), 1)
                ])
              ], 2)) : se("v-if", !0)
            ], 6)
          ], 6)
        ], 2)) : (S(), V("div", {
          key: 1,
          class: $(i(o).b("circle")),
          style: Ke({ height: `${b.width}px`, width: `${b.width}px` })
        }, [
          (S(), V("svg", tq, [
            H("path", {
              class: $(i(o).be("circle", "track")),
              d: i(a),
              stroke: `var(${i(o).cssVarName("fill-color-light")}, #e5e9f2)`,
              "stroke-width": i(s),
              fill: "none",
              style: Ke(i(d))
            }, null, 14, nq),
            H("path", {
              class: $(i(o).be("circle", "path")),
              d: i(a),
              stroke: i(h),
              fill: "none",
              opacity: b.percentage ? 1 : 0,
              "stroke-linecap": b.strokeLinecap,
              "stroke-width": i(s),
              style: Ke(i(p))
            }, null, 14, oq)
          ]))
        ], 6)),
        (b.showText || b.$slots.default) && !b.textInside ? (S(), V("div", {
          key: 2,
          class: $(i(o).e("text")),
          style: Ke({ fontSize: `${i(v)}px` })
        }, [
          he(b.$slots, "default", { percentage: b.percentage }, () => [
            b.status ? (S(), ie(i(He), { key: 1 }, {
              default: X(() => [
                (S(), ie(vt(i(m))))
              ]),
              _: 1
            })) : (S(), V("span", rq, Ne(i(g)), 1))
          ])
        ], 6)) : se("v-if", !0)
      ], 10, eq));
    }
  });
  var aq = /* @__PURE__ */ Me(lq, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
  const zE = ut(aq), iq = Ie({
    modelValue: {
      type: Number,
      default: 0
    },
    id: {
      type: String,
      default: void 0
    },
    lowThreshold: {
      type: Number,
      default: 2
    },
    highThreshold: {
      type: Number,
      default: 4
    },
    max: {
      type: Number,
      default: 5
    },
    colors: {
      type: le([Array, Object]),
      default: () => jt(["", "", ""])
    },
    voidColor: {
      type: String,
      default: ""
    },
    disabledVoidColor: {
      type: String,
      default: ""
    },
    icons: {
      type: le([Array, Object]),
      default: () => [Bi, Bi, Bi]
    },
    voidIcon: {
      type: Vt,
      default: () => Px
    },
    disabledVoidIcon: {
      type: Vt,
      default: () => Bi
    },
    disabled: Boolean,
    allowHalf: Boolean,
    showText: Boolean,
    showScore: Boolean,
    textColor: {
      type: String,
      default: ""
    },
    texts: {
      type: le(Array),
      default: () => jt([
        "Extremely bad",
        "Disappointed",
        "Fair",
        "Satisfied",
        "Surprise"
      ])
    },
    scoreTemplate: {
      type: String,
      default: "{value}"
    },
    size: yn,
    label: {
      type: String,
      default: void 0
    },
    clearable: {
      type: Boolean,
      default: !1
    }
  }), uq = {
    [Ft]: (e) => Xe(e),
    [dt]: (e) => Xe(e)
  }, cq = ["id", "aria-label", "aria-labelledby", "aria-valuenow", "aria-valuetext", "aria-valuemax"], dq = ["onMousemove", "onClick"], fq = G({
    name: "ElRate"
  }), pq = /* @__PURE__ */ G({
    ...fq,
    props: iq,
    emits: uq,
    setup(e, { expose: t, emit: n }) {
      const o = e;
      function r(x, N) {
        const R = (te) => rt(te), M = Object.keys(N).map((te) => +te).filter((te) => {
          const U = N[te];
          return (R(U) ? U.excluded : !1) ? x < te : x <= te;
        }).sort((te, U) => te - U), j = N[M[0]];
        return R(j) && j.value || j;
      }
      const s = Be(Hs, void 0), l = Be(Ho, void 0), a = on(), u = ge("rate"), { inputId: c, isLabeledByFormItem: f } = Zr(o, {
        formItemContext: l
      }), d = I(o.modelValue), p = I(-1), h = I(!0), m = E(() => [u.b(), u.m(a.value)]), v = E(() => o.disabled || (s == null ? void 0 : s.disabled)), g = E(() => u.cssVarBlock({
        "void-color": o.voidColor,
        "disabled-void-color": o.disabledVoidColor,
        "fill-color": C.value
      })), y = E(() => {
        let x = "";
        return o.showScore ? x = o.scoreTemplate.replace(/\{\s*value\s*\}/, v.value ? `${o.modelValue}` : `${d.value}`) : o.showText && (x = o.texts[Math.ceil(d.value) - 1]), x;
      }), w = E(() => o.modelValue * 100 - Math.floor(o.modelValue) * 100), b = E(() => De(o.colors) ? {
        [o.lowThreshold]: o.colors[0],
        [o.highThreshold]: { value: o.colors[1], excluded: !0 },
        [o.max]: o.colors[2]
      } : o.colors), C = E(() => {
        const x = r(d.value, b.value);
        return rt(x) ? "" : x;
      }), _ = E(() => {
        let x = "";
        return v.value ? x = `${w.value}%` : o.allowHalf && (x = "50%"), {
          color: C.value,
          width: x
        };
      }), k = E(() => {
        let x = De(o.icons) ? [...o.icons] : { ...o.icons };
        return x = ws(x), De(x) ? {
          [o.lowThreshold]: x[0],
          [o.highThreshold]: {
            value: x[1],
            excluded: !0
          },
          [o.max]: x[2]
        } : x;
      }), O = E(() => r(o.modelValue, k.value)), T = E(() => v.value ? et(o.disabledVoidIcon) ? o.disabledVoidIcon : ws(o.disabledVoidIcon) : et(o.voidIcon) ? o.voidIcon : ws(o.voidIcon)), P = E(() => r(d.value, k.value));
      function A(x) {
        const N = v.value && w.value > 0 && x - 1 < o.modelValue && x > o.modelValue, R = o.allowHalf && h.value && x - 0.5 <= d.value && x > d.value;
        return N || R;
      }
      function L(x) {
        o.clearable && x === o.modelValue && (x = 0), n(dt, x), o.modelValue !== x && n("change", x);
      }
      function D(x) {
        v.value || (o.allowHalf && h.value ? L(d.value) : L(x));
      }
      function B(x) {
        if (v.value)
          return;
        let N = d.value;
        const R = x.code;
        return R === We.up || R === We.right ? (o.allowHalf ? N += 0.5 : N += 1, x.stopPropagation(), x.preventDefault()) : (R === We.left || R === We.down) && (o.allowHalf ? N -= 0.5 : N -= 1, x.stopPropagation(), x.preventDefault()), N = N < 0 ? 0 : N, N = N > o.max ? o.max : N, n(dt, N), n("change", N), N;
      }
      function F(x, N) {
        if (!v.value) {
          if (o.allowHalf && N) {
            let R = N.target;
            Co(R, u.e("item")) && (R = R.querySelector(`.${u.e("icon")}`)), (R.clientWidth === 0 || Co(R, u.e("decimal"))) && (R = R.parentNode), h.value = N.offsetX * 2 <= R.clientWidth, d.value = h.value ? x - 0.5 : x;
          } else
            d.value = x;
          p.value = x;
        }
      }
      function W() {
        v.value || (o.allowHalf && (h.value = o.modelValue !== Math.floor(o.modelValue)), d.value = o.modelValue, p.value = -1);
      }
      return me(() => o.modelValue, (x) => {
        d.value = x, h.value = o.modelValue !== Math.floor(o.modelValue);
      }), o.modelValue || n(dt, 0), t({
        setCurrentValue: F,
        resetCurrentValue: W
      }), (x, N) => {
        var R;
        return S(), V("div", {
          id: i(c),
          class: $([i(m), i(u).is("disabled", i(v))]),
          role: "slider",
          "aria-label": i(f) ? void 0 : x.label || "rating",
          "aria-labelledby": i(f) ? (R = i(l)) == null ? void 0 : R.labelId : void 0,
          "aria-valuenow": d.value,
          "aria-valuetext": i(y) || void 0,
          "aria-valuemin": "0",
          "aria-valuemax": x.max,
          tabindex: "0",
          style: Ke(i(g)),
          onKeydown: B
        }, [
          (S(!0), V(ze, null, gt(x.max, (M, j) => (S(), V("span", {
            key: j,
            class: $(i(u).e("item")),
            onMousemove: (te) => F(M, te),
            onMouseleave: W,
            onClick: (te) => D(M)
          }, [
            K(i(He), {
              class: $([
                i(u).e("icon"),
                { hover: p.value === M },
                i(u).is("active", M <= d.value)
              ])
            }, {
              default: X(() => [
                A(M) ? se("v-if", !0) : (S(), V(ze, { key: 0 }, [
                  ot((S(), ie(vt(i(P)), null, null, 512)), [
                    [$t, M <= d.value]
                  ]),
                  ot((S(), ie(vt(i(T)), null, null, 512)), [
                    [$t, !(M <= d.value)]
                  ])
                ], 64)),
                A(M) ? (S(), ie(i(He), {
                  key: 1,
                  style: Ke(i(_)),
                  class: $([i(u).e("icon"), i(u).e("decimal")])
                }, {
                  default: X(() => [
                    (S(), ie(vt(i(O))))
                  ]),
                  _: 1
                }, 8, ["style", "class"])) : se("v-if", !0)
              ]),
              _: 2
            }, 1032, ["class"])
          ], 42, dq))), 128)),
          x.showText || x.showScore ? (S(), V("span", {
            key: 0,
            class: $(i(u).e("text"))
          }, Ne(i(y)), 3)) : se("v-if", !0)
        ], 46, cq);
      };
    }
  });
  var hq = /* @__PURE__ */ Me(pq, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/rate/src/rate.vue"]]);
  const vq = ut(hq), ol = {
    success: "icon-success",
    warning: "icon-warning",
    error: "icon-error",
    info: "icon-info"
  }, Sy = {
    [ol.success]: B3,
    [ol.warning]: Fc,
    [ol.error]: Sh,
    [ol.info]: _h
  }, mq = Ie({
    title: {
      type: String,
      default: ""
    },
    subTitle: {
      type: String,
      default: ""
    },
    icon: {
      type: String,
      values: ["success", "warning", "info", "error"],
      default: "info"
    }
  }), gq = G({
    name: "ElResult"
  }), yq = /* @__PURE__ */ G({
    ...gq,
    props: mq,
    setup(e) {
      const t = e, n = ge("result"), o = E(() => {
        const r = t.icon, s = r && ol[r] ? ol[r] : "icon-info", l = Sy[s] || Sy["icon-info"];
        return {
          class: s,
          component: l
        };
      });
      return (r, s) => (S(), V("div", {
        class: $(i(n).b())
      }, [
        H("div", {
          class: $(i(n).e("icon"))
        }, [
          he(r.$slots, "icon", {}, () => [
            i(o).component ? (S(), ie(vt(i(o).component), {
              key: 0,
              class: $(i(o).class)
            }, null, 8, ["class"])) : se("v-if", !0)
          ])
        ], 2),
        r.title || r.$slots.title ? (S(), V("div", {
          key: 0,
          class: $(i(n).e("title"))
        }, [
          he(r.$slots, "title", {}, () => [
            H("p", null, Ne(r.title), 1)
          ])
        ], 2)) : se("v-if", !0),
        r.subTitle || r.$slots["sub-title"] ? (S(), V("div", {
          key: 1,
          class: $(i(n).e("subtitle"))
        }, [
          he(r.$slots, "sub-title", {}, () => [
            H("p", null, Ne(r.subTitle), 1)
          ])
        ], 2)) : se("v-if", !0),
        r.$slots.extra ? (S(), V("div", {
          key: 2,
          class: $(i(n).e("extra"))
        }, [
          he(r.$slots, "extra")
        ], 2)) : se("v-if", !0)
      ], 2));
    }
  });
  var bq = /* @__PURE__ */ Me(yq, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/result/src/result.vue"]]);
  const wq = ut(bq);
  var _y = Number.isNaN || function(t) {
    return typeof t == "number" && t !== t;
  };
  function Cq(e, t) {
    return !!(e === t || _y(e) && _y(t));
  }
  function Eq(e, t) {
    if (e.length !== t.length)
      return !1;
    for (var n = 0; n < e.length; n++)
      if (!Cq(e[n], t[n]))
        return !1;
    return !0;
  }
  function Sq(e, t) {
    t === void 0 && (t = Eq);
    var n = null;
    function o() {
      for (var r = [], s = 0; s < arguments.length; s++)
        r[s] = arguments[s];
      if (n && n.lastThis === this && t(r, n.lastArgs))
        return n.lastResult;
      var l = e.apply(this, r);
      return n = {
        lastResult: l,
        lastArgs: r,
        lastThis: this
      }, l;
    }
    return o.clear = function() {
      n = null;
    }, o;
  }
  const KE = () => {
    const t = it().proxy.$props;
    return E(() => {
      const n = (o, r, s) => ({});
      return t.perfMode ? Dc(n) : Sq(n);
    });
  }, op = 50, rc = "itemRendered", sc = "scroll", rl = "forward", lc = "backward", eo = "auto", nd = "smart", Za = "start", Ro = "center", Qa = "end", Rl = "horizontal", lv = "vertical", _q = "ltr", vl = "rtl", ei = "negative", av = "positive-ascending", iv = "positive-descending", kq = {
    [Rl]: "left",
    [lv]: "top"
  }, $q = 20, Nq = {
    [Rl]: "deltaX",
    [lv]: "deltaY"
  }, Tq = ({ atEndEdge: e, atStartEdge: t, layout: n }, o) => {
    let r, s = 0;
    const l = (u) => u < 0 && t.value || u > 0 && e.value;
    return {
      hasReachedEdge: l,
      onWheel: (u) => {
        jc(r);
        const c = u[Nq[n.value]];
        l(s) && l(s + c) || (s += c, sw() || u.preventDefault(), r = Ka(() => {
          o(s), s = 0;
        }));
      }
    };
  }, rp = $o({
    type: le([Number, Function]),
    required: !0
  }), sp = $o({
    type: Number
  }), lp = $o({
    type: Number,
    default: 2
  }), Oq = $o({
    type: String,
    values: ["ltr", "rtl"],
    default: "ltr"
  }), ap = $o({
    type: Number,
    default: 0
  }), ac = $o({
    type: Number,
    required: !0
  }), jE = $o({
    type: String,
    values: ["horizontal", "vertical"],
    default: lv
  }), WE = Ie({
    className: {
      type: String,
      default: ""
    },
    containerElement: {
      type: le([String, Object]),
      default: "div"
    },
    data: {
      type: le(Array),
      default: () => jt([])
    },
    direction: Oq,
    height: {
      type: [String, Number],
      required: !0
    },
    innerElement: {
      type: [String, Object],
      default: "div"
    },
    style: {
      type: le([Object, String, Array])
    },
    useIsScrolling: {
      type: Boolean,
      default: !1
    },
    width: {
      type: [Number, String],
      required: !1
    },
    perfMode: {
      type: Boolean,
      default: !0
    },
    scrollbarAlwaysOn: {
      type: Boolean,
      default: !1
    }
  }), UE = Ie({
    cache: lp,
    estimatedItemSize: sp,
    layout: jE,
    initScrollOffset: ap,
    total: ac,
    itemSize: rp,
    ...WE
  }), ip = {
    type: Number,
    default: 6
  }, qE = { type: Number, default: 0 }, YE = { type: Number, default: 2 }, ks = Ie({
    columnCache: lp,
    columnWidth: rp,
    estimatedColumnWidth: sp,
    estimatedRowHeight: sp,
    initScrollLeft: ap,
    initScrollTop: ap,
    itemKey: {
      type: le(Function),
      default: ({
        columnIndex: e,
        rowIndex: t
      }) => `${t}:${e}`
    },
    rowCache: lp,
    rowHeight: rp,
    totalColumn: ac,
    totalRow: ac,
    hScrollbarSize: ip,
    vScrollbarSize: ip,
    scrollbarStartGap: qE,
    scrollbarEndGap: YE,
    role: String,
    ...WE
  }), GE = Ie({
    alwaysOn: Boolean,
    class: String,
    layout: jE,
    total: ac,
    ratio: {
      type: Number,
      required: !0
    },
    clientSize: {
      type: Number,
      required: !0
    },
    scrollFrom: {
      type: Number,
      required: !0
    },
    scrollbarSize: ip,
    startGap: qE,
    endGap: YE,
    visible: Boolean
  }), hs = (e, t) => e < t ? rl : lc, ti = (e) => e === _q || e === vl || e === Rl, ky = (e) => e === vl;
  let js = null;
  function ic(e = !1) {
    if (js === null || e) {
      const t = document.createElement("div"), n = t.style;
      n.width = "50px", n.height = "50px", n.overflow = "scroll", n.direction = "rtl";
      const o = document.createElement("div"), r = o.style;
      return r.width = "100px", r.height = "100px", t.appendChild(o), document.body.appendChild(t), t.scrollLeft > 0 ? js = iv : (t.scrollLeft = 1, t.scrollLeft === 0 ? js = ei : js = av), document.body.removeChild(t), js;
    }
    return js;
  }
  function Mq({ move: e, size: t, bar: n }, o) {
    const r = {}, s = `translate${n.axis}(${e}px)`;
    return r[n.size] = t, r.transform = s, r.msTransform = s, r.webkitTransform = s, o === "horizontal" ? r.height = "100%" : r.width = "100%", r;
  }
  const up = G({
    name: "ElVirtualScrollBar",
    props: GE,
    emits: ["scroll", "start-move", "stop-move"],
    setup(e, { emit: t }) {
      const n = E(() => e.startGap + e.endGap), o = ge("virtual-scrollbar"), r = ge("scrollbar"), s = I(), l = I();
      let a = null, u = null;
      const c = Tt({
        isDragging: !1,
        traveled: 0
      }), f = E(() => Ww[e.layout]), d = E(() => e.clientSize - i(n)), p = E(() => ({
        position: "absolute",
        width: `${Rl === e.layout ? d.value : e.scrollbarSize}px`,
        height: `${Rl === e.layout ? e.scrollbarSize : d.value}px`,
        [kq[e.layout]]: "2px",
        right: "2px",
        bottom: "2px",
        borderRadius: "4px"
      })), h = E(() => {
        const k = e.ratio, O = e.clientSize;
        if (k >= 100)
          return Number.POSITIVE_INFINITY;
        if (k >= 50)
          return k * O / 100;
        const T = O / 3;
        return Math.floor(Math.min(Math.max(k * O, $q), T));
      }), m = E(() => {
        if (!Number.isFinite(h.value))
          return {
            display: "none"
          };
        const k = `${h.value}px`;
        return Mq({
          bar: f.value,
          size: k,
          move: c.traveled
        }, e.layout);
      }), v = E(() => Math.floor(e.clientSize - h.value - i(n))), g = () => {
        window.addEventListener("mousemove", C), window.addEventListener("mouseup", b);
        const k = i(l);
        !k || (u = document.onselectstart, document.onselectstart = () => !1, k.addEventListener("touchmove", C), k.addEventListener("touchend", b));
      }, y = () => {
        window.removeEventListener("mousemove", C), window.removeEventListener("mouseup", b), document.onselectstart = u, u = null;
        const k = i(l);
        !k || (k.removeEventListener("touchmove", C), k.removeEventListener("touchend", b));
      }, w = (k) => {
        k.stopImmediatePropagation(), !(k.ctrlKey || [1, 2].includes(k.button)) && (c.isDragging = !0, c[f.value.axis] = k.currentTarget[f.value.offset] - (k[f.value.client] - k.currentTarget.getBoundingClientRect()[f.value.direction]), t("start-move"), g());
      }, b = () => {
        c.isDragging = !1, c[f.value.axis] = 0, t("stop-move"), y();
      }, C = (k) => {
        const { isDragging: O } = c;
        if (!O || !l.value || !s.value)
          return;
        const T = c[f.value.axis];
        if (!T)
          return;
        jc(a);
        const P = (s.value.getBoundingClientRect()[f.value.direction] - k[f.value.client]) * -1, A = l.value[f.value.offset] - T, L = P - A;
        a = Ka(() => {
          c.traveled = Math.max(e.startGap, Math.min(L, v.value)), t("scroll", L, v.value);
        });
      }, _ = (k) => {
        const O = Math.abs(k.target.getBoundingClientRect()[f.value.direction] - k[f.value.client]), T = l.value[f.value.offset] / 2, P = O - T;
        c.traveled = Math.max(0, Math.min(P, v.value)), t("scroll", P, v.value);
      };
      return me(() => e.scrollFrom, (k) => {
        c.isDragging || (c.traveled = Math.ceil(k * v.value));
      }), zt(() => {
        y();
      }), () => je("div", {
        role: "presentation",
        ref: s,
        class: [
          o.b(),
          e.class,
          (e.alwaysOn || c.isDragging) && "always-on"
        ],
        style: p.value,
        onMousedown: Ze(_, ["stop", "prevent"]),
        onTouchstartPrevent: w
      }, je("div", {
        ref: l,
        class: r.e("thumb"),
        style: m.value,
        onMousedown: w
      }, []));
    }
  }), XE = ({
    name: e,
    getOffset: t,
    getItemSize: n,
    getItemOffset: o,
    getEstimatedTotalSize: r,
    getStartIndexForOffset: s,
    getStopIndexForStartIndex: l,
    initCache: a,
    clearCache: u,
    validateProps: c
  }) => G({
    name: e != null ? e : "ElVirtualList",
    props: UE,
    emits: [rc, sc],
    setup(f, { emit: d, expose: p }) {
      c(f);
      const h = it(), m = ge("vl"), v = I(a(f, h)), g = KE(), y = I(), w = I(), b = I(), C = I({
        isScrolling: !1,
        scrollDir: "forward",
        scrollOffset: Xe(f.initScrollOffset) ? f.initScrollOffset : 0,
        updateRequested: !1,
        isScrollbarDragging: !1,
        scrollbarAlwaysOn: f.scrollbarAlwaysOn
      }), _ = E(() => {
        const { total: Z, cache: pe } = f, { isScrolling: J, scrollDir: ee, scrollOffset: ne } = i(C);
        if (Z === 0)
          return [0, 0, 0, 0];
        const Y = s(f, ne, i(v)), re = l(f, Y, ne, i(v)), ce = !J || ee === lc ? Math.max(1, pe) : 1, Te = !J || ee === rl ? Math.max(1, pe) : 1;
        return [
          Math.max(0, Y - ce),
          Math.max(0, Math.min(Z - 1, re + Te)),
          Y,
          re
        ];
      }), k = E(() => r(f, i(v))), O = E(() => ti(f.layout)), T = E(() => [
        {
          position: "relative",
          [`overflow-${O.value ? "x" : "y"}`]: "scroll",
          WebkitOverflowScrolling: "touch",
          willChange: "transform"
        },
        {
          direction: f.direction,
          height: Xe(f.height) ? `${f.height}px` : f.height,
          width: Xe(f.width) ? `${f.width}px` : f.width
        },
        f.style
      ]), P = E(() => {
        const Z = i(k), pe = i(O);
        return {
          height: pe ? "100%" : `${Z}px`,
          pointerEvents: i(C).isScrolling ? "none" : void 0,
          width: pe ? `${Z}px` : "100%"
        };
      }), A = E(() => O.value ? f.width : f.height), { onWheel: L } = Tq({
        atStartEdge: E(() => C.value.scrollOffset <= 0),
        atEndEdge: E(() => C.value.scrollOffset >= k.value),
        layout: E(() => f.layout)
      }, (Z) => {
        var pe, J;
        (J = (pe = b.value).onMouseUp) == null || J.call(pe), N(Math.min(C.value.scrollOffset + Z, k.value - A.value));
      }), D = () => {
        const { total: Z } = f;
        if (Z > 0) {
          const [ne, Y, re, ce] = i(_);
          d(rc, ne, Y, re, ce);
        }
        const { scrollDir: pe, scrollOffset: J, updateRequested: ee } = i(C);
        d(sc, pe, J, ee);
      }, B = (Z) => {
        const { clientHeight: pe, scrollHeight: J, scrollTop: ee } = Z.currentTarget, ne = i(C);
        if (ne.scrollOffset === ee)
          return;
        const Y = Math.max(0, Math.min(ee, J - pe));
        C.value = {
          ...ne,
          isScrolling: !0,
          scrollDir: hs(ne.scrollOffset, Y),
          scrollOffset: Y,
          updateRequested: !1
        }, Fe(j);
      }, F = (Z) => {
        const { clientWidth: pe, scrollLeft: J, scrollWidth: ee } = Z.currentTarget, ne = i(C);
        if (ne.scrollOffset === J)
          return;
        const { direction: Y } = f;
        let re = J;
        if (Y === vl)
          switch (ic()) {
            case ei: {
              re = -J;
              break;
            }
            case iv: {
              re = ee - pe - J;
              break;
            }
          }
        re = Math.max(0, Math.min(re, ee - pe)), C.value = {
          ...ne,
          isScrolling: !0,
          scrollDir: hs(ne.scrollOffset, re),
          scrollOffset: re,
          updateRequested: !1
        }, Fe(j);
      }, W = (Z) => {
        i(O) ? F(Z) : B(Z), D();
      }, x = (Z, pe) => {
        const J = (k.value - A.value) / pe * Z;
        N(Math.min(k.value - A.value, J));
      }, N = (Z) => {
        Z = Math.max(Z, 0), Z !== i(C).scrollOffset && (C.value = {
          ...i(C),
          scrollOffset: Z,
          scrollDir: hs(i(C).scrollOffset, Z),
          updateRequested: !0
        }, Fe(j));
      }, R = (Z, pe = eo) => {
        const { scrollOffset: J } = i(C);
        Z = Math.max(0, Math.min(Z, f.total - 1)), N(t(f, Z, pe, J, i(v)));
      }, M = (Z) => {
        const { direction: pe, itemSize: J, layout: ee } = f, ne = g.value(u && J, u && ee, u && pe);
        let Y;
        if (ht(ne, String(Z)))
          Y = ne[Z];
        else {
          const re = o(f, Z, i(v)), ce = n(f, Z, i(v)), Te = i(O), Pe = pe === vl, z = Te ? re : 0;
          ne[Z] = Y = {
            position: "absolute",
            left: Pe ? void 0 : `${z}px`,
            right: Pe ? `${z}px` : void 0,
            top: Te ? 0 : `${re}px`,
            height: Te ? "100%" : `${ce}px`,
            width: Te ? `${ce}px` : "100%"
          };
        }
        return Y;
      }, j = () => {
        C.value.isScrolling = !1, Fe(() => {
          g.value(-1, null, null);
        });
      }, te = () => {
        const Z = y.value;
        Z && (Z.scrollTop = 0);
      };
      st(() => {
        if (!bt)
          return;
        const { initScrollOffset: Z } = f, pe = i(y);
        Xe(Z) && pe && (i(O) ? pe.scrollLeft = Z : pe.scrollTop = Z), D();
      }), cr(() => {
        const { direction: Z, layout: pe } = f, { scrollOffset: J, updateRequested: ee } = i(C), ne = i(y);
        if (ee && ne)
          if (pe === Rl)
            if (Z === vl)
              switch (ic()) {
                case ei: {
                  ne.scrollLeft = -J;
                  break;
                }
                case av: {
                  ne.scrollLeft = J;
                  break;
                }
                default: {
                  const { clientWidth: Y, scrollWidth: re } = ne;
                  ne.scrollLeft = re - Y - J;
                  break;
                }
              }
            else
              ne.scrollLeft = J;
          else
            ne.scrollTop = J;
      });
      const U = {
        ns: m,
        clientSize: A,
        estimatedTotalSize: k,
        windowStyle: T,
        windowRef: y,
        innerRef: w,
        innerStyle: P,
        itemsToRender: _,
        scrollbarRef: b,
        states: C,
        getItemStyle: M,
        onScroll: W,
        onScrollbarScroll: x,
        onWheel: L,
        scrollTo: N,
        scrollToItem: R,
        resetScrollTop: te
      };
      return p({
        windowRef: y,
        innerRef: w,
        getItemStyleCache: g,
        scrollTo: N,
        scrollToItem: R,
        resetScrollTop: te,
        states: C
      }), U;
    },
    render(f) {
      var d;
      const {
        $slots: p,
        className: h,
        clientSize: m,
        containerElement: v,
        data: g,
        getItemStyle: y,
        innerElement: w,
        itemsToRender: b,
        innerStyle: C,
        layout: _,
        total: k,
        onScroll: O,
        onScrollbarScroll: T,
        onWheel: P,
        states: A,
        useIsScrolling: L,
        windowStyle: D,
        ns: B
      } = f, [F, W] = b, x = vt(v), N = vt(w), R = [];
      if (k > 0)
        for (let U = F; U <= W; U++)
          R.push((d = p.default) == null ? void 0 : d.call(p, {
            data: g,
            key: U,
            index: U,
            isScrolling: L ? A.isScrolling : void 0,
            style: y(U)
          }));
      const M = [
        je(N, {
          style: C,
          ref: "innerRef"
        }, et(N) ? R : {
          default: () => R
        })
      ], j = je(up, {
        ref: "scrollbarRef",
        clientSize: m,
        layout: _,
        onScroll: T,
        ratio: m * 100 / this.estimatedTotalSize,
        scrollFrom: A.scrollOffset / (this.estimatedTotalSize - m),
        total: k
      }), te = je(x, {
        class: [B.e("window"), h],
        style: D,
        onScroll: O,
        onWheel: P,
        ref: "windowRef",
        key: 0
      }, et(x) ? [M] : { default: () => [M] });
      return je("div", {
        key: 0,
        class: [B.e("wrapper"), A.scrollbarAlwaysOn ? "always-on" : ""]
      }, [te, j]);
    }
  }), JE = XE({
    name: "ElFixedSizeList",
    getItemOffset: ({ itemSize: e }, t) => t * e,
    getItemSize: ({ itemSize: e }) => e,
    getEstimatedTotalSize: ({ total: e, itemSize: t }) => t * e,
    getOffset: ({ height: e, total: t, itemSize: n, layout: o, width: r }, s, l, a) => {
      const u = ti(o) ? r : e;
      process.env.NODE_ENV !== "production" && et(u) && Yt("[ElVirtualList]", `
        You should set
          width/height
        to number when your layout is
          horizontal/vertical
      `);
      const c = Math.max(0, t * n - u), f = Math.min(c, s * n), d = Math.max(0, (s + 1) * n - u);
      switch (l === nd && (a >= d - u && a <= f + u ? l = eo : l = Ro), l) {
        case Za:
          return f;
        case Qa:
          return d;
        case Ro: {
          const p = Math.round(d + (f - d) / 2);
          return p < Math.ceil(u / 2) ? 0 : p > c + Math.floor(u / 2) ? c : p;
        }
        case eo:
        default:
          return a >= d && a <= f ? a : a < d ? d : f;
      }
    },
    getStartIndexForOffset: ({ total: e, itemSize: t }, n) => Math.max(0, Math.min(e - 1, Math.floor(n / t))),
    getStopIndexForStartIndex: ({ height: e, total: t, itemSize: n, layout: o, width: r }, s, l) => {
      const a = s * n, u = ti(o) ? r : e, c = Math.ceil((u + l - a) / n);
      return Math.max(0, Math.min(t - 1, s + c - 1));
    },
    initCache() {
    },
    clearCache: !0,
    validateProps() {
    }
  }), Iq = "ElDynamicSizeList", sl = (e, t, n) => {
    const { itemSize: o } = e, { items: r, lastVisitedIndex: s } = n;
    if (t > s) {
      let l = 0;
      if (s >= 0) {
        const a = r[s];
        l = a.offset + a.size;
      }
      for (let a = s + 1; a <= t; a++) {
        const u = o(a);
        r[a] = {
          offset: l,
          size: u
        }, l += u;
      }
      n.lastVisitedIndex = t;
    }
    return r[t];
  }, Pq = (e, t, n) => {
    const { items: o, lastVisitedIndex: r } = t;
    return (r > 0 ? o[r].offset : 0) >= n ? ZE(e, t, 0, r, n) : Aq(e, t, Math.max(0, r), n);
  }, ZE = (e, t, n, o, r) => {
    for (; n <= o; ) {
      const s = n + Math.floor((o - n) / 2), l = sl(e, s, t).offset;
      if (l === r)
        return s;
      l < r ? n = s + 1 : l > r && (o = s - 1);
    }
    return Math.max(0, n - 1);
  }, Aq = (e, t, n, o) => {
    const { total: r } = e;
    let s = 1;
    for (; n < r && sl(e, n, t).offset < o; )
      n += s, s *= 2;
    return ZE(e, t, Math.floor(n / 2), Math.min(n, r - 1), o);
  }, $y = ({ total: e }, { items: t, estimatedItemSize: n, lastVisitedIndex: o }) => {
    let r = 0;
    if (o >= e && (o = e - 1), o >= 0) {
      const a = t[o];
      r = a.offset + a.size;
    }
    const l = (e - o - 1) * n;
    return r + l;
  }, Rq = XE({
    name: "ElDynamicSizeList",
    getItemOffset: (e, t, n) => sl(e, t, n).offset,
    getItemSize: (e, t, { items: n }) => n[t].size,
    getEstimatedTotalSize: $y,
    getOffset: (e, t, n, o, r) => {
      const { height: s, layout: l, width: a } = e, u = ti(l) ? a : s, c = sl(e, t, r), f = $y(e, r), d = Math.max(0, Math.min(f - u, c.offset)), p = Math.max(0, c.offset - u + c.size);
      switch (n === nd && (o >= p - u && o <= d + u ? n = eo : n = Ro), n) {
        case Za:
          return d;
        case Qa:
          return p;
        case Ro:
          return Math.round(p + (d - p) / 2);
        case eo:
        default:
          return o >= p && o <= d ? o : o < p ? p : d;
      }
    },
    getStartIndexForOffset: (e, t, n) => Pq(e, n, t),
    getStopIndexForStartIndex: (e, t, n, o) => {
      const { height: r, total: s, layout: l, width: a } = e, u = ti(l) ? a : r, c = sl(e, t, o), f = n + u;
      let d = c.offset + c.size, p = t;
      for (; p < s - 1 && d < f; )
        p++, d += sl(e, p, o).size;
      return p;
    },
    initCache({ estimatedItemSize: e = op }, t) {
      const n = {
        items: {},
        estimatedItemSize: e,
        lastVisitedIndex: -1
      };
      return n.clearCacheAfterIndex = (o, r = !0) => {
        var s, l;
        n.lastVisitedIndex = Math.min(n.lastVisitedIndex, o - 1), (s = t.exposed) == null || s.getItemStyleCache(-1), r && ((l = t.proxy) == null || l.$forceUpdate());
      }, n;
    },
    clearCache: !1,
    validateProps: ({ itemSize: e }) => {
      process.env.NODE_ENV !== "production" && typeof e != "function" && Yt(Iq, `
          itemSize is required as function, but the given value was ${typeof e}
        `);
    }
  }), xq = ({ atXEndEdge: e, atXStartEdge: t, atYEndEdge: n, atYStartEdge: o }, r) => {
    let s = null, l = 0, a = 0;
    const u = (f, d) => {
      const p = f <= 0 && t.value || f >= 0 && e.value, h = d <= 0 && o.value || d >= 0 && n.value;
      return p && h;
    };
    return {
      hasReachedEdge: u,
      onWheel: (f) => {
        jc(s);
        let d = f.deltaX, p = f.deltaY;
        Math.abs(d) > Math.abs(p) ? p = 0 : d = 0, f.shiftKey && p !== 0 && (d = p, p = 0), !(u(l, a) && u(l + d, a + p)) && (l += d, a += p, f.preventDefault(), s = Ka(() => {
          r(l, a), l = 0, a = 0;
        }));
      }
    };
  }, QE = ({
    name: e,
    clearCache: t,
    getColumnPosition: n,
    getColumnStartIndexForOffset: o,
    getColumnStopIndexForStartIndex: r,
    getEstimatedTotalHeight: s,
    getEstimatedTotalWidth: l,
    getColumnOffset: a,
    getRowOffset: u,
    getRowPosition: c,
    getRowStartIndexForOffset: f,
    getRowStopIndexForStartIndex: d,
    initCache: p,
    injectToInstance: h,
    validateProps: m
  }) => G({
    name: e != null ? e : "ElVirtualList",
    props: ks,
    emits: [rc, sc],
    setup(v, { emit: g, expose: y, slots: w }) {
      const b = ge("vl");
      m(v);
      const C = it(), _ = I(p(v, C));
      h == null || h(C, _);
      const k = I(), O = I(), T = I(), P = I(null), A = I({
        isScrolling: !1,
        scrollLeft: Xe(v.initScrollLeft) ? v.initScrollLeft : 0,
        scrollTop: Xe(v.initScrollTop) ? v.initScrollTop : 0,
        updateRequested: !1,
        xAxisScrollDir: rl,
        yAxisScrollDir: rl
      }), L = KE(), D = E(() => Number.parseInt(`${v.height}`, 10)), B = E(() => Number.parseInt(`${v.width}`, 10)), F = E(() => {
        const { totalColumn: ae, totalRow: Ee, columnCache: we } = v, { isScrolling: Se, xAxisScrollDir: _e, scrollLeft: ke } = i(A);
        if (ae === 0 || Ee === 0)
          return [0, 0, 0, 0];
        const Re = o(v, ke, i(_)), fe = r(v, Re, ke, i(_)), Ae = !Se || _e === lc ? Math.max(1, we) : 1, qe = !Se || _e === rl ? Math.max(1, we) : 1;
        return [
          Math.max(0, Re - Ae),
          Math.max(0, Math.min(ae - 1, fe + qe)),
          Re,
          fe
        ];
      }), W = E(() => {
        const { totalColumn: ae, totalRow: Ee, rowCache: we } = v, { isScrolling: Se, yAxisScrollDir: _e, scrollTop: ke } = i(A);
        if (ae === 0 || Ee === 0)
          return [0, 0, 0, 0];
        const Re = f(v, ke, i(_)), fe = d(v, Re, ke, i(_)), Ae = !Se || _e === lc ? Math.max(1, we) : 1, qe = !Se || _e === rl ? Math.max(1, we) : 1;
        return [
          Math.max(0, Re - Ae),
          Math.max(0, Math.min(Ee - 1, fe + qe)),
          Re,
          fe
        ];
      }), x = E(() => s(v, i(_))), N = E(() => l(v, i(_))), R = E(() => {
        var ae;
        return [
          {
            position: "relative",
            overflow: "hidden",
            WebkitOverflowScrolling: "touch",
            willChange: "transform"
          },
          {
            direction: v.direction,
            height: Xe(v.height) ? `${v.height}px` : v.height,
            width: Xe(v.width) ? `${v.width}px` : v.width
          },
          (ae = v.style) != null ? ae : {}
        ];
      }), M = E(() => {
        const ae = `${i(N)}px`;
        return {
          height: `${i(x)}px`,
          pointerEvents: i(A).isScrolling ? "none" : void 0,
          width: ae
        };
      }), j = () => {
        const { totalColumn: ae, totalRow: Ee } = v;
        if (ae > 0 && Ee > 0) {
          const [
            fe,
            Ae,
            qe,
            tt
          ] = i(F), [Je, ye, Ce, ue] = i(W);
          g(rc, {
            columnCacheStart: fe,
            columnCacheEnd: Ae,
            rowCacheStart: Je,
            rowCacheEnd: ye,
            columnVisibleStart: qe,
            columnVisibleEnd: tt,
            rowVisibleStart: Ce,
            rowVisibleEnd: ue
          });
        }
        const {
          scrollLeft: we,
          scrollTop: Se,
          updateRequested: _e,
          xAxisScrollDir: ke,
          yAxisScrollDir: Re
        } = i(A);
        g(sc, {
          xAxisScrollDir: ke,
          scrollLeft: we,
          yAxisScrollDir: Re,
          scrollTop: Se,
          updateRequested: _e
        });
      }, te = (ae) => {
        const {
          clientHeight: Ee,
          clientWidth: we,
          scrollHeight: Se,
          scrollLeft: _e,
          scrollTop: ke,
          scrollWidth: Re
        } = ae.currentTarget, fe = i(A);
        if (fe.scrollTop === ke && fe.scrollLeft === _e)
          return;
        let Ae = _e;
        if (ky(v.direction))
          switch (ic()) {
            case ei:
              Ae = -_e;
              break;
            case iv:
              Ae = Re - we - _e;
              break;
          }
        A.value = {
          ...fe,
          isScrolling: !0,
          scrollLeft: Ae,
          scrollTop: Math.max(0, Math.min(ke, Se - Ee)),
          updateRequested: !0,
          xAxisScrollDir: hs(fe.scrollLeft, Ae),
          yAxisScrollDir: hs(fe.scrollTop, ke)
        }, Fe(() => Y()), re(), j();
      }, U = (ae, Ee) => {
        const we = i(D), Se = (x.value - we) / Ee * ae;
        J({
          scrollTop: Math.min(x.value - we, Se)
        });
      }, Z = (ae, Ee) => {
        const we = i(B), Se = (N.value - we) / Ee * ae;
        J({
          scrollLeft: Math.min(N.value - we, Se)
        });
      }, { onWheel: pe } = xq({
        atXStartEdge: E(() => A.value.scrollLeft <= 0),
        atXEndEdge: E(() => A.value.scrollLeft >= N.value - i(B)),
        atYStartEdge: E(() => A.value.scrollTop <= 0),
        atYEndEdge: E(() => A.value.scrollTop >= x.value - i(D))
      }, (ae, Ee) => {
        var we, Se, _e, ke;
        (Se = (we = O.value) == null ? void 0 : we.onMouseUp) == null || Se.call(we), (ke = (_e = O.value) == null ? void 0 : _e.onMouseUp) == null || ke.call(_e);
        const Re = i(B), fe = i(D);
        J({
          scrollLeft: Math.min(A.value.scrollLeft + ae, N.value - Re),
          scrollTop: Math.min(A.value.scrollTop + Ee, x.value - fe)
        });
      }), J = ({
        scrollLeft: ae = A.value.scrollLeft,
        scrollTop: Ee = A.value.scrollTop
      }) => {
        ae = Math.max(ae, 0), Ee = Math.max(Ee, 0);
        const we = i(A);
        Ee === we.scrollTop && ae === we.scrollLeft || (A.value = {
          ...we,
          xAxisScrollDir: hs(we.scrollLeft, ae),
          yAxisScrollDir: hs(we.scrollTop, Ee),
          scrollLeft: ae,
          scrollTop: Ee,
          updateRequested: !0
        }, Fe(() => Y()), re(), j());
      }, ee = (ae = 0, Ee = 0, we = eo) => {
        const Se = i(A);
        Ee = Math.max(0, Math.min(Ee, v.totalColumn - 1)), ae = Math.max(0, Math.min(ae, v.totalRow - 1));
        const _e = Y1(b.namespace.value), ke = i(_), Re = s(v, ke), fe = l(v, ke);
        J({
          scrollLeft: a(v, Ee, we, Se.scrollLeft, ke, fe > v.width ? _e : 0),
          scrollTop: u(v, ae, we, Se.scrollTop, ke, Re > v.height ? _e : 0)
        });
      }, ne = (ae, Ee) => {
        const { columnWidth: we, direction: Se, rowHeight: _e } = v, ke = L.value(t && we, t && _e, t && Se), Re = `${ae},${Ee}`;
        if (ht(ke, Re))
          return ke[Re];
        {
          const [, fe] = n(v, Ee, i(_)), Ae = i(_), qe = ky(Se), [tt, Je] = c(v, ae, Ae), [ye] = n(v, Ee, Ae);
          return ke[Re] = {
            position: "absolute",
            left: qe ? void 0 : `${fe}px`,
            right: qe ? `${fe}px` : void 0,
            top: `${Je}px`,
            height: `${tt}px`,
            width: `${ye}px`
          }, ke[Re];
        }
      }, Y = () => {
        A.value.isScrolling = !1, Fe(() => {
          L.value(-1, null, null);
        });
      };
      st(() => {
        if (!bt)
          return;
        const { initScrollLeft: ae, initScrollTop: Ee } = v, we = i(k);
        we && (Xe(ae) && (we.scrollLeft = ae), Xe(Ee) && (we.scrollTop = Ee)), j();
      });
      const re = () => {
        const { direction: ae } = v, { scrollLeft: Ee, scrollTop: we, updateRequested: Se } = i(A), _e = i(k);
        if (Se && _e) {
          if (ae === vl)
            switch (ic()) {
              case ei: {
                _e.scrollLeft = -Ee;
                break;
              }
              case av: {
                _e.scrollLeft = Ee;
                break;
              }
              default: {
                const { clientWidth: ke, scrollWidth: Re } = _e;
                _e.scrollLeft = Re - ke - Ee;
                break;
              }
            }
          else
            _e.scrollLeft = Math.max(0, Ee);
          _e.scrollTop = Math.max(0, we);
        }
      }, { resetAfterColumnIndex: ce, resetAfterRowIndex: Te, resetAfter: Pe } = C.proxy;
      y({
        windowRef: k,
        innerRef: P,
        getItemStyleCache: L,
        scrollTo: J,
        scrollToItem: ee,
        states: A,
        resetAfterColumnIndex: ce,
        resetAfterRowIndex: Te,
        resetAfter: Pe
      });
      const z = () => {
        const {
          scrollbarAlwaysOn: ae,
          scrollbarStartGap: Ee,
          scrollbarEndGap: we,
          totalColumn: Se,
          totalRow: _e
        } = v, ke = i(B), Re = i(D), fe = i(N), Ae = i(x), { scrollLeft: qe, scrollTop: tt } = i(A), Je = je(up, {
          ref: O,
          alwaysOn: ae,
          startGap: Ee,
          endGap: we,
          class: b.e("horizontal"),
          clientSize: ke,
          layout: "horizontal",
          onScroll: Z,
          ratio: ke * 100 / fe,
          scrollFrom: qe / (fe - ke),
          total: _e,
          visible: !0
        }), ye = je(up, {
          ref: T,
          alwaysOn: ae,
          startGap: Ee,
          endGap: we,
          class: b.e("vertical"),
          clientSize: Re,
          layout: "vertical",
          onScroll: U,
          ratio: Re * 100 / Ae,
          scrollFrom: tt / (Ae - Re),
          total: Se,
          visible: !0
        });
        return {
          horizontalScrollbar: Je,
          verticalScrollbar: ye
        };
      }, Q = () => {
        var ae;
        const [Ee, we] = i(F), [Se, _e] = i(W), { data: ke, totalColumn: Re, totalRow: fe, useIsScrolling: Ae, itemKey: qe } = v, tt = [];
        if (fe > 0 && Re > 0)
          for (let Je = Se; Je <= _e; Je++)
            for (let ye = Ee; ye <= we; ye++)
              tt.push((ae = w.default) == null ? void 0 : ae.call(w, {
                columnIndex: ye,
                data: ke,
                key: qe({ columnIndex: ye, data: ke, rowIndex: Je }),
                isScrolling: Ae ? i(A).isScrolling : void 0,
                style: ne(Je, ye),
                rowIndex: Je
              }));
        return tt;
      }, de = () => {
        const ae = vt(v.innerElement), Ee = Q();
        return [
          je(ae, {
            style: i(M),
            ref: P
          }, et(ae) ? Ee : {
            default: () => Ee
          })
        ];
      };
      return () => {
        const ae = vt(v.containerElement), { horizontalScrollbar: Ee, verticalScrollbar: we } = z(), Se = de();
        return je("div", {
          key: 0,
          class: b.e("wrapper"),
          role: v.role
        }, [
          je(ae, {
            class: v.className,
            style: i(R),
            onScroll: te,
            onWheel: pe,
            ref: k
          }, et(ae) ? Se : { default: () => Se }),
          Ee,
          we
        ]);
      };
    }
  }), Ny = "ElFixedSizeGrid", Dq = QE({
    name: "ElFixedSizeGrid",
    getColumnPosition: ({ columnWidth: e }, t) => [
      e,
      t * e
    ],
    getRowPosition: ({ rowHeight: e }, t) => [
      e,
      t * e
    ],
    getEstimatedTotalHeight: ({ totalRow: e, rowHeight: t }) => t * e,
    getEstimatedTotalWidth: ({ totalColumn: e, columnWidth: t }) => t * e,
    getColumnOffset: ({ totalColumn: e, columnWidth: t, width: n }, o, r, s, l, a) => {
      n = Number(n);
      const u = Math.max(0, e * t - n), c = Math.min(u, o * t), f = Math.max(0, o * t - n + a + t);
      switch (r === "smart" && (s >= f - n && s <= c + n ? r = eo : r = Ro), r) {
        case Za:
          return c;
        case Qa:
          return f;
        case Ro: {
          const d = Math.round(f + (c - f) / 2);
          return d < Math.ceil(n / 2) ? 0 : d > u + Math.floor(n / 2) ? u : d;
        }
        case eo:
        default:
          return s >= f && s <= c ? s : f > c || s < f ? f : c;
      }
    },
    getRowOffset: ({ rowHeight: e, height: t, totalRow: n }, o, r, s, l, a) => {
      t = Number(t);
      const u = Math.max(0, n * e - t), c = Math.min(u, o * e), f = Math.max(0, o * e - t + a + e);
      switch (r === nd && (s >= f - t && s <= c + t ? r = eo : r = Ro), r) {
        case Za:
          return c;
        case Qa:
          return f;
        case Ro: {
          const d = Math.round(f + (c - f) / 2);
          return d < Math.ceil(t / 2) ? 0 : d > u + Math.floor(t / 2) ? u : d;
        }
        case eo:
        default:
          return s >= f && s <= c ? s : f > c || s < f ? f : c;
      }
    },
    getColumnStartIndexForOffset: ({ columnWidth: e, totalColumn: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e))),
    getColumnStopIndexForStartIndex: ({ columnWidth: e, totalColumn: t, width: n }, o, r) => {
      const s = o * e, l = Math.ceil((n + r - s) / e);
      return Math.max(0, Math.min(t - 1, o + l - 1));
    },
    getRowStartIndexForOffset: ({ rowHeight: e, totalRow: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e))),
    getRowStopIndexForStartIndex: ({ rowHeight: e, totalRow: t, height: n }, o, r) => {
      const s = o * e, l = Math.ceil((n + r - s) / e);
      return Math.max(0, Math.min(t - 1, o + l - 1));
    },
    initCache: () => {
    },
    clearCache: !0,
    validateProps: ({ columnWidth: e, rowHeight: t }) => {
      process.env.NODE_ENV !== "production" && (Xe(e) || Yt(Ny, `
          "columnWidth" must be passed as number,
            instead ${typeof e} was given.
        `), Xe(t) || Yt(Ny, `
          "columnWidth" must be passed as number,
            instead ${typeof t} was given.
        `));
    }
  }), { max: uc, min: eS, floor: tS } = Math, Ty = "ElDynamicSizeGrid", Lq = {
    column: "columnWidth",
    row: "rowHeight"
  }, cp = {
    column: "lastVisitedColumnIndex",
    row: "lastVisitedRowIndex"
  }, Jo = (e, t, n, o) => {
    const [r, s, l] = [
      n[o],
      e[Lq[o]],
      n[cp[o]]
    ];
    if (t > l) {
      let a = 0;
      if (l >= 0) {
        const u = r[l];
        a = u.offset + u.size;
      }
      for (let u = l + 1; u <= t; u++) {
        const c = s(u);
        r[u] = {
          offset: a,
          size: c
        }, a += c;
      }
      n[cp[o]] = t;
    }
    return r[t];
  }, nS = (e, t, n, o, r, s) => {
    for (; n <= o; ) {
      const l = n + tS((o - n) / 2), a = Jo(e, l, t, s).offset;
      if (a === r)
        return l;
      a < r ? n = l + 1 : o = l - 1;
    }
    return uc(0, n - 1);
  }, Vq = (e, t, n, o, r) => {
    const s = r === "column" ? e.totalColumn : e.totalRow;
    let l = 1;
    for (; n < s && Jo(e, n, t, r).offset < o; )
      n += l, l *= 2;
    return nS(e, t, tS(n / 2), eS(n, s - 1), o, r);
  }, Oy = (e, t, n, o) => {
    const [r, s] = [
      t[o],
      t[cp[o]]
    ];
    return (s > 0 ? r[s].offset : 0) >= n ? nS(e, t, 0, s, n, o) : Vq(e, t, uc(0, s), n, o);
  }, oS = ({ totalRow: e }, { estimatedRowHeight: t, lastVisitedRowIndex: n, row: o }) => {
    let r = 0;
    if (n >= e && (n = e - 1), n >= 0) {
      const a = o[n];
      r = a.offset + a.size;
    }
    const l = (e - n - 1) * t;
    return r + l;
  }, rS = ({ totalColumn: e }, { column: t, estimatedColumnWidth: n, lastVisitedColumnIndex: o }) => {
    let r = 0;
    if (o > e && (o = e - 1), o >= 0) {
      const a = t[o];
      r = a.offset + a.size;
    }
    const l = (e - o - 1) * n;
    return r + l;
  }, Bq = {
    column: rS,
    row: oS
  }, My = (e, t, n, o, r, s, l) => {
    const [a, u] = [
      s === "row" ? e.height : e.width,
      Bq[s]
    ], c = Jo(e, t, r, s), f = u(e, r), d = uc(0, eS(f - a, c.offset)), p = uc(0, c.offset - a + l + c.size);
    switch (n === nd && (o >= p - a && o <= d + a ? n = eo : n = Ro), n) {
      case Za:
        return d;
      case Qa:
        return p;
      case Ro:
        return Math.round(p + (d - p) / 2);
      case eo:
      default:
        return o >= p && o <= d ? o : p > d || o < p ? p : d;
    }
  }, Fq = QE({
    name: "ElDynamicSizeGrid",
    getColumnPosition: (e, t, n) => {
      const o = Jo(e, t, n, "column");
      return [o.size, o.offset];
    },
    getRowPosition: (e, t, n) => {
      const o = Jo(e, t, n, "row");
      return [o.size, o.offset];
    },
    getColumnOffset: (e, t, n, o, r, s) => My(e, t, n, o, r, "column", s),
    getRowOffset: (e, t, n, o, r, s) => My(e, t, n, o, r, "row", s),
    getColumnStartIndexForOffset: (e, t, n) => Oy(e, n, t, "column"),
    getColumnStopIndexForStartIndex: (e, t, n, o) => {
      const r = Jo(e, t, o, "column"), s = n + e.width;
      let l = r.offset + r.size, a = t;
      for (; a < e.totalColumn - 1 && l < s; )
        a++, l += Jo(e, t, o, "column").size;
      return a;
    },
    getEstimatedTotalHeight: oS,
    getEstimatedTotalWidth: rS,
    getRowStartIndexForOffset: (e, t, n) => Oy(e, n, t, "row"),
    getRowStopIndexForStartIndex: (e, t, n, o) => {
      const { totalRow: r, height: s } = e, l = Jo(e, t, o, "row"), a = n + s;
      let u = l.size + l.offset, c = t;
      for (; c < r - 1 && u < a; )
        c++, u += Jo(e, c, o, "row").size;
      return c;
    },
    injectToInstance: (e, t) => {
      const n = ({ columnIndex: s, rowIndex: l }, a) => {
        var u, c;
        a = pn(a) ? !0 : a, Xe(s) && (t.value.lastVisitedColumnIndex = Math.min(t.value.lastVisitedColumnIndex, s - 1)), Xe(l) && (t.value.lastVisitedRowIndex = Math.min(t.value.lastVisitedRowIndex, l - 1)), (u = e.exposed) == null || u.getItemStyleCache.value(-1, null, null), a && ((c = e.proxy) == null || c.$forceUpdate());
      }, o = (s, l) => {
        n({
          columnIndex: s
        }, l);
      }, r = (s, l) => {
        n({
          rowIndex: s
        }, l);
      };
      Object.assign(e.proxy, {
        resetAfterColumnIndex: o,
        resetAfterRowIndex: r,
        resetAfter: n
      });
    },
    initCache: ({
      estimatedColumnWidth: e = op,
      estimatedRowHeight: t = op
    }) => ({
      column: {},
      estimatedColumnWidth: e,
      estimatedRowHeight: t,
      lastVisitedColumnIndex: -1,
      lastVisitedRowIndex: -1,
      row: {}
    }),
    clearCache: !1,
    validateProps: ({ columnWidth: e, rowHeight: t }) => {
      process.env.NODE_ENV !== "production" && (Ge(e) || Yt(Ty, `
          "columnWidth" must be passed as function,
            instead ${typeof e} was given.
        `), Ge(t) || Yt(Ty, `
          "rowHeight" must be passed as function,
            instead ${typeof t} was given.
        `));
    }
  }), Hq = G({
    props: {
      item: {
        type: Object,
        required: !0
      },
      style: Object,
      height: Number
    },
    setup() {
      return {
        ns: ge("select")
      };
    }
  });
  function zq(e, t, n, o, r, s) {
    return e.item.isTitle ? (S(), V("div", {
      key: 0,
      class: $(e.ns.be("group", "title")),
      style: Ke([e.style, { lineHeight: `${e.height}px` }])
    }, Ne(e.item.label), 7)) : (S(), V("div", {
      key: 1,
      class: $(e.ns.be("group", "split")),
      style: Ke(e.style)
    }, [
      H("span", {
        class: $(e.ns.be("group", "split-dash")),
        style: Ke({ top: `${e.height / 2}px` })
      }, null, 6)
    ], 6));
  }
  var Kq = /* @__PURE__ */ Me(Hq, [["render", zq], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/group-item.vue"]]);
  function jq(e, { emit: t }) {
    return {
      hoverItem: () => {
        e.disabled || t("hover", e.index);
      },
      selectOptionClick: () => {
        e.disabled || t("select", e.item, e.index);
      }
    };
  }
  const Wq = {
    allowCreate: Boolean,
    autocomplete: {
      type: String,
      default: "none"
    },
    automaticDropdown: Boolean,
    clearable: Boolean,
    clearIcon: {
      type: [String, Object],
      default: Yr
    },
    effect: {
      type: String,
      default: "light"
    },
    collapseTags: Boolean,
    collapseTagsTooltip: {
      type: Boolean,
      default: !1
    },
    maxCollapseTags: {
      type: Number,
      default: 1
    },
    defaultFirstOption: Boolean,
    disabled: Boolean,
    estimatedOptionHeight: {
      type: Number,
      default: void 0
    },
    filterable: Boolean,
    filterMethod: Function,
    height: {
      type: Number,
      default: 170
    },
    itemHeight: {
      type: Number,
      default: 34
    },
    id: String,
    loading: Boolean,
    loadingText: String,
    label: String,
    modelValue: [Array, String, Number, Boolean, Object],
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    name: String,
    noDataText: String,
    noMatchText: String,
    remoteMethod: Function,
    reserveKeyword: {
      type: Boolean,
      default: !0
    },
    options: {
      type: Array,
      required: !0
    },
    placeholder: {
      type: String
    },
    teleported: dn.teleported,
    persistent: {
      type: Boolean,
      default: !0
    },
    popperClass: {
      type: String,
      default: ""
    },
    popperOptions: {
      type: Object,
      default: () => ({})
    },
    remote: Boolean,
    size: {
      type: String,
      validator: zc
    },
    valueKey: {
      type: String,
      default: "value"
    },
    scrollbarAlwaysOn: {
      type: Boolean,
      default: !1
    },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    placement: {
      type: le(String),
      values: Bs,
      default: "bottom-start"
    }
  }, Uq = {
    data: Array,
    disabled: Boolean,
    hovering: Boolean,
    item: Object,
    index: Number,
    style: Object,
    selected: Boolean,
    created: Boolean
  }, qq = G({
    props: Uq,
    emits: ["select", "hover"],
    setup(e, { emit: t }) {
      const n = ge("select"), { hoverItem: o, selectOptionClick: r } = jq(e, { emit: t });
      return {
        ns: n,
        hoverItem: o,
        selectOptionClick: r
      };
    }
  }), Yq = ["aria-selected"];
  function Gq(e, t, n, o, r, s) {
    return S(), V("li", {
      "aria-selected": e.selected,
      style: Ke(e.style),
      class: $([
        e.ns.be("dropdown", "option-item"),
        e.ns.is("selected", e.selected),
        e.ns.is("disabled", e.disabled),
        e.ns.is("created", e.created),
        { hover: e.hovering }
      ]),
      onMouseenter: t[0] || (t[0] = (...l) => e.hoverItem && e.hoverItem(...l)),
      onClick: t[1] || (t[1] = Ze((...l) => e.selectOptionClick && e.selectOptionClick(...l), ["stop"]))
    }, [
      he(e.$slots, "default", {
        item: e.item,
        index: e.index,
        disabled: e.disabled
      }, () => [
        H("span", null, Ne(e.item.label), 1)
      ])
    ], 46, Yq);
  }
  var Xq = /* @__PURE__ */ Me(qq, [["render", Gq], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/option-item.vue"]]);
  const sS = Symbol("ElSelectV2Injection");
  var Jq = G({
    name: "ElSelectDropdown",
    props: {
      data: {
        type: Array,
        required: !0
      },
      hoveringIndex: Number,
      width: Number
    },
    setup(e, {
      slots: t,
      expose: n
    }) {
      const o = Be(sS), r = ge("select"), s = I([]), l = I(), a = E(() => e.data.length);
      me(() => a.value, () => {
        var T, P;
        (P = (T = o.popper.value).updatePopper) == null || P.call(T);
      });
      const u = E(() => pn(o.props.estimatedOptionHeight)), c = E(() => u.value ? {
        itemSize: o.props.itemHeight
      } : {
        estimatedSize: o.props.estimatedOptionHeight,
        itemSize: (T) => s.value[T]
      }), f = (T = [], P) => {
        const {
          props: {
            valueKey: A
          }
        } = o;
        return rt(P) ? T && T.some((L) => Kt(L, A) === Kt(P, A)) : T.includes(P);
      }, d = (T, P) => {
        if (rt(P)) {
          const {
            valueKey: A
          } = o.props;
          return Kt(T, A) === Kt(P, A);
        } else
          return T === P;
      }, p = (T, P) => {
        const {
          valueKey: A
        } = o.props;
        return o.props.multiple ? f(T, Kt(P, A)) : d(T, Kt(P, A));
      }, h = (T, P) => {
        const {
          disabled: A,
          multiple: L,
          multipleLimit: D
        } = o.props;
        return A || !P && (L ? D > 0 && T.length >= D : !1);
      }, m = (T) => e.hoveringIndex === T;
      n({
        listRef: l,
        isSized: u,
        isItemDisabled: h,
        isItemHovering: m,
        isItemSelected: p,
        scrollToItem: (T) => {
          const P = l.value;
          P && P.scrollToItem(T);
        },
        resetScrollTop: () => {
          const T = l.value;
          T && T.resetScrollTop();
        }
      });
      const y = (T) => {
        const {
          index: P,
          data: A,
          style: L
        } = T, D = i(u), {
          itemSize: B,
          estimatedSize: F
        } = i(c), {
          modelValue: W
        } = o.props, {
          onSelect: x,
          onHover: N
        } = o, R = A[P];
        if (R.type === "Group")
          return K(Kq, {
            item: R,
            style: L,
            height: D ? B : F
          }, null);
        const M = p(W, R), j = h(W, M), te = m(P);
        return K(Xq, ft(T, {
          selected: M,
          disabled: R.disabled || j,
          created: !!R.created,
          hovering: te,
          item: R,
          onSelect: x,
          onHover: N
        }), {
          default: (U) => {
            var Z;
            return ((Z = t.default) == null ? void 0 : Z.call(t, U)) || K("span", null, [R.label]);
          }
        });
      }, {
        onKeyboardNavigate: w,
        onKeyboardSelect: b
      } = o, C = () => {
        w("forward");
      }, _ = () => {
        w("backward");
      }, k = () => {
        o.expanded = !1;
      }, O = (T) => {
        const {
          code: P
        } = T, {
          tab: A,
          esc: L,
          down: D,
          up: B,
          enter: F
        } = We;
        switch (P !== A && (T.preventDefault(), T.stopPropagation()), P) {
          case A:
          case L: {
            k();
            break;
          }
          case D: {
            C();
            break;
          }
          case B: {
            _();
            break;
          }
          case F: {
            b();
            break;
          }
        }
      };
      return () => {
        var T;
        const {
          data: P,
          width: A
        } = e, {
          height: L,
          multiple: D,
          scrollbarAlwaysOn: B
        } = o.props;
        if (P.length === 0)
          return K("div", {
            class: r.b("dropdown"),
            style: {
              width: `${A}px`
            }
          }, [(T = t.empty) == null ? void 0 : T.call(t)]);
        const F = i(u) ? JE : Rq;
        return K("div", {
          class: [r.b("dropdown"), r.is("multiple", D)]
        }, [K(F, ft({
          ref: l
        }, i(c), {
          className: r.be("dropdown", "list"),
          scrollbarAlwaysOn: B,
          data: P,
          height: L,
          width: A,
          total: P.length,
          onKeydown: O
        }), {
          default: (W) => K(y, W, null)
        })]);
      };
    }
  });
  function Zq(e, t) {
    const n = I(0), o = I(null), r = E(() => e.allowCreate && e.filterable);
    function s(f) {
      const d = (p) => p.value === f;
      return e.options && e.options.some(d) || t.createdOptions.some(d);
    }
    function l(f) {
      !r.value || (e.multiple && f.created ? n.value++ : o.value = f);
    }
    function a(f) {
      if (r.value)
        if (f && f.length > 0 && !s(f)) {
          const d = {
            value: f,
            label: f,
            created: !0,
            disabled: !1
          };
          t.createdOptions.length >= n.value ? t.createdOptions[n.value] = d : t.createdOptions.push(d);
        } else if (e.multiple)
          t.createdOptions.length = n.value;
        else {
          const d = o.value;
          t.createdOptions.length = 0, d && d.created && t.createdOptions.push(d);
        }
    }
    function u(f) {
      if (!r.value || !f || !f.created || f.created && e.reserveKeyword && t.inputValue === f.label)
        return;
      const d = t.createdOptions.findIndex((p) => p.value === f.value);
      ~d && (t.createdOptions.splice(d, 1), n.value--);
    }
    function c() {
      r.value && (t.createdOptions.length = 0, n.value = 0);
    }
    return {
      createNewOption: a,
      removeNewOption: u,
      selectNewOption: l,
      clearAllNewOption: c
    };
  }
  const Qq = (e) => {
    const t = [];
    return e.forEach((n) => {
      De(n.options) ? (t.push({
        label: n.label,
        isTitle: !0,
        type: "Group"
      }), n.options.forEach((o) => {
        t.push(o);
      }), t.push({
        type: "Group"
      })) : t.push(n);
    }), t;
  };
  function eY(e) {
    const t = I(!1);
    return {
      handleCompositionStart: () => {
        t.value = !0;
      },
      handleCompositionUpdate: (s) => {
        const l = s.target.value, a = l[l.length - 1] || "";
        t.value = !Kc(a);
      },
      handleCompositionEnd: (s) => {
        t.value && (t.value = !1, Ge(e) && e(s));
      }
    };
  }
  const Iy = "", Py = 11, tY = {
    larget: 51,
    default: 42,
    small: 33
  }, nY = (e, t) => {
    const { t: n } = St(), o = ge("select-v2"), r = ge("input"), { form: s, formItem: l } = In(), a = Tt({
      inputValue: Iy,
      displayInputValue: Iy,
      calculatedWidth: 0,
      cachedPlaceholder: "",
      cachedOptions: [],
      createdOptions: [],
      createdLabel: "",
      createdSelected: !1,
      currentPlaceholder: "",
      hoveringIndex: -1,
      comboBoxHovering: !1,
      isOnComposition: !1,
      isSilentBlur: !1,
      isComposing: !1,
      inputLength: 20,
      selectWidth: 200,
      initialInputHeight: 0,
      previousQuery: null,
      previousValue: void 0,
      query: "",
      selectedLabel: "",
      softFocus: !1,
      tagInMultiLine: !1
    }), u = I(-1), c = I(-1), f = I(null), d = I(null), p = I(null), h = I(null), m = I(null), v = I(null), g = I(null), y = I(!1), w = E(() => e.disabled || (s == null ? void 0 : s.disabled)), b = E(() => {
      const $e = D.value.length * 34;
      return $e > e.height ? e.height : $e;
    }), C = E(() => !nn(e.modelValue)), _ = E(() => {
      const $e = e.multiple ? Array.isArray(e.modelValue) && e.modelValue.length > 0 : C.value;
      return e.clearable && !w.value && a.comboBoxHovering && $e;
    }), k = E(() => e.remote && e.filterable ? "" : Bc), O = E(() => k.value && o.is("reverse", y.value)), T = E(() => (l == null ? void 0 : l.validateState) || ""), P = E(() => ow[T.value]), A = E(() => e.remote ? 300 : 0), L = E(() => {
      const $e = D.value;
      return e.loading ? e.loadingText || n("el.select.loading") : e.remote && a.inputValue === "" && $e.length === 0 ? !1 : e.filterable && a.inputValue && $e.length > 0 ? e.noMatchText || n("el.select.noMatch") : $e.length === 0 ? e.noDataText || n("el.select.noData") : null;
    }), D = E(() => {
      const $e = (Ye) => {
        const _t = a.inputValue, kt = new RegExp(W1(_t), "i");
        return _t ? kt.test(Ye.label || "") : !0;
      };
      return e.loading ? [] : Qq(e.options.concat(a.createdOptions).map((Ye) => {
        if (De(Ye.options)) {
          const _t = Ye.options.filter($e);
          if (_t.length > 0)
            return {
              ...Ye,
              options: _t
            };
        } else if (e.remote || $e(Ye))
          return Ye;
        return null;
      }).filter((Ye) => Ye !== null));
    }), B = E(() => D.value.every(($e) => $e.disabled)), F = on(), W = E(() => F.value === "small" ? "small" : "default"), x = E(() => {
      const $e = v.value, Ye = W.value || "default", _t = $e ? Number.parseInt(getComputedStyle($e).paddingLeft) : 0, kt = $e ? Number.parseInt(getComputedStyle($e).paddingRight) : 0;
      return a.selectWidth - kt - _t - tY[Ye];
    }), N = () => {
      var $e;
      c.value = (($e = m.value) == null ? void 0 : $e.offsetWidth) || 200;
    }, R = E(() => ({
      width: `${a.calculatedWidth === 0 ? Py : Math.ceil(a.calculatedWidth) + Py}px`
    })), M = E(() => De(e.modelValue) ? e.modelValue.length === 0 && !a.displayInputValue : e.filterable ? a.displayInputValue.length === 0 : !0), j = E(() => {
      const $e = e.placeholder || n("el.select.placeholder");
      return e.multiple || nn(e.modelValue) ? $e : a.selectedLabel;
    }), te = E(() => {
      var $e, Ye;
      return (Ye = ($e = h.value) == null ? void 0 : $e.popperRef) == null ? void 0 : Ye.contentRef;
    }), U = E(() => {
      if (e.multiple) {
        const $e = e.modelValue.length;
        if (e.modelValue.length > 0)
          return D.value.findIndex((Ye) => Ye.value === e.modelValue[$e - 1]);
      } else if (e.modelValue)
        return D.value.findIndex(($e) => $e.value === e.modelValue);
      return -1;
    }), Z = E({
      get() {
        return y.value && L.value !== !1;
      },
      set($e) {
        y.value = $e;
      }
    }), pe = E(() => a.cachedOptions.slice(0, e.maxCollapseTags)), J = E(() => a.cachedOptions.slice(e.maxCollapseTags)), {
      createNewOption: ee,
      removeNewOption: ne,
      selectNewOption: Y,
      clearAllNewOption: re
    } = Zq(e, a), {
      handleCompositionStart: ce,
      handleCompositionUpdate: Te,
      handleCompositionEnd: Pe
    } = eY(($e) => lt($e)), z = () => {
      var $e, Ye, _t;
      (Ye = ($e = d.value) == null ? void 0 : $e.focus) == null || Ye.call($e), (_t = h.value) == null || _t.updatePopper();
    }, Q = () => {
      if (!e.automaticDropdown && !w.value)
        return a.isComposing && (a.softFocus = !0), Fe(() => {
          var $e, Ye;
          y.value = !y.value, (Ye = ($e = d.value) == null ? void 0 : $e.focus) == null || Ye.call($e);
        });
    }, de = () => (e.filterable && a.inputValue !== a.selectedLabel && (a.query = a.selectedLabel), ae(a.inputValue), Fe(() => {
      ee(a.inputValue);
    })), Oe = On(de, A.value), ae = ($e) => {
      a.previousQuery !== $e && (a.previousQuery = $e, e.filterable && Ge(e.filterMethod) ? e.filterMethod($e) : e.filterable && e.remote && Ge(e.remoteMethod) && e.remoteMethod($e));
    }, Ee = ($e) => {
      qn(e.modelValue, $e) || t(Ft, $e);
    }, we = ($e) => {
      t(dt, $e), Ee($e), a.previousValue = $e == null ? void 0 : $e.toString();
    }, Se = ($e = [], Ye) => {
      if (!rt(Ye))
        return $e.indexOf(Ye);
      const _t = e.valueKey;
      let kt = -1;
      return $e.some((cn, No) => Kt(cn, _t) === Kt(Ye, _t) ? (kt = No, !0) : !1), kt;
    }, _e = ($e) => rt($e) ? Kt($e, e.valueKey) : $e, ke = ($e) => rt($e) ? $e.label : $e, Re = () => Fe(() => {
      var $e, Ye;
      if (!d.value)
        return;
      const _t = v.value;
      m.value.height = _t.offsetHeight, y.value && L.value !== !1 && ((Ye = ($e = h.value) == null ? void 0 : $e.updatePopper) == null || Ye.call($e));
    }), fe = () => {
      var $e, Ye;
      if (Ae(), N(), (Ye = ($e = h.value) == null ? void 0 : $e.updatePopper) == null || Ye.call($e), e.multiple)
        return Re();
    }, Ae = () => {
      const $e = v.value;
      $e && (a.selectWidth = $e.getBoundingClientRect().width);
    }, qe = ($e, Ye, _t = !0) => {
      var kt, cn;
      if (e.multiple) {
        let No = e.modelValue.slice();
        const Mi = Se(No, _e($e));
        Mi > -1 ? (No = [
          ...No.slice(0, Mi),
          ...No.slice(Mi + 1)
        ], a.cachedOptions.splice(Mi, 1), ne($e)) : (e.multipleLimit <= 0 || No.length < e.multipleLimit) && (No = [...No, _e($e)], a.cachedOptions.push($e), Y($e), nt(Ye)), we(No), $e.created && (a.query = "", ae(""), a.inputLength = 20), e.filterable && !e.reserveKeyword && ((cn = (kt = d.value).focus) == null || cn.call(kt), oe("")), e.filterable && (a.calculatedWidth = g.value.getBoundingClientRect().width), Re(), Le();
      } else
        u.value = Ye, a.selectedLabel = $e.label, we(_e($e)), y.value = !1, a.isComposing = !1, a.isSilentBlur = _t, Y($e), $e.created || re(), nt(Ye);
    }, tt = ($e, Ye) => {
      const { valueKey: _t } = e, kt = e.modelValue.indexOf(Kt(Ye, _t));
      if (kt > -1 && !w.value) {
        const cn = [
          ...e.modelValue.slice(0, kt),
          ...e.modelValue.slice(kt + 1)
        ];
        return a.cachedOptions.splice(kt, 1), we(cn), t("remove-tag", Kt(Ye, _t)), a.softFocus = !0, ne(Ye), Fe(z);
      }
      $e.stopPropagation();
    }, Je = ($e) => {
      const Ye = a.isComposing;
      a.isComposing = !0, a.softFocus ? a.softFocus = !1 : Ye || t("focus", $e);
    }, ye = ($e) => (a.softFocus = !1, Fe(() => {
      var Ye, _t;
      (_t = (Ye = d.value) == null ? void 0 : Ye.blur) == null || _t.call(Ye), g.value && (a.calculatedWidth = g.value.getBoundingClientRect().width), a.isSilentBlur ? a.isSilentBlur = !1 : a.isComposing && t("blur", $e), a.isComposing = !1;
    })), Ce = () => {
      a.displayInputValue.length > 0 ? oe("") : y.value = !1;
    }, ue = ($e) => {
      if (a.displayInputValue.length === 0) {
        $e.preventDefault();
        const Ye = e.modelValue.slice();
        Ye.pop(), ne(a.cachedOptions.pop()), we(Ye);
      }
    }, q = () => {
      let $e;
      return De(e.modelValue) ? $e = [] : $e = void 0, a.softFocus = !0, e.multiple ? a.cachedOptions = [] : a.selectedLabel = "", y.value = !1, we($e), t("clear"), re(), Fe(z);
    }, oe = ($e) => {
      a.displayInputValue = $e, a.inputValue = $e;
    }, be = ($e, Ye = void 0) => {
      const _t = D.value;
      if (!["forward", "backward"].includes($e) || w.value || _t.length <= 0 || B.value)
        return;
      if (!y.value)
        return Q();
      Ye === void 0 && (Ye = a.hoveringIndex);
      let kt = -1;
      $e === "forward" ? (kt = Ye + 1, kt >= _t.length && (kt = 0)) : $e === "backward" && (kt = Ye - 1, (kt < 0 || kt >= _t.length) && (kt = _t.length - 1));
      const cn = _t[kt];
      if (cn.disabled || cn.type === "Group")
        return be($e, kt);
      nt(kt), Mt(kt);
    }, xe = () => {
      if (y.value)
        ~a.hoveringIndex && D.value[a.hoveringIndex] && qe(D.value[a.hoveringIndex], a.hoveringIndex, !1);
      else
        return Q();
    }, nt = ($e) => {
      a.hoveringIndex = $e;
    }, ve = () => {
      a.hoveringIndex = -1;
    }, Le = () => {
      var $e;
      const Ye = d.value;
      Ye && (($e = Ye.focus) == null || $e.call(Ye));
    }, lt = ($e) => {
      const Ye = $e.target.value;
      if (oe(Ye), a.displayInputValue.length > 0 && !y.value && (y.value = !0), a.calculatedWidth = g.value.getBoundingClientRect().width, e.multiple && Re(), e.remote)
        Oe();
      else
        return de();
    }, ct = () => (y.value = !1, ye()), mt = () => (a.inputValue = a.displayInputValue, Fe(() => {
      ~U.value && (nt(U.value), Mt(a.hoveringIndex));
    })), Mt = ($e) => {
      p.value.scrollToItem($e);
    }, ln = () => {
      if (ve(), e.multiple)
        if (e.modelValue.length > 0) {
          let $e = !1;
          a.cachedOptions.length = 0, a.previousValue = e.modelValue.toString(), e.modelValue.forEach((Ye) => {
            const _t = D.value.findIndex((kt) => _e(kt) === Ye);
            ~_t && (a.cachedOptions.push(D.value[_t]), $e || nt(_t), $e = !0);
          });
        } else
          a.cachedOptions = [], a.previousValue = void 0;
      else if (C.value) {
        a.previousValue = e.modelValue;
        const $e = D.value, Ye = $e.findIndex((_t) => _e(_t) === _e(e.modelValue));
        ~Ye ? (a.selectedLabel = $e[Ye].label, nt(Ye)) : a.selectedLabel = `${e.modelValue}`;
      } else
        a.selectedLabel = "", a.previousValue = void 0;
      re(), N();
    };
    return me(y, ($e) => {
      var Ye, _t;
      t("visible-change", $e), $e ? (_t = (Ye = h.value).update) == null || _t.call(Ye) : (a.displayInputValue = "", a.previousQuery = null, ee(""));
    }), me(() => e.modelValue, ($e, Ye) => {
      var _t;
      (!$e || $e.toString() !== a.previousValue) && ln(), !qn($e, Ye) && e.validateEvent && ((_t = l == null ? void 0 : l.validate) == null || _t.call(l, "change").catch((kt) => yt(kt)));
    }, {
      deep: !0
    }), me(() => e.options, () => {
      const $e = d.value;
      (!$e || $e && document.activeElement !== $e) && ln();
    }, {
      deep: !0
    }), me(D, () => Fe(p.value.resetScrollTop)), me(() => Z.value, ($e) => {
      $e || ve();
    }), st(() => {
      ln();
    }), Cn(m, fe), {
      collapseTagSize: W,
      currentPlaceholder: j,
      expanded: y,
      emptyText: L,
      popupHeight: b,
      debounce: A,
      filteredOptions: D,
      iconComponent: k,
      iconReverse: O,
      inputWrapperStyle: R,
      popperSize: c,
      dropdownMenuVisible: Z,
      hasModelValue: C,
      shouldShowPlaceholder: M,
      selectDisabled: w,
      selectSize: F,
      showClearBtn: _,
      states: a,
      tagMaxWidth: x,
      nsSelectV2: o,
      nsInput: r,
      calculatorRef: g,
      controlRef: f,
      inputRef: d,
      menuRef: p,
      popper: h,
      selectRef: m,
      selectionRef: v,
      popperRef: te,
      validateState: T,
      validateIcon: P,
      showTagList: pe,
      collapseTagList: J,
      debouncedOnInputChange: Oe,
      deleteTag: tt,
      getLabel: ke,
      getValueKey: _e,
      handleBlur: ye,
      handleClear: q,
      handleClickOutside: ct,
      handleDel: ue,
      handleEsc: Ce,
      handleFocus: Je,
      handleMenuEnter: mt,
      handleResize: fe,
      toggleMenu: Q,
      scrollTo: Mt,
      onInput: lt,
      onKeyboardNavigate: be,
      onKeyboardSelect: xe,
      onSelect: qe,
      onHover: nt,
      onUpdateInputValue: oe,
      handleCompositionStart: ce,
      handleCompositionEnd: Pe,
      handleCompositionUpdate: Te
    };
  }, oY = G({
    name: "ElSelectV2",
    components: {
      ElSelectMenu: Jq,
      ElTag: Xa,
      ElTooltip: Mn,
      ElIcon: He
    },
    directives: { ClickOutside: Kr, ModelText: th },
    props: Wq,
    emits: [
      dt,
      Ft,
      "remove-tag",
      "clear",
      "visible-change",
      "focus",
      "blur"
    ],
    setup(e, { emit: t }) {
      const n = E(() => {
        const { modelValue: r, multiple: s } = e, l = s ? [] : void 0;
        return De(r) ? s ? r : l : s ? l : r;
      }), o = nY(Tt({
        ...rn(e),
        modelValue: n
      }), t);
      return pt(sS, {
        props: Tt({
          ...rn(e),
          height: o.popupHeight,
          modelValue: n
        }),
        popper: o.popper,
        onSelect: o.onSelect,
        onHover: o.onHover,
        onKeyboardNavigate: o.onKeyboardNavigate,
        onKeyboardSelect: o.onKeyboardSelect
      }), {
        ...o,
        modelValue: n
      };
    }
  }), rY = { key: 0 }, sY = ["id", "autocomplete", "aria-expanded", "aria-labelledby", "disabled", "readonly", "name", "unselectable"], lY = ["textContent"], aY = ["id", "aria-labelledby", "aria-expanded", "autocomplete", "disabled", "name", "readonly", "unselectable"], iY = ["textContent"];
  function uY(e, t, n, o, r, s) {
    const l = Qe("el-tag"), a = Qe("el-tooltip"), u = Qe("el-icon"), c = Qe("el-select-menu"), f = Aa("model-text"), d = Aa("click-outside");
    return ot((S(), V("div", {
      ref: "selectRef",
      class: $([e.nsSelectV2.b(), e.nsSelectV2.m(e.selectSize)]),
      onClick: t[24] || (t[24] = Ze((...p) => e.toggleMenu && e.toggleMenu(...p), ["stop"])),
      onMouseenter: t[25] || (t[25] = (p) => e.states.comboBoxHovering = !0),
      onMouseleave: t[26] || (t[26] = (p) => e.states.comboBoxHovering = !1)
    }, [
      K(a, {
        ref: "popper",
        visible: e.dropdownMenuVisible,
        teleported: e.teleported,
        "popper-class": [e.nsSelectV2.e("popper"), e.popperClass],
        "gpu-acceleration": !1,
        "stop-popper-mouse-event": !1,
        "popper-options": e.popperOptions,
        "fallback-placements": ["bottom-start", "top-start", "right", "left"],
        effect: e.effect,
        placement: e.placement,
        pure: "",
        transition: `${e.nsSelectV2.namespace.value}-zoom-in-top`,
        trigger: "click",
        persistent: e.persistent,
        onBeforeShow: e.handleMenuEnter,
        onHide: t[23] || (t[23] = (p) => e.states.inputValue = e.states.displayInputValue)
      }, {
        default: X(() => [
          H("div", {
            ref: "selectionRef",
            class: $([
              e.nsSelectV2.e("wrapper"),
              e.nsSelectV2.is("focused", e.states.isComposing || e.expanded),
              e.nsSelectV2.is("hovering", e.states.comboBoxHovering),
              e.nsSelectV2.is("filterable", e.filterable),
              e.nsSelectV2.is("disabled", e.selectDisabled)
            ])
          }, [
            e.$slots.prefix ? (S(), V("div", rY, [
              he(e.$slots, "prefix")
            ])) : se("v-if", !0),
            e.multiple ? (S(), V("div", {
              key: 1,
              class: $(e.nsSelectV2.e("selection"))
            }, [
              e.collapseTags && e.modelValue.length > 0 ? (S(), V(ze, { key: 0 }, [
                (S(!0), V(ze, null, gt(e.showTagList, (p) => (S(), V("div", {
                  key: e.getValueKey(p),
                  class: $(e.nsSelectV2.e("selected-item"))
                }, [
                  K(l, {
                    closable: !e.selectDisabled && !(p != null && p.disable),
                    size: e.collapseTagSize,
                    type: "info",
                    "disable-transitions": "",
                    onClose: (h) => e.deleteTag(h, p)
                  }, {
                    default: X(() => [
                      H("span", {
                        class: $(e.nsSelectV2.e("tags-text")),
                        style: Ke({
                          maxWidth: `${e.tagMaxWidth}px`
                        })
                      }, Ne(p == null ? void 0 : p.label), 7)
                    ]),
                    _: 2
                  }, 1032, ["closable", "size", "onClose"])
                ], 2))), 128)),
                H("div", {
                  class: $(e.nsSelectV2.e("selected-item"))
                }, [
                  e.modelValue.length > e.maxCollapseTags ? (S(), ie(l, {
                    key: 0,
                    closable: !1,
                    size: e.collapseTagSize,
                    type: "info",
                    "disable-transitions": ""
                  }, {
                    default: X(() => [
                      e.collapseTagsTooltip ? (S(), ie(a, {
                        key: 0,
                        disabled: e.dropdownMenuVisible,
                        "fallback-placements": ["bottom", "top", "right", "left"],
                        effect: e.effect,
                        placement: "bottom",
                        teleported: !1
                      }, {
                        default: X(() => [
                          H("span", {
                            class: $(e.nsSelectV2.e("tags-text")),
                            style: Ke({
                              maxWidth: `${e.tagMaxWidth}px`
                            })
                          }, "+ " + Ne(e.modelValue.length - e.maxCollapseTags), 7)
                        ]),
                        content: X(() => [
                          H("div", {
                            class: $(e.nsSelectV2.e("selection"))
                          }, [
                            (S(!0), V(ze, null, gt(e.collapseTagList, (p) => (S(), V("div", {
                              key: e.getValueKey(p),
                              class: $(e.nsSelectV2.e("selected-item"))
                            }, [
                              K(l, {
                                closable: !e.selectDisabled && !p.disabled,
                                size: e.collapseTagSize,
                                class: "in-tooltip",
                                type: "info",
                                "disable-transitions": "",
                                onClose: (h) => e.deleteTag(h, p)
                              }, {
                                default: X(() => [
                                  H("span", {
                                    class: $(e.nsSelectV2.e("tags-text")),
                                    style: Ke({
                                      maxWidth: `${e.tagMaxWidth}px`
                                    })
                                  }, Ne(e.getLabel(p)), 7)
                                ]),
                                _: 2
                              }, 1032, ["closable", "size", "onClose"])
                            ], 2))), 128))
                          ], 2)
                        ]),
                        _: 1
                      }, 8, ["disabled", "effect"])) : (S(), V("span", {
                        key: 1,
                        class: $(e.nsSelectV2.e("tags-text")),
                        style: Ke({
                          maxWidth: `${e.tagMaxWidth}px`
                        })
                      }, "+ " + Ne(e.modelValue.length - e.maxCollapseTags), 7))
                    ]),
                    _: 1
                  }, 8, ["size"])) : se("v-if", !0)
                ], 2)
              ], 64)) : (S(!0), V(ze, { key: 1 }, gt(e.states.cachedOptions, (p) => (S(), V("div", {
                key: e.getValueKey(p),
                class: $(e.nsSelectV2.e("selected-item"))
              }, [
                K(l, {
                  closable: !e.selectDisabled && !p.disabled,
                  size: e.collapseTagSize,
                  type: "info",
                  "disable-transitions": "",
                  onClose: (h) => e.deleteTag(h, p)
                }, {
                  default: X(() => [
                    H("span", {
                      class: $(e.nsSelectV2.e("tags-text")),
                      style: Ke({
                        maxWidth: `${e.tagMaxWidth}px`
                      })
                    }, Ne(e.getLabel(p)), 7)
                  ]),
                  _: 2
                }, 1032, ["closable", "size", "onClose"])
              ], 2))), 128)),
              H("div", {
                class: $([
                  e.nsSelectV2.e("selected-item"),
                  e.nsSelectV2.e("input-wrapper")
                ]),
                style: Ke(e.inputWrapperStyle)
              }, [
                ot(H("input", {
                  id: e.id,
                  ref: "inputRef",
                  autocomplete: e.autocomplete,
                  "aria-autocomplete": "list",
                  "aria-haspopup": "listbox",
                  autocapitalize: "off",
                  "aria-expanded": e.expanded,
                  "aria-labelledby": e.label,
                  class: $([
                    e.nsSelectV2.is(e.selectSize),
                    e.nsSelectV2.e("combobox-input")
                  ]),
                  disabled: e.disabled,
                  role: "combobox",
                  readonly: !e.filterable,
                  spellcheck: "false",
                  type: "text",
                  name: e.name,
                  unselectable: e.expanded ? "on" : void 0,
                  "onUpdate:modelValue": t[0] || (t[0] = (...p) => e.onUpdateInputValue && e.onUpdateInputValue(...p)),
                  onFocus: t[1] || (t[1] = (...p) => e.handleFocus && e.handleFocus(...p)),
                  onBlur: t[2] || (t[2] = (...p) => e.handleBlur && e.handleBlur(...p)),
                  onInput: t[3] || (t[3] = (...p) => e.onInput && e.onInput(...p)),
                  onCompositionstart: t[4] || (t[4] = (...p) => e.handleCompositionStart && e.handleCompositionStart(...p)),
                  onCompositionupdate: t[5] || (t[5] = (...p) => e.handleCompositionUpdate && e.handleCompositionUpdate(...p)),
                  onCompositionend: t[6] || (t[6] = (...p) => e.handleCompositionEnd && e.handleCompositionEnd(...p)),
                  onKeydown: [
                    t[7] || (t[7] = Et(Ze((p) => e.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                    t[8] || (t[8] = Et(Ze((p) => e.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                    t[9] || (t[9] = Et(Ze((...p) => e.onKeyboardSelect && e.onKeyboardSelect(...p), ["stop", "prevent"]), ["enter"])),
                    t[10] || (t[10] = Et(Ze((...p) => e.handleEsc && e.handleEsc(...p), ["stop", "prevent"]), ["esc"])),
                    t[11] || (t[11] = Et(Ze((...p) => e.handleDel && e.handleDel(...p), ["stop"]), ["delete"]))
                  ]
                }, null, 42, sY), [
                  [f, e.states.displayInputValue]
                ]),
                e.filterable ? (S(), V("span", {
                  key: 0,
                  ref: "calculatorRef",
                  "aria-hidden": "true",
                  class: $(e.nsSelectV2.e("input-calculator")),
                  textContent: Ne(e.states.displayInputValue)
                }, null, 10, lY)) : se("v-if", !0)
              ], 6)
            ], 2)) : (S(), V(ze, { key: 2 }, [
              H("div", {
                class: $([
                  e.nsSelectV2.e("selected-item"),
                  e.nsSelectV2.e("input-wrapper")
                ])
              }, [
                ot(H("input", {
                  id: e.id,
                  ref: "inputRef",
                  "aria-autocomplete": "list",
                  "aria-haspopup": "listbox",
                  "aria-labelledby": e.label,
                  "aria-expanded": e.expanded,
                  autocapitalize: "off",
                  autocomplete: e.autocomplete,
                  class: $(e.nsSelectV2.e("combobox-input")),
                  disabled: e.disabled,
                  name: e.name,
                  role: "combobox",
                  readonly: !e.filterable,
                  spellcheck: "false",
                  type: "text",
                  unselectable: e.expanded ? "on" : void 0,
                  onCompositionstart: t[12] || (t[12] = (...p) => e.handleCompositionStart && e.handleCompositionStart(...p)),
                  onCompositionupdate: t[13] || (t[13] = (...p) => e.handleCompositionUpdate && e.handleCompositionUpdate(...p)),
                  onCompositionend: t[14] || (t[14] = (...p) => e.handleCompositionEnd && e.handleCompositionEnd(...p)),
                  onFocus: t[15] || (t[15] = (...p) => e.handleFocus && e.handleFocus(...p)),
                  onBlur: t[16] || (t[16] = (...p) => e.handleBlur && e.handleBlur(...p)),
                  onInput: t[17] || (t[17] = (...p) => e.onInput && e.onInput(...p)),
                  onKeydown: [
                    t[18] || (t[18] = Et(Ze((p) => e.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                    t[19] || (t[19] = Et(Ze((p) => e.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                    t[20] || (t[20] = Et(Ze((...p) => e.onKeyboardSelect && e.onKeyboardSelect(...p), ["stop", "prevent"]), ["enter"])),
                    t[21] || (t[21] = Et(Ze((...p) => e.handleEsc && e.handleEsc(...p), ["stop", "prevent"]), ["esc"]))
                  ],
                  "onUpdate:modelValue": t[22] || (t[22] = (...p) => e.onUpdateInputValue && e.onUpdateInputValue(...p))
                }, null, 42, aY), [
                  [f, e.states.displayInputValue]
                ])
              ], 2),
              e.filterable ? (S(), V("span", {
                key: 0,
                ref: "calculatorRef",
                "aria-hidden": "true",
                class: $([
                  e.nsSelectV2.e("selected-item"),
                  e.nsSelectV2.e("input-calculator")
                ]),
                textContent: Ne(e.states.displayInputValue)
              }, null, 10, iY)) : se("v-if", !0)
            ], 64)),
            e.shouldShowPlaceholder ? (S(), V("span", {
              key: 3,
              class: $([
                e.nsSelectV2.e("placeholder"),
                e.nsSelectV2.is("transparent", e.multiple ? e.modelValue.length === 0 : !e.hasModelValue)
              ])
            }, Ne(e.currentPlaceholder), 3)) : se("v-if", !0),
            H("span", {
              class: $(e.nsSelectV2.e("suffix"))
            }, [
              e.iconComponent ? ot((S(), ie(u, {
                key: 0,
                class: $([e.nsSelectV2.e("caret"), e.nsInput.e("icon"), e.iconReverse])
              }, {
                default: X(() => [
                  (S(), ie(vt(e.iconComponent)))
                ]),
                _: 1
              }, 8, ["class"])), [
                [$t, !e.showClearBtn]
              ]) : se("v-if", !0),
              e.showClearBtn && e.clearIcon ? (S(), ie(u, {
                key: 1,
                class: $([e.nsSelectV2.e("caret"), e.nsInput.e("icon")]),
                onClick: Ze(e.handleClear, ["prevent", "stop"])
              }, {
                default: X(() => [
                  (S(), ie(vt(e.clearIcon)))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : se("v-if", !0),
              e.validateState && e.validateIcon ? (S(), ie(u, {
                key: 2,
                class: $([e.nsInput.e("icon"), e.nsInput.e("validateIcon")])
              }, {
                default: X(() => [
                  (S(), ie(vt(e.validateIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : se("v-if", !0)
            ], 2)
          ], 2)
        ]),
        content: X(() => [
          K(c, {
            ref: "menuRef",
            data: e.filteredOptions,
            width: e.popperSize,
            "hovering-index": e.states.hoveringIndex,
            "scrollbar-always-on": e.scrollbarAlwaysOn
          }, {
            default: X((p) => [
              he(e.$slots, "default", mo(Nc(p)))
            ]),
            empty: X(() => [
              he(e.$slots, "empty", {}, () => [
                H("p", {
                  class: $(e.nsSelectV2.e("empty"))
                }, Ne(e.emptyText ? e.emptyText : ""), 3)
              ])
            ]),
            _: 3
          }, 8, ["data", "width", "hovering-index", "scrollbar-always-on"])
        ]),
        _: 3
      }, 8, ["visible", "teleported", "popper-class", "popper-options", "effect", "placement", "transition", "persistent", "onBeforeShow"])
    ], 34)), [
      [d, e.handleClickOutside, e.popperRef]
    ]);
  }
  var Eu = /* @__PURE__ */ Me(oY, [["render", uY], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/select.vue"]]);
  Eu.install = (e) => {
    e.component(Eu.name, Eu);
  };
  const cY = Eu, dY = cY, fY = Ie({
    animated: {
      type: Boolean,
      default: !1
    },
    count: {
      type: Number,
      default: 1
    },
    rows: {
      type: Number,
      default: 3
    },
    loading: {
      type: Boolean,
      default: !0
    },
    throttle: {
      type: Number
    }
  }), pY = Ie({
    variant: {
      type: String,
      values: [
        "circle",
        "rect",
        "h1",
        "h3",
        "text",
        "caption",
        "p",
        "image",
        "button"
      ],
      default: "text"
    }
  }), hY = G({
    name: "ElSkeletonItem"
  }), vY = /* @__PURE__ */ G({
    ...hY,
    props: pY,
    setup(e) {
      const t = ge("skeleton");
      return (n, o) => (S(), V("div", {
        class: $([i(t).e("item"), i(t).e(n.variant)])
      }, [
        n.variant === "image" ? (S(), ie(i(TR), { key: 0 })) : se("v-if", !0)
      ], 2));
    }
  });
  var cc = /* @__PURE__ */ Me(vY, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton-item.vue"]]);
  const mY = G({
    name: "ElSkeleton"
  }), gY = /* @__PURE__ */ G({
    ...mY,
    props: fY,
    setup(e, { expose: t }) {
      const n = e, o = ge("skeleton"), r = x8(Ht(n, "loading"), n.throttle);
      return t({
        uiLoading: r
      }), (s, l) => i(r) ? (S(), V("div", ft({
        key: 0,
        class: [i(o).b(), i(o).is("animated", s.animated)]
      }, s.$attrs), [
        (S(!0), V(ze, null, gt(s.count, (a) => (S(), V(ze, { key: a }, [
          s.loading ? he(s.$slots, "template", { key: a }, () => [
            K(cc, {
              class: $(i(o).is("first")),
              variant: "p"
            }, null, 8, ["class"]),
            (S(!0), V(ze, null, gt(s.rows, (u) => (S(), ie(cc, {
              key: u,
              class: $([
                i(o).e("paragraph"),
                i(o).is("last", u === s.rows && s.rows > 1)
              ]),
              variant: "p"
            }, null, 8, ["class"]))), 128))
          ]) : se("v-if", !0)
        ], 64))), 128))
      ], 16)) : he(s.$slots, "default", mo(ft({ key: 1 }, s.$attrs)));
    }
  });
  var yY = /* @__PURE__ */ Me(gY, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton.vue"]]);
  const bY = ut(yY, {
    SkeletonItem: cc
  }), wY = Gt(cc), lS = Symbol("sliderContextKey"), CY = Ie({
    modelValue: {
      type: le([Number, Array]),
      default: 0
    },
    id: {
      type: String,
      default: void 0
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1
    },
    showInput: Boolean,
    showInputControls: {
      type: Boolean,
      default: !0
    },
    size: yn,
    inputSize: yn,
    showStops: Boolean,
    showTooltip: {
      type: Boolean,
      default: !0
    },
    formatTooltip: {
      type: le(Function),
      default: void 0
    },
    disabled: Boolean,
    range: Boolean,
    vertical: Boolean,
    height: String,
    debounce: {
      type: Number,
      default: 300
    },
    label: {
      type: String,
      default: void 0
    },
    rangeStartLabel: {
      type: String,
      default: void 0
    },
    rangeEndLabel: {
      type: String,
      default: void 0
    },
    formatValueText: {
      type: le(Function),
      default: void 0
    },
    tooltipClass: {
      type: String,
      default: void 0
    },
    placement: {
      type: String,
      values: Bs,
      default: "top"
    },
    marks: {
      type: le(Object)
    },
    validateEvent: {
      type: Boolean,
      default: !0
    }
  }), Fd = (e) => Xe(e) || De(e) && e.every(Xe), EY = {
    [dt]: Fd,
    [$n]: Fd,
    [Ft]: Fd
  }, SY = (e, t, n) => {
    const o = I();
    return st(async () => {
      e.range ? (Array.isArray(e.modelValue) ? (t.firstValue = Math.max(e.min, e.modelValue[0]), t.secondValue = Math.min(e.max, e.modelValue[1])) : (t.firstValue = e.min, t.secondValue = e.max), t.oldValue = [t.firstValue, t.secondValue]) : (typeof e.modelValue != "number" || Number.isNaN(e.modelValue) ? t.firstValue = e.min : t.firstValue = Math.min(e.max, Math.max(e.min, e.modelValue)), t.oldValue = t.firstValue), Wt(window, "resize", n), await Fe(), n();
    }), {
      sliderWrapper: o
    };
  }, _Y = (e) => E(() => e.marks ? Object.keys(e.marks).map(Number.parseFloat).sort((n, o) => n - o).filter((n) => n <= e.max && n >= e.min).map((n) => ({
    point: n,
    position: (n - e.min) * 100 / (e.max - e.min),
    mark: e.marks[n]
  })) : []), kY = (e, t, n) => {
    const { form: o, formItem: r } = In(), s = xt(), l = I(), a = I(), u = {
      firstButton: l,
      secondButton: a
    }, c = E(() => e.disabled || (o == null ? void 0 : o.disabled) || !1), f = E(() => Math.min(t.firstValue, t.secondValue)), d = E(() => Math.max(t.firstValue, t.secondValue)), p = E(() => e.range ? `${100 * (d.value - f.value) / (e.max - e.min)}%` : `${100 * (t.firstValue - e.min) / (e.max - e.min)}%`), h = E(() => e.range ? `${100 * (f.value - e.min) / (e.max - e.min)}%` : "0%"), m = E(() => e.vertical ? { height: e.height } : {}), v = E(() => e.vertical ? {
      height: p.value,
      bottom: h.value
    } : {
      width: p.value,
      left: h.value
    }), g = () => {
      s.value && (t.sliderSize = s.value[`client${e.vertical ? "Height" : "Width"}`]);
    }, y = (L) => {
      const D = e.min + L * (e.max - e.min) / 100;
      if (!e.range)
        return l;
      let B;
      return Math.abs(f.value - D) < Math.abs(d.value - D) ? B = t.firstValue < t.secondValue ? "firstButton" : "secondButton" : B = t.firstValue > t.secondValue ? "firstButton" : "secondButton", u[B];
    }, w = (L) => {
      const D = y(L);
      return D.value.setPosition(L), D;
    }, b = (L) => {
      t.firstValue = L, _(e.range ? [f.value, d.value] : L);
    }, C = (L) => {
      t.secondValue = L, e.range && _([f.value, d.value]);
    }, _ = (L) => {
      n(dt, L), n($n, L);
    }, k = async () => {
      await Fe(), n(Ft, e.range ? [f.value, d.value] : e.modelValue);
    }, O = (L) => {
      var D, B, F, W, x, N;
      if (c.value || t.dragging)
        return;
      g();
      let R = 0;
      if (e.vertical) {
        const M = (F = (B = (D = L.touches) == null ? void 0 : D.item(0)) == null ? void 0 : B.clientY) != null ? F : L.clientY;
        R = (s.value.getBoundingClientRect().bottom - M) / t.sliderSize * 100;
      } else {
        const M = (N = (x = (W = L.touches) == null ? void 0 : W.item(0)) == null ? void 0 : x.clientX) != null ? N : L.clientX, j = s.value.getBoundingClientRect().left;
        R = (M - j) / t.sliderSize * 100;
      }
      if (!(R < 0 || R > 100))
        return w(R);
    };
    return {
      elFormItem: r,
      slider: s,
      firstButton: l,
      secondButton: a,
      sliderDisabled: c,
      minValue: f,
      maxValue: d,
      runwayStyle: m,
      barStyle: v,
      resetSize: g,
      setPosition: w,
      emitChange: k,
      onSliderWrapperPrevent: (L) => {
        var D, B;
        (((D = u.firstButton.value) == null ? void 0 : D.dragging) || ((B = u.secondButton.value) == null ? void 0 : B.dragging)) && L.preventDefault();
      },
      onSliderClick: (L) => {
        O(L) && k();
      },
      onSliderDown: async (L) => {
        const D = O(L);
        D && (await Fe(), D.value.onButtonDown(L));
      },
      setFirstValue: b,
      setSecondValue: C
    };
  }, { left: $Y, down: NY, right: TY, up: OY, home: MY, end: IY, pageUp: PY, pageDown: AY } = We, RY = (e, t, n) => {
    const o = I(), r = I(!1), s = E(() => t.value instanceof Function), l = E(() => s.value && t.value(e.modelValue) || e.modelValue), a = On(() => {
      n.value && (r.value = !0);
    }, 50), u = On(() => {
      n.value && (r.value = !1);
    }, 50);
    return {
      tooltip: o,
      tooltipVisible: r,
      formatValue: l,
      displayTooltip: a,
      hideTooltip: u
    };
  }, xY = (e, t, n) => {
    const {
      disabled: o,
      min: r,
      max: s,
      step: l,
      showTooltip: a,
      precision: u,
      sliderSize: c,
      formatTooltip: f,
      emitChange: d,
      resetSize: p,
      updateDragging: h
    } = Be(lS), { tooltip: m, tooltipVisible: v, formatValue: g, displayTooltip: y, hideTooltip: w } = RY(e, f, a), b = I(), C = E(() => `${(e.modelValue - r.value) / (s.value - r.value) * 100}%`), _ = E(() => e.vertical ? { bottom: C.value } : { left: C.value }), k = () => {
      t.hovering = !0, y();
    }, O = () => {
      t.hovering = !1, t.dragging || w();
    }, T = (U) => {
      o.value || (U.preventDefault(), R(U), window.addEventListener("mousemove", M), window.addEventListener("touchmove", M), window.addEventListener("mouseup", j), window.addEventListener("touchend", j), window.addEventListener("contextmenu", j), b.value.focus());
    }, P = (U) => {
      o.value || (t.newPosition = Number.parseFloat(C.value) + U / (s.value - r.value) * 100, te(t.newPosition), d());
    }, A = () => {
      P(-l.value);
    }, L = () => {
      P(l.value);
    }, D = () => {
      P(-l.value * 4);
    }, B = () => {
      P(l.value * 4);
    }, F = () => {
      o.value || (te(0), d());
    }, W = () => {
      o.value || (te(100), d());
    }, x = (U) => {
      let Z = !0;
      [$Y, NY].includes(U.key) ? A() : [TY, OY].includes(U.key) ? L() : U.key === MY ? F() : U.key === IY ? W() : U.key === AY ? D() : U.key === PY ? B() : Z = !1, Z && U.preventDefault();
    }, N = (U) => {
      let Z, pe;
      return U.type.startsWith("touch") ? (pe = U.touches[0].clientY, Z = U.touches[0].clientX) : (pe = U.clientY, Z = U.clientX), {
        clientX: Z,
        clientY: pe
      };
    }, R = (U) => {
      t.dragging = !0, t.isClick = !0;
      const { clientX: Z, clientY: pe } = N(U);
      e.vertical ? t.startY = pe : t.startX = Z, t.startPosition = Number.parseFloat(C.value), t.newPosition = t.startPosition;
    }, M = (U) => {
      if (t.dragging) {
        t.isClick = !1, y(), p();
        let Z;
        const { clientX: pe, clientY: J } = N(U);
        e.vertical ? (t.currentY = J, Z = (t.startY - t.currentY) / c.value * 100) : (t.currentX = pe, Z = (t.currentX - t.startX) / c.value * 100), t.newPosition = t.startPosition + Z, te(t.newPosition);
      }
    }, j = () => {
      t.dragging && (setTimeout(() => {
        t.dragging = !1, t.hovering || w(), t.isClick || te(t.newPosition), d();
      }, 0), window.removeEventListener("mousemove", M), window.removeEventListener("touchmove", M), window.removeEventListener("mouseup", j), window.removeEventListener("touchend", j), window.removeEventListener("contextmenu", j));
    }, te = async (U) => {
      if (U === null || Number.isNaN(+U))
        return;
      U < 0 ? U = 0 : U > 100 && (U = 100);
      const Z = 100 / ((s.value - r.value) / l.value);
      let J = Math.round(U / Z) * Z * (s.value - r.value) * 0.01 + r.value;
      J = Number.parseFloat(J.toFixed(u.value)), J !== e.modelValue && n(dt, J), !t.dragging && e.modelValue !== t.oldValue && (t.oldValue = e.modelValue), await Fe(), t.dragging && y(), m.value.updatePopper();
    };
    return me(() => t.dragging, (U) => {
      h(U);
    }), {
      disabled: o,
      button: b,
      tooltip: m,
      tooltipVisible: v,
      showTooltip: a,
      wrapperStyle: _,
      formatValue: g,
      handleMouseEnter: k,
      handleMouseLeave: O,
      onButtonDown: T,
      onKeyDown: x,
      setPosition: te
    };
  }, DY = (e, t, n, o) => ({
    stops: E(() => {
      if (!e.showStops || e.min > e.max)
        return [];
      if (e.step === 0)
        return yt("ElSlider", "step should not be 0."), [];
      const l = (e.max - e.min) / e.step, a = 100 * e.step / (e.max - e.min), u = Array.from({ length: l - 1 }).map((c, f) => (f + 1) * a);
      return e.range ? u.filter((c) => c < 100 * (n.value - e.min) / (e.max - e.min) || c > 100 * (o.value - e.min) / (e.max - e.min)) : u.filter((c) => c > 100 * (t.firstValue - e.min) / (e.max - e.min));
    }),
    getStopStyle: (l) => e.vertical ? { bottom: `${l}%` } : { left: `${l}%` }
  }), LY = (e, t, n, o, r, s) => {
    const l = (c) => {
      r(dt, c), r($n, c);
    }, a = () => e.range ? ![n.value, o.value].every((c, f) => c === t.oldValue[f]) : e.modelValue !== t.oldValue, u = () => {
      var c, f;
      e.min > e.max && Yt("Slider", "min should not be greater than max.");
      const d = e.modelValue;
      e.range && Array.isArray(d) ? d[1] < e.min ? l([e.min, e.min]) : d[0] > e.max ? l([e.max, e.max]) : d[0] < e.min ? l([e.min, d[1]]) : d[1] > e.max ? l([d[0], e.max]) : (t.firstValue = d[0], t.secondValue = d[1], a() && (e.validateEvent && ((c = s == null ? void 0 : s.validate) == null || c.call(s, "change").catch((p) => yt(p))), t.oldValue = d.slice())) : !e.range && typeof d == "number" && !Number.isNaN(d) && (d < e.min ? l(e.min) : d > e.max ? l(e.max) : (t.firstValue = d, a() && (e.validateEvent && ((f = s == null ? void 0 : s.validate) == null || f.call(s, "change").catch((p) => yt(p))), t.oldValue = d)));
    };
    u(), me(() => t.dragging, (c) => {
      c || u();
    }), me(() => e.modelValue, (c, f) => {
      t.dragging || Array.isArray(c) && Array.isArray(f) && c.every((d, p) => d === f[p]) && t.firstValue === c[0] && t.secondValue === c[1] || u();
    }, {
      deep: !0
    }), me(() => [e.min, e.max], () => {
      u();
    });
  }, VY = Ie({
    modelValue: {
      type: Number,
      default: 0
    },
    vertical: Boolean,
    tooltipClass: String,
    placement: {
      type: String,
      values: Bs,
      default: "top"
    }
  }), BY = {
    [dt]: (e) => Xe(e)
  }, FY = ["tabindex"], HY = G({
    name: "ElSliderButton"
  }), zY = /* @__PURE__ */ G({
    ...HY,
    props: VY,
    emits: BY,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = ge("slider"), s = Tt({
        hovering: !1,
        dragging: !1,
        isClick: !1,
        startX: 0,
        currentX: 0,
        startY: 0,
        currentY: 0,
        startPosition: 0,
        newPosition: 0,
        oldValue: o.modelValue
      }), {
        disabled: l,
        button: a,
        tooltip: u,
        showTooltip: c,
        tooltipVisible: f,
        wrapperStyle: d,
        formatValue: p,
        handleMouseEnter: h,
        handleMouseLeave: m,
        onButtonDown: v,
        onKeyDown: g,
        setPosition: y
      } = xY(o, s, n), { hovering: w, dragging: b } = rn(s);
      return t({
        onButtonDown: v,
        onKeyDown: g,
        setPosition: y,
        hovering: w,
        dragging: b
      }), (C, _) => (S(), V("div", {
        ref_key: "button",
        ref: a,
        class: $([i(r).e("button-wrapper"), { hover: i(w), dragging: i(b) }]),
        style: Ke(i(d)),
        tabindex: i(l) ? -1 : 0,
        onMouseenter: _[0] || (_[0] = (...k) => i(h) && i(h)(...k)),
        onMouseleave: _[1] || (_[1] = (...k) => i(m) && i(m)(...k)),
        onMousedown: _[2] || (_[2] = (...k) => i(v) && i(v)(...k)),
        onTouchstart: _[3] || (_[3] = (...k) => i(v) && i(v)(...k)),
        onFocus: _[4] || (_[4] = (...k) => i(h) && i(h)(...k)),
        onBlur: _[5] || (_[5] = (...k) => i(m) && i(m)(...k)),
        onKeydown: _[6] || (_[6] = (...k) => i(g) && i(g)(...k))
      }, [
        K(i(Mn), {
          ref_key: "tooltip",
          ref: u,
          visible: i(f),
          placement: C.placement,
          "fallback-placements": ["top", "bottom", "right", "left"],
          "stop-popper-mouse-event": !1,
          "popper-class": C.tooltipClass,
          disabled: !i(c),
          persistent: ""
        }, {
          content: X(() => [
            H("span", null, Ne(i(p)), 1)
          ]),
          default: X(() => [
            H("div", {
              class: $([i(r).e("button"), { hover: i(w), dragging: i(b) }])
            }, null, 2)
          ]),
          _: 1
        }, 8, ["visible", "placement", "popper-class", "disabled"])
      ], 46, FY));
    }
  });
  var Ay = /* @__PURE__ */ Me(zY, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);
  const KY = Ie({
    mark: {
      type: le([String, Object]),
      default: void 0
    }
  });
  var jY = G({
    name: "ElSliderMarker",
    props: KY,
    setup(e) {
      const t = ge("slider"), n = E(() => et(e.mark) ? e.mark : e.mark.label), o = E(() => et(e.mark) ? void 0 : e.mark.style);
      return () => je("div", {
        class: t.e("marks-text"),
        style: o.value
      }, n.value);
    }
  });
  const WY = ["id", "role", "aria-label", "aria-labelledby"], UY = { key: 1 }, qY = G({
    name: "ElSlider"
  }), YY = /* @__PURE__ */ G({
    ...qY,
    props: CY,
    emits: EY,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = ge("slider"), { t: s } = St(), l = Tt({
        firstValue: 0,
        secondValue: 0,
        oldValue: 0,
        dragging: !1,
        sliderSize: 1
      }), {
        elFormItem: a,
        slider: u,
        firstButton: c,
        secondButton: f,
        sliderDisabled: d,
        minValue: p,
        maxValue: h,
        runwayStyle: m,
        barStyle: v,
        resetSize: g,
        emitChange: y,
        onSliderWrapperPrevent: w,
        onSliderClick: b,
        onSliderDown: C,
        setFirstValue: _,
        setSecondValue: k
      } = kY(o, l, n), { stops: O, getStopStyle: T } = DY(o, l, p, h), { inputId: P, isLabeledByFormItem: A } = Zr(o, {
        formItemContext: a
      }), L = on(), D = E(() => o.inputSize || L.value), B = E(() => o.label || s("el.slider.defaultLabel", {
        min: o.min,
        max: o.max
      })), F = E(() => o.range ? o.rangeStartLabel || s("el.slider.defaultRangeStartLabel") : B.value), W = E(() => o.formatValueText ? o.formatValueText(U.value) : `${U.value}`), x = E(() => o.rangeEndLabel || s("el.slider.defaultRangeEndLabel")), N = E(() => o.formatValueText ? o.formatValueText(Z.value) : `${Z.value}`), R = E(() => [
        r.b(),
        r.m(L.value),
        r.is("vertical", o.vertical),
        { [r.m("with-input")]: o.showInput }
      ]), M = _Y(o);
      LY(o, l, p, h, n, a);
      const j = E(() => {
        const ee = [o.min, o.max, o.step].map((ne) => {
          const Y = `${ne}`.split(".")[1];
          return Y ? Y.length : 0;
        });
        return Math.max.apply(null, ee);
      }), { sliderWrapper: te } = SY(o, l, g), { firstValue: U, secondValue: Z, sliderSize: pe } = rn(l), J = (ee) => {
        l.dragging = ee;
      };
      return pt(lS, {
        ...rn(o),
        sliderSize: pe,
        disabled: d,
        precision: j,
        emitChange: y,
        resetSize: g,
        updateDragging: J
      }), t({
        onSliderClick: b
      }), (ee, ne) => {
        var Y, re;
        return S(), V("div", {
          id: ee.range ? i(P) : void 0,
          ref_key: "sliderWrapper",
          ref: te,
          class: $(i(R)),
          role: ee.range ? "group" : void 0,
          "aria-label": ee.range && !i(A) ? i(B) : void 0,
          "aria-labelledby": ee.range && i(A) ? (Y = i(a)) == null ? void 0 : Y.labelId : void 0,
          onTouchstart: ne[2] || (ne[2] = (...ce) => i(w) && i(w)(...ce)),
          onTouchmove: ne[3] || (ne[3] = (...ce) => i(w) && i(w)(...ce))
        }, [
          H("div", {
            ref_key: "slider",
            ref: u,
            class: $([
              i(r).e("runway"),
              { "show-input": ee.showInput && !ee.range },
              i(r).is("disabled", i(d))
            ]),
            style: Ke(i(m)),
            onMousedown: ne[0] || (ne[0] = (...ce) => i(C) && i(C)(...ce)),
            onTouchstart: ne[1] || (ne[1] = (...ce) => i(C) && i(C)(...ce))
          }, [
            H("div", {
              class: $(i(r).e("bar")),
              style: Ke(i(v))
            }, null, 6),
            K(Ay, {
              id: ee.range ? void 0 : i(P),
              ref_key: "firstButton",
              ref: c,
              "model-value": i(U),
              vertical: ee.vertical,
              "tooltip-class": ee.tooltipClass,
              placement: ee.placement,
              role: "slider",
              "aria-label": ee.range || !i(A) ? i(F) : void 0,
              "aria-labelledby": !ee.range && i(A) ? (re = i(a)) == null ? void 0 : re.labelId : void 0,
              "aria-valuemin": ee.min,
              "aria-valuemax": ee.range ? i(Z) : ee.max,
              "aria-valuenow": i(U),
              "aria-valuetext": i(W),
              "aria-orientation": ee.vertical ? "vertical" : "horizontal",
              "aria-disabled": i(d),
              "onUpdate:modelValue": i(_)
            }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
            ee.range ? (S(), ie(Ay, {
              key: 0,
              ref_key: "secondButton",
              ref: f,
              "model-value": i(Z),
              vertical: ee.vertical,
              "tooltip-class": ee.tooltipClass,
              placement: ee.placement,
              role: "slider",
              "aria-label": i(x),
              "aria-valuemin": i(U),
              "aria-valuemax": ee.max,
              "aria-valuenow": i(Z),
              "aria-valuetext": i(N),
              "aria-orientation": ee.vertical ? "vertical" : "horizontal",
              "aria-disabled": i(d),
              "onUpdate:modelValue": i(k)
            }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : se("v-if", !0),
            ee.showStops ? (S(), V("div", UY, [
              (S(!0), V(ze, null, gt(i(O), (ce, Te) => (S(), V("div", {
                key: Te,
                class: $(i(r).e("stop")),
                style: Ke(i(T)(ce))
              }, null, 6))), 128))
            ])) : se("v-if", !0),
            i(M).length > 0 ? (S(), V(ze, { key: 2 }, [
              H("div", null, [
                (S(!0), V(ze, null, gt(i(M), (ce, Te) => (S(), V("div", {
                  key: Te,
                  style: Ke(i(T)(ce.position)),
                  class: $([i(r).e("stop"), i(r).e("marks-stop")])
                }, null, 6))), 128))
              ]),
              H("div", {
                class: $(i(r).e("marks"))
              }, [
                (S(!0), V(ze, null, gt(i(M), (ce, Te) => (S(), ie(i(jY), {
                  key: Te,
                  mark: ce.mark,
                  style: Ke(i(T)(ce.position))
                }, null, 8, ["mark", "style"]))), 128))
              ], 2)
            ], 64)) : se("v-if", !0)
          ], 38),
          ee.showInput && !ee.range ? (S(), ie(i(AE), {
            key: 0,
            ref: "input",
            "model-value": i(U),
            class: $(i(r).e("input")),
            step: ee.step,
            disabled: i(d),
            controls: ee.showInputControls,
            min: ee.min,
            max: ee.max,
            debounce: ee.debounce,
            size: i(D),
            "onUpdate:modelValue": i(_),
            onChange: i(y)
          }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : se("v-if", !0)
        ], 42, WY);
      };
    }
  });
  var GY = /* @__PURE__ */ Me(YY, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);
  const XY = ut(GY), JY = Ie({
    prefixCls: {
      type: String
    }
  }), Ry = G({
    name: "ElSpaceItem",
    props: JY,
    setup(e, { slots: t }) {
      const n = ge("space"), o = E(() => `${e.prefixCls || n.b()}__item`);
      return () => je("div", { class: o.value }, he(t, "default"));
    }
  }), xy = {
    small: 8,
    default: 12,
    large: 16
  };
  function ZY(e) {
    const t = ge("space"), n = E(() => [t.b(), t.m(e.direction), e.class]), o = I(0), r = I(0), s = E(() => {
      const a = e.wrap || e.fill ? { flexWrap: "wrap", marginBottom: `-${r.value}px` } : {}, u = {
        alignItems: e.alignment
      };
      return [a, u, e.style];
    }), l = E(() => {
      const a = {
        paddingBottom: `${r.value}px`,
        marginRight: `${o.value}px`
      }, u = e.fill ? { flexGrow: 1, minWidth: `${e.fillRatio}%` } : {};
      return [a, u];
    });
    return xn(() => {
      const { size: a = "small", wrap: u, direction: c, fill: f } = e;
      if (De(a)) {
        const [d = 0, p = 0] = a;
        o.value = d, r.value = p;
      } else {
        let d;
        Xe(a) ? d = a : d = xy[a || "small"] || xy.small, (u || f) && c === "horizontal" ? o.value = r.value = d : c === "horizontal" ? (o.value = d, r.value = 0) : (r.value = d, o.value = 0);
      }
    }), {
      classes: n,
      containerStyle: s,
      itemStyle: l
    };
  }
  const QY = Ie({
    direction: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "horizontal"
    },
    class: {
      type: le([
        String,
        Object,
        Array
      ]),
      default: ""
    },
    style: {
      type: le([String, Array, Object]),
      default: ""
    },
    alignment: {
      type: le(String),
      default: "center"
    },
    prefixCls: {
      type: String
    },
    spacer: {
      type: le([Object, String, Number, Array]),
      default: null,
      validator: (e) => Bt(e) || Xe(e) || et(e)
    },
    wrap: Boolean,
    fill: Boolean,
    fillRatio: {
      type: Number,
      default: 100
    },
    size: {
      type: [String, Array, Number],
      values: zo,
      validator: (e) => Xe(e) || De(e) && e.length === 2 && e.every(Xe)
    }
  }), eG = G({
    name: "ElSpace",
    props: QY,
    setup(e, { slots: t }) {
      const { classes: n, containerStyle: o, itemStyle: r } = ZY(e);
      function s(l, a = "", u = []) {
        const { prefixCls: c } = e;
        return l.forEach((f, d) => {
          Nf(f) ? De(f.children) && f.children.forEach((p, h) => {
            Nf(p) && De(p.children) ? s(p.children, `${a + h}-`, u) : u.push(K(Ry, {
              style: r.value,
              prefixCls: c,
              key: `nested-${a + h}`
            }, {
              default: () => [p]
            }, Zn.PROPS | Zn.STYLE, ["style", "prefixCls"]));
          }) : pD(f) && u.push(K(Ry, {
            style: r.value,
            prefixCls: c,
            key: `LoopKey${a + d}`
          }, {
            default: () => [f]
          }, Zn.PROPS | Zn.STYLE, ["style", "prefixCls"]));
        }), u;
      }
      return () => {
        var l;
        const { spacer: a, direction: u } = e, c = he(t, "default", { key: 0 }, () => []);
        if (((l = c.children) != null ? l : []).length === 0)
          return null;
        if (De(c.children)) {
          let f = s(c.children);
          if (a) {
            const d = f.length - 1;
            f = f.reduce((p, h, m) => {
              const v = [...p, h];
              return m !== d && v.push(K("span", {
                style: [
                  r.value,
                  u === "vertical" ? "width: 100%" : null
                ],
                key: m
              }, [
                Bt(a) ? a : wt(a, Zn.TEXT)
              ], Zn.STYLE)), v;
            }, []);
          }
          return K("div", {
            class: n.value,
            style: o.value
          }, f, Zn.STYLE | Zn.CLASS);
        }
        return c.children;
      };
    }
  }), tG = ut(eG), nG = Ie({
    decimalSeparator: {
      type: String,
      default: "."
    },
    groupSeparator: {
      type: String,
      default: ","
    },
    precision: {
      type: Number,
      default: 0
    },
    formatter: Function,
    value: {
      type: le([Number, Object]),
      default: 0
    },
    prefix: String,
    suffix: String,
    title: String,
    valueStyle: {
      type: le([String, Object, Array])
    }
  }), oG = G({
    name: "ElStatistic"
  }), rG = /* @__PURE__ */ G({
    ...oG,
    props: nG,
    setup(e, { expose: t }) {
      const n = e, o = ge("statistic"), r = E(() => {
        const { value: s, formatter: l, precision: a, decimalSeparator: u, groupSeparator: c } = n;
        if (Ge(l))
          return l(s);
        if (!Xe(s))
          return s;
        let [f, d = ""] = String(s).split(".");
        return d = d.padEnd(a, "0").slice(0, a > 0 ? a : 0), f = f.replace(/\B(?=(\d{3})+(?!\d))/g, c), [f, d].join(d ? u : "");
      });
      return t({
        displayValue: r
      }), (s, l) => (S(), V("div", {
        class: $(i(o).b())
      }, [
        s.$slots.title || s.title ? (S(), V("div", {
          key: 0,
          class: $(i(o).e("head"))
        }, [
          he(s.$slots, "title", {}, () => [
            wt(Ne(s.title), 1)
          ])
        ], 2)) : se("v-if", !0),
        H("div", {
          class: $(i(o).e("content"))
        }, [
          s.$slots.prefix || s.prefix ? (S(), V("div", {
            key: 0,
            class: $(i(o).e("prefix"))
          }, [
            he(s.$slots, "prefix", {}, () => [
              H("span", null, Ne(s.prefix), 1)
            ])
          ], 2)) : se("v-if", !0),
          H("span", {
            class: $(i(o).e("number")),
            style: Ke(s.valueStyle)
          }, Ne(i(r)), 7),
          s.$slots.suffix || s.suffix ? (S(), V("div", {
            key: 1,
            class: $(i(o).e("suffix"))
          }, [
            he(s.$slots, "suffix", {}, () => [
              H("span", null, Ne(s.suffix), 1)
            ])
          ], 2)) : se("v-if", !0)
        ], 2)
      ], 2));
    }
  });
  var sG = /* @__PURE__ */ Me(rG, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/statistic/src/statistic.vue"]]);
  const aS = ut(sG), lG = Ie({
    format: {
      type: String,
      default: "HH:mm:ss"
    },
    prefix: String,
    suffix: String,
    title: String,
    value: {
      type: le([Number, Object]),
      default: 0
    },
    valueStyle: {
      type: le([String, Object, Array])
    }
  }), aG = {
    finish: () => !0,
    [Ft]: (e) => Xe(e)
  }, iG = [
    ["Y", 1e3 * 60 * 60 * 24 * 365],
    ["M", 1e3 * 60 * 60 * 24 * 30],
    ["D", 1e3 * 60 * 60 * 24],
    ["H", 1e3 * 60 * 60],
    ["m", 1e3 * 60],
    ["s", 1e3],
    ["S", 1]
  ], Dy = (e) => Xe(e) ? new Date(e).getTime() : e.valueOf(), Ly = (e, t) => {
    let n = e;
    const o = /\[([^\]]*)]/g;
    return iG.reduce((s, [l, a]) => {
      const u = new RegExp(`${l}+(?![^\\[\\]]*\\])`, "g");
      if (u.test(s)) {
        const c = Math.floor(n / a);
        return n -= c * a, s.replace(u, (f) => String(c).padStart(f.length, "0"));
      }
      return s;
    }, t).replace(o, "$1");
  }, uG = G({
    name: "ElCountdown"
  }), cG = /* @__PURE__ */ G({
    ...uG,
    props: lG,
    emits: aG,
    setup(e, { expose: t, emit: n }) {
      const o = e;
      let r;
      const s = I(Dy(o.value) - Date.now()), l = E(() => Ly(s.value, o.format)), a = (f) => Ly(f, o.format), u = () => {
        r && (jc(r), r = void 0);
      }, c = () => {
        const f = Dy(o.value), d = () => {
          let p = f - Date.now();
          n("change", p), p <= 0 ? (p = 0, u(), n("finish")) : r = Ka(d), s.value = p;
        };
        r = Ka(d);
      };
      return me(() => [o.value, o.format], () => {
        u(), c();
      }, {
        immediate: !0
      }), zt(() => {
        u();
      }), t({
        displayValue: l
      }), (f, d) => (S(), ie(i(aS), {
        value: s.value,
        title: f.title,
        prefix: f.prefix,
        suffix: f.suffix,
        "value-style": f.valueStyle,
        formatter: a
      }, lr({ _: 2 }, [
        gt(f.$slots, (p, h) => ({
          name: h,
          fn: X(() => [
            he(f.$slots, h)
          ])
        }))
      ]), 1032, ["value", "title", "prefix", "suffix", "value-style"]));
    }
  });
  var dG = /* @__PURE__ */ Me(cG, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/countdown/src/countdown.vue"]]);
  const fG = ut(dG), pG = Ie({
    space: {
      type: [Number, String],
      default: ""
    },
    active: {
      type: Number,
      default: 0
    },
    direction: {
      type: String,
      default: "horizontal",
      values: ["horizontal", "vertical"]
    },
    alignCenter: {
      type: Boolean
    },
    simple: {
      type: Boolean
    },
    finishStatus: {
      type: String,
      values: ["wait", "process", "finish", "error", "success"],
      default: "finish"
    },
    processStatus: {
      type: String,
      values: ["wait", "process", "finish", "error", "success"],
      default: "process"
    }
  }), hG = {
    [Ft]: (e, t) => [e, t].every(Xe)
  }, vG = G({
    name: "ElSteps"
  }), mG = /* @__PURE__ */ G({
    ...vG,
    props: pG,
    emits: hG,
    setup(e, { emit: t }) {
      const n = e, o = ge("steps"), r = I([]);
      return me(r, () => {
        r.value.forEach((s, l) => {
          s.setIndex(l);
        });
      }), pt("ElSteps", { props: n, steps: r }), me(() => n.active, (s, l) => {
        t(Ft, s, l);
      }), (s, l) => (S(), V("div", {
        class: $([i(o).b(), i(o).m(s.simple ? "simple" : s.direction)])
      }, [
        he(s.$slots, "default")
      ], 2));
    }
  });
  var gG = /* @__PURE__ */ Me(mG, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/steps.vue"]]);
  const yG = Ie({
    title: {
      type: String,
      default: ""
    },
    icon: {
      type: Vt
    },
    description: {
      type: String,
      default: ""
    },
    status: {
      type: String,
      values: ["", "wait", "process", "finish", "error", "success"],
      default: ""
    }
  }), bG = G({
    name: "ElStep"
  }), wG = G({
    ...bG,
    props: yG,
    setup(e) {
      const t = e, n = ge("step"), o = I(-1), r = I({}), s = I(""), l = Be("ElSteps"), a = it();
      st(() => {
        me([
          () => l.props.active,
          () => l.props.processStatus,
          () => l.props.finishStatus
        ], ([_]) => {
          b(_);
        }, { immediate: !0 });
      }), zt(() => {
        l.steps.value = l.steps.value.filter((_) => _.uid !== (a == null ? void 0 : a.uid));
      });
      const u = E(() => t.status || s.value), c = E(() => {
        const _ = l.steps.value[o.value - 1];
        return _ ? _.currentStatus : "wait";
      }), f = E(() => l.props.alignCenter), d = E(() => l.props.direction === "vertical"), p = E(() => l.props.simple), h = E(() => l.steps.value.length), m = E(() => {
        var _;
        return ((_ = l.steps.value[h.value - 1]) == null ? void 0 : _.uid) === (a == null ? void 0 : a.uid);
      }), v = E(() => p.value ? "" : l.props.space), g = E(() => {
        const _ = {
          flexBasis: Xe(v.value) ? `${v.value}px` : v.value ? v.value : `${100 / (h.value - (f.value ? 0 : 1))}%`
        };
        return d.value || m.value && (_.maxWidth = `${100 / h.value}%`), _;
      }), y = (_) => {
        o.value = _;
      }, w = (_) => {
        const k = _ === "wait", O = {
          transitionDelay: `${k ? "-" : ""}${150 * o.value}ms`
        }, T = _ === l.props.processStatus || k ? 0 : 100;
        O.borderWidth = T && !p.value ? "1px" : 0, O[l.props.direction === "vertical" ? "height" : "width"] = `${T}%`, r.value = O;
      }, b = (_) => {
        _ > o.value ? s.value = l.props.finishStatus : _ === o.value && c.value !== "error" ? s.value = l.props.processStatus : s.value = "wait";
        const k = l.steps.value[o.value - 1];
        k && k.calcProgress(s.value);
      }, C = Tt({
        uid: E(() => a == null ? void 0 : a.uid),
        currentStatus: u,
        setIndex: y,
        calcProgress: w
      });
      return l.steps.value = [...l.steps.value, C], (_, k) => (S(), V("div", {
        style: Ke(i(g)),
        class: $([
          i(n).b(),
          i(n).is(i(p) ? "simple" : i(l).props.direction),
          i(n).is("flex", i(m) && !i(v) && !i(f)),
          i(n).is("center", i(f) && !i(d) && !i(p))
        ])
      }, [
        se(" icon & line "),
        H("div", {
          class: $([i(n).e("head"), i(n).is(i(u))])
        }, [
          i(p) ? se("v-if", !0) : (S(), V("div", {
            key: 0,
            class: $(i(n).e("line"))
          }, [
            H("i", {
              class: $(i(n).e("line-inner")),
              style: Ke(r.value)
            }, null, 6)
          ], 2)),
          H("div", {
            class: $([i(n).e("icon"), i(n).is(_.icon || _.$slots.icon ? "icon" : "text")])
          }, [
            he(_.$slots, "icon", {}, () => [
              _.icon ? (S(), ie(i(He), {
                key: 0,
                class: $(i(n).e("icon-inner"))
              }, {
                default: X(() => [
                  (S(), ie(vt(_.icon)))
                ]),
                _: 1
              }, 8, ["class"])) : i(u) === "success" ? (S(), ie(i(He), {
                key: 1,
                class: $([i(n).e("icon-inner"), i(n).is("status")])
              }, {
                default: X(() => [
                  K(i(wi))
                ]),
                _: 1
              }, 8, ["class"])) : i(u) === "error" ? (S(), ie(i(He), {
                key: 2,
                class: $([i(n).e("icon-inner"), i(n).is("status")])
              }, {
                default: X(() => [
                  K(i(_o))
                ]),
                _: 1
              }, 8, ["class"])) : i(p) ? se("v-if", !0) : (S(), V("div", {
                key: 3,
                class: $(i(n).e("icon-inner"))
              }, Ne(o.value + 1), 3))
            ])
          ], 2)
        ], 2),
        se(" title & description "),
        H("div", {
          class: $(i(n).e("main"))
        }, [
          H("div", {
            class: $([i(n).e("title"), i(n).is(i(u))])
          }, [
            he(_.$slots, "title", {}, () => [
              wt(Ne(_.title), 1)
            ])
          ], 2),
          i(p) ? (S(), V("div", {
            key: 0,
            class: $(i(n).e("arrow"))
          }, null, 2)) : (S(), V("div", {
            key: 1,
            class: $([i(n).e("description"), i(n).is(i(u))])
          }, [
            he(_.$slots, "description", {}, () => [
              wt(Ne(_.description), 1)
            ])
          ], 2))
        ], 2)
      ], 6));
    }
  });
  var iS = /* @__PURE__ */ Me(wG, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/item.vue"]]);
  const CG = ut(gG, {
    Step: iS
  }), EG = Gt(iS), SG = Ie({
    modelValue: {
      type: [Boolean, String, Number],
      default: !1
    },
    value: {
      type: [Boolean, String, Number],
      default: !1
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    width: {
      type: [String, Number],
      default: ""
    },
    inlinePrompt: {
      type: Boolean,
      default: !1
    },
    activeIcon: {
      type: Vt
    },
    inactiveIcon: {
      type: Vt
    },
    activeText: {
      type: String,
      default: ""
    },
    inactiveText: {
      type: String,
      default: ""
    },
    activeColor: {
      type: String,
      default: ""
    },
    inactiveColor: {
      type: String,
      default: ""
    },
    borderColor: {
      type: String,
      default: ""
    },
    activeValue: {
      type: [Boolean, String, Number],
      default: !0
    },
    inactiveValue: {
      type: [Boolean, String, Number],
      default: !1
    },
    name: {
      type: String,
      default: ""
    },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    id: String,
    loading: {
      type: Boolean,
      default: !1
    },
    beforeChange: {
      type: le(Function)
    },
    size: {
      type: String,
      validator: zc
    },
    tabindex: {
      type: [String, Number]
    }
  }), _G = {
    [dt]: (e) => tn(e) || et(e) || Xe(e),
    [Ft]: (e) => tn(e) || et(e) || Xe(e),
    [$n]: (e) => tn(e) || et(e) || Xe(e)
  }, kG = ["onClick"], $G = ["id", "aria-checked", "aria-disabled", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"], NG = ["aria-hidden"], TG = ["aria-hidden"], OG = ["aria-hidden"], Su = "ElSwitch", MG = G({
    name: Su
  }), IG = /* @__PURE__ */ G({
    ...MG,
    props: SG,
    emits: _G,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = it(), { formItem: s } = In(), l = on(), a = ge("switch");
      Vo({
        from: '"value"',
        replacement: '"model-value" or "v-model"',
        scope: Su,
        version: "2.3.0",
        ref: "https://element-plus.org/en-US/component/switch.html#attributes",
        type: "Attribute"
      }, E(() => {
        var _;
        return !!((_ = r.vnode.props) != null && _.value);
      }));
      const { inputId: u } = Zr(o, {
        formItemContext: s
      }), c = Fn(E(() => o.loading)), f = I(o.modelValue !== !1), d = I(), p = I(), h = E(() => [
        a.b(),
        a.m(l.value),
        a.is("disabled", c.value),
        a.is("checked", g.value)
      ]), m = E(() => ({
        width: Jt(o.width)
      }));
      me(() => o.modelValue, () => {
        f.value = !0;
      }), me(() => o.value, () => {
        f.value = !1;
      });
      const v = E(() => f.value ? o.modelValue : o.value), g = E(() => v.value === o.activeValue);
      [o.activeValue, o.inactiveValue].includes(v.value) || (n(dt, o.inactiveValue), n(Ft, o.inactiveValue), n($n, o.inactiveValue)), me(g, (_) => {
        var k;
        d.value.checked = _, o.validateEvent && ((k = s == null ? void 0 : s.validate) == null || k.call(s, "change").catch((O) => yt(O)));
      });
      const y = () => {
        const _ = g.value ? o.inactiveValue : o.activeValue;
        n(dt, _), n(Ft, _), n($n, _), Fe(() => {
          d.value.checked = g.value;
        });
      }, w = () => {
        if (c.value)
          return;
        const { beforeChange: _ } = o;
        if (!_) {
          y();
          return;
        }
        const k = _();
        [
          yl(k),
          tn(k)
        ].includes(!0) || Yt(Su, "beforeChange must return type `Promise<boolean>` or `boolean`"), yl(k) ? k.then((T) => {
          T && y();
        }).catch((T) => {
          yt(Su, `some error occurred: ${T}`);
        }) : k && y();
      }, b = E(() => a.cssVarBlock({
        ...o.activeColor ? { "on-color": o.activeColor } : null,
        ...o.inactiveColor ? { "off-color": o.inactiveColor } : null,
        ...o.borderColor ? { "border-color": o.borderColor } : null
      })), C = () => {
        var _, k;
        (k = (_ = d.value) == null ? void 0 : _.focus) == null || k.call(_);
      };
      return st(() => {
        d.value.checked = g.value;
      }), t({
        focus: C,
        checked: g
      }), (_, k) => (S(), V("div", {
        class: $(i(h)),
        style: Ke(i(b)),
        onClick: Ze(w, ["prevent"])
      }, [
        H("input", {
          id: i(u),
          ref_key: "input",
          ref: d,
          class: $(i(a).e("input")),
          type: "checkbox",
          role: "switch",
          "aria-checked": i(g),
          "aria-disabled": i(c),
          name: _.name,
          "true-value": _.activeValue,
          "false-value": _.inactiveValue,
          disabled: i(c),
          tabindex: _.tabindex,
          onChange: y,
          onKeydown: Et(w, ["enter"])
        }, null, 42, $G),
        !_.inlinePrompt && (_.inactiveIcon || _.inactiveText) ? (S(), V("span", {
          key: 0,
          class: $([
            i(a).e("label"),
            i(a).em("label", "left"),
            i(a).is("active", !i(g))
          ])
        }, [
          _.inactiveIcon ? (S(), ie(i(He), { key: 0 }, {
            default: X(() => [
              (S(), ie(vt(_.inactiveIcon)))
            ]),
            _: 1
          })) : se("v-if", !0),
          !_.inactiveIcon && _.inactiveText ? (S(), V("span", {
            key: 1,
            "aria-hidden": i(g)
          }, Ne(_.inactiveText), 9, NG)) : se("v-if", !0)
        ], 2)) : se("v-if", !0),
        H("span", {
          ref_key: "core",
          ref: p,
          class: $(i(a).e("core")),
          style: Ke(i(m))
        }, [
          _.inlinePrompt ? (S(), V("div", {
            key: 0,
            class: $(i(a).e("inner"))
          }, [
            _.activeIcon || _.inactiveIcon ? (S(), ie(i(He), {
              key: 0,
              class: $(i(a).is("icon"))
            }, {
              default: X(() => [
                (S(), ie(vt(i(g) ? _.activeIcon : _.inactiveIcon)))
              ]),
              _: 1
            }, 8, ["class"])) : _.activeText || _.inactiveText ? (S(), V("span", {
              key: 1,
              class: $(i(a).is("text")),
              "aria-hidden": !i(g)
            }, Ne(i(g) ? _.activeText : _.inactiveText), 11, TG)) : se("v-if", !0)
          ], 2)) : se("v-if", !0),
          H("div", {
            class: $(i(a).e("action"))
          }, [
            _.loading ? (S(), ie(i(He), {
              key: 0,
              class: $(i(a).is("loading"))
            }, {
              default: X(() => [
                K(i(Gr))
              ]),
              _: 1
            }, 8, ["class"])) : se("v-if", !0)
          ], 2)
        ], 6),
        !_.inlinePrompt && (_.activeIcon || _.activeText) ? (S(), V("span", {
          key: 1,
          class: $([
            i(a).e("label"),
            i(a).em("label", "right"),
            i(a).is("active", i(g))
          ])
        }, [
          _.activeIcon ? (S(), ie(i(He), { key: 0 }, {
            default: X(() => [
              (S(), ie(vt(_.activeIcon)))
            ]),
            _: 1
          })) : se("v-if", !0),
          !_.activeIcon && _.activeText ? (S(), V("span", {
            key: 1,
            "aria-hidden": !i(g)
          }, Ne(_.activeText), 9, OG)) : se("v-if", !0)
        ], 2)) : se("v-if", !0)
      ], 14, kG));
    }
  });
  var PG = /* @__PURE__ */ Me(IG, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]]);
  const AG = ut(PG);
  /*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   */
  var RG = /["'&<>]/, xG = DG;
  function DG(e) {
    var t = "" + e, n = RG.exec(t);
    if (!n)
      return t;
    var o, r = "", s = 0, l = 0;
    for (s = n.index; s < t.length; s++) {
      switch (t.charCodeAt(s)) {
        case 34:
          o = "&quot;";
          break;
        case 38:
          o = "&amp;";
          break;
        case 39:
          o = "&#39;";
          break;
        case 60:
          o = "&lt;";
          break;
        case 62:
          o = "&gt;";
          break;
        default:
          continue;
      }
      l !== s && (r += t.substring(l, s)), l = s + 1, r += o;
    }
    return l !== s ? r + t.substring(l, s) : r;
  }
  const Hd = function(e) {
    var t;
    return (t = e.target) == null ? void 0 : t.closest("td");
  }, LG = function(e, t, n, o, r) {
    if (!t && !o && (!r || Array.isArray(r) && !r.length))
      return e;
    typeof n == "string" ? n = n === "descending" ? -1 : 1 : n = n && n < 0 ? -1 : 1;
    const s = o ? null : function(a, u) {
      return r ? (Array.isArray(r) || (r = [r]), r.map((c) => typeof c == "string" ? Kt(a, c) : c(a, u, e))) : (t !== "$key" && rt(a) && "$value" in a && (a = a.$value), [rt(a) ? Kt(a, t) : a]);
    }, l = function(a, u) {
      if (o)
        return o(a.value, u.value);
      for (let c = 0, f = a.key.length; c < f; c++) {
        if (a.key[c] < u.key[c])
          return -1;
        if (a.key[c] > u.key[c])
          return 1;
      }
      return 0;
    };
    return e.map((a, u) => ({
      value: a,
      index: u,
      key: s ? s(a, u) : null
    })).sort((a, u) => {
      let c = l(a, u);
      return c || (c = a.index - u.index), c * +n;
    }).map((a) => a.value);
  }, uS = function(e, t) {
    let n = null;
    return e.columns.forEach((o) => {
      o.id === t && (n = o);
    }), n;
  }, VG = function(e, t) {
    let n = null;
    for (let o = 0; o < e.columns.length; o++) {
      const r = e.columns[o];
      if (r.columnKey === t) {
        n = r;
        break;
      }
    }
    return n || Yt("ElTable", `No column matching with column-key: ${t}`), n;
  }, Vy = function(e, t, n) {
    const o = (t.className || "").match(new RegExp(`${n}-table_[^\\s]+`, "gm"));
    return o ? uS(e, o[0]) : null;
  }, vn = (e, t) => {
    if (!e)
      throw new Error("Row is required when get row identity");
    if (typeof t == "string") {
      if (!t.includes("."))
        return `${e[t]}`;
      const n = t.split(".");
      let o = e;
      for (const r of n)
        o = o[r];
      return `${o}`;
    } else if (typeof t == "function")
      return t.call(null, e);
  }, vs = function(e, t) {
    const n = {};
    return (e || []).forEach((o, r) => {
      n[vn(o, t)] = { row: o, index: r };
    }), n;
  };
  function BG(e, t) {
    const n = {};
    let o;
    for (o in e)
      n[o] = e[o];
    for (o in t)
      if (ht(t, o)) {
        const r = t[o];
        typeof r < "u" && (n[o] = r);
      }
    return n;
  }
  function uv(e) {
    return e === "" || e !== void 0 && (e = Number.parseInt(e, 10), Number.isNaN(e) && (e = "")), e;
  }
  function cS(e) {
    return e === "" || e !== void 0 && (e = uv(e), Number.isNaN(e) && (e = 80)), e;
  }
  function FG(e) {
    return typeof e == "number" ? e : typeof e == "string" ? /^\d+(?:px)?$/.test(e) ? Number.parseInt(e, 10) : e : null;
  }
  function HG(...e) {
    return e.length === 0 ? (t) => t : e.length === 1 ? e[0] : e.reduce((t, n) => (...o) => t(n(...o)));
  }
  function wa(e, t, n) {
    let o = !1;
    const r = e.indexOf(t), s = r !== -1, l = (a) => {
      a === "add" ? e.push(t) : e.splice(r, 1), o = !0, De(t.children) && t.children.forEach((u) => {
        wa(e, u, n != null ? n : !s);
      });
    };
    return tn(n) ? n && !s ? l("add") : !n && s && l("remove") : l(s ? "remove" : "add"), o;
  }
  function zG(e, t, n = "children", o = "hasChildren") {
    const r = (l) => !(Array.isArray(l) && l.length);
    function s(l, a, u) {
      t(l, a, u), a.forEach((c) => {
        if (c[o]) {
          t(c, null, u + 1);
          return;
        }
        const f = c[n];
        r(f) || s(c, f, u + 1);
      });
    }
    e.forEach((l) => {
      if (l[o]) {
        t(l, null, 0);
        return;
      }
      const a = l[n];
      r(a) || s(l, a, 0);
    });
  }
  let Xo;
  function KG(e, t, n, o, r) {
    r = K1({
      enterable: !0,
      showArrow: !0
    }, r);
    const s = e == null ? void 0 : e.dataset.prefix, l = e == null ? void 0 : e.querySelector(`.${s}-scrollbar__wrap`);
    function a() {
      const g = r.effect === "light", y = document.createElement("div");
      return y.className = [
        `${s}-popper`,
        g ? "is-light" : "is-dark",
        r.popperClass || ""
      ].join(" "), n = xG(n), y.innerHTML = n, y.style.zIndex = String(o()), e == null || e.appendChild(y), y;
    }
    function u() {
      const g = document.createElement("div");
      return g.className = `${s}-popper__arrow`, g;
    }
    function c() {
      f && f.update();
    }
    Xo == null || Xo(), Xo = () => {
      try {
        f && f.destroy(), h && (e == null || e.removeChild(h)), t.removeEventListener("mouseenter", d), t.removeEventListener("mouseleave", p), l == null || l.removeEventListener("scroll", Xo), Xo = void 0;
      } catch {
      }
    };
    let f = null, d = c, p = Xo;
    r.enterable && ({ onOpen: d, onClose: p } = Ew({
      showAfter: r.showAfter,
      hideAfter: r.hideAfter,
      open: c,
      close: Xo
    }));
    const h = a();
    h.onmouseenter = d, h.onmouseleave = p;
    const m = [];
    if (r.offset && m.push({
      name: "offset",
      options: {
        offset: [0, r.offset]
      }
    }), r.showArrow) {
      const g = h.appendChild(u());
      m.push({
        name: "arrow",
        options: {
          element: g,
          padding: 10
        }
      });
    }
    const v = r.popperOptions || {};
    return f = bw(t, h, {
      placement: r.placement || "top",
      strategy: "fixed",
      ...v,
      modifiers: v.modifiers ? m.concat(v.modifiers) : m
    }), t.addEventListener("mouseenter", d), t.addEventListener("mouseleave", p), l == null || l.addEventListener("scroll", Xo), f;
  }
  function dS(e) {
    return e.children ? yP(e.children, dS) : [e];
  }
  function By(e, t) {
    return e + t.colSpan;
  }
  const fS = (e, t, n, o) => {
    let r = 0, s = e;
    const l = n.states.columns.value;
    if (o) {
      const u = dS(o[e]);
      r = l.slice(0, l.indexOf(u[0])).reduce(By, 0), s = r + u.reduce(By, 0) - 1;
    } else
      r = e;
    let a;
    switch (t) {
      case "left":
        s < n.states.fixedLeafColumnsLength.value && (a = "left");
        break;
      case "right":
        r >= l.length - n.states.rightFixedLeafColumnsLength.value && (a = "right");
        break;
      default:
        s < n.states.fixedLeafColumnsLength.value ? a = "left" : r >= l.length - n.states.rightFixedLeafColumnsLength.value && (a = "right");
    }
    return a ? {
      direction: a,
      start: r,
      after: s
    } : {};
  }, cv = (e, t, n, o, r, s = 0) => {
    const l = [], { direction: a, start: u, after: c } = fS(t, n, o, r);
    if (a) {
      const f = a === "left";
      l.push(`${e}-fixed-column--${a}`), f && c + s === o.states.fixedLeafColumnsLength.value - 1 ? l.push("is-last-column") : !f && u - s === o.states.columns.value.length - o.states.rightFixedLeafColumnsLength.value && l.push("is-first-column");
    }
    return l;
  };
  function Fy(e, t) {
    return e + (t.realWidth === null || Number.isNaN(t.realWidth) ? Number(t.width) : t.realWidth);
  }
  const dv = (e, t, n, o) => {
    const {
      direction: r,
      start: s = 0,
      after: l = 0
    } = fS(e, t, n, o);
    if (!r)
      return;
    const a = {}, u = r === "left", c = n.states.columns.value;
    return u ? a.left = c.slice(0, s).reduce(Fy, 0) : a.right = c.slice(l + 1).reverse().reduce(Fy, 0), a;
  }, xl = (e, t) => {
    !e || Number.isNaN(e[t]) || (e[t] = `${e[t]}px`);
  };
  function jG(e) {
    const t = it(), n = I(!1), o = I([]);
    return {
      updateExpandRows: () => {
        const u = e.data.value || [], c = e.rowKey.value;
        if (n.value)
          o.value = u.slice();
        else if (c) {
          const f = vs(o.value, c);
          o.value = u.reduce((d, p) => {
            const h = vn(p, c);
            return f[h] && d.push(p), d;
          }, []);
        } else
          o.value = [];
      },
      toggleRowExpansion: (u, c) => {
        wa(o.value, u, c) && t.emit("expand-change", u, o.value.slice());
      },
      setExpandRowKeys: (u) => {
        t.store.assertRowKey();
        const c = e.data.value || [], f = e.rowKey.value, d = vs(c, f);
        o.value = u.reduce((p, h) => {
          const m = d[h];
          return m && p.push(m.row), p;
        }, []);
      },
      isRowExpanded: (u) => {
        const c = e.rowKey.value;
        return c ? !!vs(o.value, c)[vn(u, c)] : o.value.includes(u);
      },
      states: {
        expandRows: o,
        defaultExpandAll: n
      }
    };
  }
  function WG(e) {
    const t = it(), n = I(null), o = I(null), r = (c) => {
      t.store.assertRowKey(), n.value = c, l(c);
    }, s = () => {
      n.value = null;
    }, l = (c) => {
      const { data: f, rowKey: d } = e;
      let p = null;
      d.value && (p = (i(f) || []).find((h) => vn(h, d.value) === c)), o.value = p, t.emit("current-change", o.value, null);
    };
    return {
      setCurrentRowKey: r,
      restoreCurrentRowKey: s,
      setCurrentRowByKey: l,
      updateCurrentRow: (c) => {
        const f = o.value;
        if (c && c !== f) {
          o.value = c, t.emit("current-change", o.value, f);
          return;
        }
        !c && f && (o.value = null, t.emit("current-change", null, f));
      },
      updateCurrentRowData: () => {
        const c = e.rowKey.value, f = e.data.value || [], d = o.value;
        if (!f.includes(d) && d) {
          if (c) {
            const p = vn(d, c);
            l(p);
          } else
            o.value = null;
          o.value === null && t.emit("current-change", null, d);
        } else
          n.value && (l(n.value), s());
      },
      states: {
        _currentRowKey: n,
        currentRow: o
      }
    };
  }
  function UG(e) {
    const t = I([]), n = I({}), o = I(16), r = I(!1), s = I({}), l = I("hasChildren"), a = I("children"), u = it(), c = E(() => {
      if (!e.rowKey.value)
        return {};
      const y = e.data.value || [];
      return d(y);
    }), f = E(() => {
      const y = e.rowKey.value, w = Object.keys(s.value), b = {};
      return w.length && w.forEach((C) => {
        if (s.value[C].length) {
          const _ = { children: [] };
          s.value[C].forEach((k) => {
            const O = vn(k, y);
            _.children.push(O), k[l.value] && !b[O] && (b[O] = { children: [] });
          }), b[C] = _;
        }
      }), b;
    }), d = (y) => {
      const w = e.rowKey.value, b = {};
      return zG(y, (C, _, k) => {
        const O = vn(C, w);
        Array.isArray(_) ? b[O] = {
          children: _.map((T) => vn(T, w)),
          level: k
        } : r.value && (b[O] = {
          children: [],
          lazy: !0,
          level: k
        });
      }, a.value, l.value), b;
    }, p = (y = !1, w = ((b) => (b = u.store) == null ? void 0 : b.states.defaultExpandAll.value)()) => {
      var b;
      const C = c.value, _ = f.value, k = Object.keys(C), O = {};
      if (k.length) {
        const T = i(n), P = [], A = (D, B) => {
          if (y)
            return t.value ? w || t.value.includes(B) : !!(w || (D == null ? void 0 : D.expanded));
          {
            const F = w || t.value && t.value.includes(B);
            return !!((D == null ? void 0 : D.expanded) || F);
          }
        };
        k.forEach((D) => {
          const B = T[D], F = { ...C[D] };
          if (F.expanded = A(B, D), F.lazy) {
            const { loaded: W = !1, loading: x = !1 } = B || {};
            F.loaded = !!W, F.loading = !!x, P.push(D);
          }
          O[D] = F;
        });
        const L = Object.keys(_);
        r.value && L.length && P.length && L.forEach((D) => {
          const B = T[D], F = _[D].children;
          if (P.includes(D)) {
            if (O[D].children.length !== 0)
              throw new Error("[ElTable]children must be an empty array.");
            O[D].children = F;
          } else {
            const { loaded: W = !1, loading: x = !1 } = B || {};
            O[D] = {
              lazy: !0,
              loaded: !!W,
              loading: !!x,
              expanded: A(B, D),
              children: F,
              level: ""
            };
          }
        });
      }
      n.value = O, (b = u.store) == null || b.updateTableScrollY();
    };
    me(() => t.value, () => {
      p(!0);
    }), me(() => c.value, () => {
      p();
    }), me(() => f.value, () => {
      p();
    });
    const h = (y) => {
      t.value = y, p();
    }, m = (y, w) => {
      u.store.assertRowKey();
      const b = e.rowKey.value, C = vn(y, b), _ = C && n.value[C];
      if (C && _ && "expanded" in _) {
        const k = _.expanded;
        w = typeof w > "u" ? !_.expanded : w, n.value[C].expanded = w, k !== w && u.emit("expand-change", y, w), u.store.updateTableScrollY();
      }
    }, v = (y) => {
      u.store.assertRowKey();
      const w = e.rowKey.value, b = vn(y, w), C = n.value[b];
      r.value && C && "loaded" in C && !C.loaded ? g(y, b, C) : m(y, void 0);
    }, g = (y, w, b) => {
      const { load: C } = u.props;
      C && !n.value[w].loaded && (n.value[w].loading = !0, C(y, b, (_) => {
        if (!Array.isArray(_))
          throw new TypeError("[ElTable] data must be an array");
        n.value[w].loading = !1, n.value[w].loaded = !0, n.value[w].expanded = !0, _.length && (s.value[w] = _), u.emit("expand-change", y, !0);
      }));
    };
    return {
      loadData: g,
      loadOrToggle: v,
      toggleTreeExpansion: m,
      updateTreeExpandKeys: h,
      updateTreeData: p,
      normalize: d,
      states: {
        expandRowKeys: t,
        treeData: n,
        indent: o,
        lazy: r,
        lazyTreeNodeMap: s,
        lazyColumnIdentifier: l,
        childrenColumnName: a
      }
    };
  }
  const qG = (e, t) => {
    const n = t.sortingColumn;
    return !n || typeof n.sortable == "string" ? e : LG(e, t.sortProp, t.sortOrder, n.sortMethod, n.sortBy);
  }, _u = (e) => {
    const t = [];
    return e.forEach((n) => {
      n.children ? t.push.apply(t, _u(n.children)) : t.push(n);
    }), t;
  };
  function YG() {
    var e;
    const t = it(), { size: n } = rn((e = t.proxy) == null ? void 0 : e.$props), o = I(null), r = I([]), s = I([]), l = I(!1), a = I([]), u = I([]), c = I([]), f = I([]), d = I([]), p = I([]), h = I([]), m = I([]), v = [], g = I(0), y = I(0), w = I(0), b = I(!1), C = I([]), _ = I(!1), k = I(!1), O = I(null), T = I({}), P = I(null), A = I(null), L = I(null), D = I(null), B = I(null);
    me(r, () => t.state && N(!1), {
      deep: !0
    });
    const F = () => {
      if (!o.value)
        throw new Error("[ElTable] prop row-key is required");
    }, W = (Ce) => {
      var ue;
      (ue = Ce.children) == null || ue.forEach((q) => {
        q.fixed = Ce.fixed, W(q);
      });
    }, x = () => {
      a.value.forEach((be) => {
        W(be);
      }), f.value = a.value.filter((be) => be.fixed === !0 || be.fixed === "left"), d.value = a.value.filter((be) => be.fixed === "right"), f.value.length > 0 && a.value[0] && a.value[0].type === "selection" && !a.value[0].fixed && (a.value[0].fixed = !0, f.value.unshift(a.value[0]));
      const Ce = a.value.filter((be) => !be.fixed);
      u.value = [].concat(f.value).concat(Ce).concat(d.value);
      const ue = _u(Ce), q = _u(f.value), oe = _u(d.value);
      g.value = ue.length, y.value = q.length, w.value = oe.length, c.value = [].concat(q).concat(ue).concat(oe), l.value = f.value.length > 0 || d.value.length > 0;
    }, N = (Ce, ue = !1) => {
      Ce && x(), ue ? t.state.doLayout() : t.state.debouncedUpdateLayout();
    }, R = (Ce) => C.value.includes(Ce), M = () => {
      b.value = !1, C.value.length && (C.value = [], t.emit("selection-change", []));
    }, j = () => {
      let Ce;
      if (o.value) {
        Ce = [];
        const ue = vs(C.value, o.value), q = vs(r.value, o.value);
        for (const oe in ue)
          ht(ue, oe) && !q[oe] && Ce.push(ue[oe].row);
      } else
        Ce = C.value.filter((ue) => !r.value.includes(ue));
      if (Ce.length) {
        const ue = C.value.filter((q) => !Ce.includes(q));
        C.value = ue, t.emit("selection-change", ue.slice());
      }
    }, te = () => (C.value || []).slice(), U = (Ce, ue = void 0, q = !0) => {
      if (wa(C.value, Ce, ue)) {
        const be = (C.value || []).slice();
        q && t.emit("select", be, Ce), t.emit("selection-change", be);
      }
    }, Z = () => {
      var Ce, ue;
      const q = k.value ? !b.value : !(b.value || C.value.length);
      b.value = q;
      let oe = !1, be = 0;
      const xe = (ue = (Ce = t == null ? void 0 : t.store) == null ? void 0 : Ce.states) == null ? void 0 : ue.rowKey.value;
      r.value.forEach((nt, ve) => {
        const Le = ve + be;
        O.value ? O.value.call(null, nt, Le) && wa(C.value, nt, q) && (oe = !0) : wa(C.value, nt, q) && (oe = !0), be += ee(vn(nt, xe));
      }), oe && t.emit("selection-change", C.value ? C.value.slice() : []), t.emit("select-all", C.value);
    }, pe = () => {
      const Ce = vs(C.value, o.value);
      r.value.forEach((ue) => {
        const q = vn(ue, o.value), oe = Ce[q];
        oe && (C.value[oe.index] = ue);
      });
    }, J = () => {
      var Ce, ue, q;
      if (((Ce = r.value) == null ? void 0 : Ce.length) === 0) {
        b.value = !1;
        return;
      }
      let oe;
      o.value && (oe = vs(C.value, o.value));
      const be = function(Le) {
        return oe ? !!oe[vn(Le, o.value)] : C.value.includes(Le);
      };
      let xe = !0, nt = 0, ve = 0;
      for (let Le = 0, lt = (r.value || []).length; Le < lt; Le++) {
        const ct = (q = (ue = t == null ? void 0 : t.store) == null ? void 0 : ue.states) == null ? void 0 : q.rowKey.value, mt = Le + ve, Mt = r.value[Le], ln = O.value && O.value.call(null, Mt, mt);
        if (be(Mt))
          nt++;
        else if (!O.value || ln) {
          xe = !1;
          break;
        }
        ve += ee(vn(Mt, ct));
      }
      nt === 0 && (xe = !1), b.value = xe;
    }, ee = (Ce) => {
      var ue;
      if (!t || !t.store)
        return 0;
      const { treeData: q } = t.store.states;
      let oe = 0;
      const be = (ue = q.value[Ce]) == null ? void 0 : ue.children;
      return be && (oe += be.length, be.forEach((xe) => {
        oe += ee(xe);
      })), oe;
    }, ne = (Ce, ue) => {
      Array.isArray(Ce) || (Ce = [Ce]);
      const q = {};
      return Ce.forEach((oe) => {
        T.value[oe.id] = ue, q[oe.columnKey || oe.id] = ue;
      }), q;
    }, Y = (Ce, ue, q) => {
      A.value && A.value !== Ce && (A.value.order = null), A.value = Ce, L.value = ue, D.value = q;
    }, re = () => {
      let Ce = i(s);
      Object.keys(T.value).forEach((ue) => {
        const q = T.value[ue];
        if (!q || q.length === 0)
          return;
        const oe = uS({
          columns: c.value
        }, ue);
        oe && oe.filterMethod && (Ce = Ce.filter((be) => q.some((xe) => oe.filterMethod.call(null, xe, be, oe))));
      }), P.value = Ce;
    }, ce = () => {
      r.value = qG(P.value, {
        sortingColumn: A.value,
        sortProp: L.value,
        sortOrder: D.value
      });
    }, Te = (Ce = void 0) => {
      Ce && Ce.filter || re(), ce();
    }, Pe = (Ce) => {
      const { tableHeaderRef: ue } = t.refs;
      if (!ue)
        return;
      const q = Object.assign({}, ue.filterPanels), oe = Object.keys(q);
      if (!!oe.length)
        if (typeof Ce == "string" && (Ce = [Ce]), Array.isArray(Ce)) {
          const be = Ce.map((xe) => VG({
            columns: c.value
          }, xe));
          oe.forEach((xe) => {
            const nt = be.find((ve) => ve.id === xe);
            nt && (nt.filteredValue = []);
          }), t.store.commit("filterChange", {
            column: be,
            values: [],
            silent: !0,
            multi: !0
          });
        } else
          oe.forEach((be) => {
            const xe = c.value.find((nt) => nt.id === be);
            xe && (xe.filteredValue = []);
          }), T.value = {}, t.store.commit("filterChange", {
            column: {},
            values: [],
            silent: !0
          });
    }, z = () => {
      !A.value || (Y(null, null, null), t.store.commit("changeSortCondition", {
        silent: !0
      }));
    }, {
      setExpandRowKeys: Q,
      toggleRowExpansion: de,
      updateExpandRows: Oe,
      states: ae,
      isRowExpanded: Ee
    } = jG({
      data: r,
      rowKey: o
    }), {
      updateTreeExpandKeys: we,
      toggleTreeExpansion: Se,
      updateTreeData: _e,
      loadOrToggle: ke,
      states: Re
    } = UG({
      data: r,
      rowKey: o
    }), {
      updateCurrentRowData: fe,
      updateCurrentRow: Ae,
      setCurrentRowKey: qe,
      states: tt
    } = WG({
      data: r,
      rowKey: o
    });
    return {
      assertRowKey: F,
      updateColumns: x,
      scheduleLayout: N,
      isSelected: R,
      clearSelection: M,
      cleanSelection: j,
      getSelectionRows: te,
      toggleRowSelection: U,
      _toggleAllSelection: Z,
      toggleAllSelection: null,
      updateSelectionByRowKey: pe,
      updateAllSelected: J,
      updateFilters: ne,
      updateCurrentRow: Ae,
      updateSort: Y,
      execFilter: re,
      execSort: ce,
      execQuery: Te,
      clearFilter: Pe,
      clearSort: z,
      toggleRowExpansion: de,
      setExpandRowKeysAdapter: (Ce) => {
        Q(Ce), we(Ce);
      },
      setCurrentRowKey: qe,
      toggleRowExpansionAdapter: (Ce, ue) => {
        c.value.some(({ type: oe }) => oe === "expand") ? de(Ce, ue) : Se(Ce, ue);
      },
      isRowExpanded: Ee,
      updateExpandRows: Oe,
      updateCurrentRowData: fe,
      loadOrToggle: ke,
      updateTreeData: _e,
      states: {
        tableSize: n,
        rowKey: o,
        data: r,
        _data: s,
        isComplex: l,
        _columns: a,
        originColumns: u,
        columns: c,
        fixedColumns: f,
        rightFixedColumns: d,
        leafColumns: p,
        fixedLeafColumns: h,
        rightFixedLeafColumns: m,
        updateOrderFns: v,
        leafColumnsLength: g,
        fixedLeafColumnsLength: y,
        rightFixedLeafColumnsLength: w,
        isAllSelected: b,
        selection: C,
        reserveSelection: _,
        selectOnIndeterminate: k,
        selectable: O,
        filters: T,
        filteredData: P,
        sortingColumn: A,
        sortProp: L,
        sortOrder: D,
        hoverRow: B,
        ...ae,
        ...Re,
        ...tt
      }
    };
  }
  function dp(e, t) {
    return e.map((n) => {
      var o;
      return n.id === t.id ? t : ((o = n.children) != null && o.length && (n.children = dp(n.children, t)), n);
    });
  }
  function fp(e) {
    e.forEach((t) => {
      var n, o;
      t.no = (n = t.getColumnIndex) == null ? void 0 : n.call(t), (o = t.children) != null && o.length && fp(t.children);
    }), e.sort((t, n) => t.no - n.no);
  }
  function GG() {
    const e = it(), t = YG();
    return {
      ns: ge("table"),
      ...t,
      mutations: {
        setData(l, a) {
          const u = i(l._data) !== a;
          l.data.value = a, l._data.value = a, e.store.execQuery(), e.store.updateCurrentRowData(), e.store.updateExpandRows(), e.store.updateTreeData(e.store.states.defaultExpandAll.value), i(l.reserveSelection) ? (e.store.assertRowKey(), e.store.updateSelectionByRowKey()) : u ? e.store.clearSelection() : e.store.cleanSelection(), e.store.updateAllSelected(), e.$ready && e.store.scheduleLayout();
        },
        insertColumn(l, a, u, c) {
          const f = i(l._columns);
          let d = [];
          u ? (u && !u.children && (u.children = []), u.children.push(a), d = dp(f, u)) : (f.push(a), d = f), fp(d), l._columns.value = d, l.updateOrderFns.push(c), a.type === "selection" && (l.selectable.value = a.selectable, l.reserveSelection.value = a.reserveSelection), e.$ready && (e.store.updateColumns(), e.store.scheduleLayout());
        },
        updateColumnOrder(l, a) {
          var u;
          ((u = a.getColumnIndex) == null ? void 0 : u.call(a)) !== a.no && (fp(l._columns.value), e.$ready && e.store.updateColumns());
        },
        removeColumn(l, a, u, c) {
          const f = i(l._columns) || [];
          if (u)
            u.children.splice(u.children.findIndex((p) => p.id === a.id), 1), Fe(() => {
              var p;
              ((p = u.children) == null ? void 0 : p.length) === 0 && delete u.children;
            }), l._columns.value = dp(f, u);
          else {
            const p = f.indexOf(a);
            p > -1 && (f.splice(p, 1), l._columns.value = f);
          }
          const d = l.updateOrderFns.indexOf(c);
          d > -1 && l.updateOrderFns.splice(d, 1), e.$ready && (e.store.updateColumns(), e.store.scheduleLayout());
        },
        sort(l, a) {
          const { prop: u, order: c, init: f } = a;
          if (u) {
            const d = i(l.columns).find((p) => p.property === u);
            d && (d.order = c, e.store.updateSort(d, u, c), e.store.commit("changeSortCondition", { init: f }));
          }
        },
        changeSortCondition(l, a) {
          const { sortingColumn: u, sortProp: c, sortOrder: f } = l, d = i(u), p = i(c), h = i(f);
          h === null && (l.sortingColumn.value = null, l.sortProp.value = null);
          const m = { filter: !0 };
          e.store.execQuery(m), (!a || !(a.silent || a.init)) && e.emit("sort-change", {
            column: d,
            prop: p,
            order: h
          }), e.store.updateTableScrollY();
        },
        filterChange(l, a) {
          const { column: u, values: c, silent: f } = a, d = e.store.updateFilters(u, c);
          e.store.execQuery(), f || e.emit("filter-change", d), e.store.updateTableScrollY();
        },
        toggleAllSelection() {
          e.store.toggleAllSelection();
        },
        rowSelectedChanged(l, a) {
          e.store.toggleRowSelection(a), e.store.updateAllSelected();
        },
        setHoverRow(l, a) {
          l.hoverRow.value = a;
        },
        setCurrentRow(l, a) {
          e.store.updateCurrentRow(a);
        }
      },
      commit: function(l, ...a) {
        const u = e.store.mutations;
        if (u[l])
          u[l].apply(e, [e.store.states].concat(a));
        else
          throw new Error(`Action not found: ${l}`);
      },
      updateTableScrollY: function() {
        Fe(() => e.layout.updateScrollY.apply(e.layout));
      }
    };
  }
  const Ca = {
    rowKey: "rowKey",
    defaultExpandAll: "defaultExpandAll",
    selectOnIndeterminate: "selectOnIndeterminate",
    indent: "indent",
    lazy: "lazy",
    data: "data",
    ["treeProps.hasChildren"]: {
      key: "lazyColumnIdentifier",
      default: "hasChildren"
    },
    ["treeProps.children"]: {
      key: "childrenColumnName",
      default: "children"
    }
  };
  function XG(e, t) {
    if (!e)
      throw new Error("Table is required.");
    const n = GG();
    return n.toggleAllSelection = On(n._toggleAllSelection, 10), Object.keys(Ca).forEach((o) => {
      pS(hS(t, o), o, n);
    }), JG(n, t), n;
  }
  function JG(e, t) {
    Object.keys(Ca).forEach((n) => {
      me(() => hS(t, n), (o) => {
        pS(o, n, e);
      });
    });
  }
  function pS(e, t, n) {
    let o = e, r = Ca[t];
    typeof Ca[t] == "object" && (r = r.key, o = o || Ca[t].default), n.states[r].value = o;
  }
  function hS(e, t) {
    if (t.includes(".")) {
      const n = t.split(".");
      let o = e;
      return n.forEach((r) => {
        o = o[r];
      }), o;
    } else
      return e[t];
  }
  class ZG {
    constructor(t) {
      this.observers = [], this.table = null, this.store = null, this.columns = [], this.fit = !0, this.showHeader = !0, this.height = I(null), this.scrollX = I(!1), this.scrollY = I(!1), this.bodyWidth = I(null), this.fixedWidth = I(null), this.rightFixedWidth = I(null), this.gutterWidth = 0;
      for (const n in t)
        ht(t, n) && (Pt(this[n]) ? this[n].value = t[n] : this[n] = t[n]);
      if (!this.table)
        throw new Error("Table is required for Table Layout");
      if (!this.store)
        throw new Error("Store is required for Table Layout");
    }
    updateScrollY() {
      if (this.height.value === null)
        return !1;
      const n = this.table.refs.scrollBarRef;
      if (this.table.vnode.el && (n == null ? void 0 : n.wrapRef)) {
        let o = !0;
        const r = this.scrollY.value;
        return o = n.wrapRef.scrollHeight > n.wrapRef.clientHeight, this.scrollY.value = o, r !== o;
      }
      return !1;
    }
    setHeight(t, n = "height") {
      if (!bt)
        return;
      const o = this.table.vnode.el;
      if (t = FG(t), this.height.value = Number(t), !o && (t || t === 0))
        return Fe(() => this.setHeight(t, n));
      typeof t == "number" ? (o.style[n] = `${t}px`, this.updateElsHeight()) : typeof t == "string" && (o.style[n] = t, this.updateElsHeight());
    }
    setMaxHeight(t) {
      this.setHeight(t, "max-height");
    }
    getFlattenColumns() {
      const t = [];
      return this.table.store.states.columns.value.forEach((o) => {
        o.isColumnGroup ? t.push.apply(t, o.columns) : t.push(o);
      }), t;
    }
    updateElsHeight() {
      this.updateScrollY(), this.notifyObservers("scrollable");
    }
    headerDisplayNone(t) {
      if (!t)
        return !0;
      let n = t;
      for (; n.tagName !== "DIV"; ) {
        if (getComputedStyle(n).display === "none")
          return !0;
        n = n.parentElement;
      }
      return !1;
    }
    updateColumnsWidth() {
      if (!bt)
        return;
      const t = this.fit, n = this.table.vnode.el.clientWidth;
      let o = 0;
      const r = this.getFlattenColumns(), s = r.filter((u) => typeof u.width != "number");
      if (r.forEach((u) => {
        typeof u.width == "number" && u.realWidth && (u.realWidth = null);
      }), s.length > 0 && t) {
        if (r.forEach((u) => {
          o += Number(u.width || u.minWidth || 80);
        }), o <= n) {
          this.scrollX.value = !1;
          const u = n - o;
          if (s.length === 1)
            s[0].realWidth = Number(s[0].minWidth || 80) + u;
          else {
            const c = s.reduce((p, h) => p + Number(h.minWidth || 80), 0), f = u / c;
            let d = 0;
            s.forEach((p, h) => {
              if (h === 0)
                return;
              const m = Math.floor(Number(p.minWidth || 80) * f);
              d += m, p.realWidth = Number(p.minWidth || 80) + m;
            }), s[0].realWidth = Number(s[0].minWidth || 80) + u - d;
          }
        } else
          this.scrollX.value = !0, s.forEach((u) => {
            u.realWidth = Number(u.minWidth);
          });
        this.bodyWidth.value = Math.max(o, n), this.table.state.resizeState.value.width = this.bodyWidth.value;
      } else
        r.forEach((u) => {
          !u.width && !u.minWidth ? u.realWidth = 80 : u.realWidth = Number(u.width || u.minWidth), o += u.realWidth;
        }), this.scrollX.value = o > n, this.bodyWidth.value = o;
      const l = this.store.states.fixedColumns.value;
      if (l.length > 0) {
        let u = 0;
        l.forEach((c) => {
          u += Number(c.realWidth || c.width);
        }), this.fixedWidth.value = u;
      }
      const a = this.store.states.rightFixedColumns.value;
      if (a.length > 0) {
        let u = 0;
        a.forEach((c) => {
          u += Number(c.realWidth || c.width);
        }), this.rightFixedWidth.value = u;
      }
      this.notifyObservers("columns");
    }
    addObserver(t) {
      this.observers.push(t);
    }
    removeObserver(t) {
      const n = this.observers.indexOf(t);
      n !== -1 && this.observers.splice(n, 1);
    }
    notifyObservers(t) {
      this.observers.forEach((o) => {
        var r, s;
        switch (t) {
          case "columns":
            (r = o.state) == null || r.onColumnsChange(this);
            break;
          case "scrollable":
            (s = o.state) == null || s.onScrollableChange(this);
            break;
          default:
            throw new Error(`Table Layout don't have event ${t}.`);
        }
      });
    }
  }
  const { CheckboxGroup: QG } = co, eX = G({
    name: "ElTableFilterPanel",
    components: {
      ElCheckbox: co,
      ElCheckboxGroup: QG,
      ElScrollbar: pr,
      ElTooltip: Mn,
      ElIcon: He,
      ArrowDown: qr,
      ArrowUp: Bc
    },
    directives: { ClickOutside: Kr },
    props: {
      placement: {
        type: String,
        default: "bottom-start"
      },
      store: {
        type: Object
      },
      column: {
        type: Object
      },
      upDataColumn: {
        type: Function
      }
    },
    setup(e) {
      const t = it(), { t: n } = St(), o = ge("table-filter"), r = t == null ? void 0 : t.parent;
      r.filterPanels.value[e.column.id] || (r.filterPanels.value[e.column.id] = t);
      const s = I(!1), l = I(null), a = E(() => e.column && e.column.filters), u = E({
        get: () => {
          var C;
          return (((C = e.column) == null ? void 0 : C.filteredValue) || [])[0];
        },
        set: (C) => {
          c.value && (typeof C < "u" && C !== null ? c.value.splice(0, 1, C) : c.value.splice(0, 1));
        }
      }), c = E({
        get() {
          return e.column ? e.column.filteredValue || [] : [];
        },
        set(C) {
          e.column && e.upDataColumn("filteredValue", C);
        }
      }), f = E(() => e.column ? e.column.filterMultiple : !0), d = (C) => C.value === u.value, p = () => {
        s.value = !1;
      }, h = (C) => {
        C.stopPropagation(), s.value = !s.value;
      }, m = () => {
        s.value = !1;
      }, v = () => {
        w(c.value), p();
      }, g = () => {
        c.value = [], w(c.value), p();
      }, y = (C) => {
        u.value = C, w(typeof C < "u" && C !== null ? c.value : []), p();
      }, w = (C) => {
        e.store.commit("filterChange", {
          column: e.column,
          values: C
        }), e.store.updateAllSelected();
      };
      me(s, (C) => {
        e.column && e.upDataColumn("filterOpened", C);
      }, {
        immediate: !0
      });
      const b = E(() => {
        var C, _;
        return (_ = (C = l.value) == null ? void 0 : C.popperRef) == null ? void 0 : _.contentRef;
      });
      return {
        tooltipVisible: s,
        multiple: f,
        filteredValue: c,
        filterValue: u,
        filters: a,
        handleConfirm: v,
        handleReset: g,
        handleSelect: y,
        isActive: d,
        t: n,
        ns: o,
        showFilterPanel: h,
        hideFilterPanel: m,
        popperPaneRef: b,
        tooltip: l
      };
    }
  }), tX = { key: 0 }, nX = ["disabled"], oX = ["label", "onClick"];
  function rX(e, t, n, o, r, s) {
    const l = Qe("el-checkbox"), a = Qe("el-checkbox-group"), u = Qe("el-scrollbar"), c = Qe("arrow-up"), f = Qe("arrow-down"), d = Qe("el-icon"), p = Qe("el-tooltip"), h = Aa("click-outside");
    return S(), ie(p, {
      ref: "tooltip",
      visible: e.tooltipVisible,
      offset: 0,
      placement: e.placement,
      "show-arrow": !1,
      "stop-popper-mouse-event": !1,
      teleported: "",
      effect: "light",
      pure: "",
      "popper-class": e.ns.b(),
      persistent: ""
    }, {
      content: X(() => [
        e.multiple ? (S(), V("div", tX, [
          H("div", {
            class: $(e.ns.e("content"))
          }, [
            K(u, {
              "wrap-class": e.ns.e("wrap")
            }, {
              default: X(() => [
                K(a, {
                  modelValue: e.filteredValue,
                  "onUpdate:modelValue": t[0] || (t[0] = (m) => e.filteredValue = m),
                  class: $(e.ns.e("checkbox-group"))
                }, {
                  default: X(() => [
                    (S(!0), V(ze, null, gt(e.filters, (m) => (S(), ie(l, {
                      key: m.value,
                      label: m.value
                    }, {
                      default: X(() => [
                        wt(Ne(m.text), 1)
                      ]),
                      _: 2
                    }, 1032, ["label"]))), 128))
                  ]),
                  _: 1
                }, 8, ["modelValue", "class"])
              ]),
              _: 1
            }, 8, ["wrap-class"])
          ], 2),
          H("div", {
            class: $(e.ns.e("bottom"))
          }, [
            H("button", {
              class: $({ [e.ns.is("disabled")]: e.filteredValue.length === 0 }),
              disabled: e.filteredValue.length === 0,
              type: "button",
              onClick: t[1] || (t[1] = (...m) => e.handleConfirm && e.handleConfirm(...m))
            }, Ne(e.t("el.table.confirmFilter")), 11, nX),
            H("button", {
              type: "button",
              onClick: t[2] || (t[2] = (...m) => e.handleReset && e.handleReset(...m))
            }, Ne(e.t("el.table.resetFilter")), 1)
          ], 2)
        ])) : (S(), V("ul", {
          key: 1,
          class: $(e.ns.e("list"))
        }, [
          H("li", {
            class: $([
              e.ns.e("list-item"),
              {
                [e.ns.is("active")]: e.filterValue === void 0 || e.filterValue === null
              }
            ]),
            onClick: t[3] || (t[3] = (m) => e.handleSelect(null))
          }, Ne(e.t("el.table.clearFilter")), 3),
          (S(!0), V(ze, null, gt(e.filters, (m) => (S(), V("li", {
            key: m.value,
            class: $([e.ns.e("list-item"), e.ns.is("active", e.isActive(m))]),
            label: m.value,
            onClick: (v) => e.handleSelect(m.value)
          }, Ne(m.text), 11, oX))), 128))
        ], 2))
      ]),
      default: X(() => [
        ot((S(), V("span", {
          class: $([
            `${e.ns.namespace.value}-table__column-filter-trigger`,
            `${e.ns.namespace.value}-none-outline`
          ]),
          onClick: t[4] || (t[4] = (...m) => e.showFilterPanel && e.showFilterPanel(...m))
        }, [
          K(d, null, {
            default: X(() => [
              e.column.filterOpened ? (S(), ie(c, { key: 0 })) : (S(), ie(f, { key: 1 }))
            ]),
            _: 1
          })
        ], 2)), [
          [h, e.hideFilterPanel, e.popperPaneRef]
        ])
      ]),
      _: 1
    }, 8, ["visible", "placement", "popper-class"]);
  }
  var sX = /* @__PURE__ */ Me(eX, [["render", rX], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/filter-panel.vue"]]);
  function vS(e) {
    const t = it();
    kc(() => {
      n.value.addObserver(t);
    }), st(() => {
      o(n.value), r(n.value);
    }), cr(() => {
      o(n.value), r(n.value);
    }), Ur(() => {
      n.value.removeObserver(t);
    });
    const n = E(() => {
      const s = e.layout;
      if (!s)
        throw new Error("Can not find table layout.");
      return s;
    }), o = (s) => {
      var l;
      const a = ((l = e.vnode.el) == null ? void 0 : l.querySelectorAll("colgroup > col")) || [];
      if (!a.length)
        return;
      const u = s.getFlattenColumns(), c = {};
      u.forEach((f) => {
        c[f.id] = f;
      });
      for (let f = 0, d = a.length; f < d; f++) {
        const p = a[f], h = p.getAttribute("name"), m = c[h];
        m && p.setAttribute("width", m.realWidth || m.width);
      }
    }, r = (s) => {
      var l, a;
      const u = ((l = e.vnode.el) == null ? void 0 : l.querySelectorAll("colgroup > col[name=gutter]")) || [];
      for (let f = 0, d = u.length; f < d; f++)
        u[f].setAttribute("width", s.scrollY.value ? s.gutterWidth : "0");
      const c = ((a = e.vnode.el) == null ? void 0 : a.querySelectorAll("th.gutter")) || [];
      for (let f = 0, d = c.length; f < d; f++) {
        const p = c[f];
        p.style.width = s.scrollY.value ? `${s.gutterWidth}px` : "0", p.style.display = s.scrollY.value ? "" : "none";
      }
    };
    return {
      tableLayout: n.value,
      onColumnsChange: o,
      onScrollableChange: r
    };
  }
  const Ko = Symbol("ElTable");
  function lX(e, t) {
    const n = it(), o = Be(Ko), r = (v) => {
      v.stopPropagation();
    }, s = (v, g) => {
      !g.filters && g.sortable ? m(v, g, !1) : g.filterable && !g.sortable && r(v), o == null || o.emit("header-click", g, v);
    }, l = (v, g) => {
      o == null || o.emit("header-contextmenu", g, v);
    }, a = I(null), u = I(!1), c = I({}), f = (v, g) => {
      if (!!bt && !(g.children && g.children.length > 0) && a.value && e.border) {
        u.value = !0;
        const y = o;
        t("set-drag-visible", !0);
        const b = (y == null ? void 0 : y.vnode.el).getBoundingClientRect().left, C = n.vnode.el.querySelector(`th.${g.id}`), _ = C.getBoundingClientRect(), k = _.left - b + 30;
        Ao(C, "noclick"), c.value = {
          startMouseLeft: v.clientX,
          startLeft: _.right - b,
          startColumnLeft: _.left - b,
          tableLeft: b
        };
        const O = y == null ? void 0 : y.refs.resizeProxy;
        O.style.left = `${c.value.startLeft}px`, document.onselectstart = function() {
          return !1;
        }, document.ondragstart = function() {
          return !1;
        };
        const T = (A) => {
          const L = A.clientX - c.value.startMouseLeft, D = c.value.startLeft + L;
          O.style.left = `${Math.max(k, D)}px`;
        }, P = () => {
          if (u.value) {
            const { startColumnLeft: A, startLeft: L } = c.value, B = Number.parseInt(O.style.left, 10) - A;
            g.width = g.realWidth = B, y == null || y.emit("header-dragend", g.width, L - A, g, v), requestAnimationFrame(() => {
              e.store.scheduleLayout(!1, !0);
            }), document.body.style.cursor = "", u.value = !1, a.value = null, c.value = {}, t("set-drag-visible", !1);
          }
          document.removeEventListener("mousemove", T), document.removeEventListener("mouseup", P), document.onselectstart = null, document.ondragstart = null, setTimeout(() => {
            Dn(C, "noclick");
          }, 0);
        };
        document.addEventListener("mousemove", T), document.addEventListener("mouseup", P);
      }
    }, d = (v, g) => {
      var y;
      if (g.children && g.children.length > 0)
        return;
      const w = (y = v.target) == null ? void 0 : y.closest("th");
      if (!(!g || !g.resizable) && !u.value && e.border) {
        const b = w.getBoundingClientRect(), C = document.body.style;
        b.width > 12 && b.right - v.pageX < 8 ? (C.cursor = "col-resize", Co(w, "is-sortable") && (w.style.cursor = "col-resize"), a.value = g) : u.value || (C.cursor = "", Co(w, "is-sortable") && (w.style.cursor = "pointer"), a.value = null);
      }
    }, p = () => {
      !bt || (document.body.style.cursor = "");
    }, h = ({ order: v, sortOrders: g }) => {
      if (v === "")
        return g[0];
      const y = g.indexOf(v || null);
      return g[y > g.length - 2 ? 0 : y + 1];
    }, m = (v, g, y) => {
      var w;
      v.stopPropagation();
      const b = g.order === y ? null : y || h(g), C = (w = v.target) == null ? void 0 : w.closest("th");
      if (C && Co(C, "noclick")) {
        Dn(C, "noclick");
        return;
      }
      if (!g.sortable)
        return;
      const _ = e.store.states;
      let k = _.sortProp.value, O;
      const T = _.sortingColumn.value;
      (T !== g || T === g && T.order === null) && (T && (T.order = null), _.sortingColumn.value = g, k = g.property), b ? O = g.order = b : O = g.order = null, _.sortProp.value = k, _.sortOrder.value = O, o == null || o.store.commit("changeSortCondition");
    };
    return {
      handleHeaderClick: s,
      handleHeaderContextMenu: l,
      handleMouseDown: f,
      handleMouseMove: d,
      handleMouseOut: p,
      handleSortClick: m,
      handleFilterClick: r
    };
  }
  function aX(e) {
    const t = Be(Ko), n = ge("table");
    return {
      getHeaderRowStyle: (a) => {
        const u = t == null ? void 0 : t.props.headerRowStyle;
        return typeof u == "function" ? u.call(null, { rowIndex: a }) : u;
      },
      getHeaderRowClass: (a) => {
        const u = [], c = t == null ? void 0 : t.props.headerRowClassName;
        return typeof c == "string" ? u.push(c) : typeof c == "function" && u.push(c.call(null, { rowIndex: a })), u.join(" ");
      },
      getHeaderCellStyle: (a, u, c, f) => {
        var d;
        let p = (d = t == null ? void 0 : t.props.headerCellStyle) != null ? d : {};
        typeof p == "function" && (p = p.call(null, {
          rowIndex: a,
          columnIndex: u,
          row: c,
          column: f
        }));
        const h = dv(u, f.fixed, e.store, c);
        return xl(h, "left"), xl(h, "right"), Object.assign({}, p, h);
      },
      getHeaderCellClass: (a, u, c, f) => {
        const d = cv(n.b(), u, f.fixed, e.store, c), p = [
          f.id,
          f.order,
          f.headerAlign,
          f.className,
          f.labelClassName,
          ...d
        ];
        f.children || p.push("is-leaf"), f.sortable && p.push("is-sortable");
        const h = t == null ? void 0 : t.props.headerCellClassName;
        return typeof h == "string" ? p.push(h) : typeof h == "function" && p.push(h.call(null, {
          rowIndex: a,
          columnIndex: u,
          row: c,
          column: f
        })), p.push(n.e("cell")), p.filter((m) => Boolean(m)).join(" ");
      }
    };
  }
  const mS = (e) => {
    const t = [];
    return e.forEach((n) => {
      n.children ? (t.push(n), t.push.apply(t, mS(n.children))) : t.push(n);
    }), t;
  }, iX = (e) => {
    let t = 1;
    const n = (s, l) => {
      if (l && (s.level = l.level + 1, t < s.level && (t = s.level)), s.children) {
        let a = 0;
        s.children.forEach((u) => {
          n(u, s), a += u.colSpan;
        }), s.colSpan = a;
      } else
        s.colSpan = 1;
    };
    e.forEach((s) => {
      s.level = 1, n(s, void 0);
    });
    const o = [];
    for (let s = 0; s < t; s++)
      o.push([]);
    return mS(e).forEach((s) => {
      s.children ? (s.rowSpan = 1, s.children.forEach((l) => l.isSubColumn = !0)) : s.rowSpan = t - s.level + 1, o[s.level - 1].push(s);
    }), o;
  };
  function uX(e) {
    const t = Be(Ko), n = E(() => iX(e.store.states.originColumns.value));
    return {
      isGroup: E(() => {
        const s = n.value.length > 1;
        return s && t && (t.state.isGroup.value = !0), s;
      }),
      toggleAllSelection: (s) => {
        s.stopPropagation(), t == null || t.store.commit("toggleAllSelection");
      },
      columnRows: n
    };
  }
  var cX = G({
    name: "ElTableHeader",
    components: {
      ElCheckbox: co
    },
    props: {
      fixed: {
        type: String,
        default: ""
      },
      store: {
        required: !0,
        type: Object
      },
      border: Boolean,
      defaultSort: {
        type: Object,
        default: () => ({
          prop: "",
          order: ""
        })
      }
    },
    setup(e, { emit: t }) {
      const n = it(), o = Be(Ko), r = ge("table"), s = I({}), { onColumnsChange: l, onScrollableChange: a } = vS(o);
      st(async () => {
        await Fe(), await Fe();
        const { prop: k, order: O } = e.defaultSort;
        o == null || o.store.commit("sort", { prop: k, order: O, init: !0 });
      });
      const {
        handleHeaderClick: u,
        handleHeaderContextMenu: c,
        handleMouseDown: f,
        handleMouseMove: d,
        handleMouseOut: p,
        handleSortClick: h,
        handleFilterClick: m
      } = lX(e, t), {
        getHeaderRowStyle: v,
        getHeaderRowClass: g,
        getHeaderCellStyle: y,
        getHeaderCellClass: w
      } = aX(e), { isGroup: b, toggleAllSelection: C, columnRows: _ } = uX(e);
      return n.state = {
        onColumnsChange: l,
        onScrollableChange: a
      }, n.filterPanels = s, {
        ns: r,
        filterPanels: s,
        onColumnsChange: l,
        onScrollableChange: a,
        columnRows: _,
        getHeaderRowClass: g,
        getHeaderRowStyle: v,
        getHeaderCellClass: w,
        getHeaderCellStyle: y,
        handleHeaderClick: u,
        handleHeaderContextMenu: c,
        handleMouseDown: f,
        handleMouseMove: d,
        handleMouseOut: p,
        handleSortClick: h,
        handleFilterClick: m,
        isGroup: b,
        toggleAllSelection: C
      };
    },
    render() {
      const {
        ns: e,
        isGroup: t,
        columnRows: n,
        getHeaderCellStyle: o,
        getHeaderCellClass: r,
        getHeaderRowClass: s,
        getHeaderRowStyle: l,
        handleHeaderClick: a,
        handleHeaderContextMenu: u,
        handleMouseDown: c,
        handleMouseMove: f,
        handleSortClick: d,
        handleMouseOut: p,
        store: h,
        $parent: m
      } = this;
      let v = 1;
      return je("thead", {
        class: { [e.is("group")]: t }
      }, n.map((g, y) => je("tr", {
        class: s(y),
        key: y,
        style: l(y)
      }, g.map((w, b) => (w.rowSpan > v && (v = w.rowSpan), je("th", {
        class: r(y, b, g, w),
        colspan: w.colSpan,
        key: `${w.id}-thead`,
        rowspan: w.rowSpan,
        style: o(y, b, g, w),
        onClick: (C) => a(C, w),
        onContextmenu: (C) => u(C, w),
        onMousedown: (C) => c(C, w),
        onMousemove: (C) => f(C, w),
        onMouseout: p
      }, [
        je("div", {
          class: [
            "cell",
            w.filteredValue && w.filteredValue.length > 0 ? "highlight" : ""
          ]
        }, [
          w.renderHeader ? w.renderHeader({
            column: w,
            $index: b,
            store: h,
            _self: m
          }) : w.label,
          w.sortable && je("span", {
            onClick: (C) => d(C, w),
            class: "caret-wrapper"
          }, [
            je("i", {
              onClick: (C) => d(C, w, "ascending"),
              class: "sort-caret ascending"
            }),
            je("i", {
              onClick: (C) => d(C, w, "descending"),
              class: "sort-caret descending"
            })
          ]),
          w.filterable && je(sX, {
            store: h,
            placement: w.filterPlacement || "bottom-start",
            column: w,
            upDataColumn: (C, _) => {
              w[C] = _;
            }
          })
        ])
      ]))))));
    }
  });
  function dX(e) {
    const t = Be(Ko), n = I(""), o = I(je("div")), { nextZIndex: r } = Fs(), s = (h, m, v) => {
      var g;
      const y = t, w = Hd(h);
      let b;
      const C = (g = y == null ? void 0 : y.vnode.el) == null ? void 0 : g.dataset.prefix;
      w && (b = Vy({
        columns: e.store.states.columns.value
      }, w, C), b && (y == null || y.emit(`cell-${v}`, m, b, w, h))), y == null || y.emit(`row-${v}`, m, b, h);
    }, l = (h, m) => {
      s(h, m, "dblclick");
    }, a = (h, m) => {
      e.store.commit("setCurrentRow", m), s(h, m, "click");
    }, u = (h, m) => {
      s(h, m, "contextmenu");
    }, c = On((h) => {
      e.store.commit("setHoverRow", h);
    }, 30), f = On(() => {
      e.store.commit("setHoverRow", null);
    }, 30);
    return {
      handleDoubleClick: l,
      handleClick: a,
      handleContextMenu: u,
      handleMouseEnter: c,
      handleMouseLeave: f,
      handleCellMouseEnter: (h, m, v) => {
        var g;
        const y = t, w = Hd(h), b = (g = y == null ? void 0 : y.vnode.el) == null ? void 0 : g.dataset.prefix;
        if (w) {
          const T = Vy({
            columns: e.store.states.columns.value
          }, w, b), P = y.hoverState = { cell: w, column: T, row: m };
          y == null || y.emit("cell-mouse-enter", P.row, P.column, P.cell, h);
        }
        if (!v)
          return;
        const C = h.target.querySelector(".cell");
        if (!(Co(C, `${b}-tooltip`) && C.childNodes.length))
          return;
        const _ = document.createRange();
        _.setStart(C, 0), _.setEnd(C, C.childNodes.length);
        const k = Math.round(_.getBoundingClientRect().width), O = (Number.parseInt(Qo(C, "paddingLeft"), 10) || 0) + (Number.parseInt(Qo(C, "paddingRight"), 10) || 0);
        (k + O > C.offsetWidth || C.scrollWidth > C.offsetWidth) && KG(t == null ? void 0 : t.refs.tableWrapper, w, w.innerText || w.textContent, r, v);
      },
      handleCellMouseLeave: (h) => {
        if (!Hd(h))
          return;
        const v = t == null ? void 0 : t.hoverState;
        t == null || t.emit("cell-mouse-leave", v == null ? void 0 : v.row, v == null ? void 0 : v.column, v == null ? void 0 : v.cell, h);
      },
      tooltipContent: n,
      tooltipTrigger: o
    };
  }
  function fX(e) {
    const t = Be(Ko), n = ge("table");
    return {
      getRowStyle: (c, f) => {
        const d = t == null ? void 0 : t.props.rowStyle;
        return typeof d == "function" ? d.call(null, {
          row: c,
          rowIndex: f
        }) : d || null;
      },
      getRowClass: (c, f) => {
        const d = [n.e("row")];
        (t == null ? void 0 : t.props.highlightCurrentRow) && c === e.store.states.currentRow.value && d.push("current-row"), e.stripe && f % 2 === 1 && d.push(n.em("row", "striped"));
        const p = t == null ? void 0 : t.props.rowClassName;
        return typeof p == "string" ? d.push(p) : typeof p == "function" && d.push(p.call(null, {
          row: c,
          rowIndex: f
        })), d;
      },
      getCellStyle: (c, f, d, p) => {
        const h = t == null ? void 0 : t.props.cellStyle;
        let m = h != null ? h : {};
        typeof h == "function" && (m = h.call(null, {
          rowIndex: c,
          columnIndex: f,
          row: d,
          column: p
        }));
        const v = dv(f, e == null ? void 0 : e.fixed, e.store);
        return xl(v, "left"), xl(v, "right"), Object.assign({}, m, v);
      },
      getCellClass: (c, f, d, p, h) => {
        const m = cv(n.b(), f, e == null ? void 0 : e.fixed, e.store, void 0, h), v = [p.id, p.align, p.className, ...m], g = t == null ? void 0 : t.props.cellClassName;
        return typeof g == "string" ? v.push(g) : typeof g == "function" && v.push(g.call(null, {
          rowIndex: c,
          columnIndex: f,
          row: d,
          column: p
        })), v.push(n.e("cell")), v.filter((y) => Boolean(y)).join(" ");
      },
      getSpan: (c, f, d, p) => {
        let h = 1, m = 1;
        const v = t == null ? void 0 : t.props.spanMethod;
        if (typeof v == "function") {
          const g = v({
            row: c,
            column: f,
            rowIndex: d,
            columnIndex: p
          });
          Array.isArray(g) ? (h = g[0], m = g[1]) : typeof g == "object" && (h = g.rowspan, m = g.colspan);
        }
        return { rowspan: h, colspan: m };
      },
      getColspanRealWidth: (c, f, d) => {
        if (f < 1)
          return c[d].realWidth;
        const p = c.map(({ realWidth: h, width: m }) => h || m).slice(d, d + f);
        return Number(p.reduce((h, m) => Number(h) + Number(m), -1));
      }
    };
  }
  function pX(e) {
    const t = Be(Ko), n = ge("table"), {
      handleDoubleClick: o,
      handleClick: r,
      handleContextMenu: s,
      handleMouseEnter: l,
      handleMouseLeave: a,
      handleCellMouseEnter: u,
      handleCellMouseLeave: c,
      tooltipContent: f,
      tooltipTrigger: d
    } = dX(e), {
      getRowStyle: p,
      getRowClass: h,
      getCellStyle: m,
      getCellClass: v,
      getSpan: g,
      getColspanRealWidth: y
    } = fX(e), w = E(() => e.store.states.columns.value.findIndex(({ type: O }) => O === "default")), b = (O, T) => {
      const P = t.props.rowKey;
      return P ? vn(O, P) : T;
    }, C = (O, T, P, A = !1) => {
      const { tooltipEffect: L, tooltipOptions: D, store: B } = e, { indent: F, columns: W } = B.states, x = h(O, T);
      let N = !0;
      return P && (x.push(n.em("row", `level-${P.level}`)), N = P.display), je("tr", {
        style: [N ? null : {
          display: "none"
        }, p(O, T)],
        class: x,
        key: b(O, T),
        onDblclick: (M) => o(M, O),
        onClick: (M) => r(M, O),
        onContextmenu: (M) => s(M, O),
        onMouseenter: () => l(T),
        onMouseleave: a
      }, W.value.map((M, j) => {
        const { rowspan: te, colspan: U } = g(O, M, T, j);
        if (!te || !U)
          return null;
        const Z = { ...M };
        Z.realWidth = y(W.value, U, j);
        const pe = {
          store: e.store,
          _self: e.context || t,
          column: Z,
          row: O,
          $index: T,
          cellIndex: j,
          expanded: A
        };
        j === w.value && P && (pe.treeNode = {
          indent: P.level * F.value,
          level: P.level
        }, typeof P.expanded == "boolean" && (pe.treeNode.expanded = P.expanded, "loading" in P && (pe.treeNode.loading = P.loading), "noLazyChildren" in P && (pe.treeNode.noLazyChildren = P.noLazyChildren)));
        const J = `${T},${j}`, ee = Z.columnKey || Z.rawColumnKey || "", ne = _(j, M, pe), Y = M.showOverflowTooltip && K1({
          effect: L
        }, D, M.showOverflowTooltip);
        return je("td", {
          style: m(T, j, O, M),
          class: v(T, j, O, M, U - 1),
          key: `${ee}${J}`,
          rowspan: te,
          colspan: U,
          onMouseenter: (re) => u(re, O, Y),
          onMouseleave: c
        }, [ne]);
      }));
    }, _ = (O, T, P) => T.renderCell(P);
    return {
      wrappedRowRender: (O, T) => {
        const P = e.store, { isRowExpanded: A, assertRowKey: L } = P, { treeData: D, lazyTreeNodeMap: B, childrenColumnName: F, rowKey: W } = P.states, x = P.states.columns.value;
        if (x.some(({ type: R }) => R === "expand")) {
          const R = A(O), M = C(O, T, void 0, R), j = t.renderExpanded;
          return R ? j ? [
            [
              M,
              je("tr", {
                key: `expanded-row__${M.key}`
              }, [
                je("td", {
                  colspan: x.length,
                  class: `${n.e("cell")} ${n.e("expanded-cell")}`
                }, [j({ row: O, $index: T, store: P, expanded: R })])
              ])
            ]
          ] : (console.error("[Element Error]renderExpanded is required."), M) : [[M]];
        } else if (Object.keys(D.value).length) {
          L();
          const R = vn(O, W.value);
          let M = D.value[R], j = null;
          M && (j = {
            expanded: M.expanded,
            level: M.level,
            display: !0
          }, typeof M.lazy == "boolean" && (typeof M.loaded == "boolean" && M.loaded && (j.noLazyChildren = !(M.children && M.children.length)), j.loading = M.loading));
          const te = [C(O, T, j)];
          if (M) {
            let U = 0;
            const Z = (J, ee) => {
              !(J && J.length && ee) || J.forEach((ne) => {
                const Y = {
                  display: ee.display && ee.expanded,
                  level: ee.level + 1,
                  expanded: !1,
                  noLazyChildren: !1,
                  loading: !1
                }, re = vn(ne, W.value);
                if (re == null)
                  throw new Error("For nested data item, row-key is required.");
                if (M = { ...D.value[re] }, M && (Y.expanded = M.expanded, M.level = M.level || Y.level, M.display = !!(M.expanded && Y.display), typeof M.lazy == "boolean" && (typeof M.loaded == "boolean" && M.loaded && (Y.noLazyChildren = !(M.children && M.children.length)), Y.loading = M.loading)), U++, te.push(C(ne, T + U, Y)), M) {
                  const ce = B.value[re] || ne[F.value];
                  Z(ce, M);
                }
              });
            };
            M.display = !0;
            const pe = B.value[R] || O[F.value];
            Z(pe, M);
          }
          return te;
        } else
          return C(O, T, void 0);
      },
      tooltipContent: f,
      tooltipTrigger: d
    };
  }
  const hX = {
    store: {
      required: !0,
      type: Object
    },
    stripe: Boolean,
    tooltipEffect: String,
    tooltipOptions: {
      type: Object
    },
    context: {
      default: () => ({}),
      type: Object
    },
    rowClassName: [String, Function],
    rowStyle: [Object, Function],
    fixed: {
      type: String,
      default: ""
    },
    highlight: Boolean
  };
  var vX = G({
    name: "ElTableBody",
    props: hX,
    setup(e) {
      const t = it(), n = Be(Ko), o = ge("table"), { wrappedRowRender: r, tooltipContent: s, tooltipTrigger: l } = pX(e), { onColumnsChange: a, onScrollableChange: u } = vS(n);
      return me(e.store.states.hoverRow, (c, f) => {
        if (!e.store.states.isComplex.value || !bt)
          return;
        let d = window.requestAnimationFrame;
        d || (d = (p) => window.setTimeout(p, 16)), d(() => {
          const p = t == null ? void 0 : t.vnode.el, h = Array.from((p == null ? void 0 : p.children) || []).filter((g) => g == null ? void 0 : g.classList.contains(`${o.e("row")}`)), m = h[f], v = h[c];
          m && Dn(m, "hover-row"), v && Ao(v, "hover-row");
        });
      }), Ur(() => {
        var c;
        (c = Xo) == null || c();
      }), {
        ns: o,
        onColumnsChange: a,
        onScrollableChange: u,
        wrappedRowRender: r,
        tooltipContent: s,
        tooltipTrigger: l
      };
    },
    render() {
      const { wrappedRowRender: e, store: t } = this, n = t.states.data.value || [];
      return je("tbody", {}, [
        n.reduce((o, r) => o.concat(e(r, o.length)), [])
      ]);
    }
  });
  function fv(e) {
    const t = e.tableLayout === "auto";
    let n = e.columns || [];
    t && n.every((r) => r.width === void 0) && (n = []);
    const o = (r) => {
      const s = {
        key: `${e.tableLayout}_${r.id}`,
        style: {},
        name: void 0
      };
      return t ? s.style = {
        width: `${r.width}px`
      } : s.name = r.id, s;
    };
    return je("colgroup", {}, n.map((r) => je("col", o(r))));
  }
  fv.props = ["columns", "tableLayout"];
  function mX() {
    const e = Be(Ko), t = e == null ? void 0 : e.store, n = E(() => t.states.fixedLeafColumnsLength.value), o = E(() => t.states.rightFixedColumns.value.length), r = E(() => t.states.columns.value.length), s = E(() => t.states.fixedColumns.value.length), l = E(() => t.states.rightFixedColumns.value.length);
    return {
      leftFixedLeafCount: n,
      rightFixedLeafCount: o,
      columnsCount: r,
      leftFixedCount: s,
      rightFixedCount: l,
      columns: t.states.columns
    };
  }
  function gX(e) {
    const { columns: t } = mX(), n = ge("table");
    return {
      getCellClasses: (s, l) => {
        const a = s[l], u = [
          n.e("cell"),
          a.id,
          a.align,
          a.labelClassName,
          ...cv(n.b(), l, a.fixed, e.store)
        ];
        return a.className && u.push(a.className), a.children || u.push(n.is("leaf")), u;
      },
      getCellStyles: (s, l) => {
        const a = dv(l, s.fixed, e.store);
        return xl(a, "left"), xl(a, "right"), a;
      },
      columns: t
    };
  }
  var yX = G({
    name: "ElTableFooter",
    props: {
      fixed: {
        type: String,
        default: ""
      },
      store: {
        required: !0,
        type: Object
      },
      summaryMethod: Function,
      sumText: String,
      border: Boolean,
      defaultSort: {
        type: Object,
        default: () => ({
          prop: "",
          order: ""
        })
      }
    },
    setup(e) {
      const { getCellClasses: t, getCellStyles: n, columns: o } = gX(e);
      return {
        ns: ge("table"),
        getCellClasses: t,
        getCellStyles: n,
        columns: o
      };
    },
    render() {
      const {
        columns: e,
        getCellStyles: t,
        getCellClasses: n,
        summaryMethod: o,
        sumText: r,
        ns: s
      } = this, l = this.store.states.data.value;
      let a = [];
      return o ? a = o({
        columns: e,
        data: l
      }) : e.forEach((u, c) => {
        if (c === 0) {
          a[c] = r;
          return;
        }
        const f = l.map((m) => Number(m[u.property])), d = [];
        let p = !0;
        f.forEach((m) => {
          if (!Number.isNaN(+m)) {
            p = !1;
            const v = `${m}`.split(".")[1];
            d.push(v ? v.length : 0);
          }
        });
        const h = Math.max.apply(null, d);
        p ? a[c] = "" : a[c] = f.reduce((m, v) => {
          const g = Number(v);
          return Number.isNaN(+g) ? m : Number.parseFloat((m + v).toFixed(Math.min(h, 20)));
        }, 0);
      }), je("table", {
        class: s.e("footer"),
        cellspacing: "0",
        cellpadding: "0",
        border: "0"
      }, [
        fv({
          columns: e
        }),
        je("tbody", [
          je("tr", {}, [
            ...e.map((u, c) => je("td", {
              key: c,
              colspan: u.colSpan,
              rowspan: u.rowSpan,
              class: n(e, c),
              style: t(u, c)
            }, [
              je("div", {
                class: ["cell", u.labelClassName]
              }, [a[c]])
            ]))
          ])
        ])
      ]);
    }
  });
  function bX(e) {
    return {
      setCurrentRow: (f) => {
        e.commit("setCurrentRow", f);
      },
      getSelectionRows: () => e.getSelectionRows(),
      toggleRowSelection: (f, d) => {
        e.toggleRowSelection(f, d, !1), e.updateAllSelected();
      },
      clearSelection: () => {
        e.clearSelection();
      },
      clearFilter: (f) => {
        e.clearFilter(f);
      },
      toggleAllSelection: () => {
        e.commit("toggleAllSelection");
      },
      toggleRowExpansion: (f, d) => {
        e.toggleRowExpansionAdapter(f, d);
      },
      clearSort: () => {
        e.clearSort();
      },
      sort: (f, d) => {
        e.commit("sort", { prop: f, order: d });
      }
    };
  }
  function wX(e, t, n, o) {
    const r = I(!1), s = I(null), l = I(!1), a = (R) => {
      l.value = R;
    }, u = I({
      width: null,
      height: null,
      headerHeight: null
    }), c = I(!1), f = {
      display: "inline-block",
      verticalAlign: "middle"
    }, d = I(), p = I(0), h = I(0), m = I(0), v = I(0);
    xn(() => {
      t.setHeight(e.height);
    }), xn(() => {
      t.setMaxHeight(e.maxHeight);
    }), me(() => [e.currentRowKey, n.states.rowKey], ([R, M]) => {
      !i(M) || !i(R) || n.setCurrentRowKey(`${R}`);
    }, {
      immediate: !0
    }), me(() => e.data, (R) => {
      o.store.commit("setData", R);
    }, {
      immediate: !0,
      deep: !0
    }), xn(() => {
      e.expandRowKeys && n.setExpandRowKeysAdapter(e.expandRowKeys);
    });
    const g = () => {
      o.store.commit("setHoverRow", null), o.hoverState && (o.hoverState = null);
    }, y = (R, M) => {
      const { pixelX: j, pixelY: te } = M;
      Math.abs(j) >= Math.abs(te) && (o.refs.bodyWrapper.scrollLeft += M.pixelX / 5);
    }, w = E(() => e.height || e.maxHeight || n.states.fixedColumns.value.length > 0 || n.states.rightFixedColumns.value.length > 0), b = E(() => ({
      width: t.bodyWidth.value ? `${t.bodyWidth.value}px` : ""
    })), C = () => {
      w.value && t.updateElsHeight(), t.updateColumnsWidth(), requestAnimationFrame(T);
    };
    st(async () => {
      await Fe(), n.updateColumns(), P(), requestAnimationFrame(C);
      const R = o.vnode.el, M = o.refs.headerWrapper;
      e.flexible && R && R.parentElement && (R.parentElement.style.minWidth = "0"), u.value = {
        width: d.value = R.offsetWidth,
        height: R.offsetHeight,
        headerHeight: e.showHeader && M ? M.offsetHeight : null
      }, n.states.columns.value.forEach((j) => {
        j.filteredValue && j.filteredValue.length && o.store.commit("filterChange", {
          column: j,
          values: j.filteredValue,
          silent: !0
        });
      }), o.$ready = !0;
    });
    const _ = (R, M) => {
      if (!R)
        return;
      const j = Array.from(R.classList).filter((te) => !te.startsWith("is-scrolling-"));
      j.push(t.scrollX.value ? M : "is-scrolling-none"), R.className = j.join(" ");
    }, k = (R) => {
      const { tableWrapper: M } = o.refs;
      _(M, R);
    }, O = (R) => {
      const { tableWrapper: M } = o.refs;
      return !!(M && M.classList.contains(R));
    }, T = function() {
      if (!o.refs.scrollBarRef)
        return;
      if (!t.scrollX.value) {
        const J = "is-scrolling-none";
        O(J) || k(J);
        return;
      }
      const R = o.refs.scrollBarRef.wrapRef;
      if (!R)
        return;
      const { scrollLeft: M, offsetWidth: j, scrollWidth: te } = R, { headerWrapper: U, footerWrapper: Z } = o.refs;
      U && (U.scrollLeft = M), Z && (Z.scrollLeft = M);
      const pe = te - j - 1;
      M >= pe ? k("is-scrolling-right") : k(M === 0 ? "is-scrolling-left" : "is-scrolling-middle");
    }, P = () => {
      !o.refs.scrollBarRef || (o.refs.scrollBarRef.wrapRef && Wt(o.refs.scrollBarRef.wrapRef, "scroll", T, {
        passive: !0
      }), e.fit ? Cn(o.vnode.el, A) : Wt(window, "resize", A), Cn(o.refs.bodyWrapper, () => {
        var R, M;
        A(), (M = (R = o.refs) == null ? void 0 : R.scrollBarRef) == null || M.update();
      }));
    }, A = () => {
      var R, M, j;
      const te = o.vnode.el;
      if (!o.$ready || !te)
        return;
      let U = !1;
      const {
        width: Z,
        height: pe,
        headerHeight: J
      } = u.value, ee = d.value = te.offsetWidth;
      Z !== ee && (U = !0);
      const ne = te.offsetHeight;
      (e.height || w.value) && pe !== ne && (U = !0);
      const Y = e.tableLayout === "fixed" ? o.refs.headerWrapper : (R = o.refs.tableHeaderRef) == null ? void 0 : R.$el;
      e.showHeader && (Y == null ? void 0 : Y.offsetHeight) !== J && (U = !0), p.value = ((M = o.refs.tableWrapper) == null ? void 0 : M.scrollHeight) || 0, m.value = (Y == null ? void 0 : Y.scrollHeight) || 0, v.value = ((j = o.refs.footerWrapper) == null ? void 0 : j.offsetHeight) || 0, h.value = p.value - m.value - v.value, U && (u.value = {
        width: ee,
        height: ne,
        headerHeight: e.showHeader && (Y == null ? void 0 : Y.offsetHeight) || 0
      }, C());
    }, L = on(), D = E(() => {
      const { bodyWidth: R, scrollY: M, gutterWidth: j } = t;
      return R.value ? `${R.value - (M.value ? j : 0)}px` : "";
    }), B = E(() => e.maxHeight ? "fixed" : e.tableLayout), F = E(() => {
      if (e.data && e.data.length)
        return null;
      let R = "100%";
      e.height && h.value && (R = `${h.value}px`);
      const M = d.value;
      return {
        width: M ? `${M}px` : "",
        height: R
      };
    }), W = E(() => e.height ? {
      height: Number.isNaN(Number(e.height)) ? e.height : `${e.height}px`
    } : e.maxHeight ? {
      maxHeight: Number.isNaN(Number(e.maxHeight)) ? e.maxHeight : `${e.maxHeight}px`
    } : {}), x = E(() => {
      if (e.height)
        return {
          height: "100%"
        };
      if (e.maxHeight) {
        if (Number.isNaN(Number(e.maxHeight)))
          return {
            maxHeight: `calc(${e.maxHeight} - ${m.value + v.value}px)`
          };
        {
          const R = e.maxHeight;
          if (p.value >= Number(R))
            return {
              maxHeight: `${p.value - m.value - v.value}px`
            };
        }
      }
      return {};
    });
    return {
      isHidden: r,
      renderExpanded: s,
      setDragVisible: a,
      isGroup: c,
      handleMouseLeave: g,
      handleHeaderFooterMousewheel: y,
      tableSize: L,
      emptyBlockStyle: F,
      handleFixedMousewheel: (R, M) => {
        const j = o.refs.bodyWrapper;
        if (Math.abs(M.spinY) > 0) {
          const te = j.scrollTop;
          M.pixelY < 0 && te !== 0 && R.preventDefault(), M.pixelY > 0 && j.scrollHeight - j.clientHeight > te && R.preventDefault(), j.scrollTop += Math.ceil(M.pixelY / 5);
        } else
          j.scrollLeft += Math.ceil(M.pixelX / 5);
      },
      resizeProxyVisible: l,
      bodyWidth: D,
      resizeState: u,
      doLayout: C,
      tableBodyStyles: b,
      tableLayout: B,
      scrollbarViewStyle: f,
      tableInnerStyle: W,
      scrollbarStyle: x
    };
  }
  function CX(e) {
    const t = I(), n = () => {
      const r = e.vnode.el.querySelector(".hidden-columns"), s = { childList: !0, subtree: !0 }, l = e.store.states.updateOrderFns;
      t.value = new MutationObserver(() => {
        l.forEach((a) => a());
      }), t.value.observe(r, s);
    };
    st(() => {
      n();
    }), Ur(() => {
      var o;
      (o = t.value) == null || o.disconnect();
    });
  }
  var EX = {
    data: {
      type: Array,
      default: () => []
    },
    size: yn,
    width: [String, Number],
    height: [String, Number],
    maxHeight: [String, Number],
    fit: {
      type: Boolean,
      default: !0
    },
    stripe: Boolean,
    border: Boolean,
    rowKey: [String, Function],
    showHeader: {
      type: Boolean,
      default: !0
    },
    showSummary: Boolean,
    sumText: String,
    summaryMethod: Function,
    rowClassName: [String, Function],
    rowStyle: [Object, Function],
    cellClassName: [String, Function],
    cellStyle: [Object, Function],
    headerRowClassName: [String, Function],
    headerRowStyle: [Object, Function],
    headerCellClassName: [String, Function],
    headerCellStyle: [Object, Function],
    highlightCurrentRow: Boolean,
    currentRowKey: [String, Number],
    emptyText: String,
    expandRowKeys: Array,
    defaultExpandAll: Boolean,
    defaultSort: Object,
    tooltipEffect: String,
    tooltipOptions: Object,
    spanMethod: Function,
    selectOnIndeterminate: {
      type: Boolean,
      default: !0
    },
    indent: {
      type: Number,
      default: 16
    },
    treeProps: {
      type: Object,
      default: () => ({
        hasChildren: "hasChildren",
        children: "children"
      })
    },
    lazy: Boolean,
    load: Function,
    style: {
      type: Object,
      default: () => ({})
    },
    className: {
      type: String,
      default: ""
    },
    tableLayout: {
      type: String,
      default: "fixed"
    },
    scrollbarAlwaysOn: {
      type: Boolean,
      default: !1
    },
    flexible: Boolean
  };
  const SX = () => {
    const e = I(), t = (s, l) => {
      const a = e.value;
      a && a.scrollTo(s, l);
    }, n = (s, l) => {
      const a = e.value;
      a && Xe(l) && ["Top", "Left"].includes(s) && a[`setScroll${s}`](l);
    };
    return {
      scrollBarRef: e,
      scrollTo: t,
      setScrollTop: (s) => n("Top", s),
      setScrollLeft: (s) => n("Left", s)
    };
  };
  let _X = 1;
  const kX = G({
    name: "ElTable",
    directives: {
      Mousewheel: _F
    },
    components: {
      TableHeader: cX,
      TableBody: vX,
      TableFooter: yX,
      ElScrollbar: pr,
      hColgroup: fv
    },
    props: EX,
    emits: [
      "select",
      "select-all",
      "selection-change",
      "cell-mouse-enter",
      "cell-mouse-leave",
      "cell-contextmenu",
      "cell-click",
      "cell-dblclick",
      "row-click",
      "row-contextmenu",
      "row-dblclick",
      "header-click",
      "header-contextmenu",
      "sort-change",
      "filter-change",
      "current-change",
      "header-dragend",
      "expand-change"
    ],
    setup(e) {
      const { t } = St(), n = ge("table"), o = it();
      pt(Ko, o);
      const r = XG(o, e);
      o.store = r;
      const s = new ZG({
        store: o.store,
        table: o,
        fit: e.fit,
        showHeader: e.showHeader
      });
      o.layout = s;
      const l = E(() => (r.states.data.value || []).length === 0), {
        setCurrentRow: a,
        getSelectionRows: u,
        toggleRowSelection: c,
        clearSelection: f,
        clearFilter: d,
        toggleAllSelection: p,
        toggleRowExpansion: h,
        clearSort: m,
        sort: v
      } = bX(r), {
        isHidden: g,
        renderExpanded: y,
        setDragVisible: w,
        isGroup: b,
        handleMouseLeave: C,
        handleHeaderFooterMousewheel: _,
        tableSize: k,
        emptyBlockStyle: O,
        handleFixedMousewheel: T,
        resizeProxyVisible: P,
        bodyWidth: A,
        resizeState: L,
        doLayout: D,
        tableBodyStyles: B,
        tableLayout: F,
        scrollbarViewStyle: W,
        tableInnerStyle: x,
        scrollbarStyle: N
      } = wX(e, s, r, o), { scrollBarRef: R, scrollTo: M, setScrollLeft: j, setScrollTop: te } = SX(), U = On(D, 50), Z = `${n.namespace.value}-table_${_X++}`;
      o.tableId = Z, o.state = {
        isGroup: b,
        resizeState: L,
        doLayout: D,
        debouncedUpdateLayout: U
      };
      const pe = E(() => e.sumText || t("el.table.sumText")), J = E(() => e.emptyText || t("el.table.emptyText"));
      return CX(o), {
        ns: n,
        layout: s,
        store: r,
        handleHeaderFooterMousewheel: _,
        handleMouseLeave: C,
        tableId: Z,
        tableSize: k,
        isHidden: g,
        isEmpty: l,
        renderExpanded: y,
        resizeProxyVisible: P,
        resizeState: L,
        isGroup: b,
        bodyWidth: A,
        tableBodyStyles: B,
        emptyBlockStyle: O,
        debouncedUpdateLayout: U,
        handleFixedMousewheel: T,
        setCurrentRow: a,
        getSelectionRows: u,
        toggleRowSelection: c,
        clearSelection: f,
        clearFilter: d,
        toggleAllSelection: p,
        toggleRowExpansion: h,
        clearSort: m,
        doLayout: D,
        sort: v,
        t,
        setDragVisible: w,
        context: o,
        computedSumText: pe,
        computedEmptyText: J,
        tableLayout: F,
        scrollbarViewStyle: W,
        tableInnerStyle: x,
        scrollbarStyle: N,
        scrollBarRef: R,
        scrollTo: M,
        setScrollLeft: j,
        setScrollTop: te
      };
    }
  }), $X = ["data-prefix"], NX = {
    ref: "hiddenColumns",
    class: "hidden-columns"
  };
  function TX(e, t, n, o, r, s) {
    const l = Qe("hColgroup"), a = Qe("table-header"), u = Qe("table-body"), c = Qe("el-scrollbar"), f = Qe("table-footer"), d = Aa("mousewheel");
    return S(), V("div", {
      ref: "tableWrapper",
      class: $([
        {
          [e.ns.m("fit")]: e.fit,
          [e.ns.m("striped")]: e.stripe,
          [e.ns.m("border")]: e.border || e.isGroup,
          [e.ns.m("hidden")]: e.isHidden,
          [e.ns.m("group")]: e.isGroup,
          [e.ns.m("fluid-height")]: e.maxHeight,
          [e.ns.m("scrollable-x")]: e.layout.scrollX.value,
          [e.ns.m("scrollable-y")]: e.layout.scrollY.value,
          [e.ns.m("enable-row-hover")]: !e.store.states.isComplex.value,
          [e.ns.m("enable-row-transition")]: (e.store.states.data.value || []).length !== 0 && (e.store.states.data.value || []).length < 100,
          "has-footer": e.showSummary
        },
        e.ns.m(e.tableSize),
        e.className,
        e.ns.b(),
        e.ns.m(`layout-${e.tableLayout}`)
      ]),
      style: Ke(e.style),
      "data-prefix": e.ns.namespace.value,
      onMouseleave: t[0] || (t[0] = (...p) => e.handleMouseLeave && e.handleMouseLeave(...p))
    }, [
      H("div", {
        class: $(e.ns.e("inner-wrapper")),
        style: Ke(e.tableInnerStyle)
      }, [
        H("div", NX, [
          he(e.$slots, "default")
        ], 512),
        e.showHeader && e.tableLayout === "fixed" ? ot((S(), V("div", {
          key: 0,
          ref: "headerWrapper",
          class: $(e.ns.e("header-wrapper"))
        }, [
          H("table", {
            ref: "tableHeader",
            class: $(e.ns.e("header")),
            style: Ke(e.tableBodyStyles),
            border: "0",
            cellpadding: "0",
            cellspacing: "0"
          }, [
            K(l, {
              columns: e.store.states.columns.value,
              "table-layout": e.tableLayout
            }, null, 8, ["columns", "table-layout"]),
            K(a, {
              ref: "tableHeaderRef",
              border: e.border,
              "default-sort": e.defaultSort,
              store: e.store,
              onSetDragVisible: e.setDragVisible
            }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
          ], 6)
        ], 2)), [
          [d, e.handleHeaderFooterMousewheel]
        ]) : se("v-if", !0),
        H("div", {
          ref: "bodyWrapper",
          class: $(e.ns.e("body-wrapper"))
        }, [
          K(c, {
            ref: "scrollBarRef",
            "view-style": e.scrollbarViewStyle,
            "wrap-style": e.scrollbarStyle,
            always: e.scrollbarAlwaysOn
          }, {
            default: X(() => [
              H("table", {
                ref: "tableBody",
                class: $(e.ns.e("body")),
                cellspacing: "0",
                cellpadding: "0",
                border: "0",
                style: Ke({
                  width: e.bodyWidth,
                  tableLayout: e.tableLayout
                })
              }, [
                K(l, {
                  columns: e.store.states.columns.value,
                  "table-layout": e.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                e.showHeader && e.tableLayout === "auto" ? (S(), ie(a, {
                  key: 0,
                  ref: "tableHeaderRef",
                  border: e.border,
                  "default-sort": e.defaultSort,
                  store: e.store,
                  onSetDragVisible: e.setDragVisible
                }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])) : se("v-if", !0),
                K(u, {
                  context: e.context,
                  highlight: e.highlightCurrentRow,
                  "row-class-name": e.rowClassName,
                  "tooltip-effect": e.tooltipEffect,
                  "tooltip-options": e.tooltipOptions,
                  "row-style": e.rowStyle,
                  store: e.store,
                  stripe: e.stripe
                }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"])
              ], 6),
              e.isEmpty ? (S(), V("div", {
                key: 0,
                ref: "emptyBlock",
                style: Ke(e.emptyBlockStyle),
                class: $(e.ns.e("empty-block"))
              }, [
                H("span", {
                  class: $(e.ns.e("empty-text"))
                }, [
                  he(e.$slots, "empty", {}, () => [
                    wt(Ne(e.computedEmptyText), 1)
                  ])
                ], 2)
              ], 6)) : se("v-if", !0),
              e.$slots.append ? (S(), V("div", {
                key: 1,
                ref: "appendWrapper",
                class: $(e.ns.e("append-wrapper"))
              }, [
                he(e.$slots, "append")
              ], 2)) : se("v-if", !0)
            ]),
            _: 3
          }, 8, ["view-style", "wrap-style", "always"])
        ], 2),
        e.showSummary ? ot((S(), V("div", {
          key: 1,
          ref: "footerWrapper",
          class: $(e.ns.e("footer-wrapper"))
        }, [
          K(f, {
            border: e.border,
            "default-sort": e.defaultSort,
            store: e.store,
            style: Ke(e.tableBodyStyles),
            "sum-text": e.computedSumText,
            "summary-method": e.summaryMethod
          }, null, 8, ["border", "default-sort", "store", "style", "sum-text", "summary-method"])
        ], 2)), [
          [$t, !e.isEmpty],
          [d, e.handleHeaderFooterMousewheel]
        ]) : se("v-if", !0),
        e.border || e.isGroup ? (S(), V("div", {
          key: 2,
          class: $(e.ns.e("border-left-patch"))
        }, null, 2)) : se("v-if", !0)
      ], 6),
      ot(H("div", {
        ref: "resizeProxy",
        class: $(e.ns.e("column-resize-proxy"))
      }, null, 2), [
        [$t, e.resizeProxyVisible]
      ])
    ], 46, $X);
  }
  var OX = /* @__PURE__ */ Me(kX, [["render", TX], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/table.vue"]]);
  const MX = {
    selection: "table-column--selection",
    expand: "table__expand-column"
  }, IX = {
    default: {
      order: ""
    },
    selection: {
      width: 48,
      minWidth: 48,
      realWidth: 48,
      order: ""
    },
    expand: {
      width: 48,
      minWidth: 48,
      realWidth: 48,
      order: ""
    },
    index: {
      width: 48,
      minWidth: 48,
      realWidth: 48,
      order: ""
    }
  }, PX = (e) => MX[e] || "", AX = {
    selection: {
      renderHeader({ store: e }) {
        function t() {
          return e.states.data.value && e.states.data.value.length === 0;
        }
        return je(co, {
          disabled: t(),
          size: e.states.tableSize.value,
          indeterminate: e.states.selection.value.length > 0 && !e.states.isAllSelected.value,
          "onUpdate:modelValue": e.toggleAllSelection,
          modelValue: e.states.isAllSelected.value
        });
      },
      renderCell({
        row: e,
        column: t,
        store: n,
        $index: o
      }) {
        return je(co, {
          disabled: t.selectable ? !t.selectable.call(null, e, o) : !1,
          size: n.states.tableSize.value,
          onChange: () => {
            n.commit("rowSelectedChanged", e);
          },
          onClick: (r) => r.stopPropagation(),
          modelValue: n.isSelected(e)
        });
      },
      sortable: !1,
      resizable: !1
    },
    index: {
      renderHeader({ column: e }) {
        return e.label || "#";
      },
      renderCell({
        column: e,
        $index: t
      }) {
        let n = t + 1;
        const o = e.index;
        return typeof o == "number" ? n = t + o : typeof o == "function" && (n = o(t)), je("div", {}, [n]);
      },
      sortable: !1
    },
    expand: {
      renderHeader({ column: e }) {
        return e.label || "";
      },
      renderCell({
        row: e,
        store: t,
        expanded: n
      }) {
        const { ns: o } = t, r = [o.e("expand-icon")];
        return n && r.push(o.em("expand-icon", "expanded")), je("div", {
          class: r,
          onClick: function(l) {
            l.stopPropagation(), t.toggleRowExpansion(e);
          }
        }, {
          default: () => [
            je(He, null, {
              default: () => [je(kn)]
            })
          ]
        });
      },
      sortable: !1,
      resizable: !1
    }
  };
  function RX({
    row: e,
    column: t,
    $index: n
  }) {
    var o;
    const r = t.property, s = r && iu(e, r).value;
    return t && t.formatter ? t.formatter(e, t, s, n) : ((o = s == null ? void 0 : s.toString) == null ? void 0 : o.call(s)) || "";
  }
  function xX({
    row: e,
    treeNode: t,
    store: n
  }, o = !1) {
    const { ns: r } = n;
    if (!t)
      return o ? [
        je("span", {
          class: r.e("placeholder")
        })
      ] : null;
    const s = [], l = function(a) {
      a.stopPropagation(), !t.loading && n.loadOrToggle(e);
    };
    if (t.indent && s.push(je("span", {
      class: r.e("indent"),
      style: { "padding-left": `${t.indent}px` }
    })), typeof t.expanded == "boolean" && !t.noLazyChildren) {
      const a = [
        r.e("expand-icon"),
        t.expanded ? r.em("expand-icon", "expanded") : ""
      ];
      let u = kn;
      t.loading && (u = Gr), s.push(je("div", {
        class: a,
        onClick: l
      }, {
        default: () => [
          je(He, { class: { [r.is("loading")]: t.loading } }, {
            default: () => [je(u)]
          })
        ]
      }));
    } else
      s.push(je("span", {
        class: r.e("placeholder")
      }));
    return s;
  }
  function Hy(e, t) {
    return e.reduce((n, o) => (n[o] = o, n), t);
  }
  function DX(e, t) {
    const n = it();
    return {
      registerComplexWatchers: () => {
        const s = ["fixed"], l = {
          realWidth: "width",
          realMinWidth: "minWidth"
        }, a = Hy(s, l);
        Object.keys(a).forEach((u) => {
          const c = l[u];
          ht(t, c) && me(() => t[c], (f) => {
            let d = f;
            c === "width" && u === "realWidth" && (d = uv(f)), c === "minWidth" && u === "realMinWidth" && (d = cS(f)), n.columnConfig.value[c] = d, n.columnConfig.value[u] = d;
            const p = c === "fixed";
            e.value.store.scheduleLayout(p);
          });
        });
      },
      registerNormalWatchers: () => {
        const s = [
          "label",
          "filters",
          "filterMultiple",
          "sortable",
          "index",
          "formatter",
          "className",
          "labelClassName",
          "showOverflowTooltip"
        ], l = {
          property: "prop",
          align: "realAlign",
          headerAlign: "realHeaderAlign"
        }, a = Hy(s, l);
        Object.keys(a).forEach((u) => {
          const c = l[u];
          ht(t, c) && me(() => t[c], (f) => {
            n.columnConfig.value[u] = f;
          });
        });
      }
    };
  }
  function LX(e, t, n) {
    const o = it(), r = I(""), s = I(!1), l = I(), a = I(), u = ge("table");
    xn(() => {
      l.value = e.align ? `is-${e.align}` : null, l.value;
    }), xn(() => {
      a.value = e.headerAlign ? `is-${e.headerAlign}` : l.value, a.value;
    });
    const c = E(() => {
      let C = o.vnode.vParent || o.parent;
      for (; C && !C.tableId && !C.columnId; )
        C = C.vnode.vParent || C.parent;
      return C;
    }), f = E(() => {
      const { store: C } = o.parent;
      if (!C)
        return !1;
      const { treeData: _ } = C.states, k = _.value;
      return k && Object.keys(k).length > 0;
    }), d = I(uv(e.width)), p = I(cS(e.minWidth)), h = (C) => (d.value && (C.width = d.value), p.value && (C.minWidth = p.value), !d.value && p.value && (C.width = void 0), C.minWidth || (C.minWidth = 80), C.realWidth = Number(C.width === void 0 ? C.minWidth : C.width), C), m = (C) => {
      const _ = C.type, k = AX[_] || {};
      Object.keys(k).forEach((T) => {
        const P = k[T];
        T !== "className" && P !== void 0 && (C[T] = P);
      });
      const O = PX(_);
      if (O) {
        const T = `${i(u.namespace)}-${O}`;
        C.className = C.className ? `${C.className} ${T}` : T;
      }
      return C;
    }, v = (C) => {
      Array.isArray(C) ? C.forEach((k) => _(k)) : _(C);
      function _(k) {
        var O;
        ((O = k == null ? void 0 : k.type) == null ? void 0 : O.name) === "ElTableColumn" && (k.vParent = o);
      }
    };
    return {
      columnId: r,
      realAlign: l,
      isSubColumn: s,
      realHeaderAlign: a,
      columnOrTableParent: c,
      setColumnWidth: h,
      setColumnForcedProps: m,
      setColumnRenders: (C) => {
        e.renderHeader ? yt("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.") : C.type !== "selection" && (C.renderHeader = (k) => {
          o.columnConfig.value.label;
          const O = t.header;
          return O ? O(k) : C.label;
        });
        let _ = C.renderCell;
        return C.type === "expand" ? (C.renderCell = (k) => je("div", {
          class: "cell"
        }, [_(k)]), n.value.renderExpanded = (k) => t.default ? t.default(k) : t.default) : (_ = _ || RX, C.renderCell = (k) => {
          let O = null;
          if (t.default) {
            const B = t.default(k);
            O = B.some((F) => F.type !== en) ? B : _(k);
          } else
            O = _(k);
          const { columns: T } = n.value.store.states, P = T.value.findIndex((B) => B.type === "default"), A = f.value && k.cellIndex === P, L = xX(k, A), D = {
            class: "cell",
            style: {}
          };
          return C.showOverflowTooltip && (D.class = `${D.class} ${i(u.namespace)}-tooltip`, D.style = {
            width: `${(k.column.realWidth || Number(k.column.width)) - 1}px`
          }), v(O), je("div", D, [L, O]);
        }), C;
      },
      getPropsData: (...C) => C.reduce((_, k) => (Array.isArray(k) && k.forEach((O) => {
        _[O] = e[O];
      }), _), {}),
      getColumnElIndex: (C, _) => Array.prototype.indexOf.call(C, _),
      updateColumnOrder: () => {
        n.value.store.commit("updateColumnOrder", o.columnConfig.value);
      }
    };
  }
  var VX = {
    type: {
      type: String,
      default: "default"
    },
    label: String,
    className: String,
    labelClassName: String,
    property: String,
    prop: String,
    width: {
      type: [String, Number],
      default: ""
    },
    minWidth: {
      type: [String, Number],
      default: ""
    },
    renderHeader: Function,
    sortable: {
      type: [Boolean, String],
      default: !1
    },
    sortMethod: Function,
    sortBy: [String, Function, Array],
    resizable: {
      type: Boolean,
      default: !0
    },
    columnKey: String,
    align: String,
    headerAlign: String,
    showOverflowTooltip: [Boolean, Object],
    fixed: [Boolean, String],
    formatter: Function,
    selectable: Function,
    reserveSelection: Boolean,
    filterMethod: Function,
    filteredValue: Array,
    filters: Array,
    filterPlacement: String,
    filterMultiple: {
      type: Boolean,
      default: !0
    },
    index: [Number, Function],
    sortOrders: {
      type: Array,
      default: () => ["ascending", "descending", null],
      validator: (e) => e.every((t) => ["ascending", "descending", null].includes(t))
    }
  };
  let BX = 1;
  var gS = G({
    name: "ElTableColumn",
    components: {
      ElCheckbox: co
    },
    props: VX,
    setup(e, { slots: t }) {
      const n = it(), o = I({}), r = E(() => {
        let b = n.parent;
        for (; b && !b.tableId; )
          b = b.parent;
        return b;
      }), { registerNormalWatchers: s, registerComplexWatchers: l } = DX(r, e), {
        columnId: a,
        isSubColumn: u,
        realHeaderAlign: c,
        columnOrTableParent: f,
        setColumnWidth: d,
        setColumnForcedProps: p,
        setColumnRenders: h,
        getPropsData: m,
        getColumnElIndex: v,
        realAlign: g,
        updateColumnOrder: y
      } = LX(e, t, r), w = f.value;
      a.value = `${w.tableId || w.columnId}_column_${BX++}`, kc(() => {
        u.value = r.value !== w;
        const b = e.type || "default", C = e.sortable === "" ? !0 : e.sortable, _ = {
          ...IX[b],
          id: a.value,
          type: b,
          property: e.prop || e.property,
          align: g,
          headerAlign: c,
          showOverflowTooltip: e.showOverflowTooltip,
          filterable: e.filters || e.filterMethod,
          filteredValue: [],
          filterPlacement: "",
          isColumnGroup: !1,
          isSubColumn: !1,
          filterOpened: !1,
          sortable: C,
          index: e.index,
          rawColumnKey: n.vnode.key
        };
        let A = m([
          "columnKey",
          "label",
          "className",
          "labelClassName",
          "type",
          "renderHeader",
          "formatter",
          "fixed",
          "resizable"
        ], ["sortMethod", "sortBy", "sortOrders"], ["selectable", "reserveSelection"], [
          "filterMethod",
          "filters",
          "filterMultiple",
          "filterOpened",
          "filteredValue",
          "filterPlacement"
        ]);
        A = BG(_, A), A = HG(h, d, p)(A), o.value = A, s(), l();
      }), st(() => {
        var b;
        const C = f.value, _ = u.value ? C.vnode.el.children : (b = C.refs.hiddenColumns) == null ? void 0 : b.children, k = () => v(_ || [], n.vnode.el);
        o.value.getColumnIndex = k, k() > -1 && r.value.store.commit("insertColumn", o.value, u.value ? C.columnConfig.value : null, y);
      }), zt(() => {
        r.value.store.commit("removeColumn", o.value, u.value ? w.columnConfig.value : null, y);
      }), n.columnId = a.value, n.columnConfig = o;
    },
    render() {
      var e, t, n;
      try {
        const o = (t = (e = this.$slots).default) == null ? void 0 : t.call(e, {
          row: {},
          column: {},
          $index: -1
        }), r = [];
        if (Array.isArray(o))
          for (const l of o)
            ((n = l.type) == null ? void 0 : n.name) === "ElTableColumn" || l.shapeFlag & 2 ? r.push(l) : l.type === ze && Array.isArray(l.children) && l.children.forEach((a) => {
              (a == null ? void 0 : a.patchFlag) !== 1024 && !et(a == null ? void 0 : a.children) && r.push(a);
            });
        return je("div", r);
      } catch {
        return je("div", []);
      }
    }
  });
  const FX = ut(OX, {
    TableColumn: gS
  }), HX = Gt(gS);
  var ni = /* @__PURE__ */ ((e) => (e.ASC = "asc", e.DESC = "desc", e))(ni || {}), oi = /* @__PURE__ */ ((e) => (e.CENTER = "center", e.RIGHT = "right", e))(oi || {}), yS = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e))(yS || {});
  const pp = {
    asc: "desc",
    desc: "asc"
  }, ri = Symbol("placeholder"), zX = (e, t, n) => {
    var o;
    const r = {
      flexGrow: 0,
      flexShrink: 0,
      ...n ? {} : {
        flexGrow: e.flexGrow || 0,
        flexShrink: e.flexShrink || 1
      }
    };
    n || (r.flexShrink = 1);
    const s = {
      ...(o = e.style) != null ? o : {},
      ...r,
      flexBasis: "auto",
      width: e.width
    };
    return t || (e.maxWidth && (s.maxWidth = e.maxWidth), e.minWidth && (s.minWidth = e.minWidth)), s;
  };
  function KX(e, t, n) {
    const o = E(() => i(t).filter((v) => !v.hidden)), r = E(() => i(o).filter((v) => v.fixed === "left" || v.fixed === !0)), s = E(() => i(o).filter((v) => v.fixed === "right")), l = E(() => i(o).filter((v) => !v.fixed)), a = E(() => {
      const v = [];
      return i(r).forEach((g) => {
        v.push({
          ...g,
          placeholderSign: ri
        });
      }), i(l).forEach((g) => {
        v.push(g);
      }), i(s).forEach((g) => {
        v.push({
          ...g,
          placeholderSign: ri
        });
      }), v;
    }), u = E(() => i(r).length || i(s).length), c = E(() => i(t).reduce((g, y) => (g[y.key] = zX(y, i(n), e.fixed), g), {})), f = E(() => i(o).reduce((v, g) => v + g.width, 0)), d = (v) => i(t).find((g) => g.key === v), p = (v) => i(c)[v], h = (v, g) => {
      v.width = g;
    };
    function m(v) {
      var g;
      const { key: y } = v.currentTarget.dataset;
      if (!y)
        return;
      const { sortState: w, sortBy: b } = e;
      let C = ni.ASC;
      rt(w) ? C = pp[w[y]] : C = pp[b.order], (g = e.onColumnSort) == null || g.call(e, { column: d(y), key: y, order: C });
    }
    return {
      columns: t,
      columnsStyles: c,
      columnsTotalWidth: f,
      fixedColumnsOnLeft: r,
      fixedColumnsOnRight: s,
      hasFixedColumns: u,
      mainColumns: a,
      normalColumns: l,
      visibleColumns: o,
      getColumn: d,
      getColumnStyle: p,
      updateColumnWidth: h,
      onColumnSorted: m
    };
  }
  const jX = (e, {
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: o,
    onMaybeEndReached: r
  }) => {
    const s = I({ scrollLeft: 0, scrollTop: 0 });
    function l(h) {
      var m, v, g;
      const { scrollTop: y } = h;
      (m = t.value) == null || m.scrollTo(h), (v = n.value) == null || v.scrollToTop(y), (g = o.value) == null || g.scrollToTop(y);
    }
    function a(h) {
      s.value = h, l(h);
    }
    function u(h) {
      s.value.scrollTop = h, l(i(s));
    }
    function c(h) {
      var m, v;
      s.value.scrollLeft = h, (v = (m = t.value) == null ? void 0 : m.scrollTo) == null || v.call(m, i(s));
    }
    function f(h) {
      var m;
      a(h), (m = e.onScroll) == null || m.call(e, h);
    }
    function d({ scrollTop: h }) {
      const { scrollTop: m } = i(s);
      h !== m && u(h);
    }
    function p(h, m = "auto") {
      var v;
      (v = t.value) == null || v.scrollToRow(h, m);
    }
    return me(() => i(s).scrollTop, (h, m) => {
      h > m && r();
    }), {
      scrollPos: s,
      scrollTo: a,
      scrollToLeft: c,
      scrollToTop: u,
      scrollToRow: p,
      onScroll: f,
      onVerticalScroll: d
    };
  }, WX = (e, { mainTableRef: t, leftTableRef: n, rightTableRef: o }) => {
    const r = it(), { emit: s } = r, l = xt(!1), a = xt(null), u = I(e.defaultExpandedRowKeys || []), c = I(-1), f = xt(null), d = I({}), p = I({}), h = xt({}), m = xt({}), v = xt({}), g = E(() => Xe(e.estimatedRowHeight));
    function y(T) {
      var P;
      (P = e.onRowsRendered) == null || P.call(e, T), T.rowCacheEnd > i(c) && (c.value = T.rowCacheEnd);
    }
    function w({ hovered: T, rowKey: P }) {
      a.value = T ? P : null;
    }
    function b({
      expanded: T,
      rowData: P,
      rowIndex: A,
      rowKey: L
    }) {
      var D, B;
      const F = [...i(u)], W = F.indexOf(L);
      T ? W === -1 && F.push(L) : W > -1 && F.splice(W, 1), u.value = F, s("update:expandedRowKeys", F), (D = e.onRowExpand) == null || D.call(e, {
        expanded: T,
        rowData: P,
        rowIndex: A,
        rowKey: L
      }), (B = e.onExpandedRowsChange) == null || B.call(e, F);
    }
    const C = On(() => {
      var T, P, A, L;
      l.value = !0, d.value = { ...i(d), ...i(p) }, _(i(f), !1), p.value = {}, f.value = null, (T = t.value) == null || T.forceUpdate(), (P = n.value) == null || P.forceUpdate(), (A = o.value) == null || A.forceUpdate(), (L = r.proxy) == null || L.$forceUpdate(), l.value = !1;
    }, 0);
    function _(T, P = !1) {
      !i(g) || [t, n, o].forEach((A) => {
        const L = i(A);
        L && L.resetAfterRowIndex(T, P);
      });
    }
    function k(T, P, A) {
      const L = i(f);
      (L === null || L > A) && (f.value = A), p.value[T] = P;
    }
    function O({ rowKey: T, height: P, rowIndex: A }, L) {
      L ? L === yS.RIGHT ? v.value[T] = P : h.value[T] = P : m.value[T] = P;
      const D = Math.max(...[h, v, m].map((B) => B.value[T] || 0));
      i(d)[T] !== D && (k(T, D, A), C());
    }
    return {
      hoveringRowKey: a,
      expandedRowKeys: u,
      lastRenderedRowIndex: c,
      isDynamic: g,
      isResetting: l,
      rowHeights: d,
      resetAfterIndex: _,
      onRowExpanded: b,
      onRowHovered: w,
      onRowsRendered: y,
      onRowHeightChange: O
    };
  }, UX = (e, { expandedRowKeys: t, lastRenderedRowIndex: n, resetAfterIndex: o }) => {
    const r = I({}), s = E(() => {
      const a = {}, { data: u, rowKey: c } = e, f = i(t);
      if (!f || !f.length)
        return u;
      const d = [], p = /* @__PURE__ */ new Set();
      f.forEach((m) => p.add(m));
      let h = u.slice();
      for (h.forEach((m) => a[m[c]] = 0); h.length > 0; ) {
        const m = h.shift();
        d.push(m), p.has(m[c]) && Array.isArray(m.children) && m.children.length > 0 && (h = [...m.children, ...h], m.children.forEach((v) => a[v[c]] = a[m[c]] + 1));
      }
      return r.value = a, d;
    }), l = E(() => {
      const { data: a, expandColumnKey: u } = e;
      return u ? i(s) : a;
    });
    return me(l, (a, u) => {
      a !== u && (n.value = -1, o(0, !0));
    }), {
      data: l,
      depthMap: r
    };
  }, qX = (e, t) => e + t, ku = (e) => De(e) ? e.reduce(qX, 0) : e, As = (e, t, n = {}) => Ge(e) ? e(t) : e != null ? e : n, Ir = (e) => (["width", "maxWidth", "minWidth", "height"].forEach((t) => {
    e[t] = Jt(e[t]);
  }), e), bS = (e) => Bt(e) ? (t) => je(e, t) : e, YX = (e, {
    columnsTotalWidth: t,
    data: n,
    fixedColumnsOnLeft: o,
    fixedColumnsOnRight: r
  }) => {
    const s = E(() => {
      const { fixed: b, width: C, vScrollbarSize: _ } = e, k = C - _;
      return b ? Math.max(Math.round(i(t)), k) : k;
    }), l = E(() => i(s) + (e.fixed ? e.vScrollbarSize : 0)), a = E(() => {
      const { height: b = 0, maxHeight: C = 0, footerHeight: _, hScrollbarSize: k } = e;
      if (C > 0) {
        const O = i(m), T = i(u), A = i(h) + O + T + k;
        return Math.min(A, C - _);
      }
      return b - _;
    }), u = E(() => {
      const { rowHeight: b, estimatedRowHeight: C } = e, _ = i(n);
      return Xe(C) ? _.length * C : _.length * b;
    }), c = E(() => {
      const { maxHeight: b } = e, C = i(a);
      if (Xe(b) && b > 0)
        return C;
      const _ = i(u) + i(h) + i(m);
      return Math.min(C, _);
    }), f = (b) => b.width, d = E(() => ku(i(o).map(f))), p = E(() => ku(i(r).map(f))), h = E(() => ku(e.headerHeight)), m = E(() => {
      var b;
      return (((b = e.fixedData) == null ? void 0 : b.length) || 0) * e.rowHeight;
    }), v = E(() => i(a) - i(h) - i(m)), g = E(() => {
      const { style: b = {}, height: C, width: _ } = e;
      return Ir({
        ...b,
        height: C,
        width: _
      });
    }), y = E(() => Ir({ height: e.footerHeight })), w = E(() => ({
      top: Jt(i(h)),
      bottom: Jt(e.footerHeight),
      width: Jt(e.width)
    }));
    return {
      bodyWidth: s,
      fixedTableHeight: c,
      mainTableHeight: a,
      leftTableWidth: d,
      rightTableWidth: p,
      headerWidth: l,
      rowsHeight: u,
      windowHeight: v,
      footerHeight: y,
      emptyStyle: w,
      rootStyle: g,
      headerHeight: h
    };
  }, GX = (e) => {
    const t = I(), n = I(0), o = I(0);
    let r;
    return st(() => {
      r = Cn(t, ([s]) => {
        const { width: l, height: a } = s.contentRect, { paddingLeft: u, paddingRight: c, paddingTop: f, paddingBottom: d } = getComputedStyle(s.target), p = Number.parseInt(u) || 0, h = Number.parseInt(c) || 0, m = Number.parseInt(f) || 0, v = Number.parseInt(d) || 0;
        n.value = l - p - h, o.value = a - m - v;
      }).stop;
    }), zt(() => {
      r == null || r();
    }), me([n, o], ([s, l]) => {
      var a;
      (a = e.onResize) == null || a.call(e, {
        width: s,
        height: l
      });
    }), {
      sizer: t,
      width: n,
      height: o
    };
  };
  function XX(e) {
    const t = I(), n = I(), o = I(), {
      columns: r,
      columnsStyles: s,
      columnsTotalWidth: l,
      fixedColumnsOnLeft: a,
      fixedColumnsOnRight: u,
      hasFixedColumns: c,
      mainColumns: f,
      onColumnSorted: d
    } = KX(e, Ht(e, "columns"), Ht(e, "fixed")), {
      scrollTo: p,
      scrollToLeft: h,
      scrollToTop: m,
      scrollToRow: v,
      onScroll: g,
      onVerticalScroll: y,
      scrollPos: w
    } = jX(e, {
      mainTableRef: t,
      leftTableRef: n,
      rightTableRef: o,
      onMaybeEndReached: Pe
    }), {
      expandedRowKeys: b,
      hoveringRowKey: C,
      lastRenderedRowIndex: _,
      isDynamic: k,
      isResetting: O,
      rowHeights: T,
      resetAfterIndex: P,
      onRowExpanded: A,
      onRowHeightChange: L,
      onRowHovered: D,
      onRowsRendered: B
    } = WX(e, {
      mainTableRef: t,
      leftTableRef: n,
      rightTableRef: o
    }), { data: F, depthMap: W } = UX(e, {
      expandedRowKeys: b,
      lastRenderedRowIndex: _,
      resetAfterIndex: P
    }), {
      bodyWidth: x,
      fixedTableHeight: N,
      mainTableHeight: R,
      leftTableWidth: M,
      rightTableWidth: j,
      headerWidth: te,
      rowsHeight: U,
      windowHeight: Z,
      footerHeight: pe,
      emptyStyle: J,
      rootStyle: ee,
      headerHeight: ne
    } = YX(e, {
      columnsTotalWidth: l,
      data: F,
      fixedColumnsOnLeft: a,
      fixedColumnsOnRight: u
    }), Y = xt(!1), re = I(), ce = E(() => {
      const z = i(F).length === 0;
      return De(e.fixedData) ? e.fixedData.length === 0 && z : z;
    });
    function Te(z) {
      const { estimatedRowHeight: Q, rowHeight: de, rowKey: Oe } = e;
      return Q ? i(T)[i(F)[z][Oe]] || Q : de;
    }
    function Pe() {
      const { onEndReached: z } = e;
      if (!z)
        return;
      const { scrollTop: Q } = i(w), de = i(U), Oe = i(Z), ae = de - (Q + Oe) + e.hScrollbarSize;
      i(_) >= 0 && de === Q + i(R) - i(ne) && z(ae);
    }
    return me(() => e.expandedRowKeys, (z) => b.value = z, {
      deep: !0
    }), {
      columns: r,
      containerRef: re,
      mainTableRef: t,
      leftTableRef: n,
      rightTableRef: o,
      isDynamic: k,
      isResetting: O,
      isScrolling: Y,
      hoveringRowKey: C,
      hasFixedColumns: c,
      columnsStyles: s,
      columnsTotalWidth: l,
      data: F,
      expandedRowKeys: b,
      depthMap: W,
      fixedColumnsOnLeft: a,
      fixedColumnsOnRight: u,
      mainColumns: f,
      bodyWidth: x,
      emptyStyle: J,
      rootStyle: ee,
      headerWidth: te,
      footerHeight: pe,
      mainTableHeight: R,
      fixedTableHeight: N,
      leftTableWidth: M,
      rightTableWidth: j,
      showEmpty: ce,
      getRowHeight: Te,
      onColumnSorted: d,
      onRowHovered: D,
      onRowExpanded: A,
      onRowsRendered: B,
      onRowHeightChange: L,
      scrollTo: p,
      scrollToLeft: h,
      scrollToTop: m,
      scrollToRow: v,
      onScroll: g,
      onVerticalScroll: y
    };
  }
  const pv = Symbol("tableV2"), wS = String, $i = {
    type: le(Array),
    required: !0
  }, hv = {
    type: le(Array)
  }, CS = {
    ...hv,
    required: !0
  }, JX = String, zy = {
    type: le(Array),
    default: () => jt([])
  }, us = {
    type: Number,
    required: !0
  }, ES = {
    type: le([String, Number, Symbol]),
    default: "id"
  }, Ky = {
    type: le(Object)
  }, ms = Ie({
    class: String,
    columns: $i,
    columnsStyles: {
      type: le(Object),
      required: !0
    },
    depth: Number,
    expandColumnKey: JX,
    estimatedRowHeight: {
      ...ks.estimatedRowHeight,
      default: void 0
    },
    isScrolling: Boolean,
    onRowExpand: {
      type: le(Function)
    },
    onRowHover: {
      type: le(Function)
    },
    onRowHeightChange: {
      type: le(Function)
    },
    rowData: {
      type: le(Object),
      required: !0
    },
    rowEventHandlers: {
      type: le(Object)
    },
    rowIndex: {
      type: Number,
      required: !0
    },
    rowKey: ES,
    style: {
      type: le(Object)
    }
  }), zd = {
    type: Number,
    required: !0
  }, vv = Ie({
    class: String,
    columns: $i,
    fixedHeaderData: {
      type: le(Array)
    },
    headerData: {
      type: le(Array),
      required: !0
    },
    headerHeight: {
      type: le([Number, Array]),
      default: 50
    },
    rowWidth: zd,
    rowHeight: {
      type: Number,
      default: 50
    },
    height: zd,
    width: zd
  }), $u = Ie({
    columns: $i,
    data: CS,
    fixedData: hv,
    estimatedRowHeight: ms.estimatedRowHeight,
    width: us,
    height: us,
    headerWidth: us,
    headerHeight: vv.headerHeight,
    bodyWidth: us,
    rowHeight: us,
    cache: UE.cache,
    useIsScrolling: Boolean,
    scrollbarAlwaysOn: ks.scrollbarAlwaysOn,
    scrollbarStartGap: ks.scrollbarStartGap,
    scrollbarEndGap: ks.scrollbarEndGap,
    class: wS,
    style: Ky,
    containerStyle: Ky,
    getRowHeight: {
      type: le(Function),
      required: !0
    },
    rowKey: ms.rowKey,
    onRowsRendered: {
      type: le(Function)
    },
    onScroll: {
      type: le(Function)
    }
  }), ZX = Ie({
    cache: $u.cache,
    estimatedRowHeight: ms.estimatedRowHeight,
    rowKey: ES,
    headerClass: {
      type: le([
        String,
        Function
      ])
    },
    headerProps: {
      type: le([
        Object,
        Function
      ])
    },
    headerCellProps: {
      type: le([
        Object,
        Function
      ])
    },
    headerHeight: vv.headerHeight,
    footerHeight: {
      type: Number,
      default: 0
    },
    rowClass: {
      type: le([String, Function])
    },
    rowProps: {
      type: le([Object, Function])
    },
    rowHeight: {
      type: Number,
      default: 50
    },
    cellProps: {
      type: le([
        Object,
        Function
      ])
    },
    columns: $i,
    data: CS,
    dataGetter: {
      type: le(Function)
    },
    fixedData: hv,
    expandColumnKey: ms.expandColumnKey,
    expandedRowKeys: zy,
    defaultExpandedRowKeys: zy,
    class: wS,
    fixed: Boolean,
    style: {
      type: le(Object)
    },
    width: us,
    height: us,
    maxHeight: Number,
    useIsScrolling: Boolean,
    indentSize: {
      type: Number,
      default: 12
    },
    iconSize: {
      type: Number,
      default: 12
    },
    hScrollbarSize: ks.hScrollbarSize,
    vScrollbarSize: ks.vScrollbarSize,
    scrollbarAlwaysOn: GE.alwaysOn,
    sortBy: {
      type: le(Object),
      default: () => ({})
    },
    sortState: {
      type: le(Object),
      default: void 0
    },
    onColumnSort: {
      type: le(Function)
    },
    onExpandedRowsChange: {
      type: le(Function)
    },
    onEndReached: {
      type: le(Function)
    },
    onRowExpand: ms.onRowExpand,
    onScroll: $u.onScroll,
    onRowsRendered: $u.onRowsRendered,
    rowEventHandlers: ms.rowEventHandlers
  }), mv = (e, {
    slots: t
  }) => {
    var n;
    const {
      cellData: o,
      style: r
    } = e, s = ((n = o == null ? void 0 : o.toString) == null ? void 0 : n.call(o)) || "";
    return K("div", {
      class: e.class,
      title: s,
      style: r
    }, [t.default ? t.default(e) : s]);
  };
  mv.displayName = "ElTableV2Cell";
  mv.inheritAttrs = !1;
  const gv = (e, {
    slots: t
  }) => {
    var n, o;
    return t.default ? t.default(e) : K("div", {
      class: e.class,
      title: (n = e.column) == null ? void 0 : n.title
    }, [(o = e.column) == null ? void 0 : o.title]);
  };
  gv.displayName = "ElTableV2HeaderCell";
  gv.inheritAttrs = !1;
  const QX = Ie({
    class: String,
    columns: $i,
    columnsStyles: {
      type: le(Object),
      required: !0
    },
    headerIndex: Number,
    style: { type: le(Object) }
  }), eJ = G({
    name: "ElTableV2HeaderRow",
    props: QX,
    setup(e, {
      slots: t
    }) {
      return () => {
        const {
          columns: n,
          columnsStyles: o,
          headerIndex: r,
          style: s
        } = e;
        let l = n.map((a, u) => t.cell({
          columns: n,
          column: a,
          columnIndex: u,
          headerIndex: r,
          style: o[a.key]
        }));
        return t.header && (l = t.header({
          cells: l.map((a) => De(a) && a.length === 1 ? a[0] : a),
          columns: n,
          headerIndex: r
        })), K("div", {
          class: e.class,
          style: s,
          role: "row"
        }, [l]);
      };
    }
  }), tJ = "ElTableV2Header", nJ = G({
    name: tJ,
    props: vv,
    setup(e, {
      slots: t,
      expose: n
    }) {
      const o = ge("table-v2"), r = I(), s = E(() => Ir({
        width: e.width,
        height: e.height
      })), l = E(() => Ir({
        width: e.rowWidth,
        height: e.height
      })), a = E(() => kl(i(e.headerHeight))), u = (d) => {
        const p = i(r);
        Fe(() => {
          p != null && p.scroll && p.scroll({
            left: d
          });
        });
      }, c = () => {
        const d = o.e("fixed-header-row"), {
          columns: p,
          fixedHeaderData: h,
          rowHeight: m
        } = e;
        return h == null ? void 0 : h.map((v, g) => {
          var y;
          const w = Ir({
            height: m,
            width: "100%"
          });
          return (y = t.fixed) == null ? void 0 : y.call(t, {
            class: d,
            columns: p,
            rowData: v,
            rowIndex: -(g + 1),
            style: w
          });
        });
      }, f = () => {
        const d = o.e("dynamic-header-row"), {
          columns: p
        } = e;
        return i(a).map((h, m) => {
          var v;
          const g = Ir({
            width: "100%",
            height: h
          });
          return (v = t.dynamic) == null ? void 0 : v.call(t, {
            class: d,
            columns: p,
            headerIndex: m,
            style: g
          });
        });
      };
      return n({
        scrollToLeft: u
      }), () => {
        if (!(e.height <= 0))
          return K("div", {
            ref: r,
            class: e.class,
            style: i(s),
            role: "rowgroup"
          }, [K("div", {
            style: i(l),
            class: o.e("header")
          }, [f(), c()])]);
      };
    }
  }), oJ = (e) => {
    const {
      isScrolling: t
    } = Be(pv), n = I(!1), o = I(), r = E(() => Xe(e.estimatedRowHeight) && e.rowIndex >= 0), s = (u = !1) => {
      const c = i(o);
      if (!c)
        return;
      const {
        columns: f,
        onRowHeightChange: d,
        rowKey: p,
        rowIndex: h,
        style: m
      } = e, {
        height: v
      } = c.getBoundingClientRect();
      n.value = !0, Fe(() => {
        if (u || v !== Number.parseInt(m.height)) {
          const g = f[0], y = (g == null ? void 0 : g.placeholderSign) === ri;
          d == null || d({
            rowKey: p,
            height: v,
            rowIndex: h
          }, g && !y && g.fixed);
        }
      });
    }, l = E(() => {
      const {
        rowData: u,
        rowIndex: c,
        rowKey: f,
        onRowHover: d
      } = e, p = e.rowEventHandlers || {}, h = {};
      return Object.entries(p).forEach(([m, v]) => {
        Ge(v) && (h[m] = (g) => {
          v({
            event: g,
            rowData: u,
            rowIndex: c,
            rowKey: f
          });
        });
      }), d && [{
        name: "onMouseleave",
        hovered: !1
      }, {
        name: "onMouseenter",
        hovered: !0
      }].forEach(({
        name: m,
        hovered: v
      }) => {
        const g = h[m];
        h[m] = (y) => {
          d({
            event: y,
            hovered: v,
            rowData: u,
            rowIndex: c,
            rowKey: f
          }), g == null || g(y);
        };
      }), h;
    }), a = (u) => {
      const {
        onRowExpand: c,
        rowData: f,
        rowIndex: d,
        rowKey: p
      } = e;
      c == null || c({
        expanded: u,
        rowData: f,
        rowIndex: d,
        rowKey: p
      });
    };
    return st(() => {
      i(r) && s(!0);
    }), {
      isScrolling: t,
      measurable: r,
      measured: n,
      rowRef: o,
      eventHandlers: l,
      onExpand: a
    };
  }, rJ = "ElTableV2TableRow", sJ = G({
    name: rJ,
    props: ms,
    setup(e, {
      expose: t,
      slots: n,
      attrs: o
    }) {
      const {
        eventHandlers: r,
        isScrolling: s,
        measurable: l,
        measured: a,
        rowRef: u,
        onExpand: c
      } = oJ(e);
      return t({
        onExpand: c
      }), () => {
        const {
          columns: f,
          columnsStyles: d,
          expandColumnKey: p,
          depth: h,
          rowData: m,
          rowIndex: v,
          style: g
        } = e;
        let y = f.map((w, b) => {
          const C = De(m.children) && m.children.length > 0 && w.key === p;
          return n.cell({
            column: w,
            columns: f,
            columnIndex: b,
            depth: h,
            style: d[w.key],
            rowData: m,
            rowIndex: v,
            isScrolling: i(s),
            expandIconProps: C ? {
              rowData: m,
              rowIndex: v,
              onExpand: c
            } : void 0
          });
        });
        if (n.row && (y = n.row({
          cells: y.map((w) => De(w) && w.length === 1 ? w[0] : w),
          style: g,
          columns: f,
          depth: h,
          rowData: m,
          rowIndex: v,
          isScrolling: i(s)
        })), i(l)) {
          const {
            height: w,
            ...b
          } = g || {}, C = i(a);
          return K("div", ft({
            ref: u,
            class: e.class,
            style: C ? g : b,
            role: "row"
          }, o, i(r)), [y]);
        }
        return K("div", ft(o, {
          ref: u,
          class: e.class,
          style: g,
          role: "row"
        }, i(r)), [y]);
      };
    }
  }), lJ = (e) => {
    const {
      sortOrder: t
    } = e;
    return K(He, {
      size: 14,
      class: e.class
    }, {
      default: () => [t === ni.ASC ? K(Cx, null, null) : K(vx, null, null)]
    });
  }, aJ = (e) => {
    const {
      expanded: t,
      expandable: n,
      onExpand: o,
      style: r,
      size: s
    } = e, l = {
      onClick: n ? () => o(!t) : void 0,
      class: e.class
    };
    return K(He, ft(l, {
      size: s,
      style: r
    }), {
      default: () => [K(kn, null, null)]
    });
  }, iJ = "ElTableV2Grid", uJ = (e) => {
    const t = I(), n = I(), o = E(() => {
      const {
        data: v,
        rowHeight: g,
        estimatedRowHeight: y
      } = e;
      if (!y)
        return v.length * g;
    }), r = E(() => {
      const {
        fixedData: v,
        rowHeight: g
      } = e;
      return ((v == null ? void 0 : v.length) || 0) * g;
    }), s = E(() => ku(e.headerHeight)), l = E(() => {
      const {
        height: v
      } = e;
      return Math.max(0, v - i(s) - i(r));
    }), a = E(() => i(s) + i(r) > 0), u = ({
      data: v,
      rowIndex: g
    }) => v[g][e.rowKey];
    function c({
      rowCacheStart: v,
      rowCacheEnd: g,
      rowVisibleStart: y,
      rowVisibleEnd: w
    }) {
      var b;
      (b = e.onRowsRendered) == null || b.call(e, {
        rowCacheStart: v,
        rowCacheEnd: g,
        rowVisibleStart: y,
        rowVisibleEnd: w
      });
    }
    function f(v, g) {
      var y;
      (y = n.value) == null || y.resetAfterRowIndex(v, g);
    }
    function d(v, g) {
      const y = i(t), w = i(n);
      !y || !w || (rt(v) ? (y.scrollToLeft(v.scrollLeft), w.scrollTo(v)) : (y.scrollToLeft(v), w.scrollTo({
        scrollLeft: v,
        scrollTop: g
      })));
    }
    function p(v) {
      var g;
      (g = i(n)) == null || g.scrollTo({
        scrollTop: v
      });
    }
    function h(v, g) {
      var y;
      (y = i(n)) == null || y.scrollToItem(v, 1, g);
    }
    function m() {
      var v, g;
      (v = i(n)) == null || v.$forceUpdate(), (g = i(t)) == null || g.$forceUpdate();
    }
    return {
      bodyRef: n,
      forceUpdate: m,
      fixedRowHeight: r,
      gridHeight: l,
      hasHeader: a,
      headerHeight: s,
      headerRef: t,
      totalHeight: o,
      itemKey: u,
      onItemRendered: c,
      resetAfterRowIndex: f,
      scrollTo: d,
      scrollToTop: p,
      scrollToRow: h
    };
  }, yv = G({
    name: iJ,
    props: $u,
    setup(e, {
      slots: t,
      expose: n
    }) {
      const {
        ns: o
      } = Be(pv), {
        bodyRef: r,
        fixedRowHeight: s,
        gridHeight: l,
        hasHeader: a,
        headerRef: u,
        headerHeight: c,
        totalHeight: f,
        forceUpdate: d,
        itemKey: p,
        onItemRendered: h,
        resetAfterRowIndex: m,
        scrollTo: v,
        scrollToTop: g,
        scrollToRow: y
      } = uJ(e);
      n({
        forceUpdate: d,
        totalHeight: f,
        scrollTo: v,
        scrollToTop: g,
        scrollToRow: y,
        resetAfterRowIndex: m
      });
      const w = () => e.bodyWidth;
      return () => {
        const {
          cache: b,
          columns: C,
          data: _,
          fixedData: k,
          useIsScrolling: O,
          scrollbarAlwaysOn: T,
          scrollbarEndGap: P,
          scrollbarStartGap: A,
          style: L,
          rowHeight: D,
          bodyWidth: B,
          estimatedRowHeight: F,
          headerWidth: W,
          height: x,
          width: N,
          getRowHeight: R,
          onScroll: M
        } = e, j = Xe(F), te = j ? Fq : Dq, U = i(c);
        return K("div", {
          role: "table",
          class: [o.e("table"), e.class],
          style: L
        }, [K(te, {
          ref: r,
          data: _,
          useIsScrolling: O,
          itemKey: p,
          columnCache: 0,
          columnWidth: j ? w : B,
          totalColumn: 1,
          totalRow: _.length,
          rowCache: b,
          rowHeight: j ? R : D,
          width: N,
          height: i(l),
          class: o.e("body"),
          role: "rowgroup",
          scrollbarStartGap: A,
          scrollbarEndGap: P,
          scrollbarAlwaysOn: T,
          onScroll: M,
          onItemRendered: h,
          perfMode: !1
        }, {
          default: (Z) => {
            var pe;
            const J = _[Z.rowIndex];
            return (pe = t.row) == null ? void 0 : pe.call(t, {
              ...Z,
              columns: C,
              rowData: J
            });
          }
        }), i(a) && K(nJ, {
          ref: u,
          class: o.e("header-wrapper"),
          columns: C,
          headerData: _,
          headerHeight: e.headerHeight,
          fixedHeaderData: k,
          rowWidth: W,
          rowHeight: D,
          width: N,
          height: Math.min(U + i(s), x)
        }, {
          dynamic: t.header,
          fixed: t.row
        })]);
      };
    }
  });
  function cJ(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Bt(e);
  }
  const dJ = (e, {
    slots: t
  }) => {
    const {
      mainTableRef: n,
      ...o
    } = e;
    return K(yv, ft({
      ref: n
    }, o), cJ(t) ? t : {
      default: () => [t]
    });
  };
  function fJ(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Bt(e);
  }
  const pJ = (e, {
    slots: t
  }) => {
    if (!e.columns.length)
      return;
    const {
      leftTableRef: n,
      ...o
    } = e;
    return K(yv, ft({
      ref: n
    }, o), fJ(t) ? t : {
      default: () => [t]
    });
  };
  function hJ(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Bt(e);
  }
  const vJ = (e, {
    slots: t
  }) => {
    if (!e.columns.length)
      return;
    const {
      rightTableRef: n,
      ...o
    } = e;
    return K(yv, ft({
      ref: n
    }, o), hJ(t) ? t : {
      default: () => [t]
    });
  };
  function mJ(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Bt(e);
  }
  const gJ = (e, {
    slots: t
  }) => {
    const {
      columns: n,
      columnsStyles: o,
      depthMap: r,
      expandColumnKey: s,
      expandedRowKeys: l,
      estimatedRowHeight: a,
      hasFixedColumns: u,
      hoveringRowKey: c,
      rowData: f,
      rowIndex: d,
      style: p,
      isScrolling: h,
      rowProps: m,
      rowClass: v,
      rowKey: g,
      rowEventHandlers: y,
      ns: w,
      onRowHovered: b,
      onRowExpanded: C
    } = e, _ = As(v, {
      columns: n,
      rowData: f,
      rowIndex: d
    }, ""), k = As(m, {
      columns: n,
      rowData: f,
      rowIndex: d
    }), O = f[g], T = r[O] || 0, P = Boolean(s), A = d < 0, L = [w.e("row"), _, {
      [w.e(`row-depth-${T}`)]: P && d >= 0,
      [w.is("expanded")]: P && l.includes(O),
      [w.is("hovered")]: !h && O === c,
      [w.is("fixed")]: !T && A,
      [w.is("customized")]: Boolean(t.row)
    }], D = u ? b : void 0, B = {
      ...k,
      columns: n,
      columnsStyles: o,
      class: L,
      depth: T,
      expandColumnKey: s,
      estimatedRowHeight: A ? void 0 : a,
      isScrolling: h,
      rowIndex: d,
      rowData: f,
      rowKey: O,
      rowEventHandlers: y,
      style: p
    };
    return K(sJ, ft(B, {
      onRowHover: D,
      onRowExpand: C
    }), mJ(t) ? t : {
      default: () => [t]
    });
  }, hp = ({
    columns: e,
    column: t,
    columnIndex: n,
    depth: o,
    expandIconProps: r,
    isScrolling: s,
    rowData: l,
    rowIndex: a,
    style: u,
    expandedRowKeys: c,
    ns: f,
    cellProps: d,
    expandColumnKey: p,
    indentSize: h,
    iconSize: m,
    rowKey: v
  }, {
    slots: g
  }) => {
    const y = Ir(u);
    if (t.placeholderSign === ri)
      return K("div", {
        class: f.em("row-cell", "placeholder"),
        style: y
      }, null);
    const {
      cellRenderer: w,
      dataKey: b,
      dataGetter: C
    } = t, k = bS(w) || g.default || ((x) => K(mv, x, null)), O = Ge(C) ? C({
      columns: e,
      column: t,
      columnIndex: n,
      rowData: l,
      rowIndex: a
    }) : Kt(l, b != null ? b : ""), T = As(d, {
      cellData: O,
      columns: e,
      column: t,
      columnIndex: n,
      rowIndex: a,
      rowData: l
    }), P = {
      class: f.e("cell-text"),
      columns: e,
      column: t,
      columnIndex: n,
      cellData: O,
      isScrolling: s,
      rowData: l,
      rowIndex: a
    }, A = k(P), L = [f.e("row-cell"), t.class, t.align === oi.CENTER && f.is("align-center"), t.align === oi.RIGHT && f.is("align-right")], D = a >= 0 && t.key === p, B = a >= 0 && c.includes(l[v]);
    let F;
    const W = `margin-inline-start: ${o * h}px;`;
    return D && (rt(r) ? F = K(aJ, ft(r, {
      class: [f.e("expand-icon"), f.is("expanded", B)],
      size: m,
      expanded: B,
      style: W,
      expandable: !0
    }), null) : F = K("div", {
      style: [W, `width: ${m}px; height: ${m}px;`].join(" ")
    }, null)), K("div", ft({
      class: L,
      style: y
    }, T, {
      role: "cell"
    }), [F, A]);
  };
  hp.inheritAttrs = !1;
  function yJ(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Bt(e);
  }
  const bJ = ({
    columns: e,
    columnsStyles: t,
    headerIndex: n,
    style: o,
    headerClass: r,
    headerProps: s,
    ns: l
  }, {
    slots: a
  }) => {
    const u = {
      columns: e,
      headerIndex: n
    }, c = [l.e("header-row"), As(r, u, ""), {
      [l.is("customized")]: Boolean(a.header)
    }], f = {
      ...As(s, u),
      columnsStyles: t,
      class: c,
      columns: e,
      headerIndex: n,
      style: o
    };
    return K(eJ, f, yJ(a) ? a : {
      default: () => [a]
    });
  }, jy = (e, {
    slots: t
  }) => {
    const {
      column: n,
      ns: o,
      style: r,
      onColumnSorted: s
    } = e, l = Ir(r);
    if (n.placeholderSign === ri)
      return K("div", {
        class: o.em("header-row-cell", "placeholder"),
        style: l
      }, null);
    const {
      headerCellRenderer: a,
      headerClass: u,
      sortable: c
    } = n, f = {
      ...e,
      class: o.e("header-cell-text")
    }, p = (bS(a) || t.default || ((C) => K(gv, C, null)))(f), {
      sortBy: h,
      sortState: m,
      headerCellProps: v
    } = e;
    let g, y;
    if (m) {
      const C = m[n.key];
      g = Boolean(pp[C]), y = g ? C : ni.ASC;
    } else
      g = n.key === h.key, y = g ? h.order : ni.ASC;
    const w = [o.e("header-cell"), As(u, e, ""), n.align === oi.CENTER && o.is("align-center"), n.align === oi.RIGHT && o.is("align-right"), c && o.is("sortable")], b = {
      ...As(v, e),
      onClick: n.sortable ? s : void 0,
      class: w,
      style: l,
      ["data-key"]: n.key
    };
    return K("div", ft(b, {
      role: "columnheader"
    }), [p, c && K(lJ, {
      class: [o.e("sort-icon"), g && o.is("sorting")],
      sortOrder: y
    }, null)]);
  }, SS = (e, {
    slots: t
  }) => {
    var n;
    return K("div", {
      class: e.class,
      style: e.style
    }, [(n = t.default) == null ? void 0 : n.call(t)]);
  };
  SS.displayName = "ElTableV2Footer";
  const _S = (e, {
    slots: t
  }) => K("div", {
    class: e.class,
    style: e.style
  }, [t.default ? t.default() : K(IE, null, null)]);
  _S.displayName = "ElTableV2Empty";
  const kS = (e, {
    slots: t
  }) => {
    var n;
    return K("div", {
      class: e.class,
      style: e.style
    }, [(n = t.default) == null ? void 0 : n.call(t)]);
  };
  kS.displayName = "ElTableV2Overlay";
  function na(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Bt(e);
  }
  const wJ = "ElTableV2", CJ = G({
    name: wJ,
    props: ZX,
    setup(e, {
      slots: t,
      expose: n
    }) {
      const o = ge("table-v2"), {
        columnsStyles: r,
        fixedColumnsOnLeft: s,
        fixedColumnsOnRight: l,
        mainColumns: a,
        mainTableHeight: u,
        fixedTableHeight: c,
        leftTableWidth: f,
        rightTableWidth: d,
        data: p,
        depthMap: h,
        expandedRowKeys: m,
        hasFixedColumns: v,
        hoveringRowKey: g,
        mainTableRef: y,
        leftTableRef: w,
        rightTableRef: b,
        isDynamic: C,
        isResetting: _,
        isScrolling: k,
        bodyWidth: O,
        emptyStyle: T,
        rootStyle: P,
        headerWidth: A,
        footerHeight: L,
        showEmpty: D,
        scrollTo: B,
        scrollToLeft: F,
        scrollToTop: W,
        scrollToRow: x,
        getRowHeight: N,
        onColumnSorted: R,
        onRowHeightChange: M,
        onRowHovered: j,
        onRowExpanded: te,
        onRowsRendered: U,
        onScroll: Z,
        onVerticalScroll: pe
      } = XX(e);
      return n({
        scrollTo: B,
        scrollToLeft: F,
        scrollToTop: W,
        scrollToRow: x
      }), pt(pv, {
        ns: o,
        isResetting: _,
        hoveringRowKey: g,
        isScrolling: k
      }), () => {
        const {
          cache: J,
          cellProps: ee,
          estimatedRowHeight: ne,
          expandColumnKey: Y,
          fixedData: re,
          headerHeight: ce,
          headerClass: Te,
          headerProps: Pe,
          headerCellProps: z,
          sortBy: Q,
          sortState: de,
          rowHeight: Oe,
          rowClass: ae,
          rowEventHandlers: Ee,
          rowKey: we,
          rowProps: Se,
          scrollbarAlwaysOn: _e,
          indentSize: ke,
          iconSize: Re,
          useIsScrolling: fe,
          vScrollbarSize: Ae,
          width: qe
        } = e, tt = i(p), Je = {
          cache: J,
          class: o.e("main"),
          columns: i(a),
          data: tt,
          fixedData: re,
          estimatedRowHeight: ne,
          bodyWidth: i(O),
          headerHeight: ce,
          headerWidth: i(A),
          height: i(u),
          mainTableRef: y,
          rowKey: we,
          rowHeight: Oe,
          scrollbarAlwaysOn: _e,
          scrollbarStartGap: 2,
          scrollbarEndGap: Ae,
          useIsScrolling: fe,
          width: qe,
          getRowHeight: N,
          onRowsRendered: U,
          onScroll: Z
        }, ye = i(f), Ce = i(c), ue = {
          cache: J,
          class: o.e("left"),
          columns: i(s),
          data: tt,
          estimatedRowHeight: ne,
          leftTableRef: w,
          rowHeight: Oe,
          bodyWidth: ye,
          headerWidth: ye,
          headerHeight: ce,
          height: Ce,
          rowKey: we,
          scrollbarAlwaysOn: _e,
          scrollbarStartGap: 2,
          scrollbarEndGap: Ae,
          useIsScrolling: fe,
          width: ye,
          getRowHeight: N,
          onScroll: pe
        }, oe = i(d) + Ae, be = {
          cache: J,
          class: o.e("right"),
          columns: i(l),
          data: tt,
          estimatedRowHeight: ne,
          rightTableRef: b,
          rowHeight: Oe,
          bodyWidth: oe,
          headerWidth: oe,
          headerHeight: ce,
          height: Ce,
          rowKey: we,
          scrollbarAlwaysOn: _e,
          scrollbarStartGap: 2,
          scrollbarEndGap: Ae,
          width: oe,
          style: `--${i(o.namespace)}-table-scrollbar-size: ${Ae}px`,
          useIsScrolling: fe,
          getRowHeight: N,
          onScroll: pe
        }, xe = i(r), nt = {
          ns: o,
          depthMap: i(h),
          columnsStyles: xe,
          expandColumnKey: Y,
          expandedRowKeys: i(m),
          estimatedRowHeight: ne,
          hasFixedColumns: i(v),
          hoveringRowKey: i(g),
          rowProps: Se,
          rowClass: ae,
          rowKey: we,
          rowEventHandlers: Ee,
          onRowHovered: j,
          onRowExpanded: te,
          onRowHeightChange: M
        }, ve = {
          cellProps: ee,
          expandColumnKey: Y,
          indentSize: ke,
          iconSize: Re,
          rowKey: we,
          expandedRowKeys: i(m),
          ns: o
        }, Le = {
          ns: o,
          headerClass: Te,
          headerProps: Pe,
          columnsStyles: xe
        }, lt = {
          ns: o,
          sortBy: Q,
          sortState: de,
          headerCellProps: z,
          onColumnSorted: R
        }, ct = {
          row: (ln) => K(gJ, ft(ln, nt), {
            row: t.row,
            cell: ($e) => {
              let Ye;
              return t.cell ? K(hp, ft($e, ve, {
                style: xe[$e.column.key]
              }), na(Ye = t.cell($e)) ? Ye : {
                default: () => [Ye]
              }) : K(hp, ft($e, ve, {
                style: xe[$e.column.key]
              }), null);
            }
          }),
          header: (ln) => K(bJ, ft(ln, Le), {
            header: t.header,
            cell: ($e) => {
              let Ye;
              return t["header-cell"] ? K(jy, ft($e, lt, {
                style: xe[$e.column.key]
              }), na(Ye = t["header-cell"]($e)) ? Ye : {
                default: () => [Ye]
              }) : K(jy, ft($e, lt, {
                style: xe[$e.column.key]
              }), null);
            }
          })
        }, mt = [e.class, o.b(), o.e("root"), {
          [o.is("dynamic")]: i(C)
        }], Mt = {
          class: o.e("footer"),
          style: i(L)
        };
        return K("div", {
          class: mt,
          style: i(P)
        }, [K(dJ, Je, na(ct) ? ct : {
          default: () => [ct]
        }), K(pJ, ue, na(ct) ? ct : {
          default: () => [ct]
        }), K(vJ, be, na(ct) ? ct : {
          default: () => [ct]
        }), t.footer && K(SS, Mt, {
          default: t.footer
        }), i(D) && K(_S, {
          class: o.e("empty"),
          style: i(T)
        }, {
          default: t.empty
        }), t.overlay && K(kS, {
          class: o.e("overlay")
        }, {
          default: t.overlay
        })]);
      };
    }
  }), EJ = Ie({
    disableWidth: Boolean,
    disableHeight: Boolean,
    onResize: {
      type: le(Function)
    }
  }), SJ = G({
    name: "ElAutoResizer",
    props: EJ,
    setup(e, {
      slots: t
    }) {
      const n = ge("auto-resizer"), {
        height: o,
        width: r,
        sizer: s
      } = GX(e), l = {
        width: "100%",
        height: "100%"
      };
      return () => {
        var a;
        return K("div", {
          ref: s,
          class: n.b(),
          style: l
        }, [(a = t.default) == null ? void 0 : a.call(t, {
          height: o.value,
          width: r.value
        })]);
      };
    }
  }), _J = ut(CJ), kJ = ut(SJ), od = Symbol("tabsRootContextKey"), $J = Ie({
    tabs: {
      type: le(Array),
      default: () => jt([])
    }
  }), $S = "ElTabBar", NJ = G({
    name: $S
  }), TJ = /* @__PURE__ */ G({
    ...NJ,
    props: $J,
    setup(e, { expose: t }) {
      const n = e, o = it(), r = Be(od);
      r || Yt($S, "<el-tabs><el-tab-bar /></el-tabs>");
      const s = ge("tabs"), l = I(), a = I(), u = () => {
        let f = 0, d = 0;
        const p = ["top", "bottom"].includes(r.props.tabPosition) ? "width" : "height", h = p === "width" ? "x" : "y", m = h === "x" ? "left" : "top";
        return n.tabs.every((v) => {
          var g, y;
          const w = (y = (g = o.parent) == null ? void 0 : g.refs) == null ? void 0 : y[`tab-${v.uid}`];
          if (!w)
            return !1;
          if (!v.active)
            return !0;
          f = w[`offset${Po(m)}`], d = w[`client${Po(p)}`];
          const b = window.getComputedStyle(w);
          return p === "width" && (n.tabs.length > 1 && (d -= Number.parseFloat(b.paddingLeft) + Number.parseFloat(b.paddingRight)), f += Number.parseFloat(b.paddingLeft)), !1;
        }), {
          [p]: `${d}px`,
          transform: `translate${Po(h)}(${f}px)`
        };
      }, c = () => a.value = u();
      return me(() => n.tabs, async () => {
        await Fe(), c();
      }, { immediate: !0 }), Cn(l, () => c()), t({
        ref: l,
        update: c
      }), (f, d) => (S(), V("div", {
        ref_key: "barRef",
        ref: l,
        class: $([i(s).e("active-bar"), i(s).is(i(r).props.tabPosition)]),
        style: Ke(a.value)
      }, null, 6));
    }
  });
  var OJ = /* @__PURE__ */ Me(TJ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-bar.vue"]]);
  const MJ = Ie({
    panes: {
      type: le(Array),
      default: () => jt([])
    },
    currentName: {
      type: [String, Number],
      default: ""
    },
    editable: Boolean,
    type: {
      type: String,
      values: ["card", "border-card", ""],
      default: ""
    },
    stretch: Boolean
  }), IJ = {
    tabClick: (e, t, n) => n instanceof Event,
    tabRemove: (e, t) => t instanceof Event
  }, Wy = "ElTabNav", PJ = G({
    name: Wy,
    props: MJ,
    emits: IJ,
    setup(e, {
      expose: t,
      emit: n
    }) {
      const o = it(), r = Be(od);
      r || Yt(Wy, "<el-tabs><tab-nav /></el-tabs>");
      const s = ge("tabs"), l = gN(), a = NN(), u = I(), c = I(), f = I(), d = I(), p = I(!1), h = I(0), m = I(!1), v = I(!0), g = E(() => ["top", "bottom"].includes(r.props.tabPosition) ? "width" : "height"), y = E(() => ({
        transform: `translate${g.value === "width" ? "X" : "Y"}(-${h.value}px)`
      })), w = () => {
        if (!u.value)
          return;
        const P = u.value[`offset${Po(g.value)}`], A = h.value;
        if (!A)
          return;
        const L = A > P ? A - P : 0;
        h.value = L;
      }, b = () => {
        if (!u.value || !c.value)
          return;
        const P = c.value[`offset${Po(g.value)}`], A = u.value[`offset${Po(g.value)}`], L = h.value;
        if (P - L <= A)
          return;
        const D = P - L > A * 2 ? L + A : P - A;
        h.value = D;
      }, C = async () => {
        const P = c.value;
        if (!p.value || !f.value || !u.value || !P)
          return;
        await Fe();
        const A = f.value.querySelector(".is-active");
        if (!A)
          return;
        const L = u.value, D = ["top", "bottom"].includes(r.props.tabPosition), B = A.getBoundingClientRect(), F = L.getBoundingClientRect(), W = D ? P.offsetWidth - F.width : P.offsetHeight - F.height, x = h.value;
        let N = x;
        D ? (B.left < F.left && (N = x - (F.left - B.left)), B.right > F.right && (N = x + B.right - F.right)) : (B.top < F.top && (N = x - (F.top - B.top)), B.bottom > F.bottom && (N = x + (B.bottom - F.bottom))), N = Math.max(N, 0), h.value = Math.min(N, W);
      }, _ = () => {
        var P;
        if (!c.value || !u.value)
          return;
        e.stretch && ((P = d.value) == null || P.update());
        const A = c.value[`offset${Po(g.value)}`], L = u.value[`offset${Po(g.value)}`], D = h.value;
        L < A ? (p.value = p.value || {}, p.value.prev = D, p.value.next = D + L < A, A - D < L && (h.value = A - L)) : (p.value = !1, D > 0 && (h.value = 0));
      }, k = (P) => {
        const A = P.code, {
          up: L,
          down: D,
          left: B,
          right: F
        } = We;
        if (![L, D, B, F].includes(A))
          return;
        const W = Array.from(P.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)")), x = W.indexOf(P.target);
        let N;
        A === B || A === L ? x === 0 ? N = W.length - 1 : N = x - 1 : x < W.length - 1 ? N = x + 1 : N = 0, W[N].focus({
          preventScroll: !0
        }), W[N].click(), O();
      }, O = () => {
        v.value && (m.value = !0);
      }, T = () => m.value = !1;
      return me(l, (P) => {
        P === "hidden" ? v.value = !1 : P === "visible" && setTimeout(() => v.value = !0, 50);
      }), me(a, (P) => {
        P ? setTimeout(() => v.value = !0, 50) : v.value = !1;
      }), Cn(f, _), st(() => setTimeout(() => C(), 0)), cr(() => _()), t({
        scrollToActiveTab: C,
        removeFocus: T
      }), me(() => e.panes, () => o.update(), {
        flush: "post",
        deep: !0
      }), () => {
        const P = p.value ? [K("span", {
          class: [s.e("nav-prev"), s.is("disabled", !p.value.prev)],
          onClick: w
        }, [K(He, null, {
          default: () => [K(Br, null, null)]
        })]), K("span", {
          class: [s.e("nav-next"), s.is("disabled", !p.value.next)],
          onClick: b
        }, [K(He, null, {
          default: () => [K(kn, null, null)]
        })])] : null, A = e.panes.map((L, D) => {
          var B, F, W, x;
          const N = L.uid, R = L.props.disabled, M = (F = (B = L.props.name) != null ? B : L.index) != null ? F : `${D}`, j = !R && (L.isClosable || e.editable);
          L.index = `${D}`;
          const te = j ? K(He, {
            class: "is-icon-close",
            onClick: (pe) => n("tabRemove", L, pe)
          }, {
            default: () => [K(_o, null, null)]
          }) : null, U = ((x = (W = L.slots).label) == null ? void 0 : x.call(W)) || L.props.label, Z = !R && L.active ? 0 : -1;
          return K("div", {
            ref: `tab-${N}`,
            class: [s.e("item"), s.is(r.props.tabPosition), s.is("active", L.active), s.is("disabled", R), s.is("closable", j), s.is("focus", m.value)],
            id: `tab-${M}`,
            key: `tab-${N}`,
            "aria-controls": `pane-${M}`,
            role: "tab",
            "aria-selected": L.active,
            tabindex: Z,
            onFocus: () => O(),
            onBlur: () => T(),
            onClick: (pe) => {
              T(), n("tabClick", L, M, pe);
            },
            onKeydown: (pe) => {
              j && (pe.code === We.delete || pe.code === We.backspace) && n("tabRemove", L, pe);
            }
          }, [U, te]);
        });
        return K("div", {
          ref: f,
          class: [s.e("nav-wrap"), s.is("scrollable", !!p.value), s.is(r.props.tabPosition)]
        }, [P, K("div", {
          class: s.e("nav-scroll"),
          ref: u
        }, [K("div", {
          class: [s.e("nav"), s.is(r.props.tabPosition), s.is("stretch", e.stretch && ["top", "bottom"].includes(r.props.tabPosition))],
          ref: c,
          style: y.value,
          role: "tablist",
          onKeydown: k
        }, [e.type ? null : K(OJ, {
          ref: d,
          tabs: [...e.panes]
        }, null), A])])]);
      };
    }
  }), AJ = Ie({
    type: {
      type: String,
      values: ["card", "border-card", ""],
      default: ""
    },
    activeName: {
      type: [String, Number]
    },
    closable: Boolean,
    addable: Boolean,
    modelValue: {
      type: [String, Number]
    },
    editable: Boolean,
    tabPosition: {
      type: String,
      values: ["top", "right", "bottom", "left"],
      default: "top"
    },
    beforeLeave: {
      type: le(Function),
      default: () => !0
    },
    stretch: Boolean
  }), Kd = (e) => et(e) || Xe(e), RJ = {
    [dt]: (e) => Kd(e),
    tabClick: (e, t) => t instanceof Event,
    tabChange: (e) => Kd(e),
    edit: (e, t) => ["remove", "add"].includes(t),
    tabRemove: (e) => Kd(e),
    tabAdd: () => !0
  };
  var xJ = G({
    name: "ElTabs",
    props: AJ,
    emits: RJ,
    setup(e, {
      emit: t,
      slots: n,
      expose: o
    }) {
      var r, s;
      const l = ge("tabs"), {
        children: a,
        addChild: u,
        removeChild: c
      } = Vw(it(), "ElTabPane"), f = I(), d = I((s = (r = e.modelValue) != null ? r : e.activeName) != null ? s : "0"), p = (y) => {
        d.value = y, t(dt, y), t("tabChange", y);
      }, h = async (y) => {
        var w, b, C;
        if (!(d.value === y || pn(y)))
          try {
            await ((w = e.beforeLeave) == null ? void 0 : w.call(e, y, d.value)) !== !1 && (p(y), (C = (b = f.value) == null ? void 0 : b.removeFocus) == null || C.call(b));
          } catch {
          }
      }, m = (y, w, b) => {
        y.props.disabled || (h(w), t("tabClick", y, b));
      }, v = (y, w) => {
        y.props.disabled || pn(y.props.name) || (w.stopPropagation(), t("edit", y.props.name, "remove"), t("tabRemove", y.props.name));
      }, g = () => {
        t("edit", void 0, "add"), t("tabAdd");
      };
      return Vo({
        from: '"activeName"',
        replacement: '"model-value" or "v-model"',
        scope: "ElTabs",
        version: "2.3.0",
        ref: "https://element-plus.org/en-US/component/tabs.html#attributes",
        type: "Attribute"
      }, E(() => !!e.activeName)), me(() => e.activeName, (y) => h(y)), me(() => e.modelValue, (y) => h(y)), me(d, async () => {
        var y;
        await Fe(), (y = f.value) == null || y.scrollToActiveTab();
      }), pt(od, {
        props: e,
        currentName: d,
        registerPane: u,
        unregisterPane: c
      }), o({
        currentName: d
      }), () => {
        const y = e.editable || e.addable ? K("span", {
          class: l.e("new-tab"),
          tabindex: "0",
          onClick: g,
          onKeydown: (C) => {
            C.code === We.enter && g();
          }
        }, [K(He, {
          class: l.is("icon-plus")
        }, {
          default: () => [K(Z1, null, null)]
        })]) : null, w = K("div", {
          class: [l.e("header"), l.is(e.tabPosition)]
        }, [y, K(PJ, {
          ref: f,
          currentName: d.value,
          editable: e.editable,
          type: e.type,
          panes: a.value,
          stretch: e.stretch,
          onTabClick: m,
          onTabRemove: v
        }, null)]), b = K("div", {
          class: l.e("content")
        }, [he(n, "default")]);
        return K("div", {
          class: [l.b(), l.m(e.tabPosition), {
            [l.m("card")]: e.type === "card",
            [l.m("border-card")]: e.type === "border-card"
          }]
        }, [...e.tabPosition !== "bottom" ? [w, b] : [b, w]]);
      };
    }
  });
  const DJ = Ie({
    label: {
      type: String,
      default: ""
    },
    name: {
      type: [String, Number]
    },
    closable: Boolean,
    disabled: Boolean,
    lazy: Boolean
  }), LJ = ["id", "aria-hidden", "aria-labelledby"], NS = "ElTabPane", VJ = G({
    name: NS
  }), BJ = /* @__PURE__ */ G({
    ...VJ,
    props: DJ,
    setup(e) {
      const t = e, n = it(), o = hn(), r = Be(od);
      r || Yt(NS, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
      const s = ge("tab-pane"), l = I(), a = E(() => t.closable || r.props.closable), u = km(() => {
        var h;
        return r.currentName.value === ((h = t.name) != null ? h : l.value);
      }), c = I(u.value), f = E(() => {
        var h;
        return (h = t.name) != null ? h : l.value;
      }), d = km(() => !t.lazy || c.value || u.value);
      me(u, (h) => {
        h && (c.value = !0);
      });
      const p = Tt({
        uid: n.uid,
        slots: o,
        props: t,
        paneName: f,
        active: u,
        index: l,
        isClosable: a
      });
      return st(() => {
        r.registerPane(p);
      }), Ur(() => {
        r.unregisterPane(p.uid);
      }), (h, m) => i(d) ? ot((S(), V("div", {
        key: 0,
        id: `pane-${i(f)}`,
        class: $(i(s).b()),
        role: "tabpanel",
        "aria-hidden": !i(u),
        "aria-labelledby": `tab-${i(f)}`
      }, [
        he(h.$slots, "default")
      ], 10, LJ)), [
        [$t, i(u)]
      ]) : se("v-if", !0);
    }
  });
  var TS = /* @__PURE__ */ Me(BJ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-pane.vue"]]);
  const FJ = ut(xJ, {
    TabPane: TS
  }), HJ = Gt(TS), zJ = Ie({
    type: {
      type: String,
      values: ["primary", "success", "info", "warning", "danger", ""],
      default: ""
    },
    size: {
      type: String,
      values: zo,
      default: ""
    },
    truncated: {
      type: Boolean
    },
    tag: {
      type: String,
      default: "span"
    }
  }), KJ = G({
    name: "ElText"
  }), jJ = /* @__PURE__ */ G({
    ...KJ,
    props: zJ,
    setup(e) {
      const t = e, n = on(), o = ge("text"), r = E(() => [
        o.b(),
        o.m(t.type),
        o.m(n.value),
        o.is("truncated", t.truncated)
      ]);
      return (s, l) => (S(), ie(vt(s.tag), {
        class: $(i(r))
      }, {
        default: X(() => [
          he(s.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"]));
    }
  });
  var WJ = /* @__PURE__ */ Me(jJ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/text/src/text.vue"]]);
  const UJ = ut(WJ), qJ = Ie({
    format: {
      type: String,
      default: "HH:mm"
    },
    modelValue: String,
    disabled: Boolean,
    editable: {
      type: Boolean,
      default: !0
    },
    effect: {
      type: String,
      default: "light"
    },
    clearable: {
      type: Boolean,
      default: !0
    },
    size: yn,
    placeholder: String,
    start: {
      type: String,
      default: "09:00"
    },
    end: {
      type: String,
      default: "18:00"
    },
    step: {
      type: String,
      default: "00:30"
    },
    minTime: String,
    maxTime: String,
    name: String,
    prefixIcon: {
      type: le([String, Object]),
      default: () => J1
    },
    clearIcon: {
      type: le([String, Object]),
      default: () => Yr
    }
  }), er = (e) => {
    const t = (e || "").split(":");
    if (t.length >= 2) {
      let n = Number.parseInt(t[0], 10);
      const o = Number.parseInt(t[1], 10), r = e.toUpperCase();
      return r.includes("AM") && n === 12 ? n = 0 : r.includes("PM") && n !== 12 && (n += 12), {
        hours: n,
        minutes: o
      };
    }
    return null;
  }, jd = (e, t) => {
    const n = er(e);
    if (!n)
      return -1;
    const o = er(t);
    if (!o)
      return -1;
    const r = n.minutes + n.hours * 60, s = o.minutes + o.hours * 60;
    return r === s ? 0 : r > s ? 1 : -1;
  }, Uy = (e) => `${e}`.padStart(2, "0"), Zs = (e) => `${Uy(e.hours)}:${Uy(e.minutes)}`, YJ = (e, t) => {
    const n = er(e);
    if (!n)
      return "";
    const o = er(t);
    if (!o)
      return "";
    const r = {
      hours: n.hours,
      minutes: n.minutes
    };
    return r.minutes += o.minutes, r.hours += o.hours, r.hours += Math.floor(r.minutes / 60), r.minutes = r.minutes % 60, Zs(r);
  }, GJ = G({
    name: "ElTimeSelect"
  }), XJ = /* @__PURE__ */ G({
    ...GJ,
    props: qJ,
    emits: ["change", "blur", "focus", "update:modelValue"],
    setup(e, { expose: t }) {
      const n = e;
      at.extend(Uh);
      const { Option: o } = Ps, r = ge("input"), s = I(), l = Fn(), a = E(() => n.modelValue), u = E(() => {
        const g = er(n.start);
        return g ? Zs(g) : null;
      }), c = E(() => {
        const g = er(n.end);
        return g ? Zs(g) : null;
      }), f = E(() => {
        const g = er(n.step);
        return g ? Zs(g) : null;
      }), d = E(() => {
        const g = er(n.minTime || "");
        return g ? Zs(g) : null;
      }), p = E(() => {
        const g = er(n.maxTime || "");
        return g ? Zs(g) : null;
      }), h = E(() => {
        const g = [];
        if (n.start && n.end && n.step) {
          let y = u.value, w;
          for (; y && c.value && jd(y, c.value) <= 0; )
            w = at(y, "HH:mm").format(n.format), g.push({
              value: w,
              disabled: jd(y, d.value || "-1:-1") <= 0 || jd(y, p.value || "100:100") >= 0
            }), y = YJ(y, f.value);
        }
        return g;
      });
      return t({
        blur: () => {
          var g, y;
          (y = (g = s.value) == null ? void 0 : g.blur) == null || y.call(g);
        },
        focus: () => {
          var g, y;
          (y = (g = s.value) == null ? void 0 : g.focus) == null || y.call(g);
        }
      }), (g, y) => (S(), ie(i(Ps), {
        ref_key: "select",
        ref: s,
        "model-value": i(a),
        disabled: i(l),
        clearable: g.clearable,
        "clear-icon": g.clearIcon,
        size: g.size,
        effect: g.effect,
        placeholder: g.placeholder,
        "default-first-option": "",
        filterable: g.editable,
        "onUpdate:modelValue": y[0] || (y[0] = (w) => g.$emit("update:modelValue", w)),
        onChange: y[1] || (y[1] = (w) => g.$emit("change", w)),
        onBlur: y[2] || (y[2] = (w) => g.$emit("blur", w)),
        onFocus: y[3] || (y[3] = (w) => g.$emit("focus", w))
      }, {
        prefix: X(() => [
          g.prefixIcon ? (S(), ie(i(He), {
            key: 0,
            class: $(i(r).e("prefix-icon"))
          }, {
            default: X(() => [
              (S(), ie(vt(g.prefixIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : se("v-if", !0)
        ]),
        default: X(() => [
          (S(!0), V(ze, null, gt(i(h), (w) => (S(), ie(i(o), {
            key: w.value,
            label: w.value,
            value: w.value,
            disabled: w.disabled
          }, null, 8, ["label", "value", "disabled"]))), 128))
        ]),
        _: 1
      }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "effect", "placeholder", "filterable"]));
    }
  });
  var Nu = /* @__PURE__ */ Me(XJ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-select/src/time-select.vue"]]);
  Nu.install = (e) => {
    e.component(Nu.name, Nu);
  };
  const JJ = Nu, ZJ = JJ, QJ = G({
    name: "ElTimeline",
    setup(e, { slots: t }) {
      const n = ge("timeline");
      return pt("timeline", t), () => je("ul", { class: [n.b()] }, [he(t, "default")]);
    }
  }), eZ = Ie({
    timestamp: {
      type: String,
      default: ""
    },
    hideTimestamp: {
      type: Boolean,
      default: !1
    },
    center: {
      type: Boolean,
      default: !1
    },
    placement: {
      type: String,
      values: ["top", "bottom"],
      default: "bottom"
    },
    type: {
      type: String,
      values: ["primary", "success", "warning", "danger", "info"],
      default: ""
    },
    color: {
      type: String,
      default: ""
    },
    size: {
      type: String,
      values: ["normal", "large"],
      default: "normal"
    },
    icon: {
      type: Vt
    },
    hollow: {
      type: Boolean,
      default: !1
    }
  }), tZ = G({
    name: "ElTimelineItem"
  }), nZ = /* @__PURE__ */ G({
    ...tZ,
    props: eZ,
    setup(e) {
      const t = ge("timeline-item");
      return (n, o) => (S(), V("li", {
        class: $([i(t).b(), { [i(t).e("center")]: n.center }])
      }, [
        H("div", {
          class: $(i(t).e("tail"))
        }, null, 2),
        n.$slots.dot ? se("v-if", !0) : (S(), V("div", {
          key: 0,
          class: $([
            i(t).e("node"),
            i(t).em("node", n.size || ""),
            i(t).em("node", n.type || ""),
            i(t).is("hollow", n.hollow)
          ]),
          style: Ke({
            backgroundColor: n.color
          })
        }, [
          n.icon ? (S(), ie(i(He), {
            key: 0,
            class: $(i(t).e("icon"))
          }, {
            default: X(() => [
              (S(), ie(vt(n.icon)))
            ]),
            _: 1
          }, 8, ["class"])) : se("v-if", !0)
        ], 6)),
        n.$slots.dot ? (S(), V("div", {
          key: 1,
          class: $(i(t).e("dot"))
        }, [
          he(n.$slots, "dot")
        ], 2)) : se("v-if", !0),
        H("div", {
          class: $(i(t).e("wrapper"))
        }, [
          !n.hideTimestamp && n.placement === "top" ? (S(), V("div", {
            key: 0,
            class: $([i(t).e("timestamp"), i(t).is("top")])
          }, Ne(n.timestamp), 3)) : se("v-if", !0),
          H("div", {
            class: $(i(t).e("content"))
          }, [
            he(n.$slots, "default")
          ], 2),
          !n.hideTimestamp && n.placement === "bottom" ? (S(), V("div", {
            key: 1,
            class: $([i(t).e("timestamp"), i(t).is("bottom")])
          }, Ne(n.timestamp), 3)) : se("v-if", !0)
        ], 2)
      ], 2));
    }
  });
  var OS = /* @__PURE__ */ Me(nZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/timeline/src/timeline-item.vue"]]);
  const oZ = ut(QJ, {
    TimelineItem: OS
  }), rZ = Gt(OS), MS = Ie({
    nowrap: Boolean
  });
  var IS = /* @__PURE__ */ ((e) => (e.top = "top", e.bottom = "bottom", e.left = "left", e.right = "right", e))(IS || {});
  const sZ = Object.values(IS), bv = Ie({
    width: {
      type: Number,
      default: 10
    },
    height: {
      type: Number,
      default: 10
    },
    style: {
      type: le(Object),
      default: null
    }
  }), lZ = Ie({
    side: {
      type: le(String),
      values: sZ,
      required: !0
    }
  }), aZ = ["absolute", "fixed"], iZ = [
    "top-start",
    "top-end",
    "top",
    "bottom-start",
    "bottom-end",
    "bottom",
    "left-start",
    "left-end",
    "left",
    "right-start",
    "right-end",
    "right"
  ], wv = Ie({
    ariaLabel: String,
    arrowPadding: {
      type: le(Number),
      default: 5
    },
    effect: {
      type: String,
      default: ""
    },
    contentClass: String,
    placement: {
      type: le(String),
      values: iZ,
      default: "bottom"
    },
    reference: {
      type: le(Object),
      default: null
    },
    offset: {
      type: Number,
      default: 8
    },
    strategy: {
      type: le(String),
      values: aZ,
      default: "absolute"
    },
    showArrow: {
      type: Boolean,
      default: !1
    }
  }), Cv = Ie({
    delayDuration: {
      type: Number,
      default: 300
    },
    defaultOpen: Boolean,
    open: {
      type: Boolean,
      default: void 0
    },
    onOpenChange: {
      type: le(Function)
    },
    "onUpdate:open": {
      type: le(Function)
    }
  }), Ws = {
    type: le(Function)
  }, Ev = Ie({
    onBlur: Ws,
    onClick: Ws,
    onFocus: Ws,
    onMouseDown: Ws,
    onMouseEnter: Ws,
    onMouseLeave: Ws
  }), uZ = Ie({
    ...Cv,
    ...bv,
    ...Ev,
    ...wv,
    alwaysOn: Boolean,
    fullTransition: Boolean,
    transitionProps: {
      type: le(Object),
      default: null
    },
    teleported: Boolean,
    to: {
      type: le(String),
      default: "body"
    }
  }), rd = Symbol("tooltipV2"), PS = Symbol("tooltipV2Content"), Wd = "tooltip_v2.open", cZ = G({
    name: "ElTooltipV2Root"
  }), dZ = /* @__PURE__ */ G({
    ...cZ,
    props: Cv,
    setup(e, { expose: t }) {
      const n = e, o = I(n.defaultOpen), r = I(null), s = E({
        get: () => RP(n.open) ? o.value : n.open,
        set: (g) => {
          var y;
          o.value = g, (y = n["onUpdate:open"]) == null || y.call(n, g);
        }
      }), l = E(() => Xe(n.delayDuration) && n.delayDuration > 0), { start: a, stop: u } = Os(() => {
        s.value = !0;
      }, E(() => n.delayDuration), {
        immediate: !1
      }), c = ge("tooltip-v2"), f = io(), d = () => {
        u(), s.value = !0;
      }, p = () => {
        i(l) ? a() : d();
      }, h = d, m = () => {
        u(), s.value = !1;
      };
      return me(s, (g) => {
        var y;
        g && (document.dispatchEvent(new CustomEvent(Wd)), h()), (y = n.onOpenChange) == null || y.call(n, g);
      }), st(() => {
        document.addEventListener(Wd, m);
      }), zt(() => {
        u(), document.removeEventListener(Wd, m);
      }), pt(rd, {
        contentId: f,
        triggerRef: r,
        ns: c,
        onClose: m,
        onDelayOpen: p,
        onOpen: h
      }), t({
        onOpen: h,
        onClose: m
      }), (g, y) => he(g.$slots, "default", { open: i(s) });
    }
  });
  var fZ = /* @__PURE__ */ Me(dZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/root.vue"]]);
  const pZ = G({
    name: "ElTooltipV2Arrow"
  }), hZ = /* @__PURE__ */ G({
    ...pZ,
    props: {
      ...bv,
      ...lZ
    },
    setup(e) {
      const t = e, { ns: n } = Be(rd), { arrowRef: o } = Be(PS), r = E(() => {
        const { style: s, width: l, height: a } = t, u = n.namespace.value;
        return {
          [`--${u}-tooltip-v2-arrow-width`]: `${l}px`,
          [`--${u}-tooltip-v2-arrow-height`]: `${a}px`,
          [`--${u}-tooltip-v2-arrow-border-width`]: `${l / 2}px`,
          [`--${u}-tooltip-v2-arrow-cover-width`]: l / 2 - 1,
          ...s || {}
        };
      });
      return (s, l) => (S(), V("span", {
        ref_key: "arrowRef",
        ref: o,
        style: Ke(i(r)),
        class: $(i(n).e("arrow"))
      }, null, 6));
    }
  });
  var qy = /* @__PURE__ */ Me(hZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/arrow.vue"]]);
  const vZ = Ie({
    style: {
      type: le([String, Object, Array]),
      default: () => ({})
    }
  }), mZ = G({
    name: "ElVisuallyHidden"
  }), gZ = /* @__PURE__ */ G({
    ...mZ,
    props: vZ,
    setup(e) {
      const t = e, n = E(() => [
        t.style,
        {
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal"
        }
      ]);
      return (o, r) => (S(), V("span", ft(o.$attrs, { style: i(n) }), [
        he(o.$slots, "default")
      ], 16));
    }
  });
  var yZ = /* @__PURE__ */ Me(gZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/visual-hidden/src/visual-hidden.vue"]]);
  const bZ = ["data-side"], wZ = G({
    name: "ElTooltipV2Content"
  }), CZ = /* @__PURE__ */ G({
    ...wZ,
    props: { ...wv, ...MS },
    setup(e) {
      const t = e, { triggerRef: n, contentId: o } = Be(rd), r = I(t.placement), s = I(t.strategy), l = I(null), { referenceRef: a, contentRef: u, middlewareData: c, x: f, y: d, update: p } = vL({
        placement: r,
        strategy: s,
        middleware: E(() => {
          const b = [X8(t.offset)];
          return t.showArrow && b.push(mL({
            arrowRef: l
          })), b;
        })
      }), h = Fs().nextZIndex(), m = ge("tooltip-v2"), v = E(() => r.value.split("-")[0]), g = E(() => ({
        position: i(s),
        top: `${i(d) || 0}px`,
        left: `${i(f) || 0}px`,
        zIndex: h
      })), y = E(() => {
        if (!t.showArrow)
          return {};
        const { arrow: b } = i(c);
        return {
          [`--${m.namespace.value}-tooltip-v2-arrow-x`]: `${b == null ? void 0 : b.x}px` || "",
          [`--${m.namespace.value}-tooltip-v2-arrow-y`]: `${b == null ? void 0 : b.y}px` || ""
        };
      }), w = E(() => [
        m.e("content"),
        m.is("dark", t.effect === "dark"),
        m.is(i(s)),
        t.contentClass
      ]);
      return me(l, () => p()), me(() => t.placement, (b) => r.value = b), st(() => {
        me(() => t.reference || n.value, (b) => {
          a.value = b || void 0;
        }, {
          immediate: !0
        });
      }), pt(PS, { arrowRef: l }), (b, C) => (S(), V("div", {
        ref_key: "contentRef",
        ref: u,
        style: Ke(i(g)),
        "data-tooltip-v2-root": ""
      }, [
        b.nowrap ? se("v-if", !0) : (S(), V("div", {
          key: 0,
          "data-side": i(v),
          class: $(i(w))
        }, [
          he(b.$slots, "default", {
            contentStyle: i(g),
            contentClass: i(w)
          }),
          K(i(yZ), {
            id: i(o),
            role: "tooltip"
          }, {
            default: X(() => [
              b.ariaLabel ? (S(), V(ze, { key: 0 }, [
                wt(Ne(b.ariaLabel), 1)
              ], 64)) : he(b.$slots, "default", { key: 1 })
            ]),
            _: 3
          }, 8, ["id"]),
          he(b.$slots, "arrow", {
            style: Ke(i(y)),
            side: i(v)
          })
        ], 10, bZ))
      ], 4));
    }
  });
  var Yy = /* @__PURE__ */ Me(CZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/content.vue"]]);
  const EZ = Ie({
    setRef: {
      type: le(Function),
      required: !0
    },
    onlyChild: Boolean
  });
  var SZ = G({
    props: EZ,
    setup(e, {
      slots: t
    }) {
      const n = I(), o = Hc(n, (r) => {
        r ? e.setRef(r.nextElementSibling) : e.setRef(null);
      });
      return () => {
        var r;
        const [s] = ((r = t.default) == null ? void 0 : r.call(t)) || [], l = e.onlyChild ? vD(s.children) : s.children;
        return K(ze, {
          ref: o
        }, [l]);
      };
    }
  });
  const _Z = G({
    name: "ElTooltipV2Trigger"
  }), kZ = /* @__PURE__ */ G({
    ..._Z,
    props: {
      ...MS,
      ...Ev
    },
    setup(e) {
      const t = e, { onClose: n, onOpen: o, onDelayOpen: r, triggerRef: s, contentId: l } = Be(rd);
      let a = !1;
      const u = (w) => {
        s.value = w;
      }, c = () => {
        a = !1;
      }, f = qt(t.onMouseEnter, r), d = qt(t.onMouseLeave, n), p = qt(t.onMouseDown, () => {
        n(), a = !0, document.addEventListener("mouseup", c, { once: !0 });
      }), h = qt(t.onFocus, () => {
        a || o();
      }), m = qt(t.onBlur, n), v = qt(t.onClick, (w) => {
        w.detail === 0 && n();
      }), g = {
        blur: m,
        click: v,
        focus: h,
        mousedown: p,
        mouseenter: f,
        mouseleave: d
      }, y = (w, b, C) => {
        w && Object.entries(b).forEach(([_, k]) => {
          w[C](_, k);
        });
      };
      return me(s, (w, b) => {
        y(w, g, "addEventListener"), y(b, g, "removeEventListener"), w && w.setAttribute("aria-describedby", l.value);
      }), zt(() => {
        y(s.value, g, "removeEventListener"), document.removeEventListener("mouseup", c);
      }), (w, b) => w.nowrap ? (S(), ie(i(SZ), {
        key: 0,
        "set-ref": u,
        "only-child": ""
      }, {
        default: X(() => [
          he(w.$slots, "default")
        ]),
        _: 3
      })) : (S(), V("button", ft({
        key: 1,
        ref_key: "triggerRef",
        ref: s
      }, w.$attrs), [
        he(w.$slots, "default")
      ], 16));
    }
  });
  var $Z = /* @__PURE__ */ Me(kZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/trigger.vue"]]);
  const NZ = G({
    name: "ElTooltipV2"
  }), TZ = /* @__PURE__ */ G({
    ...NZ,
    props: uZ,
    setup(e) {
      const n = rn(e), o = Tt(tr(n, Object.keys(bv))), r = Tt(tr(n, Object.keys(wv))), s = Tt(tr(n, Object.keys(Cv))), l = Tt(tr(n, Object.keys(Ev)));
      return (a, u) => (S(), ie(fZ, mo(Nc(s)), {
        default: X(({ open: c }) => [
          K($Z, ft(l, { nowrap: "" }), {
            default: X(() => [
              he(a.$slots, "trigger")
            ]),
            _: 3
          }, 16),
          (S(), ie(pi, {
            to: a.to,
            disabled: !a.teleported
          }, [
            a.fullTransition ? (S(), ie(Qt, mo(ft({ key: 0 }, a.transitionProps)), {
              default: X(() => [
                a.alwaysOn || c ? (S(), ie(Yy, mo(ft({ key: 0 }, r)), {
                  arrow: X(({ style: f, side: d }) => [
                    a.showArrow ? (S(), ie(qy, ft({ key: 0 }, o, {
                      style: f,
                      side: d
                    }), null, 16, ["style", "side"])) : se("v-if", !0)
                  ]),
                  default: X(() => [
                    he(a.$slots, "default")
                  ]),
                  _: 3
                }, 16)) : se("v-if", !0)
              ]),
              _: 2
            }, 1040)) : (S(), V(ze, { key: 1 }, [
              a.alwaysOn || c ? (S(), ie(Yy, mo(ft({ key: 0 }, r)), {
                arrow: X(({ style: f, side: d }) => [
                  a.showArrow ? (S(), ie(qy, ft({ key: 0 }, o, {
                    style: f,
                    side: d
                  }), null, 16, ["style", "side"])) : se("v-if", !0)
                ]),
                default: X(() => [
                  he(a.$slots, "default")
                ]),
                _: 3
              }, 16)) : se("v-if", !0)
            ], 64))
          ], 8, ["to", "disabled"]))
        ]),
        _: 3
      }, 16));
    }
  });
  var OZ = /* @__PURE__ */ Me(TZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/tooltip.vue"]]);
  const MZ = ut(OZ), AS = "left-check-change", RS = "right-check-change", Qs = Ie({
    data: {
      type: le(Array),
      default: () => []
    },
    titles: {
      type: le(Array),
      default: () => []
    },
    buttonTexts: {
      type: le(Array),
      default: () => []
    },
    filterPlaceholder: String,
    filterMethod: {
      type: le(Function)
    },
    leftDefaultChecked: {
      type: le(Array),
      default: () => []
    },
    rightDefaultChecked: {
      type: le(Array),
      default: () => []
    },
    renderContent: {
      type: le(Function)
    },
    modelValue: {
      type: le(Array),
      default: () => []
    },
    format: {
      type: le(Object),
      default: () => ({})
    },
    filterable: Boolean,
    props: {
      type: le(Object),
      default: () => jt({
        label: "label",
        key: "key",
        disabled: "disabled"
      })
    },
    targetOrder: {
      type: String,
      values: ["original", "push", "unshift"],
      default: "original"
    },
    validateEvent: {
      type: Boolean,
      default: !0
    }
  }), vp = (e, t) => [e, t].every(De) || De(e) && nn(t), IZ = {
    [Ft]: (e, t, n) => [e, n].every(De) && ["left", "right"].includes(t),
    [dt]: (e) => De(e),
    [AS]: vp,
    [RS]: vp
  }, mp = "checked-change", PZ = Ie({
    data: Qs.data,
    optionRender: {
      type: le(Function)
    },
    placeholder: String,
    title: String,
    filterable: Boolean,
    format: Qs.format,
    filterMethod: Qs.filterMethod,
    defaultChecked: Qs.leftDefaultChecked,
    props: Qs.props
  }), AZ = {
    [mp]: vp
  }, Ni = (e) => {
    const t = {
      label: "label",
      key: "key",
      disabled: "disabled"
    };
    return E(() => ({
      ...t,
      ...e.props
    }));
  }, RZ = (e, t, n) => {
    const o = Ni(e), r = E(() => e.data.filter((f) => Ge(e.filterMethod) ? e.filterMethod(t.query, f) : String(f[o.value.label] || f[o.value.key]).toLowerCase().includes(t.query.toLowerCase()))), s = E(() => r.value.filter((f) => !f[o.value.disabled])), l = E(() => {
      const f = t.checked.length, d = e.data.length, { noChecked: p, hasChecked: h } = e.format;
      return p && h ? f > 0 ? h.replace(/\${checked}/g, f.toString()).replace(/\${total}/g, d.toString()) : p.replace(/\${total}/g, d.toString()) : `${f}/${d}`;
    }), a = E(() => {
      const f = t.checked.length;
      return f > 0 && f < s.value.length;
    }), u = () => {
      const f = s.value.map((d) => d[o.value.key]);
      t.allChecked = f.length > 0 && f.every((d) => t.checked.includes(d));
    }, c = (f) => {
      t.checked = f ? s.value.map((d) => d[o.value.key]) : [];
    };
    return me(() => t.checked, (f, d) => {
      if (u(), t.checkChangeByUser) {
        const p = f.concat(d).filter((h) => !f.includes(h) || !d.includes(h));
        n(mp, f, p);
      } else
        n(mp, f), t.checkChangeByUser = !0;
    }), me(s, () => {
      u();
    }), me(() => e.data, () => {
      const f = [], d = r.value.map((p) => p[o.value.key]);
      t.checked.forEach((p) => {
        d.includes(p) && f.push(p);
      }), t.checkChangeByUser = !1, t.checked = f;
    }), me(() => e.defaultChecked, (f, d) => {
      if (d && f.length === d.length && f.every((m) => d.includes(m)))
        return;
      const p = [], h = s.value.map((m) => m[o.value.key]);
      f.forEach((m) => {
        h.includes(m) && p.push(m);
      }), t.checkChangeByUser = !1, t.checked = p;
    }, {
      immediate: !0
    }), {
      filteredData: r,
      checkableData: s,
      checkedSummary: l,
      isIndeterminate: a,
      updateAllChecked: u,
      handleAllCheckedChange: c
    };
  }, xZ = (e, t) => ({
    onSourceCheckedChange: (r, s) => {
      e.leftChecked = r, s && t(AS, r, s);
    },
    onTargetCheckedChange: (r, s) => {
      e.rightChecked = r, s && t(RS, r, s);
    }
  }), DZ = (e) => {
    const t = Ni(e), n = E(() => e.data.reduce((s, l) => (s[l[t.value.key]] = l) && s, {})), o = E(() => e.data.filter((s) => !e.modelValue.includes(s[t.value.key]))), r = E(() => e.targetOrder === "original" ? e.data.filter((s) => e.modelValue.includes(s[t.value.key])) : e.modelValue.reduce((s, l) => {
      const a = n.value[l];
      return a && s.push(a), s;
    }, []));
    return {
      sourceData: o,
      targetData: r
    };
  }, LZ = (e, t, n) => {
    const o = Ni(e), r = (a, u, c) => {
      n(dt, a), n(Ft, a, u, c);
    };
    return {
      addToLeft: () => {
        const a = e.modelValue.slice();
        t.rightChecked.forEach((u) => {
          const c = a.indexOf(u);
          c > -1 && a.splice(c, 1);
        }), r(a, "left", t.rightChecked);
      },
      addToRight: () => {
        let a = e.modelValue.slice();
        const u = e.data.filter((c) => {
          const f = c[o.value.key];
          return t.leftChecked.includes(f) && !e.modelValue.includes(f);
        }).map((c) => c[o.value.key]);
        a = e.targetOrder === "unshift" ? u.concat(a) : a.concat(u), e.targetOrder === "original" && (a = e.data.filter((c) => a.includes(c[o.value.key])).map((c) => c[o.value.key])), r(a, "right", t.leftChecked);
      }
    };
  }, VZ = G({
    name: "ElTransferPanel"
  }), BZ = /* @__PURE__ */ G({
    ...VZ,
    props: PZ,
    emits: AZ,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = hn(), s = ({ option: b }) => b, { t: l } = St(), a = ge("transfer"), u = Tt({
        checked: [],
        allChecked: !1,
        query: "",
        checkChangeByUser: !0
      }), c = Ni(o), {
        filteredData: f,
        checkedSummary: d,
        isIndeterminate: p,
        handleAllCheckedChange: h
      } = RZ(o, u, n), m = E(() => !Qn(u.query) && Qn(f.value)), v = E(() => !Qn(r.default()[0].children)), { checked: g, allChecked: y, query: w } = rn(u);
      return t({
        query: w
      }), (b, C) => (S(), V("div", {
        class: $(i(a).b("panel"))
      }, [
        H("p", {
          class: $(i(a).be("panel", "header"))
        }, [
          K(i(co), {
            modelValue: i(y),
            "onUpdate:modelValue": C[0] || (C[0] = (_) => Pt(y) ? y.value = _ : null),
            indeterminate: i(p),
            "validate-event": !1,
            onChange: i(h)
          }, {
            default: X(() => [
              wt(Ne(b.title) + " ", 1),
              H("span", null, Ne(i(d)), 1)
            ]),
            _: 1
          }, 8, ["modelValue", "indeterminate", "onChange"])
        ], 2),
        H("div", {
          class: $([i(a).be("panel", "body"), i(a).is("with-footer", i(v))])
        }, [
          b.filterable ? (S(), ie(i(wn), {
            key: 0,
            modelValue: i(w),
            "onUpdate:modelValue": C[1] || (C[1] = (_) => Pt(w) ? w.value = _ : null),
            class: $(i(a).be("panel", "filter")),
            size: "default",
            placeholder: b.placeholder,
            "prefix-icon": i(ux),
            clearable: "",
            "validate-event": !1
          }, null, 8, ["modelValue", "class", "placeholder", "prefix-icon"])) : se("v-if", !0),
          ot(K(i(HC), {
            modelValue: i(g),
            "onUpdate:modelValue": C[2] || (C[2] = (_) => Pt(g) ? g.value = _ : null),
            "validate-event": !1,
            class: $([i(a).is("filterable", b.filterable), i(a).be("panel", "list")])
          }, {
            default: X(() => [
              (S(!0), V(ze, null, gt(i(f), (_) => (S(), ie(i(co), {
                key: _[i(c).key],
                class: $(i(a).be("panel", "item")),
                label: _[i(c).key],
                disabled: _[i(c).disabled],
                "validate-event": !1
              }, {
                default: X(() => {
                  var k;
                  return [
                    K(s, {
                      option: (k = b.optionRender) == null ? void 0 : k.call(b, _)
                    }, null, 8, ["option"])
                  ];
                }),
                _: 2
              }, 1032, ["class", "label", "disabled"]))), 128))
            ]),
            _: 1
          }, 8, ["modelValue", "class"]), [
            [$t, !i(m) && !i(Qn)(b.data)]
          ]),
          ot(H("p", {
            class: $(i(a).be("panel", "empty"))
          }, Ne(i(m) ? i(l)("el.transfer.noMatch") : i(l)("el.transfer.noData")), 3), [
            [$t, i(m) || i(Qn)(b.data)]
          ])
        ], 2),
        i(v) ? (S(), V("p", {
          key: 0,
          class: $(i(a).be("panel", "footer"))
        }, [
          he(b.$slots, "default")
        ], 2)) : se("v-if", !0)
      ], 2));
    }
  });
  var Gy = /* @__PURE__ */ Me(BZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer-panel.vue"]]);
  const FZ = { key: 0 }, HZ = { key: 0 }, zZ = G({
    name: "ElTransfer"
  }), KZ = /* @__PURE__ */ G({
    ...zZ,
    props: Qs,
    emits: IZ,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = hn(), { t: s } = St(), l = ge("transfer"), { formItem: a } = In(), u = Tt({
        leftChecked: [],
        rightChecked: []
      }), c = Ni(o), { sourceData: f, targetData: d } = DZ(o), { onSourceCheckedChange: p, onTargetCheckedChange: h } = xZ(u, n), { addToLeft: m, addToRight: v } = LZ(o, u, n), g = I(), y = I(), w = (T) => {
        switch (T) {
          case "left":
            g.value.query = "";
            break;
          case "right":
            y.value.query = "";
            break;
        }
      }, b = E(() => o.buttonTexts.length === 2), C = E(() => o.titles[0] || s("el.transfer.titles.0")), _ = E(() => o.titles[1] || s("el.transfer.titles.1")), k = E(() => o.filterPlaceholder || s("el.transfer.filterPlaceholder"));
      me(() => o.modelValue, () => {
        var T;
        o.validateEvent && ((T = a == null ? void 0 : a.validate) == null || T.call(a, "change").catch((P) => yt(P)));
      });
      const O = E(() => (T) => o.renderContent ? o.renderContent(je, T) : r.default ? r.default({ option: T }) : je("span", T[c.value.label] || T[c.value.key]));
      return t({
        clearQuery: w,
        leftPanel: g,
        rightPanel: y
      }), (T, P) => (S(), V("div", {
        class: $(i(l).b())
      }, [
        K(Gy, {
          ref_key: "leftPanel",
          ref: g,
          data: i(f),
          "option-render": i(O),
          placeholder: i(k),
          title: i(C),
          filterable: T.filterable,
          format: T.format,
          "filter-method": T.filterMethod,
          "default-checked": T.leftDefaultChecked,
          props: o.props,
          onCheckedChange: i(p)
        }, {
          default: X(() => [
            he(T.$slots, "left-footer")
          ]),
          _: 3
        }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]),
        H("div", {
          class: $(i(l).e("buttons"))
        }, [
          K(i(gn), {
            type: "primary",
            class: $([i(l).e("button"), i(l).is("with-texts", i(b))]),
            disabled: i(Qn)(u.rightChecked),
            onClick: i(m)
          }, {
            default: X(() => [
              K(i(He), null, {
                default: X(() => [
                  K(i(Br))
                ]),
                _: 1
              }),
              i(pn)(T.buttonTexts[0]) ? se("v-if", !0) : (S(), V("span", FZ, Ne(T.buttonTexts[0]), 1))
            ]),
            _: 1
          }, 8, ["class", "disabled", "onClick"]),
          K(i(gn), {
            type: "primary",
            class: $([i(l).e("button"), i(l).is("with-texts", i(b))]),
            disabled: i(Qn)(u.leftChecked),
            onClick: i(v)
          }, {
            default: X(() => [
              i(pn)(T.buttonTexts[1]) ? se("v-if", !0) : (S(), V("span", HZ, Ne(T.buttonTexts[1]), 1)),
              K(i(He), null, {
                default: X(() => [
                  K(i(kn))
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["class", "disabled", "onClick"])
        ], 2),
        K(Gy, {
          ref_key: "rightPanel",
          ref: y,
          data: i(d),
          "option-render": i(O),
          placeholder: i(k),
          filterable: T.filterable,
          format: T.format,
          "filter-method": T.filterMethod,
          title: i(_),
          "default-checked": T.rightDefaultChecked,
          props: o.props,
          onCheckedChange: i(h)
        }, {
          default: X(() => [
            he(T.$slots, "right-footer")
          ]),
          _: 3
        }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])
      ], 2));
    }
  });
  var jZ = /* @__PURE__ */ Me(KZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer.vue"]]);
  const WZ = ut(jZ), ml = "$treeNodeId", Xy = function(e, t) {
    !t || t[ml] || Object.defineProperty(t, ml, {
      value: e.id,
      enumerable: !1,
      configurable: !1,
      writable: !1
    });
  }, Sv = function(e, t) {
    return e ? t[e] : t[ml];
  }, gp = (e, t, n) => {
    const o = e.value.currentNode;
    n();
    const r = e.value.currentNode;
    o !== r && t("current-change", r ? r.data : null, r);
  }, yp = (e) => {
    let t = !0, n = !0, o = !0;
    for (let r = 0, s = e.length; r < s; r++) {
      const l = e[r];
      (l.checked !== !0 || l.indeterminate) && (t = !1, l.disabled || (o = !1)), (l.checked !== !1 || l.indeterminate) && (n = !1);
    }
    return { all: t, none: n, allWithoutDisable: o, half: !t && !n };
  }, Tu = function(e) {
    if (e.childNodes.length === 0 || e.loading)
      return;
    const { all: t, none: n, half: o } = yp(e.childNodes);
    t ? (e.checked = !0, e.indeterminate = !1) : o ? (e.checked = !1, e.indeterminate = !0) : n && (e.checked = !1, e.indeterminate = !1);
    const r = e.parent;
    !r || r.level === 0 || e.store.checkStrictly || Tu(r);
  }, Zi = function(e, t) {
    const n = e.store.props, o = e.data || {}, r = n[t];
    if (typeof r == "function")
      return r(o, e);
    if (typeof r == "string")
      return o[r];
    if (typeof r > "u") {
      const s = o[t];
      return s === void 0 ? "" : s;
    }
  };
  let UZ = 0;
  class $s {
    constructor(t) {
      this.id = UZ++, this.text = null, this.checked = !1, this.indeterminate = !1, this.data = null, this.expanded = !1, this.parent = null, this.visible = !0, this.isCurrent = !1, this.canFocus = !1;
      for (const n in t)
        ht(t, n) && (this[n] = t[n]);
      this.level = 0, this.loaded = !1, this.childNodes = [], this.loading = !1, this.parent && (this.level = this.parent.level + 1);
    }
    initialize() {
      const t = this.store;
      if (!t)
        throw new Error("[Node]store is required!");
      t.registerNode(this);
      const n = t.props;
      if (n && typeof n.isLeaf < "u") {
        const s = Zi(this, "isLeaf");
        typeof s == "boolean" && (this.isLeafByUser = s);
      }
      if (t.lazy !== !0 && this.data ? (this.setData(this.data), t.defaultExpandAll && (this.expanded = !0, this.canFocus = !0)) : this.level > 0 && t.lazy && t.defaultExpandAll && this.expand(), Array.isArray(this.data) || Xy(this, this.data), !this.data)
        return;
      const o = t.defaultExpandedKeys, r = t.key;
      r && o && o.includes(this.key) && this.expand(null, t.autoExpandParent), r && t.currentNodeKey !== void 0 && this.key === t.currentNodeKey && (t.currentNode = this, t.currentNode.isCurrent = !0), t.lazy && t._initDefaultCheckedNode(this), this.updateLeafState(), this.parent && (this.level === 1 || this.parent.expanded === !0) && (this.canFocus = !0);
    }
    setData(t) {
      Array.isArray(t) || Xy(this, t), this.data = t, this.childNodes = [];
      let n;
      this.level === 0 && Array.isArray(this.data) ? n = this.data : n = Zi(this, "children") || [];
      for (let o = 0, r = n.length; o < r; o++)
        this.insertChild({ data: n[o] });
    }
    get label() {
      return Zi(this, "label");
    }
    get key() {
      const t = this.store.key;
      return this.data ? this.data[t] : null;
    }
    get disabled() {
      return Zi(this, "disabled");
    }
    get nextSibling() {
      const t = this.parent;
      if (t) {
        const n = t.childNodes.indexOf(this);
        if (n > -1)
          return t.childNodes[n + 1];
      }
      return null;
    }
    get previousSibling() {
      const t = this.parent;
      if (t) {
        const n = t.childNodes.indexOf(this);
        if (n > -1)
          return n > 0 ? t.childNodes[n - 1] : null;
      }
      return null;
    }
    contains(t, n = !0) {
      return (this.childNodes || []).some((o) => o === t || n && o.contains(t));
    }
    remove() {
      const t = this.parent;
      t && t.removeChild(this);
    }
    insertChild(t, n, o) {
      if (!t)
        throw new Error("InsertChild error: child is required.");
      if (!(t instanceof $s)) {
        if (!o) {
          const r = this.getChildren(!0);
          r.includes(t.data) || (typeof n > "u" || n < 0 ? r.push(t.data) : r.splice(n, 0, t.data));
        }
        Object.assign(t, {
          parent: this,
          store: this.store
        }), t = Tt(new $s(t)), t instanceof $s && t.initialize();
      }
      t.level = this.level + 1, typeof n > "u" || n < 0 ? this.childNodes.push(t) : this.childNodes.splice(n, 0, t), this.updateLeafState();
    }
    insertBefore(t, n) {
      let o;
      n && (o = this.childNodes.indexOf(n)), this.insertChild(t, o);
    }
    insertAfter(t, n) {
      let o;
      n && (o = this.childNodes.indexOf(n), o !== -1 && (o += 1)), this.insertChild(t, o);
    }
    removeChild(t) {
      const n = this.getChildren() || [], o = n.indexOf(t.data);
      o > -1 && n.splice(o, 1);
      const r = this.childNodes.indexOf(t);
      r > -1 && (this.store && this.store.deregisterNode(t), t.parent = null, this.childNodes.splice(r, 1)), this.updateLeafState();
    }
    removeChildByData(t) {
      let n = null;
      for (let o = 0; o < this.childNodes.length; o++)
        if (this.childNodes[o].data === t) {
          n = this.childNodes[o];
          break;
        }
      n && this.removeChild(n);
    }
    expand(t, n) {
      const o = () => {
        if (n) {
          let r = this.parent;
          for (; r.level > 0; )
            r.expanded = !0, r = r.parent;
        }
        this.expanded = !0, t && t(), this.childNodes.forEach((r) => {
          r.canFocus = !0;
        });
      };
      this.shouldLoadData() ? this.loadData((r) => {
        Array.isArray(r) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || Tu(this), o());
      }) : o();
    }
    doCreateChildren(t, n = {}) {
      t.forEach((o) => {
        this.insertChild(Object.assign({ data: o }, n), void 0, !0);
      });
    }
    collapse() {
      this.expanded = !1, this.childNodes.forEach((t) => {
        t.canFocus = !1;
      });
    }
    shouldLoadData() {
      return this.store.lazy === !0 && this.store.load && !this.loaded;
    }
    updateLeafState() {
      if (this.store.lazy === !0 && this.loaded !== !0 && typeof this.isLeafByUser < "u") {
        this.isLeaf = this.isLeafByUser;
        return;
      }
      const t = this.childNodes;
      if (!this.store.lazy || this.store.lazy === !0 && this.loaded === !0) {
        this.isLeaf = !t || t.length === 0;
        return;
      }
      this.isLeaf = !1;
    }
    setChecked(t, n, o, r) {
      if (this.indeterminate = t === "half", this.checked = t === !0, this.store.checkStrictly)
        return;
      if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
        const { all: l, allWithoutDisable: a } = yp(this.childNodes);
        !this.isLeaf && !l && a && (this.checked = !1, t = !1);
        const u = () => {
          if (n) {
            const c = this.childNodes;
            for (let p = 0, h = c.length; p < h; p++) {
              const m = c[p];
              r = r || t !== !1;
              const v = m.disabled ? m.checked : r;
              m.setChecked(v, n, !0, r);
            }
            const { half: f, all: d } = yp(c);
            d || (this.checked = d, this.indeterminate = f);
          }
        };
        if (this.shouldLoadData()) {
          this.loadData(() => {
            u(), Tu(this);
          }, {
            checked: t !== !1
          });
          return;
        } else
          u();
      }
      const s = this.parent;
      !s || s.level === 0 || o || Tu(s);
    }
    getChildren(t = !1) {
      if (this.level === 0)
        return this.data;
      const n = this.data;
      if (!n)
        return null;
      const o = this.store.props;
      let r = "children";
      return o && (r = o.children || "children"), n[r] === void 0 && (n[r] = null), t && !n[r] && (n[r] = []), n[r];
    }
    updateChildren() {
      const t = this.getChildren() || [], n = this.childNodes.map((s) => s.data), o = {}, r = [];
      t.forEach((s, l) => {
        const a = s[ml];
        !!a && n.findIndex((c) => c[ml] === a) >= 0 ? o[a] = { index: l, data: s } : r.push({ index: l, data: s });
      }), this.store.lazy || n.forEach((s) => {
        o[s[ml]] || this.removeChildByData(s);
      }), r.forEach(({ index: s, data: l }) => {
        this.insertChild({ data: l }, s);
      }), this.updateLeafState();
    }
    loadData(t, n = {}) {
      if (this.store.lazy === !0 && this.store.load && !this.loaded && (!this.loading || Object.keys(n).length)) {
        this.loading = !0;
        const o = (r) => {
          this.childNodes = [], this.doCreateChildren(r, n), this.loaded = !0, this.loading = !1, this.updateLeafState(), t && t.call(this, r);
        };
        this.store.load(this, o);
      } else
        t && t.call(this);
    }
  }
  class qZ {
    constructor(t) {
      this.currentNode = null, this.currentNodeKey = null;
      for (const n in t)
        ht(t, n) && (this[n] = t[n]);
      this.nodesMap = {};
    }
    initialize() {
      if (this.root = new $s({
        data: this.data,
        store: this
      }), this.root.initialize(), this.lazy && this.load) {
        const t = this.load;
        t(this.root, (n) => {
          this.root.doCreateChildren(n), this._initDefaultCheckedNodes();
        });
      } else
        this._initDefaultCheckedNodes();
    }
    filter(t) {
      const n = this.filterNodeMethod, o = this.lazy, r = function(s) {
        const l = s.root ? s.root.childNodes : s.childNodes;
        if (l.forEach((a) => {
          a.visible = n.call(a, t, a.data, a), r(a);
        }), !s.visible && l.length) {
          let a = !0;
          a = !l.some((u) => u.visible), s.root ? s.root.visible = a === !1 : s.visible = a === !1;
        }
        !t || s.visible && !s.isLeaf && !o && s.expand();
      };
      r(this);
    }
    setData(t) {
      t !== this.root.data ? (this.root.setData(t), this._initDefaultCheckedNodes()) : this.root.updateChildren();
    }
    getNode(t) {
      if (t instanceof $s)
        return t;
      const n = rt(t) ? Sv(this.key, t) : t;
      return this.nodesMap[n] || null;
    }
    insertBefore(t, n) {
      const o = this.getNode(n);
      o.parent.insertBefore({ data: t }, o);
    }
    insertAfter(t, n) {
      const o = this.getNode(n);
      o.parent.insertAfter({ data: t }, o);
    }
    remove(t) {
      const n = this.getNode(t);
      n && n.parent && (n === this.currentNode && (this.currentNode = null), n.parent.removeChild(n));
    }
    append(t, n) {
      const o = n ? this.getNode(n) : this.root;
      o && o.insertChild({ data: t });
    }
    _initDefaultCheckedNodes() {
      const t = this.defaultCheckedKeys || [], n = this.nodesMap;
      t.forEach((o) => {
        const r = n[o];
        r && r.setChecked(!0, !this.checkStrictly);
      });
    }
    _initDefaultCheckedNode(t) {
      (this.defaultCheckedKeys || []).includes(t.key) && t.setChecked(!0, !this.checkStrictly);
    }
    setDefaultCheckedKey(t) {
      t !== this.defaultCheckedKeys && (this.defaultCheckedKeys = t, this._initDefaultCheckedNodes());
    }
    registerNode(t) {
      const n = this.key;
      !t || !t.data || (n ? t.key !== void 0 && (this.nodesMap[t.key] = t) : this.nodesMap[t.id] = t);
    }
    deregisterNode(t) {
      !this.key || !t || !t.data || (t.childNodes.forEach((o) => {
        this.deregisterNode(o);
      }), delete this.nodesMap[t.key]);
    }
    getCheckedNodes(t = !1, n = !1) {
      const o = [], r = function(s) {
        (s.root ? s.root.childNodes : s.childNodes).forEach((a) => {
          (a.checked || n && a.indeterminate) && (!t || t && a.isLeaf) && o.push(a.data), r(a);
        });
      };
      return r(this), o;
    }
    getCheckedKeys(t = !1) {
      return this.getCheckedNodes(t).map((n) => (n || {})[this.key]);
    }
    getHalfCheckedNodes() {
      const t = [], n = function(o) {
        (o.root ? o.root.childNodes : o.childNodes).forEach((s) => {
          s.indeterminate && t.push(s.data), n(s);
        });
      };
      return n(this), t;
    }
    getHalfCheckedKeys() {
      return this.getHalfCheckedNodes().map((t) => (t || {})[this.key]);
    }
    _getAllNodes() {
      const t = [], n = this.nodesMap;
      for (const o in n)
        ht(n, o) && t.push(n[o]);
      return t;
    }
    updateChildren(t, n) {
      const o = this.nodesMap[t];
      if (!o)
        return;
      const r = o.childNodes;
      for (let s = r.length - 1; s >= 0; s--) {
        const l = r[s];
        this.remove(l.data);
      }
      for (let s = 0, l = n.length; s < l; s++) {
        const a = n[s];
        this.append(a, o.data);
      }
    }
    _setCheckedKeys(t, n = !1, o) {
      const r = this._getAllNodes().sort((a, u) => u.level - a.level), s = /* @__PURE__ */ Object.create(null), l = Object.keys(o);
      r.forEach((a) => a.setChecked(!1, !1));
      for (let a = 0, u = r.length; a < u; a++) {
        const c = r[a], f = c.data[t].toString();
        if (!l.includes(f)) {
          c.checked && !s[f] && c.setChecked(!1, !1);
          continue;
        }
        let p = c.parent;
        for (; p && p.level > 0; )
          s[p.data[t]] = !0, p = p.parent;
        if (c.isLeaf || this.checkStrictly) {
          c.setChecked(!0, !1);
          continue;
        }
        if (c.setChecked(!0, !0), n) {
          c.setChecked(!1, !1);
          const h = function(m) {
            m.childNodes.forEach((g) => {
              g.isLeaf || g.setChecked(!1, !1), h(g);
            });
          };
          h(c);
        }
      }
    }
    setCheckedNodes(t, n = !1) {
      const o = this.key, r = {};
      t.forEach((s) => {
        r[(s || {})[o]] = !0;
      }), this._setCheckedKeys(o, n, r);
    }
    setCheckedKeys(t, n = !1) {
      this.defaultCheckedKeys = t;
      const o = this.key, r = {};
      t.forEach((s) => {
        r[s] = !0;
      }), this._setCheckedKeys(o, n, r);
    }
    setDefaultExpandedKeys(t) {
      t = t || [], this.defaultExpandedKeys = t, t.forEach((n) => {
        const o = this.getNode(n);
        o && o.expand(null, this.autoExpandParent);
      });
    }
    setChecked(t, n, o) {
      const r = this.getNode(t);
      r && r.setChecked(!!n, o);
    }
    getCurrentNode() {
      return this.currentNode;
    }
    setCurrentNode(t) {
      const n = this.currentNode;
      n && (n.isCurrent = !1), this.currentNode = t, this.currentNode.isCurrent = !0;
    }
    setUserCurrentNode(t, n = !0) {
      const o = t[this.key], r = this.nodesMap[o];
      this.setCurrentNode(r), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0);
    }
    setCurrentNodeKey(t, n = !0) {
      if (t == null) {
        this.currentNode && (this.currentNode.isCurrent = !1), this.currentNode = null;
        return;
      }
      const o = this.getNode(t);
      o && (this.setCurrentNode(o), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0));
    }
  }
  const YZ = G({
    name: "ElTreeNodeContent",
    props: {
      node: {
        type: Object,
        required: !0
      },
      renderContent: Function
    },
    setup(e) {
      const t = ge("tree"), n = Be("NodeInstance"), o = Be("RootTree");
      return () => {
        const r = e.node, { data: s, store: l } = r;
        return e.renderContent ? e.renderContent(je, { _self: n, node: r, data: s, store: l }) : o.ctx.slots.default ? o.ctx.slots.default({ node: r, data: s }) : je("span", { class: t.be("node", "label") }, [r.label]);
      };
    }
  });
  var GZ = /* @__PURE__ */ Me(YZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node-content.vue"]]);
  function xS(e) {
    const t = Be("TreeNodeMap", null), n = {
      treeNodeExpand: (o) => {
        e.node !== o && e.node.collapse();
      },
      children: []
    };
    return t && t.children.push(n), pt("TreeNodeMap", n), {
      broadcastExpanded: (o) => {
        if (!!e.accordion)
          for (const r of n.children)
            r.treeNodeExpand(o);
      }
    };
  }
  const DS = Symbol("dragEvents");
  function XZ({ props: e, ctx: t, el$: n, dropIndicator$: o, store: r }) {
    const s = ge("tree"), l = I({
      showDropIndicator: !1,
      draggingNode: null,
      dropNode: null,
      allowDrop: !0,
      dropType: null
    });
    return pt(DS, {
      treeNodeDragStart: ({ event: f, treeNode: d }) => {
        if (typeof e.allowDrag == "function" && !e.allowDrag(d.node))
          return f.preventDefault(), !1;
        f.dataTransfer.effectAllowed = "move";
        try {
          f.dataTransfer.setData("text/plain", "");
        } catch {
        }
        l.value.draggingNode = d, t.emit("node-drag-start", d.node, f);
      },
      treeNodeDragOver: ({ event: f, treeNode: d }) => {
        const p = d, h = l.value.dropNode;
        h && h !== p && Dn(h.$el, s.is("drop-inner"));
        const m = l.value.draggingNode;
        if (!m || !p)
          return;
        let v = !0, g = !0, y = !0, w = !0;
        typeof e.allowDrop == "function" && (v = e.allowDrop(m.node, p.node, "prev"), w = g = e.allowDrop(m.node, p.node, "inner"), y = e.allowDrop(m.node, p.node, "next")), f.dataTransfer.dropEffect = g || v || y ? "move" : "none", (v || g || y) && h !== p && (h && t.emit("node-drag-leave", m.node, h.node, f), t.emit("node-drag-enter", m.node, p.node, f)), (v || g || y) && (l.value.dropNode = p), p.node.nextSibling === m.node && (y = !1), p.node.previousSibling === m.node && (v = !1), p.node.contains(m.node, !1) && (g = !1), (m.node === p.node || m.node.contains(p.node)) && (v = !1, g = !1, y = !1);
        const b = p.$el.getBoundingClientRect(), C = n.value.getBoundingClientRect();
        let _;
        const k = v ? g ? 0.25 : y ? 0.45 : 1 : -1, O = y ? g ? 0.75 : v ? 0.55 : 0 : 1;
        let T = -9999;
        const P = f.clientY - b.top;
        P < b.height * k ? _ = "before" : P > b.height * O ? _ = "after" : g ? _ = "inner" : _ = "none";
        const A = p.$el.querySelector(`.${s.be("node", "expand-icon")}`).getBoundingClientRect(), L = o.value;
        _ === "before" ? T = A.top - C.top : _ === "after" && (T = A.bottom - C.top), L.style.top = `${T}px`, L.style.left = `${A.right - C.left}px`, _ === "inner" ? Ao(p.$el, s.is("drop-inner")) : Dn(p.$el, s.is("drop-inner")), l.value.showDropIndicator = _ === "before" || _ === "after", l.value.allowDrop = l.value.showDropIndicator || w, l.value.dropType = _, t.emit("node-drag-over", m.node, p.node, f);
      },
      treeNodeDragEnd: (f) => {
        const { draggingNode: d, dropType: p, dropNode: h } = l.value;
        if (f.preventDefault(), f.dataTransfer.dropEffect = "move", d && h) {
          const m = { data: d.node.data };
          p !== "none" && d.node.remove(), p === "before" ? h.node.parent.insertBefore(m, h.node) : p === "after" ? h.node.parent.insertAfter(m, h.node) : p === "inner" && h.node.insertChild(m), p !== "none" && r.value.registerNode(m), Dn(h.$el, s.is("drop-inner")), t.emit("node-drag-end", d.node, h.node, p, f), p !== "none" && t.emit("node-drop", d.node, h.node, p, f);
        }
        d && !h && t.emit("node-drag-end", d.node, null, p, f), l.value.showDropIndicator = !1, l.value.draggingNode = null, l.value.dropNode = null, l.value.allowDrop = !0;
      }
    }), {
      dragState: l
    };
  }
  const JZ = G({
    name: "ElTreeNode",
    components: {
      ElCollapseTransition: ed,
      ElCheckbox: co,
      NodeContent: GZ,
      ElIcon: He,
      Loading: Gr
    },
    props: {
      node: {
        type: $s,
        default: () => ({})
      },
      props: {
        type: Object,
        default: () => ({})
      },
      accordion: Boolean,
      renderContent: Function,
      renderAfterExpand: Boolean,
      showCheckbox: {
        type: Boolean,
        default: !1
      }
    },
    emits: ["node-expand"],
    setup(e, t) {
      const n = ge("tree"), { broadcastExpanded: o } = xS(e), r = Be("RootTree"), s = I(!1), l = I(!1), a = I(null), u = I(null), c = I(null), f = Be(DS), d = it();
      pt("NodeInstance", d), r || yt("Tree", "Can not find node's tree."), e.node.expanded && (s.value = !0, l.value = !0);
      const p = r.props.children || "children";
      me(() => {
        const P = e.node.data[p];
        return P && [...P];
      }, () => {
        e.node.updateChildren();
      }), me(() => e.node.indeterminate, (P) => {
        v(e.node.checked, P);
      }), me(() => e.node.checked, (P) => {
        v(P, e.node.indeterminate);
      }), me(() => e.node.expanded, (P) => {
        Fe(() => s.value = P), P && (l.value = !0);
      });
      const h = (P) => Sv(r.props.nodeKey, P.data), m = (P) => {
        const A = e.props.class;
        if (!A)
          return {};
        let L;
        if (Ge(A)) {
          const { data: D } = P;
          L = A(D, P);
        } else
          L = A;
        return et(L) ? { [L]: !0 } : L;
      }, v = (P, A) => {
        (a.value !== P || u.value !== A) && r.ctx.emit("check-change", e.node.data, P, A), a.value = P, u.value = A;
      }, g = (P) => {
        gp(r.store, r.ctx.emit, () => r.store.value.setCurrentNode(e.node)), r.currentNode.value = e.node, r.props.expandOnClickNode && w(), r.props.checkOnClickNode && !e.node.disabled && b(null, {
          target: { checked: !e.node.checked }
        }), r.ctx.emit("node-click", e.node.data, e.node, d, P);
      }, y = (P) => {
        r.instance.vnode.props.onNodeContextmenu && (P.stopPropagation(), P.preventDefault()), r.ctx.emit("node-contextmenu", P, e.node.data, e.node, d);
      }, w = () => {
        e.node.isLeaf || (s.value ? (r.ctx.emit("node-collapse", e.node.data, e.node, d), e.node.collapse()) : (e.node.expand(), t.emit("node-expand", e.node.data, e.node, d)));
      }, b = (P, A) => {
        e.node.setChecked(A.target.checked, !r.props.checkStrictly), Fe(() => {
          const L = r.store.value;
          r.ctx.emit("check", e.node.data, {
            checkedNodes: L.getCheckedNodes(),
            checkedKeys: L.getCheckedKeys(),
            halfCheckedNodes: L.getHalfCheckedNodes(),
            halfCheckedKeys: L.getHalfCheckedKeys()
          });
        });
      };
      return {
        ns: n,
        node$: c,
        tree: r,
        expanded: s,
        childNodeRendered: l,
        oldChecked: a,
        oldIndeterminate: u,
        getNodeKey: h,
        getNodeClass: m,
        handleSelectChange: v,
        handleClick: g,
        handleContextMenu: y,
        handleExpandIconClick: w,
        handleCheckChange: b,
        handleChildNodeExpand: (P, A, L) => {
          o(A), r.ctx.emit("node-expand", P, A, L);
        },
        handleDragStart: (P) => {
          !r.props.draggable || f.treeNodeDragStart({ event: P, treeNode: e });
        },
        handleDragOver: (P) => {
          P.preventDefault(), r.props.draggable && f.treeNodeDragOver({
            event: P,
            treeNode: { $el: c.value, node: e.node }
          });
        },
        handleDrop: (P) => {
          P.preventDefault();
        },
        handleDragEnd: (P) => {
          !r.props.draggable || f.treeNodeDragEnd(P);
        },
        CaretRight: X1
      };
    }
  }), ZZ = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"], QZ = ["aria-expanded"];
  function eQ(e, t, n, o, r, s) {
    const l = Qe("el-icon"), a = Qe("el-checkbox"), u = Qe("loading"), c = Qe("node-content"), f = Qe("el-tree-node"), d = Qe("el-collapse-transition");
    return ot((S(), V("div", {
      ref: "node$",
      class: $([
        e.ns.b("node"),
        e.ns.is("expanded", e.expanded),
        e.ns.is("current", e.node.isCurrent),
        e.ns.is("hidden", !e.node.visible),
        e.ns.is("focusable", !e.node.disabled),
        e.ns.is("checked", !e.node.disabled && e.node.checked),
        e.getNodeClass(e.node)
      ]),
      role: "treeitem",
      tabindex: "-1",
      "aria-expanded": e.expanded,
      "aria-disabled": e.node.disabled,
      "aria-checked": e.node.checked,
      draggable: e.tree.props.draggable,
      "data-key": e.getNodeKey(e.node),
      onClick: t[1] || (t[1] = Ze((...p) => e.handleClick && e.handleClick(...p), ["stop"])),
      onContextmenu: t[2] || (t[2] = (...p) => e.handleContextMenu && e.handleContextMenu(...p)),
      onDragstart: t[3] || (t[3] = Ze((...p) => e.handleDragStart && e.handleDragStart(...p), ["stop"])),
      onDragover: t[4] || (t[4] = Ze((...p) => e.handleDragOver && e.handleDragOver(...p), ["stop"])),
      onDragend: t[5] || (t[5] = Ze((...p) => e.handleDragEnd && e.handleDragEnd(...p), ["stop"])),
      onDrop: t[6] || (t[6] = Ze((...p) => e.handleDrop && e.handleDrop(...p), ["stop"]))
    }, [
      H("div", {
        class: $(e.ns.be("node", "content")),
        style: Ke({ paddingLeft: (e.node.level - 1) * e.tree.props.indent + "px" })
      }, [
        e.tree.props.icon || e.CaretRight ? (S(), ie(l, {
          key: 0,
          class: $([
            e.ns.be("node", "expand-icon"),
            e.ns.is("leaf", e.node.isLeaf),
            {
              expanded: !e.node.isLeaf && e.expanded
            }
          ]),
          onClick: Ze(e.handleExpandIconClick, ["stop"])
        }, {
          default: X(() => [
            (S(), ie(vt(e.tree.props.icon || e.CaretRight)))
          ]),
          _: 1
        }, 8, ["class", "onClick"])) : se("v-if", !0),
        e.showCheckbox ? (S(), ie(a, {
          key: 1,
          "model-value": e.node.checked,
          indeterminate: e.node.indeterminate,
          disabled: !!e.node.disabled,
          onClick: t[0] || (t[0] = Ze(() => {
          }, ["stop"])),
          onChange: e.handleCheckChange
        }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : se("v-if", !0),
        e.node.loading ? (S(), ie(l, {
          key: 2,
          class: $([e.ns.be("node", "loading-icon"), e.ns.is("loading")])
        }, {
          default: X(() => [
            K(u)
          ]),
          _: 1
        }, 8, ["class"])) : se("v-if", !0),
        K(c, {
          node: e.node,
          "render-content": e.renderContent
        }, null, 8, ["node", "render-content"])
      ], 6),
      K(d, null, {
        default: X(() => [
          !e.renderAfterExpand || e.childNodeRendered ? ot((S(), V("div", {
            key: 0,
            class: $(e.ns.be("node", "children")),
            role: "group",
            "aria-expanded": e.expanded
          }, [
            (S(!0), V(ze, null, gt(e.node.childNodes, (p) => (S(), ie(f, {
              key: e.getNodeKey(p),
              "render-content": e.renderContent,
              "render-after-expand": e.renderAfterExpand,
              "show-checkbox": e.showCheckbox,
              node: p,
              accordion: e.accordion,
              props: e.props,
              onNodeExpand: e.handleChildNodeExpand
            }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]))), 128))
          ], 10, QZ)), [
            [$t, e.expanded]
          ]) : se("v-if", !0)
        ]),
        _: 1
      })
    ], 42, ZZ)), [
      [$t, e.node.visible]
    ]);
  }
  var tQ = /* @__PURE__ */ Me(JZ, [["render", eQ], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]]);
  function nQ({ el$: e }, t) {
    const n = ge("tree"), o = xt([]), r = xt([]);
    st(() => {
      l();
    }), cr(() => {
      o.value = Array.from(e.value.querySelectorAll("[role=treeitem]")), r.value = Array.from(e.value.querySelectorAll("input[type=checkbox]"));
    }), me(r, (a) => {
      a.forEach((u) => {
        u.setAttribute("tabindex", "-1");
      });
    }), Wt(e, "keydown", (a) => {
      const u = a.target;
      if (!u.className.includes(n.b("node")))
        return;
      const c = a.code;
      o.value = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`));
      const f = o.value.indexOf(u);
      let d;
      if ([We.up, We.down].includes(c)) {
        if (a.preventDefault(), c === We.up) {
          d = f === -1 ? 0 : f !== 0 ? f - 1 : o.value.length - 1;
          const h = d;
          for (; !t.value.getNode(o.value[d].dataset.key).canFocus; ) {
            if (d--, d === h) {
              d = -1;
              break;
            }
            d < 0 && (d = o.value.length - 1);
          }
        } else {
          d = f === -1 ? 0 : f < o.value.length - 1 ? f + 1 : 0;
          const h = d;
          for (; !t.value.getNode(o.value[d].dataset.key).canFocus; ) {
            if (d++, d === h) {
              d = -1;
              break;
            }
            d >= o.value.length && (d = 0);
          }
        }
        d !== -1 && o.value[d].focus();
      }
      [We.left, We.right].includes(c) && (a.preventDefault(), u.click());
      const p = u.querySelector('[type="checkbox"]');
      [We.enter, We.space].includes(c) && p && (a.preventDefault(), p.click());
    });
    const l = () => {
      var a;
      o.value = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)), r.value = Array.from(e.value.querySelectorAll("input[type=checkbox]"));
      const u = e.value.querySelectorAll(`.${n.is("checked")}[role=treeitem]`);
      if (u.length) {
        u[0].setAttribute("tabindex", "0");
        return;
      }
      (a = o.value[0]) == null || a.setAttribute("tabindex", "0");
    };
  }
  const oQ = G({
    name: "ElTree",
    components: { ElTreeNode: tQ },
    props: {
      data: {
        type: Array,
        default: () => []
      },
      emptyText: {
        type: String
      },
      renderAfterExpand: {
        type: Boolean,
        default: !0
      },
      nodeKey: String,
      checkStrictly: Boolean,
      defaultExpandAll: Boolean,
      expandOnClickNode: {
        type: Boolean,
        default: !0
      },
      checkOnClickNode: Boolean,
      checkDescendants: {
        type: Boolean,
        default: !1
      },
      autoExpandParent: {
        type: Boolean,
        default: !0
      },
      defaultCheckedKeys: Array,
      defaultExpandedKeys: Array,
      currentNodeKey: [String, Number],
      renderContent: Function,
      showCheckbox: {
        type: Boolean,
        default: !1
      },
      draggable: {
        type: Boolean,
        default: !1
      },
      allowDrag: Function,
      allowDrop: Function,
      props: {
        type: Object,
        default: () => ({
          children: "children",
          label: "label",
          disabled: "disabled"
        })
      },
      lazy: {
        type: Boolean,
        default: !1
      },
      highlightCurrent: Boolean,
      load: Function,
      filterNodeMethod: Function,
      accordion: Boolean,
      indent: {
        type: Number,
        default: 18
      },
      icon: {
        type: Vt
      }
    },
    emits: [
      "check-change",
      "current-change",
      "node-click",
      "node-contextmenu",
      "node-collapse",
      "node-expand",
      "check",
      "node-drag-start",
      "node-drag-end",
      "node-drop",
      "node-drag-leave",
      "node-drag-enter",
      "node-drag-over"
    ],
    setup(e, t) {
      const { t: n } = St(), o = ge("tree"), r = I(new qZ({
        key: e.nodeKey,
        data: e.data,
        lazy: e.lazy,
        props: e.props,
        load: e.load,
        currentNodeKey: e.currentNodeKey,
        checkStrictly: e.checkStrictly,
        checkDescendants: e.checkDescendants,
        defaultCheckedKeys: e.defaultCheckedKeys,
        defaultExpandedKeys: e.defaultExpandedKeys,
        autoExpandParent: e.autoExpandParent,
        defaultExpandAll: e.defaultExpandAll,
        filterNodeMethod: e.filterNodeMethod
      }));
      r.value.initialize();
      const s = I(r.value.root), l = I(null), a = I(null), u = I(null), { broadcastExpanded: c } = xS(e), { dragState: f } = XZ({
        props: e,
        ctx: t,
        el$: a,
        dropIndicator$: u,
        store: r
      });
      nQ({ el$: a }, r);
      const d = E(() => {
        const { childNodes: N } = s.value;
        return !N || N.length === 0 || N.every(({ visible: R }) => !R);
      });
      me(() => e.currentNodeKey, (N) => {
        r.value.setCurrentNodeKey(N);
      }), me(() => e.defaultCheckedKeys, (N) => {
        r.value.setDefaultCheckedKey(N);
      }), me(() => e.defaultExpandedKeys, (N) => {
        r.value.setDefaultExpandedKeys(N);
      }), me(() => e.data, (N) => {
        r.value.setData(N);
      }, { deep: !0 }), me(() => e.checkStrictly, (N) => {
        r.value.checkStrictly = N;
      });
      const p = (N) => {
        if (!e.filterNodeMethod)
          throw new Error("[Tree] filterNodeMethod is required when filter");
        r.value.filter(N);
      }, h = (N) => Sv(e.nodeKey, N.data), m = (N) => {
        if (!e.nodeKey)
          throw new Error("[Tree] nodeKey is required in getNodePath");
        const R = r.value.getNode(N);
        if (!R)
          return [];
        const M = [R.data];
        let j = R.parent;
        for (; j && j !== s.value; )
          M.push(j.data), j = j.parent;
        return M.reverse();
      }, v = (N, R) => r.value.getCheckedNodes(N, R), g = (N) => r.value.getCheckedKeys(N), y = () => {
        const N = r.value.getCurrentNode();
        return N ? N.data : null;
      }, w = () => {
        if (!e.nodeKey)
          throw new Error("[Tree] nodeKey is required in getCurrentKey");
        const N = y();
        return N ? N[e.nodeKey] : null;
      }, b = (N, R) => {
        if (!e.nodeKey)
          throw new Error("[Tree] nodeKey is required in setCheckedNodes");
        r.value.setCheckedNodes(N, R);
      }, C = (N, R) => {
        if (!e.nodeKey)
          throw new Error("[Tree] nodeKey is required in setCheckedKeys");
        r.value.setCheckedKeys(N, R);
      }, _ = (N, R, M) => {
        r.value.setChecked(N, R, M);
      }, k = () => r.value.getHalfCheckedNodes(), O = () => r.value.getHalfCheckedKeys(), T = (N, R = !0) => {
        if (!e.nodeKey)
          throw new Error("[Tree] nodeKey is required in setCurrentNode");
        gp(r, t.emit, () => r.value.setUserCurrentNode(N, R));
      }, P = (N, R = !0) => {
        if (!e.nodeKey)
          throw new Error("[Tree] nodeKey is required in setCurrentKey");
        gp(r, t.emit, () => r.value.setCurrentNodeKey(N, R));
      }, A = (N) => r.value.getNode(N), L = (N) => {
        r.value.remove(N);
      }, D = (N, R) => {
        r.value.append(N, R);
      }, B = (N, R) => {
        r.value.insertBefore(N, R);
      }, F = (N, R) => {
        r.value.insertAfter(N, R);
      }, W = (N, R, M) => {
        c(R), t.emit("node-expand", N, R, M);
      }, x = (N, R) => {
        if (!e.nodeKey)
          throw new Error("[Tree] nodeKey is required in updateKeyChild");
        r.value.updateChildren(N, R);
      };
      return pt("RootTree", {
        ctx: t,
        props: e,
        store: r,
        root: s,
        currentNode: l,
        instance: it()
      }), pt(Ho, void 0), {
        ns: o,
        store: r,
        root: s,
        currentNode: l,
        dragState: f,
        el$: a,
        dropIndicator$: u,
        isEmpty: d,
        filter: p,
        getNodeKey: h,
        getNodePath: m,
        getCheckedNodes: v,
        getCheckedKeys: g,
        getCurrentNode: y,
        getCurrentKey: w,
        setCheckedNodes: b,
        setCheckedKeys: C,
        setChecked: _,
        getHalfCheckedNodes: k,
        getHalfCheckedKeys: O,
        setCurrentNode: T,
        setCurrentKey: P,
        t: n,
        getNode: A,
        remove: L,
        append: D,
        insertBefore: B,
        insertAfter: F,
        handleNodeExpand: W,
        updateKeyChildren: x
      };
    }
  });
  function rQ(e, t, n, o, r, s) {
    var l;
    const a = Qe("el-tree-node");
    return S(), V("div", {
      ref: "el$",
      class: $([
        e.ns.b(),
        e.ns.is("dragging", !!e.dragState.draggingNode),
        e.ns.is("drop-not-allow", !e.dragState.allowDrop),
        e.ns.is("drop-inner", e.dragState.dropType === "inner"),
        { [e.ns.m("highlight-current")]: e.highlightCurrent }
      ]),
      role: "tree"
    }, [
      (S(!0), V(ze, null, gt(e.root.childNodes, (u) => (S(), ie(a, {
        key: e.getNodeKey(u),
        node: u,
        props: e.props,
        accordion: e.accordion,
        "render-after-expand": e.renderAfterExpand,
        "show-checkbox": e.showCheckbox,
        "render-content": e.renderContent,
        onNodeExpand: e.handleNodeExpand
      }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]))), 128)),
      e.isEmpty ? (S(), V("div", {
        key: 0,
        class: $(e.ns.e("empty-block"))
      }, [
        H("span", {
          class: $(e.ns.e("empty-text"))
        }, Ne((l = e.emptyText) != null ? l : e.t("el.tree.emptyText")), 3)
      ], 2)) : se("v-if", !0),
      ot(H("div", {
        ref: "dropIndicator$",
        class: $(e.ns.e("drop-indicator"))
      }, null, 2), [
        [$t, e.dragState.showDropIndicator]
      ])
    ], 2);
  }
  var Ou = /* @__PURE__ */ Me(oQ, [["render", rQ], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]]);
  Ou.install = (e) => {
    e.component(Ou.name, Ou);
  };
  const dc = Ou, sQ = dc, lQ = (e, { attrs: t }, {
    tree: n,
    key: o
  }) => {
    const r = ge("tree-select"), s = {
      ...tr(rn(e), Object.keys(Ps.props)),
      ...t,
      valueKey: o,
      popperClass: E(() => {
        const l = [r.e("popper")];
        return e.popperClass && l.push(e.popperClass), l.join(" ");
      }),
      filterMethod: (l = "") => {
        e.filterMethod && e.filterMethod(l), Fe(() => {
          var a;
          (a = n.value) == null || a.filter(l);
        });
      },
      onVisibleChange: (l) => {
        var a;
        (a = t.onVisibleChange) == null || a.call(t, l), e.filterable && l && s.filterMethod();
      }
    };
    return s;
  }, aQ = G({
    extends: oc,
    setup(e, t) {
      const n = oc.setup(e, t);
      delete n.selectOptionClick;
      const o = it().proxy;
      return Fe(() => {
        n.select.cachedOptions.get(o.value) || n.select.onOptionCreate(o);
      }), n;
    },
    methods: {
      selectOptionClick() {
        this.$el.parentElement.click();
      }
    }
  });
  function bp(e) {
    return e || e === 0;
  }
  function _v(e) {
    return Array.isArray(e) && e.length;
  }
  function Ud(e) {
    return Array.isArray(e) ? e : bp(e) ? [e] : [];
  }
  function Mu(e, t, n, o, r) {
    for (let s = 0; s < e.length; s++) {
      const l = e[s];
      if (t(l, s, e, r))
        return o ? o(l, s, e, r) : l;
      {
        const a = n(l);
        if (_v(a)) {
          const u = Mu(a, t, n, o, l);
          if (u)
            return u;
        }
      }
    }
  }
  function LS(e, t, n, o) {
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      t(s, r, e, o);
      const l = n(s);
      _v(l) && LS(l, t, n, s);
    }
  }
  const iQ = (e, { attrs: t, slots: n, emit: o }, {
    select: r,
    tree: s,
    key: l
  }) => {
    me(() => e.modelValue, () => {
      e.showCheckbox && Fe(() => {
        const d = s.value;
        d && !qn(d.getCheckedKeys(), Ud(e.modelValue)) && d.setCheckedKeys(Ud(e.modelValue));
      });
    }, {
      immediate: !0,
      deep: !0
    });
    const a = E(() => ({
      value: l.value,
      label: "label",
      children: "children",
      disabled: "disabled",
      isLeaf: "isLeaf",
      ...e.props
    })), u = (d, p) => {
      var h;
      const m = a.value[d];
      return Ge(m) ? m(p, (h = s.value) == null ? void 0 : h.getNode(u("value", p))) : p[m];
    }, c = Ud(e.modelValue).map((d) => Mu(e.data || [], (p) => u("value", p) === d, (p) => u("children", p), (p, h, m, v) => v && u("value", v))).filter((d) => bp(d)), f = E(() => {
      if (!e.renderAfterExpand && !e.lazy)
        return [];
      const d = [];
      return LS(e.data.concat(e.cacheData), (p) => {
        const h = u("value", p);
        d.push({
          value: h,
          currentLabel: u("label", p),
          isDisabled: u("disabled", p)
        });
      }, (p) => u("children", p)), d;
    });
    return {
      ...tr(rn(e), Object.keys(dc.props)),
      ...t,
      nodeKey: l,
      expandOnClickNode: E(() => !e.checkStrictly && e.expandOnClickNode),
      defaultExpandedKeys: E(() => e.defaultExpandedKeys ? e.defaultExpandedKeys.concat(c) : c),
      renderContent: (d, { node: p, data: h, store: m }) => d(aQ, {
        value: u("value", h),
        label: u("label", h),
        disabled: u("disabled", h)
      }, e.renderContent ? () => e.renderContent(d, { node: p, data: h, store: m }) : n.default ? () => n.default({ node: p, data: h, store: m }) : void 0),
      filterNodeMethod: (d, p, h) => {
        var m;
        return e.filterNodeMethod ? e.filterNodeMethod(d, p, h) : d ? (m = u("label", p)) == null ? void 0 : m.includes(d) : !0;
      },
      onNodeClick: (d, p, h) => {
        var m, v, g;
        if ((m = t.onNodeClick) == null || m.call(t, d, p, h), !(e.showCheckbox && e.checkOnClickNode))
          if (!e.showCheckbox && (e.checkStrictly || p.isLeaf)) {
            if (!u("disabled", d)) {
              const y = (v = r.value) == null ? void 0 : v.options.get(u("value", d));
              (g = r.value) == null || g.handleOptionSelect(y, !0);
            }
          } else
            e.expandOnClickNode && h.proxy.handleExpandIconClick();
      },
      onCheck: (d, p) => {
        var h;
        (h = t.onCheck) == null || h.call(t, d, p);
        const m = u("value", d);
        if (e.checkStrictly)
          o(dt, e.multiple ? p.checkedKeys : p.checkedKeys.includes(m) ? m : void 0);
        else if (e.multiple)
          o(dt, s.value.getCheckedKeys(!0));
        else {
          const v = Mu([d], (w) => !_v(u("children", w)) && !u("disabled", w), (w) => u("children", w)), g = v ? u("value", v) : void 0, y = bp(e.modelValue) && !!Mu([d], (w) => u("value", w) === e.modelValue, (w) => u("children", w));
          o(dt, g === e.modelValue || y ? void 0 : g);
        }
      },
      cacheOptions: f
    };
  };
  var uQ = G({
    props: {
      data: {
        type: Array,
        default: () => []
      }
    },
    setup(e) {
      const t = Be(ki);
      return me(() => e.data, () => {
        var n;
        e.data.forEach((r) => {
          t.cachedOptions.has(r.value) || t.cachedOptions.set(r.value, r);
        });
        const o = ((n = t.selectWrapper) == null ? void 0 : n.querySelectorAll("input")) || [];
        Array.from(o).includes(document.activeElement) || t.setSelected();
      }, { flush: "post", immediate: !0 }), () => {
      };
    }
  });
  const cQ = G({
    name: "ElTreeSelect",
    inheritAttrs: !1,
    props: {
      ...Ps.props,
      ...dc.props,
      cacheData: {
        type: Array,
        default: () => []
      }
    },
    setup(e, t) {
      const { slots: n, expose: o } = t, r = I(), s = I(), l = E(() => e.nodeKey || e.valueKey || "value"), a = lQ(e, t, { select: r, tree: s, key: l }), { cacheOptions: u, ...c } = iQ(e, t, {
        select: r,
        tree: s,
        key: l
      }), f = Tt({});
      return o(f), st(() => {
        Object.assign(f, {
          ...tr(s.value, [
            "filter",
            "updateKeyChildren",
            "getCheckedNodes",
            "setCheckedNodes",
            "getCheckedKeys",
            "setCheckedKeys",
            "setChecked",
            "getHalfCheckedNodes",
            "getHalfCheckedKeys",
            "getCurrentKey",
            "getCurrentNode",
            "setCurrentKey",
            "setCurrentNode",
            "getNode",
            "remove",
            "append",
            "insertBefore",
            "insertAfter"
          ]),
          ...tr(r.value, ["focus", "blur"])
        });
      }), () => je(Ps, Tt({
        ...a,
        ref: (d) => r.value = d
      }), {
        ...n,
        default: () => [
          je(uQ, { data: u.value }),
          je(dc, Tt({
            ...c,
            ref: (d) => s.value = d
          }))
        ]
      });
    }
  });
  var Iu = /* @__PURE__ */ Me(cQ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-select/src/tree-select.vue"]]);
  Iu.install = (e) => {
    e.component(Iu.name, Iu);
  };
  const dQ = Iu, fQ = dQ, kv = Symbol(), pQ = {
    key: -1,
    level: -1,
    data: {}
  };
  var ua = /* @__PURE__ */ ((e) => (e.KEY = "id", e.LABEL = "label", e.CHILDREN = "children", e.DISABLED = "disabled", e))(ua || {}), wp = /* @__PURE__ */ ((e) => (e.ADD = "add", e.DELETE = "delete", e))(wp || {});
  const VS = {
    type: Number,
    default: 26
  }, hQ = Ie({
    data: {
      type: le(Array),
      default: () => jt([])
    },
    emptyText: {
      type: String
    },
    height: {
      type: Number,
      default: 200
    },
    props: {
      type: le(Object),
      default: () => jt({
        children: "children",
        label: "label",
        disabled: "disabled",
        value: "id"
      })
    },
    highlightCurrent: {
      type: Boolean,
      default: !1
    },
    showCheckbox: {
      type: Boolean,
      default: !1
    },
    defaultCheckedKeys: {
      type: le(Array),
      default: () => jt([])
    },
    checkStrictly: {
      type: Boolean,
      default: !1
    },
    defaultExpandedKeys: {
      type: le(Array),
      default: () => jt([])
    },
    indent: {
      type: Number,
      default: 16
    },
    itemSize: VS,
    icon: {
      type: Vt
    },
    expandOnClickNode: {
      type: Boolean,
      default: !0
    },
    checkOnClickNode: {
      type: Boolean,
      default: !1
    },
    currentNodeKey: {
      type: le([String, Number])
    },
    accordion: {
      type: Boolean,
      default: !1
    },
    filterMethod: {
      type: le(Function)
    },
    perfMode: {
      type: Boolean,
      default: !0
    }
  }), vQ = Ie({
    node: {
      type: le(Object),
      default: () => jt(pQ)
    },
    expanded: {
      type: Boolean,
      default: !1
    },
    checked: {
      type: Boolean,
      default: !1
    },
    indeterminate: {
      type: Boolean,
      default: !1
    },
    showCheckbox: {
      type: Boolean,
      default: !1
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    current: {
      type: Boolean,
      default: !1
    },
    hiddenExpandIcon: {
      type: Boolean,
      default: !1
    },
    itemSize: VS
  }), mQ = Ie({
    node: {
      type: le(Object),
      required: !0
    }
  }), BS = "node-click", FS = "node-expand", HS = "node-collapse", zS = "current-change", KS = "check", jS = "check-change", WS = "node-contextmenu", gQ = {
    [BS]: (e, t, n) => e && t && n,
    [FS]: (e, t) => e && t,
    [HS]: (e, t) => e && t,
    [zS]: (e, t) => e && t,
    [KS]: (e, t) => e && t,
    [jS]: (e, t) => e && typeof t == "boolean",
    [WS]: (e, t, n) => e && t && n
  }, yQ = {
    click: (e, t) => !!(e && t),
    toggle: (e) => !!e,
    check: (e, t) => e && typeof t == "boolean"
  };
  function bQ(e, t) {
    const n = I(/* @__PURE__ */ new Set()), o = I(/* @__PURE__ */ new Set()), { emit: r } = it();
    me([() => t.value, () => e.defaultCheckedKeys], () => Fe(() => {
      w(e.defaultCheckedKeys);
    }), {
      immediate: !0
    });
    const s = () => {
      if (!t.value || !e.showCheckbox || e.checkStrictly)
        return;
      const { levelTreeNodeMap: b, maxLevel: C } = t.value, _ = n.value, k = /* @__PURE__ */ new Set();
      for (let O = C - 1; O >= 1; --O) {
        const T = b.get(O);
        !T || T.forEach((P) => {
          const A = P.children;
          if (A) {
            let L = !0, D = !1;
            for (const B of A) {
              const F = B.key;
              if (_.has(F))
                D = !0;
              else if (k.has(F)) {
                L = !1, D = !0;
                break;
              } else
                L = !1;
            }
            L ? _.add(P.key) : D ? (k.add(P.key), _.delete(P.key)) : (_.delete(P.key), k.delete(P.key));
          }
        });
      }
      o.value = k;
    }, l = (b) => n.value.has(b.key), a = (b) => o.value.has(b.key), u = (b, C, _ = !0) => {
      const k = n.value, O = (T, P) => {
        k[P ? wp.ADD : wp.DELETE](T.key);
        const A = T.children;
        !e.checkStrictly && A && A.forEach((L) => {
          L.disabled || O(L, P);
        });
      };
      O(b, C), s(), _ && c(b, C);
    }, c = (b, C) => {
      const { checkedNodes: _, checkedKeys: k } = m(), { halfCheckedNodes: O, halfCheckedKeys: T } = v();
      r(KS, b.data, {
        checkedKeys: k,
        checkedNodes: _,
        halfCheckedKeys: T,
        halfCheckedNodes: O
      }), r(jS, b.data, C);
    };
    function f(b = !1) {
      return m(b).checkedKeys;
    }
    function d(b = !1) {
      return m(b).checkedNodes;
    }
    function p() {
      return v().halfCheckedKeys;
    }
    function h() {
      return v().halfCheckedNodes;
    }
    function m(b = !1) {
      const C = [], _ = [];
      if ((t == null ? void 0 : t.value) && e.showCheckbox) {
        const { treeNodeMap: k } = t.value;
        n.value.forEach((O) => {
          const T = k.get(O);
          T && (!b || b && T.isLeaf) && (_.push(O), C.push(T.data));
        });
      }
      return {
        checkedKeys: _,
        checkedNodes: C
      };
    }
    function v() {
      const b = [], C = [];
      if ((t == null ? void 0 : t.value) && e.showCheckbox) {
        const { treeNodeMap: _ } = t.value;
        o.value.forEach((k) => {
          const O = _.get(k);
          O && (C.push(k), b.push(O.data));
        });
      }
      return {
        halfCheckedNodes: b,
        halfCheckedKeys: C
      };
    }
    function g(b) {
      n.value.clear(), o.value.clear(), w(b);
    }
    function y(b, C) {
      if ((t == null ? void 0 : t.value) && e.showCheckbox) {
        const _ = t.value.treeNodeMap.get(b);
        _ && u(_, C, !1);
      }
    }
    function w(b) {
      if (t != null && t.value) {
        const { treeNodeMap: C } = t.value;
        if (e.showCheckbox && C && b)
          for (const _ of b) {
            const k = C.get(_);
            k && !l(k) && u(k, !0, !1);
          }
      }
    }
    return {
      updateCheckedKeys: s,
      toggleCheckbox: u,
      isChecked: l,
      isIndeterminate: a,
      getCheckedKeys: f,
      getCheckedNodes: d,
      getHalfCheckedKeys: p,
      getHalfCheckedNodes: h,
      setChecked: y,
      setCheckedKeys: g
    };
  }
  function wQ(e, t) {
    const n = I(/* @__PURE__ */ new Set([])), o = I(/* @__PURE__ */ new Set([])), r = E(() => Ge(e.filterMethod));
    function s(a) {
      var u;
      if (!r.value)
        return;
      const c = /* @__PURE__ */ new Set(), f = o.value, d = n.value, p = [], h = ((u = t.value) == null ? void 0 : u.treeNodes) || [], m = e.filterMethod;
      d.clear();
      function v(g) {
        g.forEach((y) => {
          p.push(y), m != null && m(a, y.data) ? p.forEach((b) => {
            c.add(b.key);
          }) : y.isLeaf && d.add(y.key);
          const w = y.children;
          if (w && v(w), !y.isLeaf) {
            if (!c.has(y.key))
              d.add(y.key);
            else if (w) {
              let b = !0;
              for (const C of w)
                if (!d.has(C.key)) {
                  b = !1;
                  break;
                }
              b ? f.add(y.key) : f.delete(y.key);
            }
          }
          p.pop();
        });
      }
      return v(h), c;
    }
    function l(a) {
      return o.value.has(a.key);
    }
    return {
      hiddenExpandIconKeySet: o,
      hiddenNodeKeySet: n,
      doFilter: s,
      isForceHiddenExpandIcon: l
    };
  }
  function CQ(e, t) {
    const n = I(new Set(e.defaultExpandedKeys)), o = I(), r = xt();
    me(() => e.currentNodeKey, (Y) => {
      o.value = Y;
    }, {
      immediate: !0
    }), me(() => e.data, (Y) => {
      ee(Y);
    }, {
      immediate: !0
    });
    const {
      isIndeterminate: s,
      isChecked: l,
      toggleCheckbox: a,
      getCheckedKeys: u,
      getCheckedNodes: c,
      getHalfCheckedKeys: f,
      getHalfCheckedNodes: d,
      setChecked: p,
      setCheckedKeys: h
    } = bQ(e, r), { doFilter: m, hiddenNodeKeySet: v, isForceHiddenExpandIcon: g } = wQ(e, r), y = E(() => {
      var Y;
      return ((Y = e.props) == null ? void 0 : Y.value) || ua.KEY;
    }), w = E(() => {
      var Y;
      return ((Y = e.props) == null ? void 0 : Y.children) || ua.CHILDREN;
    }), b = E(() => {
      var Y;
      return ((Y = e.props) == null ? void 0 : Y.disabled) || ua.DISABLED;
    }), C = E(() => {
      var Y;
      return ((Y = e.props) == null ? void 0 : Y.label) || ua.LABEL;
    }), _ = E(() => {
      const Y = n.value, re = v.value, ce = [], Te = r.value && r.value.treeNodes || [];
      function Pe() {
        const z = [];
        for (let Q = Te.length - 1; Q >= 0; --Q)
          z.push(Te[Q]);
        for (; z.length; ) {
          const Q = z.pop();
          if (!!Q && (re.has(Q.key) || ce.push(Q), Y.has(Q.key))) {
            const de = Q.children;
            if (de) {
              const Oe = de.length;
              for (let ae = Oe - 1; ae >= 0; --ae)
                z.push(de[ae]);
            }
          }
        }
      }
      return Pe(), ce;
    }), k = E(() => _.value.length > 0);
    function O(Y) {
      const re = /* @__PURE__ */ new Map(), ce = /* @__PURE__ */ new Map();
      let Te = 1;
      function Pe(Q, de = 1, Oe = void 0) {
        var ae;
        const Ee = [];
        for (const we of Q) {
          const Se = A(we), _e = {
            level: de,
            key: Se,
            data: we
          };
          _e.label = D(we), _e.parent = Oe;
          const ke = P(we);
          _e.disabled = L(we), _e.isLeaf = !ke || ke.length === 0, ke && ke.length && (_e.children = Pe(ke, de + 1, _e)), Ee.push(_e), re.set(Se, _e), ce.has(de) || ce.set(de, []), (ae = ce.get(de)) == null || ae.push(_e);
        }
        return de > Te && (Te = de), Ee;
      }
      const z = Pe(Y);
      return {
        treeNodeMap: re,
        levelTreeNodeMap: ce,
        maxLevel: Te,
        treeNodes: z
      };
    }
    function T(Y) {
      const re = m(Y);
      re && (n.value = re);
    }
    function P(Y) {
      return Y[w.value];
    }
    function A(Y) {
      return Y ? Y[y.value] : "";
    }
    function L(Y) {
      return Y[b.value];
    }
    function D(Y) {
      return Y[C.value];
    }
    function B(Y) {
      n.value.has(Y.key) ? M(Y) : R(Y);
    }
    function F(Y) {
      n.value = new Set(Y);
    }
    function W(Y, re) {
      t(BS, Y.data, Y, re), x(Y), e.expandOnClickNode && B(Y), e.showCheckbox && e.checkOnClickNode && !Y.disabled && a(Y, !l(Y), !0);
    }
    function x(Y) {
      U(Y) || (o.value = Y.key, t(zS, Y.data, Y));
    }
    function N(Y, re) {
      a(Y, re);
    }
    function R(Y) {
      const re = n.value;
      if (r.value && e.accordion) {
        const { treeNodeMap: ce } = r.value;
        re.forEach((Te) => {
          const Pe = ce.get(Te);
          Y && Y.level === (Pe == null ? void 0 : Pe.level) && re.delete(Te);
        });
      }
      re.add(Y.key), t(FS, Y.data, Y);
    }
    function M(Y) {
      n.value.delete(Y.key), t(HS, Y.data, Y);
    }
    function j(Y) {
      return n.value.has(Y.key);
    }
    function te(Y) {
      return !!Y.disabled;
    }
    function U(Y) {
      const re = o.value;
      return !!re && re === Y.key;
    }
    function Z() {
      var Y, re;
      if (!!o.value)
        return (re = (Y = r.value) == null ? void 0 : Y.treeNodeMap.get(o.value)) == null ? void 0 : re.data;
    }
    function pe() {
      return o.value;
    }
    function J(Y) {
      o.value = Y;
    }
    function ee(Y) {
      Fe(() => r.value = O(Y));
    }
    function ne(Y) {
      var re;
      const ce = rt(Y) ? A(Y) : Y;
      return (re = r.value) == null ? void 0 : re.treeNodeMap.get(ce);
    }
    return {
      tree: r,
      flattenTree: _,
      isNotEmpty: k,
      getKey: A,
      getChildren: P,
      toggleExpand: B,
      toggleCheckbox: a,
      isExpanded: j,
      isChecked: l,
      isIndeterminate: s,
      isDisabled: te,
      isCurrent: U,
      isForceHiddenExpandIcon: g,
      handleNodeClick: W,
      handleNodeCheck: N,
      getCurrentNode: Z,
      getCurrentKey: pe,
      setCurrentKey: J,
      getCheckedKeys: u,
      getCheckedNodes: c,
      getHalfCheckedKeys: f,
      getHalfCheckedNodes: d,
      setChecked: p,
      setCheckedKeys: h,
      filter: T,
      setData: ee,
      getNode: ne,
      expandNode: R,
      collapseNode: M,
      setExpandedKeys: F
    };
  }
  var EQ = G({
    name: "ElTreeNodeContent",
    props: mQ,
    setup(e) {
      const t = Be(kv), n = ge("tree");
      return () => {
        const o = e.node, { data: r } = o;
        return t != null && t.ctx.slots.default ? t.ctx.slots.default({ node: o, data: r }) : je("span", { class: n.be("node", "label") }, [o == null ? void 0 : o.label]);
      };
    }
  });
  const SQ = ["aria-expanded", "aria-disabled", "aria-checked", "data-key", "onClick"], _Q = G({
    name: "ElTreeNode"
  }), kQ = /* @__PURE__ */ G({
    ..._Q,
    props: vQ,
    emits: yQ,
    setup(e, { emit: t }) {
      const n = e, o = Be(kv), r = ge("tree"), s = E(() => {
        var d;
        return (d = o == null ? void 0 : o.props.indent) != null ? d : 16;
      }), l = E(() => {
        var d;
        return (d = o == null ? void 0 : o.props.icon) != null ? d : X1;
      }), a = (d) => {
        t("click", n.node, d);
      }, u = () => {
        t("toggle", n.node);
      }, c = (d) => {
        t("check", n.node, d);
      }, f = (d) => {
        var p, h, m, v;
        (m = (h = (p = o == null ? void 0 : o.instance) == null ? void 0 : p.vnode) == null ? void 0 : h.props) != null && m.onNodeContextmenu && (d.stopPropagation(), d.preventDefault()), o == null || o.ctx.emit(WS, d, (v = n.node) == null ? void 0 : v.data, n.node);
      };
      return (d, p) => {
        var h, m, v;
        return S(), V("div", {
          ref: "node$",
          class: $([
            i(r).b("node"),
            i(r).is("expanded", d.expanded),
            i(r).is("current", d.current),
            i(r).is("focusable", !d.disabled),
            i(r).is("checked", !d.disabled && d.checked)
          ]),
          role: "treeitem",
          tabindex: "-1",
          "aria-expanded": d.expanded,
          "aria-disabled": d.disabled,
          "aria-checked": d.checked,
          "data-key": (h = d.node) == null ? void 0 : h.key,
          onClick: Ze(a, ["stop"]),
          onContextmenu: f
        }, [
          H("div", {
            class: $(i(r).be("node", "content")),
            style: Ke({
              paddingLeft: `${(d.node.level - 1) * i(s)}px`,
              height: d.itemSize + "px"
            })
          }, [
            i(l) ? (S(), ie(i(He), {
              key: 0,
              class: $([
                i(r).is("leaf", !!((m = d.node) != null && m.isLeaf)),
                i(r).is("hidden", d.hiddenExpandIcon),
                {
                  expanded: !((v = d.node) != null && v.isLeaf) && d.expanded
                },
                i(r).be("node", "expand-icon")
              ]),
              onClick: Ze(u, ["stop"])
            }, {
              default: X(() => [
                (S(), ie(vt(i(l))))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : se("v-if", !0),
            d.showCheckbox ? (S(), ie(i(co), {
              key: 1,
              "model-value": d.checked,
              indeterminate: d.indeterminate,
              disabled: d.disabled,
              onChange: c,
              onClick: p[0] || (p[0] = Ze(() => {
              }, ["stop"]))
            }, null, 8, ["model-value", "indeterminate", "disabled"])) : se("v-if", !0),
            K(i(EQ), { node: d.node }, null, 8, ["node"])
          ], 6)
        ], 42, SQ);
      };
    }
  });
  var $Q = /* @__PURE__ */ Me(kQ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree-node.vue"]]);
  const NQ = G({
    name: "ElTreeV2"
  }), TQ = /* @__PURE__ */ G({
    ...NQ,
    props: hQ,
    emits: gQ,
    setup(e, { expose: t, emit: n }) {
      const o = e, r = hn(), s = E(() => o.itemSize);
      pt(kv, {
        ctx: {
          emit: n,
          slots: r
        },
        props: o,
        instance: it()
      }), pt(Ho, void 0);
      const { t: l } = St(), a = ge("tree"), {
        flattenTree: u,
        isNotEmpty: c,
        toggleExpand: f,
        isExpanded: d,
        isIndeterminate: p,
        isChecked: h,
        isDisabled: m,
        isCurrent: v,
        isForceHiddenExpandIcon: g,
        handleNodeClick: y,
        handleNodeCheck: w,
        toggleCheckbox: b,
        getCurrentNode: C,
        getCurrentKey: _,
        setCurrentKey: k,
        getCheckedKeys: O,
        getCheckedNodes: T,
        getHalfCheckedKeys: P,
        getHalfCheckedNodes: A,
        setChecked: L,
        setCheckedKeys: D,
        filter: B,
        setData: F,
        getNode: W,
        expandNode: x,
        collapseNode: N,
        setExpandedKeys: R
      } = CQ(o, n);
      return t({
        toggleCheckbox: b,
        getCurrentNode: C,
        getCurrentKey: _,
        setCurrentKey: k,
        getCheckedKeys: O,
        getCheckedNodes: T,
        getHalfCheckedKeys: P,
        getHalfCheckedNodes: A,
        setChecked: L,
        setCheckedKeys: D,
        filter: B,
        setData: F,
        getNode: W,
        expandNode: x,
        collapseNode: N,
        setExpandedKeys: R
      }), (M, j) => {
        var te;
        return S(), V("div", {
          class: $([i(a).b(), { [i(a).m("highlight-current")]: M.highlightCurrent }]),
          role: "tree"
        }, [
          i(c) ? (S(), ie(i(JE), {
            key: 0,
            "class-name": i(a).b("virtual-list"),
            data: i(u),
            total: i(u).length,
            height: M.height,
            "item-size": i(s),
            "perf-mode": M.perfMode
          }, {
            default: X(({ data: U, index: Z, style: pe }) => [
              (S(), ie($Q, {
                key: U[Z].key,
                style: Ke(pe),
                node: U[Z],
                expanded: i(d)(U[Z]),
                "show-checkbox": M.showCheckbox,
                checked: i(h)(U[Z]),
                indeterminate: i(p)(U[Z]),
                "item-size": i(s),
                disabled: i(m)(U[Z]),
                current: i(v)(U[Z]),
                "hidden-expand-icon": i(g)(U[Z]),
                onClick: i(y),
                onToggle: i(f),
                onCheck: i(w)
              }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "item-size", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck"]))
            ]),
            _: 1
          }, 8, ["class-name", "data", "total", "height", "item-size", "perf-mode"])) : (S(), V("div", {
            key: 1,
            class: $(i(a).e("empty-block"))
          }, [
            H("span", {
              class: $(i(a).e("empty-text"))
            }, Ne((te = M.emptyText) != null ? te : i(l)("el.tree.emptyText")), 3)
          ], 2))
        ], 2);
      };
    }
  });
  var OQ = /* @__PURE__ */ Me(TQ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree.vue"]]);
  const MQ = ut(OQ), US = Symbol("uploadContextKey"), IQ = "ElUpload";
  class PQ extends Error {
    constructor(t, n, o, r) {
      super(t), this.name = "UploadAjaxError", this.status = n, this.method = o, this.url = r;
    }
  }
  function Jy(e, t, n) {
    let o;
    return n.response ? o = `${n.response.error || n.response}` : n.responseText ? o = `${n.responseText}` : o = `fail to ${t.method} ${e} ${n.status}`, new PQ(o, n.status, t.method, e);
  }
  function AQ(e) {
    const t = e.responseText || e.response;
    if (!t)
      return t;
    try {
      return JSON.parse(t);
    } catch {
      return t;
    }
  }
  const RQ = (e) => {
    typeof XMLHttpRequest > "u" && Yt(IQ, "XMLHttpRequest is undefined");
    const t = new XMLHttpRequest(), n = e.action;
    t.upload && t.upload.addEventListener("progress", (s) => {
      const l = s;
      l.percent = s.total > 0 ? s.loaded / s.total * 100 : 0, e.onProgress(l);
    });
    const o = new FormData();
    if (e.data)
      for (const [s, l] of Object.entries(e.data))
        Array.isArray(l) ? o.append(s, ...l) : o.append(s, l);
    o.append(e.filename, e.file, e.file.name), t.addEventListener("error", () => {
      e.onError(Jy(n, e, t));
    }), t.addEventListener("load", () => {
      if (t.status < 200 || t.status >= 300)
        return e.onError(Jy(n, e, t));
      e.onSuccess(AQ(t));
    }), t.open(e.method, n, !0), e.withCredentials && "withCredentials" in t && (t.withCredentials = !0);
    const r = e.headers || {};
    if (r instanceof Headers)
      r.forEach((s, l) => t.setRequestHeader(l, s));
    else
      for (const [s, l] of Object.entries(r))
        nn(l) || t.setRequestHeader(s, String(l));
    return t.send(o), t;
  }, qS = ["text", "picture", "picture-card"];
  let xQ = 1;
  const Cp = () => Date.now() + xQ++, YS = Ie({
    action: {
      type: String,
      default: "#"
    },
    headers: {
      type: le(Object)
    },
    method: {
      type: String,
      default: "post"
    },
    data: {
      type: Object,
      default: () => jt({})
    },
    multiple: {
      type: Boolean,
      default: !1
    },
    name: {
      type: String,
      default: "file"
    },
    drag: {
      type: Boolean,
      default: !1
    },
    withCredentials: Boolean,
    showFileList: {
      type: Boolean,
      default: !0
    },
    accept: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      default: "select"
    },
    fileList: {
      type: le(Array),
      default: () => jt([])
    },
    autoUpload: {
      type: Boolean,
      default: !0
    },
    listType: {
      type: String,
      values: qS,
      default: "text"
    },
    httpRequest: {
      type: le(Function),
      default: RQ
    },
    disabled: Boolean,
    limit: Number
  }), DQ = Ie({
    ...YS,
    beforeUpload: {
      type: le(Function),
      default: Nt
    },
    beforeRemove: {
      type: le(Function)
    },
    onRemove: {
      type: le(Function),
      default: Nt
    },
    onChange: {
      type: le(Function),
      default: Nt
    },
    onPreview: {
      type: le(Function),
      default: Nt
    },
    onSuccess: {
      type: le(Function),
      default: Nt
    },
    onProgress: {
      type: le(Function),
      default: Nt
    },
    onError: {
      type: le(Function),
      default: Nt
    },
    onExceed: {
      type: le(Function),
      default: Nt
    }
  }), LQ = Ie({
    files: {
      type: le(Array),
      default: () => jt([])
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    handlePreview: {
      type: le(Function),
      default: Nt
    },
    listType: {
      type: String,
      values: qS,
      default: "text"
    }
  }), VQ = {
    remove: (e) => !!e
  }, BQ = ["onKeydown"], FQ = ["src"], HQ = ["onClick"], zQ = ["onClick"], KQ = ["onClick"], jQ = G({
    name: "ElUploadList"
  }), WQ = /* @__PURE__ */ G({
    ...jQ,
    props: LQ,
    emits: VQ,
    setup(e, { emit: t }) {
      const { t: n } = St(), o = ge("upload"), r = ge("icon"), s = ge("list"), l = Fn(), a = I(!1), u = (c) => {
        t("remove", c);
      };
      return (c, f) => (S(), ie(Q0, {
        tag: "ul",
        class: $([
          i(o).b("list"),
          i(o).bm("list", c.listType),
          i(o).is("disabled", i(l))
        ]),
        name: i(s).b()
      }, {
        default: X(() => [
          (S(!0), V(ze, null, gt(c.files, (d) => (S(), V("li", {
            key: d.uid || d.name,
            class: $([
              i(o).be("list", "item"),
              i(o).is(d.status),
              { focusing: a.value }
            ]),
            tabindex: "0",
            onKeydown: Et((p) => !i(l) && u(d), ["delete"]),
            onFocus: f[0] || (f[0] = (p) => a.value = !0),
            onBlur: f[1] || (f[1] = (p) => a.value = !1),
            onClick: f[2] || (f[2] = (p) => a.value = !1)
          }, [
            he(c.$slots, "default", { file: d }, () => [
              c.listType === "picture" || d.status !== "uploading" && c.listType === "picture-card" ? (S(), V("img", {
                key: 0,
                class: $(i(o).be("list", "item-thumbnail")),
                src: d.url,
                alt: ""
              }, null, 10, FQ)) : se("v-if", !0),
              d.status === "uploading" || c.listType !== "picture-card" ? (S(), V("div", {
                key: 1,
                class: $(i(o).be("list", "item-info"))
              }, [
                H("a", {
                  class: $(i(o).be("list", "item-name")),
                  onClick: Ze((p) => c.handlePreview(d), ["prevent"])
                }, [
                  K(i(He), {
                    class: $(i(r).m("document"))
                  }, {
                    default: X(() => [
                      K(i(DA))
                    ]),
                    _: 1
                  }, 8, ["class"]),
                  H("span", {
                    class: $(i(o).be("list", "item-file-name"))
                  }, Ne(d.name), 3)
                ], 10, HQ),
                d.status === "uploading" ? (S(), ie(i(zE), {
                  key: 0,
                  type: c.listType === "picture-card" ? "circle" : "line",
                  "stroke-width": c.listType === "picture-card" ? 6 : 2,
                  percentage: Number(d.percentage),
                  style: Ke(c.listType === "picture-card" ? "" : "margin-top: 0.5rem")
                }, null, 8, ["type", "stroke-width", "percentage", "style"])) : se("v-if", !0)
              ], 2)) : se("v-if", !0),
              H("label", {
                class: $(i(o).be("list", "item-status-label"))
              }, [
                c.listType === "text" ? (S(), ie(i(He), {
                  key: 0,
                  class: $([i(r).m("upload-success"), i(r).m("circle-check")])
                }, {
                  default: X(() => [
                    K(i(Eh))
                  ]),
                  _: 1
                }, 8, ["class"])) : ["picture-card", "picture"].includes(c.listType) ? (S(), ie(i(He), {
                  key: 1,
                  class: $([i(r).m("upload-success"), i(r).m("check")])
                }, {
                  default: X(() => [
                    K(i(wi))
                  ]),
                  _: 1
                }, 8, ["class"])) : se("v-if", !0)
              ], 2),
              i(l) ? se("v-if", !0) : (S(), ie(i(He), {
                key: 2,
                class: $(i(r).m("close")),
                onClick: (p) => u(d)
              }, {
                default: X(() => [
                  K(i(_o))
                ]),
                _: 2
              }, 1032, ["class", "onClick"])),
              se(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
              se(" This is a bug which needs to be fixed "),
              se(" TODO: Fix the incorrect navigation interaction "),
              i(l) ? se("v-if", !0) : (S(), V("i", {
                key: 3,
                class: $(i(r).m("close-tip"))
              }, Ne(i(n)("el.upload.deleteTip")), 3)),
              c.listType === "picture-card" ? (S(), V("span", {
                key: 4,
                class: $(i(o).be("list", "item-actions"))
              }, [
                H("span", {
                  class: $(i(o).be("list", "item-preview")),
                  onClick: (p) => c.handlePreview(d)
                }, [
                  K(i(He), {
                    class: $(i(r).m("zoom-in"))
                  }, {
                    default: X(() => [
                      K(i(ew))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, zQ),
                i(l) ? se("v-if", !0) : (S(), V("span", {
                  key: 0,
                  class: $(i(o).be("list", "item-delete")),
                  onClick: (p) => u(d)
                }, [
                  K(i(He), {
                    class: $(i(r).m("delete"))
                  }, {
                    default: X(() => [
                      K(i(MA))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, KQ))
              ], 2)) : se("v-if", !0)
            ])
          ], 42, BQ))), 128)),
          he(c.$slots, "append")
        ]),
        _: 3
      }, 8, ["class", "name"]));
    }
  });
  var Zy = /* @__PURE__ */ Me(WQ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]);
  const UQ = Ie({
    disabled: {
      type: Boolean,
      default: !1
    }
  }), qQ = {
    file: (e) => De(e)
  }, YQ = ["onDrop", "onDragover"], GS = "ElUploadDrag", GQ = G({
    name: GS
  }), XQ = /* @__PURE__ */ G({
    ...GQ,
    props: UQ,
    emits: qQ,
    setup(e, { emit: t }) {
      const n = Be(US);
      n || Yt(GS, "usage: <el-upload><el-upload-dragger /></el-upload>");
      const o = ge("upload"), r = I(!1), s = Fn(), l = (u) => {
        if (s.value)
          return;
        r.value = !1, u.stopPropagation();
        const c = Array.from(u.dataTransfer.files), f = n.accept.value;
        if (!f) {
          t("file", c);
          return;
        }
        const d = c.filter((p) => {
          const { type: h, name: m } = p, v = m.includes(".") ? `.${m.split(".").pop()}` : "", g = h.replace(/\/.*$/, "");
          return f.split(",").map((y) => y.trim()).filter((y) => y).some((y) => y.startsWith(".") ? v === y : /\/\*$/.test(y) ? g === y.replace(/\/\*$/, "") : /^[^/]+\/[^/]+$/.test(y) ? h === y : !1);
        });
        t("file", d);
      }, a = () => {
        s.value || (r.value = !0);
      };
      return (u, c) => (S(), V("div", {
        class: $([i(o).b("dragger"), i(o).is("dragover", r.value)]),
        onDrop: Ze(l, ["prevent"]),
        onDragover: Ze(a, ["prevent"]),
        onDragleave: c[0] || (c[0] = Ze((f) => r.value = !1, ["prevent"]))
      }, [
        he(u.$slots, "default")
      ], 42, YQ));
    }
  });
  var JQ = /* @__PURE__ */ Me(XQ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]);
  const ZQ = Ie({
    ...YS,
    beforeUpload: {
      type: le(Function),
      default: Nt
    },
    onRemove: {
      type: le(Function),
      default: Nt
    },
    onStart: {
      type: le(Function),
      default: Nt
    },
    onSuccess: {
      type: le(Function),
      default: Nt
    },
    onProgress: {
      type: le(Function),
      default: Nt
    },
    onError: {
      type: le(Function),
      default: Nt
    },
    onExceed: {
      type: le(Function),
      default: Nt
    }
  }), QQ = ["onKeydown"], eee = ["name", "multiple", "accept"], tee = G({
    name: "ElUploadContent",
    inheritAttrs: !1
  }), nee = /* @__PURE__ */ G({
    ...tee,
    props: ZQ,
    setup(e, { expose: t }) {
      const n = e, o = ge("upload"), r = Fn(), s = xt({}), l = xt(), a = (m) => {
        if (m.length === 0)
          return;
        const { autoUpload: v, limit: g, fileList: y, multiple: w, onStart: b, onExceed: C } = n;
        if (g && y.length + m.length > g) {
          C(m, y);
          return;
        }
        w || (m = m.slice(0, 1));
        for (const _ of m) {
          const k = _;
          k.uid = Cp(), b(k), v && u(k);
        }
      }, u = async (m) => {
        if (l.value.value = "", !n.beforeUpload)
          return c(m);
        let v, g = {};
        try {
          const w = n.beforeUpload(m);
          g = rt(n.data) ? bh(n.data) : n.data, v = await w;
        } catch {
          v = !1;
        }
        if (v === !1) {
          n.onRemove(m);
          return;
        }
        let y = m;
        v instanceof Blob && (v instanceof File ? y = v : y = new File([v], m.name, {
          type: m.type
        })), c(Object.assign(y, {
          uid: m.uid
        }), g);
      }, c = (m, v) => {
        const {
          headers: g,
          data: y,
          method: w,
          withCredentials: b,
          name: C,
          action: _,
          onProgress: k,
          onSuccess: O,
          onError: T,
          httpRequest: P
        } = n, { uid: A } = m, L = {
          headers: g || {},
          withCredentials: b,
          file: m,
          data: v != null ? v : y,
          method: w,
          filename: C,
          action: _,
          onProgress: (B) => {
            k(B, m);
          },
          onSuccess: (B) => {
            O(B, m), delete s.value[A];
          },
          onError: (B) => {
            T(B, m), delete s.value[A];
          }
        }, D = P(L);
        s.value[A] = D, D instanceof Promise && D.then(L.onSuccess, L.onError);
      }, f = (m) => {
        const v = m.target.files;
        !v || a(Array.from(v));
      }, d = () => {
        r.value || (l.value.value = "", l.value.click());
      }, p = () => {
        d();
      };
      return t({
        abort: (m) => {
          DP(s.value).filter(m ? ([g]) => String(m.uid) === g : () => !0).forEach(([g, y]) => {
            y instanceof XMLHttpRequest && y.abort(), delete s.value[g];
          });
        },
        upload: u
      }), (m, v) => (S(), V("div", {
        class: $([i(o).b(), i(o).m(m.listType), i(o).is("drag", m.drag)]),
        tabindex: "0",
        onClick: d,
        onKeydown: Et(Ze(p, ["self"]), ["enter", "space"])
      }, [
        m.drag ? (S(), ie(JQ, {
          key: 0,
          disabled: i(r),
          onFile: a
        }, {
          default: X(() => [
            he(m.$slots, "default")
          ]),
          _: 3
        }, 8, ["disabled"])) : he(m.$slots, "default", { key: 1 }),
        H("input", {
          ref_key: "inputRef",
          ref: l,
          class: $(i(o).e("input")),
          name: m.name,
          multiple: m.multiple,
          accept: m.accept,
          type: "file",
          onChange: f,
          onClick: v[0] || (v[0] = Ze(() => {
          }, ["stop"]))
        }, null, 42, eee)
      ], 42, QQ));
    }
  });
  var Qy = /* @__PURE__ */ Me(nee, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]);
  const eb = "ElUpload", oee = (e) => {
    var t;
    (t = e.url) != null && t.startsWith("blob:") && URL.revokeObjectURL(e.url);
  }, ree = (e, t) => {
    const n = $N(e, "fileList", void 0, { passive: !0 }), o = (p) => n.value.find((h) => h.uid === p.uid);
    function r(p) {
      var h;
      (h = t.value) == null || h.abort(p);
    }
    function s(p = ["ready", "uploading", "success", "fail"]) {
      n.value = n.value.filter((h) => !p.includes(h.status));
    }
    const l = (p, h) => {
      const m = o(h);
      !m || (console.error(p), m.status = "fail", n.value.splice(n.value.indexOf(m), 1), e.onError(p, m, n.value), e.onChange(m, n.value));
    }, a = (p, h) => {
      const m = o(h);
      !m || (e.onProgress(p, m, n.value), m.status = "uploading", m.percentage = Math.round(p.percent));
    }, u = (p, h) => {
      const m = o(h);
      !m || (m.status = "success", m.response = p, e.onSuccess(p, m, n.value), e.onChange(m, n.value));
    }, c = (p) => {
      nn(p.uid) && (p.uid = Cp());
      const h = {
        name: p.name,
        percentage: 0,
        status: "ready",
        size: p.size,
        raw: p,
        uid: p.uid
      };
      if (e.listType === "picture-card" || e.listType === "picture")
        try {
          h.url = URL.createObjectURL(p);
        } catch (m) {
          yt(eb, m.message), e.onError(m, h, n.value);
        }
      n.value = [...n.value, h], e.onChange(h, n.value);
    }, f = async (p) => {
      const h = p instanceof File ? o(p) : p;
      h || Yt(eb, "file to be removed not found");
      const m = (v) => {
        r(v);
        const g = n.value;
        g.splice(g.indexOf(v), 1), e.onRemove(v, g), oee(v);
      };
      e.beforeRemove ? await e.beforeRemove(h, n.value) !== !1 && m(h) : m(h);
    };
    function d() {
      n.value.filter(({ status: p }) => p === "ready").forEach(({ raw: p }) => {
        var h;
        return p && ((h = t.value) == null ? void 0 : h.upload(p));
      });
    }
    return me(() => e.listType, (p) => {
      p !== "picture-card" && p !== "picture" || (n.value = n.value.map((h) => {
        const { raw: m, url: v } = h;
        if (!v && m)
          try {
            h.url = URL.createObjectURL(m);
          } catch (g) {
            e.onError(g, h, n.value);
          }
        return h;
      }));
    }), me(n, (p) => {
      for (const h of p)
        h.uid || (h.uid = Cp()), h.status || (h.status = "success");
    }, { immediate: !0, deep: !0 }), {
      uploadFiles: n,
      abort: r,
      clearFiles: s,
      handleError: l,
      handleProgress: a,
      handleStart: c,
      handleSuccess: u,
      handleRemove: f,
      submit: d
    };
  }, see = G({
    name: "ElUpload"
  }), lee = /* @__PURE__ */ G({
    ...see,
    props: DQ,
    setup(e, { expose: t }) {
      const n = e, o = hn(), r = Fn(), s = xt(), {
        abort: l,
        submit: a,
        clearFiles: u,
        uploadFiles: c,
        handleStart: f,
        handleError: d,
        handleRemove: p,
        handleSuccess: h,
        handleProgress: m
      } = ree(n, s), v = E(() => n.listType === "picture-card"), g = E(() => ({
        ...n,
        fileList: c.value,
        onStart: f,
        onProgress: m,
        onSuccess: h,
        onError: d,
        onRemove: p
      }));
      return zt(() => {
        c.value.forEach(({ url: y }) => {
          y != null && y.startsWith("blob:") && URL.revokeObjectURL(y);
        });
      }), pt(US, {
        accept: Ht(n, "accept")
      }), t({
        abort: l,
        submit: a,
        clearFiles: u,
        handleStart: f,
        handleRemove: p
      }), (y, w) => (S(), V("div", null, [
        i(v) && y.showFileList ? (S(), ie(Zy, {
          key: 0,
          disabled: i(r),
          "list-type": y.listType,
          files: i(c),
          "handle-preview": y.onPreview,
          onRemove: i(p)
        }, lr({
          append: X(() => [
            K(Qy, ft({
              ref_key: "uploadRef",
              ref: s
            }, i(g)), {
              default: X(() => [
                i(o).trigger ? he(y.$slots, "trigger", { key: 0 }) : se("v-if", !0),
                !i(o).trigger && i(o).default ? he(y.$slots, "default", { key: 1 }) : se("v-if", !0)
              ]),
              _: 3
            }, 16)
          ]),
          _: 2
        }, [
          y.$slots.file ? {
            name: "default",
            fn: X(({ file: b }) => [
              he(y.$slots, "file", { file: b })
            ])
          } : void 0
        ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : se("v-if", !0),
        !i(v) || i(v) && !y.showFileList ? (S(), ie(Qy, ft({
          key: 1,
          ref_key: "uploadRef",
          ref: s
        }, i(g)), {
          default: X(() => [
            i(o).trigger ? he(y.$slots, "trigger", { key: 0 }) : se("v-if", !0),
            !i(o).trigger && i(o).default ? he(y.$slots, "default", { key: 1 }) : se("v-if", !0)
          ]),
          _: 3
        }, 16)) : se("v-if", !0),
        y.$slots.trigger ? he(y.$slots, "default", { key: 2 }) : se("v-if", !0),
        he(y.$slots, "tip"),
        !i(v) && y.showFileList ? (S(), ie(Zy, {
          key: 3,
          disabled: i(r),
          "list-type": y.listType,
          files: i(c),
          "handle-preview": y.onPreview,
          onRemove: i(p)
        }, lr({ _: 2 }, [
          y.$slots.file ? {
            name: "default",
            fn: X(({ file: b }) => [
              he(y.$slots, "file", { file: b })
            ])
          } : void 0
        ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : se("v-if", !0)
      ]));
    }
  });
  var aee = /* @__PURE__ */ Me(lee, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]);
  const iee = ut(aee);
  var uee = [
    IL,
    zL,
    dB,
    kJ,
    yB,
    kB,
    rC,
    VB,
    BB,
    gn,
    dC,
    t5,
    l5,
    w5,
    C5,
    xH,
    CH,
    HH,
    co,
    H5,
    HC,
    QH,
    yz,
    bz,
    uz,
    Yz,
    SL,
    lK,
    aK,
    iK,
    uK,
    cK,
    g9,
    N9,
    T9,
    K9,
    EE,
    oj,
    Yj,
    Gj,
    Xj,
    IE,
    RV,
    xV,
    He,
    zW,
    PE,
    wn,
    AE,
    n7,
    E7,
    S7,
    _7,
    k7,
    P7,
    LU,
    KU,
    ZU,
    tC,
    zE,
    YC,
    oH,
    nH,
    vq,
    wq,
    YH,
    pr,
    Ps,
    oc,
    uU,
    dY,
    bY,
    wY,
    XY,
    tG,
    aS,
    fG,
    CG,
    EG,
    AG,
    FX,
    HX,
    _J,
    FJ,
    HJ,
    Xa,
    UJ,
    xF,
    ZJ,
    oZ,
    rZ,
    Mn,
    MZ,
    WZ,
    sQ,
    fQ,
    MQ,
    iee
  ];
  const vo = "ElInfiniteScroll", cee = 50, dee = 200, fee = 0, pee = {
    delay: {
      type: Number,
      default: dee
    },
    distance: {
      type: Number,
      default: fee
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    immediate: {
      type: Boolean,
      default: !0
    }
  }, $v = (e, t) => Object.entries(pee).reduce((n, [o, r]) => {
    var s, l;
    const { type: a, default: u } = r, c = e.getAttribute(`infinite-scroll-${o}`);
    let f = (l = (s = t[c]) != null ? s : c) != null ? l : u;
    return f = f === "false" ? !1 : f, f = a(f), n[o] = Number.isNaN(f) ? u : f, n;
  }, {}), XS = (e) => {
    const { observer: t } = e[vo];
    t && (t.disconnect(), delete e[vo].observer);
  }, hee = (e, t) => {
    const { container: n, containerEl: o, instance: r, observer: s, lastScrollTop: l } = e[vo], { disabled: a, distance: u } = $v(e, r), { clientHeight: c, scrollHeight: f, scrollTop: d } = o, p = d - l;
    if (e[vo].lastScrollTop = d, s || a || p < 0)
      return;
    let h = !1;
    if (n === e)
      h = f - (c + d) <= u;
    else {
      const { clientTop: m, scrollHeight: v } = e, g = MN(e, o);
      h = d + c >= g + m + v - u;
    }
    h && t.call(r);
  };
  function qd(e, t) {
    const { containerEl: n, instance: o } = e[vo], { disabled: r } = $v(e, o);
    r || n.clientHeight === 0 || (n.scrollHeight <= n.clientHeight ? t.call(o) : XS(e));
  }
  const vee = {
    async mounted(e, t) {
      const { instance: n, value: o } = t;
      Ge(o) || Yt(vo, "'v-infinite-scroll' binding value must be a function"), await Fe();
      const { delay: r, immediate: s } = $v(e, n), l = Ch(e, !0), a = l === window ? document.documentElement : l, u = Ss(hee.bind(null, e, o), r);
      if (!!l) {
        if (e[vo] = {
          instance: n,
          container: l,
          containerEl: a,
          delay: r,
          cb: o,
          onScroll: u,
          lastScrollTop: a.scrollTop
        }, s) {
          const c = new MutationObserver(Ss(qd.bind(null, e, o), cee));
          e[vo].observer = c, c.observe(e, { childList: !0, subtree: !0 }), qd(e, o);
        }
        l.addEventListener("scroll", u);
      }
    },
    unmounted(e) {
      const { container: t, onScroll: n } = e[vo];
      t == null || t.removeEventListener("scroll", n), XS(e);
    },
    async updated(e) {
      if (!e[vo])
        await Fe();
      else {
        const { containerEl: t, cb: n, observer: o } = e[vo];
        t.clientHeight && o && qd(e, n);
      }
    }
  }, Ep = vee;
  Ep.install = (e) => {
    e.directive("InfiniteScroll", Ep);
  };
  const mee = Ep;
  function gee(e) {
    let t;
    const n = I(!1), o = Tt({
      ...e,
      originalPosition: "",
      originalOverflow: "",
      visible: !1
    });
    function r(p) {
      o.text = p;
    }
    function s() {
      const p = o.parent, h = d.ns;
      if (!p.vLoadingAddClassList) {
        let m = p.getAttribute("loading-number");
        m = Number.parseInt(m) - 1, m ? p.setAttribute("loading-number", m.toString()) : (Dn(p, h.bm("parent", "relative")), p.removeAttribute("loading-number")), Dn(p, h.bm("parent", "hidden"));
      }
      l(), f.unmount();
    }
    function l() {
      var p, h;
      (h = (p = d.$el) == null ? void 0 : p.parentNode) == null || h.removeChild(d.$el);
    }
    function a() {
      var p;
      e.beforeClose && !e.beforeClose() || (n.value = !0, clearTimeout(t), t = window.setTimeout(u, 400), o.visible = !1, (p = e.closed) == null || p.call(e));
    }
    function u() {
      if (!n.value)
        return;
      const p = o.parent;
      n.value = !1, p.vLoadingAddClassList = void 0, s();
    }
    const c = G({
      name: "ElLoading",
      setup(p, { expose: h }) {
        const { ns: m } = Xc("loading"), v = Fs();
        return h({
          ns: m,
          zIndex: v
        }), () => {
          const g = o.spinner || o.svg, y = je("svg", {
            class: "circular",
            viewBox: o.svgViewBox ? o.svgViewBox : "0 0 50 50",
            ...g ? { innerHTML: g } : {}
          }, [
            je("circle", {
              class: "path",
              cx: "25",
              cy: "25",
              r: "20",
              fill: "none"
            })
          ]), w = o.text ? je("p", { class: m.b("text") }, [o.text]) : void 0;
          return je(Qt, {
            name: m.b("fade"),
            onAfterLeave: u
          }, {
            default: X(() => [
              ot(K("div", {
                style: {
                  backgroundColor: o.background || ""
                },
                class: [
                  m.b("mask"),
                  o.customClass,
                  o.fullscreen ? "is-fullscreen" : ""
                ]
              }, [
                je("div", {
                  class: m.b("spinner")
                }, [y, w])
              ]), [[$t, o.visible]])
            ])
          });
        };
      }
    }), f = r1(c), d = f.mount(document.createElement("div"));
    return {
      ...rn(o),
      setText: r,
      removeElLoadingChild: l,
      close: a,
      handleAfterLeave: u,
      vm: d,
      get $el() {
        return d.$el;
      }
    };
  }
  let Qi;
  const Sp = function(e = {}) {
    if (!bt)
      return;
    const t = yee(e);
    if (t.fullscreen && Qi)
      return Qi;
    const n = gee({
      ...t,
      closed: () => {
        var r;
        (r = t.closed) == null || r.call(t), t.fullscreen && (Qi = void 0);
      }
    });
    bee(t, t.parent, n), tb(t, t.parent, n), t.parent.vLoadingAddClassList = () => tb(t, t.parent, n);
    let o = t.parent.getAttribute("loading-number");
    return o ? o = `${Number.parseInt(o) + 1}` : o = "1", t.parent.setAttribute("loading-number", o), t.parent.appendChild(n.$el), Fe(() => n.visible.value = t.visible), t.fullscreen && (Qi = n), n;
  }, yee = (e) => {
    var t, n, o, r;
    let s;
    return et(e.target) ? s = (t = document.querySelector(e.target)) != null ? t : document.body : s = e.target || document.body, {
      parent: s === document.body || e.body ? document.body : s,
      background: e.background || "",
      svg: e.svg || "",
      svgViewBox: e.svgViewBox || "",
      spinner: e.spinner || !1,
      text: e.text || "",
      fullscreen: s === document.body && ((n = e.fullscreen) != null ? n : !0),
      lock: (o = e.lock) != null ? o : !1,
      customClass: e.customClass || "",
      visible: (r = e.visible) != null ? r : !0,
      target: s
    };
  }, bee = async (e, t, n) => {
    const { nextZIndex: o } = n.vm.zIndex, r = {};
    if (e.fullscreen)
      n.originalPosition.value = Qo(document.body, "position"), n.originalOverflow.value = Qo(document.body, "overflow"), r.zIndex = o();
    else if (e.parent === document.body) {
      n.originalPosition.value = Qo(document.body, "position"), await Fe();
      for (const s of ["top", "left"]) {
        const l = s === "top" ? "scrollTop" : "scrollLeft";
        r[s] = `${e.target.getBoundingClientRect()[s] + document.body[l] + document.documentElement[l] - Number.parseInt(Qo(document.body, `margin-${s}`), 10)}px`;
      }
      for (const s of ["height", "width"])
        r[s] = `${e.target.getBoundingClientRect()[s]}px`;
    } else
      n.originalPosition.value = Qo(t, "position");
    for (const [s, l] of Object.entries(r))
      n.$el.style[s] = l;
  }, tb = (e, t, n) => {
    const o = n.vm.ns;
    ["absolute", "fixed", "sticky"].includes(n.originalPosition.value) ? Dn(t, o.bm("parent", "relative")) : Ao(t, o.bm("parent", "relative")), e.fullscreen && e.lock ? Ao(t, o.bm("parent", "hidden")) : Dn(t, o.bm("parent", "hidden"));
  }, _p = Symbol("ElLoading"), nb = (e, t) => {
    var n, o, r, s;
    const l = t.instance, a = (p) => rt(t.value) ? t.value[p] : void 0, u = (p) => {
      const h = et(p) && (l == null ? void 0 : l[p]) || p;
      return h && I(h);
    }, c = (p) => u(a(p) || e.getAttribute(`element-loading-${Do(p)}`)), f = (n = a("fullscreen")) != null ? n : t.modifiers.fullscreen, d = {
      text: c("text"),
      svg: c("svg"),
      svgViewBox: c("svgViewBox"),
      spinner: c("spinner"),
      background: c("background"),
      customClass: c("customClass"),
      fullscreen: f,
      target: (o = a("target")) != null ? o : f ? void 0 : e,
      body: (r = a("body")) != null ? r : t.modifiers.body,
      lock: (s = a("lock")) != null ? s : t.modifiers.lock
    };
    e[_p] = {
      options: d,
      instance: Sp(d)
    };
  }, wee = (e, t) => {
    for (const n of Object.keys(t))
      Pt(t[n]) && (t[n].value = e[n]);
  }, ob = {
    mounted(e, t) {
      t.value && nb(e, t);
    },
    updated(e, t) {
      const n = e[_p];
      t.oldValue !== t.value && (t.value && !t.oldValue ? nb(e, t) : t.value && t.oldValue ? rt(t.value) && wee(t.value, n.options) : n == null || n.instance.close());
    },
    unmounted(e) {
      var t;
      (t = e[_p]) == null || t.instance.close();
    }
  }, Cee = {
    install(e) {
      e.directive("loading", ob), e.config.globalProperties.$loading = Sp;
    },
    directive: ob,
    service: Sp
  }, JS = ["success", "info", "warning", "error"], An = jt({
    customClass: "",
    center: !1,
    dangerouslyUseHTMLString: !1,
    duration: 3e3,
    icon: void 0,
    id: "",
    message: "",
    onClose: void 0,
    showClose: !1,
    type: "info",
    offset: 16,
    zIndex: 0,
    grouping: !1,
    repeatNum: 1,
    appendTo: bt ? document.body : void 0
  }), Eee = Ie({
    customClass: {
      type: String,
      default: An.customClass
    },
    center: {
      type: Boolean,
      default: An.center
    },
    dangerouslyUseHTMLString: {
      type: Boolean,
      default: An.dangerouslyUseHTMLString
    },
    duration: {
      type: Number,
      default: An.duration
    },
    icon: {
      type: Vt,
      default: An.icon
    },
    id: {
      type: String,
      default: An.id
    },
    message: {
      type: le([
        String,
        Object,
        Function
      ]),
      default: An.message
    },
    onClose: {
      type: le(Function),
      required: !1
    },
    showClose: {
      type: Boolean,
      default: An.showClose
    },
    type: {
      type: String,
      values: JS,
      default: An.type
    },
    offset: {
      type: Number,
      default: An.offset
    },
    zIndex: {
      type: Number,
      default: An.zIndex
    },
    grouping: {
      type: Boolean,
      default: An.grouping
    },
    repeatNum: {
      type: Number,
      default: An.repeatNum
    }
  }), See = {
    destroy: () => !0
  }, yo = e0([]), _ee = (e) => {
    const t = yo.findIndex((r) => r.id === e), n = yo[t];
    let o;
    return t > 0 && (o = yo[t - 1]), { current: n, prev: o };
  }, kee = (e) => {
    const { prev: t } = _ee(e);
    return t ? t.vm.exposed.bottom.value : 0;
  }, $ee = (e, t) => yo.findIndex((o) => o.id === e) > 0 ? 20 : t, Nee = ["id"], Tee = ["innerHTML"], Oee = G({
    name: "ElMessage"
  }), Mee = /* @__PURE__ */ G({
    ...Oee,
    props: Eee,
    emits: See,
    setup(e, { expose: t }) {
      const n = e, { Close: o } = kh, { ns: r, zIndex: s } = Xc("message"), { currentZIndex: l, nextZIndex: a } = s, u = I(), c = I(!1), f = I(0);
      let d;
      const p = E(() => n.type ? n.type === "error" ? "danger" : n.type : "info"), h = E(() => {
        const O = n.type;
        return { [r.bm("icon", O)]: O && Fr[O] };
      }), m = E(() => n.icon || Fr[n.type] || ""), v = E(() => kee(n.id)), g = E(() => $ee(n.id, n.offset) + v.value), y = E(() => f.value + g.value), w = E(() => ({
        top: `${g.value}px`,
        zIndex: l.value
      }));
      function b() {
        n.duration !== 0 && ({ stop: d } = Os(() => {
          _();
        }, n.duration));
      }
      function C() {
        d == null || d();
      }
      function _() {
        c.value = !1;
      }
      function k({ code: O }) {
        O === We.esc && _();
      }
      return st(() => {
        b(), a(), c.value = !0;
      }), me(() => n.repeatNum, () => {
        C(), b();
      }), Wt(document, "keydown", k), Cn(u, () => {
        f.value = u.value.getBoundingClientRect().height;
      }), t({
        visible: c,
        bottom: y,
        close: _
      }), (O, T) => (S(), ie(Qt, {
        name: i(r).b("fade"),
        onBeforeLeave: O.onClose,
        onAfterLeave: T[0] || (T[0] = (P) => O.$emit("destroy")),
        persisted: ""
      }, {
        default: X(() => [
          ot(H("div", {
            id: O.id,
            ref_key: "messageRef",
            ref: u,
            class: $([
              i(r).b(),
              { [i(r).m(O.type)]: O.type && !O.icon },
              i(r).is("center", O.center),
              i(r).is("closable", O.showClose),
              O.customClass
            ]),
            style: Ke(i(w)),
            role: "alert",
            onMouseenter: C,
            onMouseleave: b
          }, [
            O.repeatNum > 1 ? (S(), ie(i(rC), {
              key: 0,
              value: O.repeatNum,
              type: i(p),
              class: $(i(r).e("badge"))
            }, null, 8, ["value", "type", "class"])) : se("v-if", !0),
            i(m) ? (S(), ie(i(He), {
              key: 1,
              class: $([i(r).e("icon"), i(h)])
            }, {
              default: X(() => [
                (S(), ie(vt(i(m))))
              ]),
              _: 1
            }, 8, ["class"])) : se("v-if", !0),
            he(O.$slots, "default", {}, () => [
              O.dangerouslyUseHTMLString ? (S(), V(ze, { key: 1 }, [
                se(" Caution here, message could've been compromised, never use user's input as message "),
                H("p", {
                  class: $(i(r).e("content")),
                  innerHTML: O.message
                }, null, 10, Tee)
              ], 2112)) : (S(), V("p", {
                key: 0,
                class: $(i(r).e("content"))
              }, Ne(O.message), 3))
            ]),
            O.showClose ? (S(), ie(i(He), {
              key: 2,
              class: $(i(r).e("closeBtn")),
              onClick: Ze(_, ["stop"])
            }, {
              default: X(() => [
                K(i(o))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : se("v-if", !0)
          ], 46, Nee), [
            [$t, c.value]
          ])
        ]),
        _: 3
      }, 8, ["name", "onBeforeLeave"]));
    }
  });
  var Iee = /* @__PURE__ */ Me(Mee, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);
  let Pee = 1;
  const ZS = (e) => {
    const t = !e || et(e) || Bt(e) || Ge(e) ? { message: e } : e, n = {
      ...An,
      ...t
    };
    if (!n.appendTo)
      n.appendTo = document.body;
    else if (et(n.appendTo)) {
      let o = document.querySelector(n.appendTo);
      So(o) || (yt("ElMessage", "the appendTo option is not an HTMLElement. Falling back to document.body."), o = document.body), n.appendTo = o;
    }
    return n;
  }, Aee = (e) => {
    const t = yo.indexOf(e);
    if (t === -1)
      return;
    yo.splice(t, 1);
    const { handler: n } = e;
    n.close();
  }, Ree = ({ appendTo: e, ...t }, n) => {
    const o = `message_${Pee++}`, r = t.onClose, s = document.createElement("div"), l = {
      ...t,
      id: o,
      onClose: () => {
        r == null || r(), Aee(f);
      },
      onDestroy: () => {
        El(null, s);
      }
    }, a = K(Iee, l, Ge(l.message) || Bt(l.message) ? {
      default: Ge(l.message) ? l.message : () => l.message
    } : null);
    a.appContext = n || Dl._context, El(a, s), e.appendChild(s.firstElementChild);
    const u = a.component, f = {
      id: o,
      vnode: a,
      vm: u,
      handler: {
        close: () => {
          u.exposed.visible.value = !1;
        }
      },
      props: a.component.props
    };
    return f;
  }, Dl = (e = {}, t) => {
    if (!bt)
      return { close: () => {
      } };
    if (Xe(Pf.max) && yo.length >= Pf.max)
      return { close: () => {
      } };
    const n = ZS(e);
    if (n.grouping && yo.length) {
      const r = yo.find(({ vnode: s }) => {
        var l;
        return ((l = s.props) == null ? void 0 : l.message) === n.message;
      });
      if (r)
        return r.props.repeatNum += 1, r.props.type = n.type, r.handler;
    }
    const o = Ree(n, t);
    return yo.push(o), o.handler;
  };
  JS.forEach((e) => {
    Dl[e] = (t = {}, n) => {
      const o = ZS(t);
      return Dl({ ...o, type: e }, n);
    };
  });
  function xee(e) {
    for (const t of yo)
      (!e || e === t.props.type) && t.handler.close();
  }
  Dl.closeAll = xee;
  Dl._context = null;
  const Dee = rw(Dl, "$message"), Lee = G({
    name: "ElMessageBox",
    directives: {
      TrapFocus: gF
    },
    components: {
      ElButton: gn,
      ElFocusTrap: Zc,
      ElInput: wn,
      ElOverlay: Qh,
      ElIcon: He,
      ...kh
    },
    inheritAttrs: !1,
    props: {
      buttonSize: {
        type: String,
        validator: zc
      },
      modal: {
        type: Boolean,
        default: !0
      },
      lockScroll: {
        type: Boolean,
        default: !0
      },
      showClose: {
        type: Boolean,
        default: !0
      },
      closeOnClickModal: {
        type: Boolean,
        default: !0
      },
      closeOnPressEscape: {
        type: Boolean,
        default: !0
      },
      closeOnHashChange: {
        type: Boolean,
        default: !0
      },
      center: Boolean,
      draggable: Boolean,
      roundButton: {
        default: !1,
        type: Boolean
      },
      container: {
        type: String,
        default: "body"
      },
      boxType: {
        type: String,
        default: ""
      }
    },
    emits: ["vanish", "action"],
    setup(e, { emit: t }) {
      const {
        locale: n,
        zIndex: o,
        ns: r,
        size: s
      } = Xc("message-box", E(() => e.buttonSize)), { t: l } = n, { nextZIndex: a } = o, u = I(!1), c = Tt({
        autofocus: !0,
        beforeClose: null,
        callback: null,
        cancelButtonText: "",
        cancelButtonClass: "",
        confirmButtonText: "",
        confirmButtonClass: "",
        customClass: "",
        customStyle: {},
        dangerouslyUseHTMLString: !1,
        distinguishCancelAndClose: !1,
        icon: "",
        inputPattern: null,
        inputPlaceholder: "",
        inputType: "text",
        inputValue: null,
        inputValidator: null,
        inputErrorMessage: "",
        message: null,
        modalFade: !0,
        modalClass: "",
        showCancelButton: !1,
        showConfirmButton: !0,
        type: "",
        title: void 0,
        showInput: !1,
        action: "",
        confirmButtonLoading: !1,
        cancelButtonLoading: !1,
        confirmButtonDisabled: !1,
        editorErrorMessage: "",
        validateError: !1,
        zIndex: a()
      }), f = E(() => {
        const W = c.type;
        return { [r.bm("icon", W)]: W && Fr[W] };
      }), d = io(), p = io(), h = E(() => c.icon || Fr[c.type] || ""), m = E(() => !!c.message), v = I(), g = I(), y = I(), w = I(), b = I(), C = E(() => c.confirmButtonClass);
      me(() => c.inputValue, async (W) => {
        await Fe(), e.boxType === "prompt" && W !== null && L();
      }, { immediate: !0 }), me(() => u.value, (W) => {
        var x, N;
        W && (e.boxType !== "prompt" && (c.autofocus ? y.value = (N = (x = b.value) == null ? void 0 : x.$el) != null ? N : v.value : y.value = v.value), c.zIndex = a()), e.boxType === "prompt" && (W ? Fe().then(() => {
          var R;
          w.value && w.value.$el && (c.autofocus ? y.value = (R = D()) != null ? R : v.value : y.value = v.value);
        }) : (c.editorErrorMessage = "", c.validateError = !1));
      });
      const _ = E(() => e.draggable);
      lw(v, g, _), st(async () => {
        await Fe(), e.closeOnHashChange && window.addEventListener("hashchange", k);
      }), zt(() => {
        e.closeOnHashChange && window.removeEventListener("hashchange", k);
      });
      function k() {
        !u.value || (u.value = !1, Fe(() => {
          c.action && t("action", c.action);
        }));
      }
      const O = () => {
        e.closeOnClickModal && A(c.distinguishCancelAndClose ? "close" : "cancel");
      }, T = xh(O), P = (W) => {
        if (c.inputType !== "textarea")
          return W.preventDefault(), A("confirm");
      }, A = (W) => {
        var x;
        e.boxType === "prompt" && W === "confirm" && !L() || (c.action = W, c.beforeClose ? (x = c.beforeClose) == null || x.call(c, W, c, k) : k());
      }, L = () => {
        if (e.boxType === "prompt") {
          const W = c.inputPattern;
          if (W && !W.test(c.inputValue || ""))
            return c.editorErrorMessage = c.inputErrorMessage || l("el.messagebox.error"), c.validateError = !0, !1;
          const x = c.inputValidator;
          if (typeof x == "function") {
            const N = x(c.inputValue);
            if (N === !1)
              return c.editorErrorMessage = c.inputErrorMessage || l("el.messagebox.error"), c.validateError = !0, !1;
            if (typeof N == "string")
              return c.editorErrorMessage = N, c.validateError = !0, !1;
          }
        }
        return c.editorErrorMessage = "", c.validateError = !1, !0;
      }, D = () => {
        const W = w.value.$refs;
        return W.input || W.textarea;
      }, B = () => {
        A("close");
      }, F = () => {
        e.closeOnPressEscape && B();
      };
      return e.lockScroll && uw(u), R8(u), {
        ...rn(c),
        ns: r,
        overlayEvent: T,
        visible: u,
        hasMessage: m,
        typeClass: f,
        contentId: d,
        inputId: p,
        btnSize: s,
        iconComponent: h,
        confirmButtonClasses: C,
        rootRef: v,
        focusStartRef: y,
        headerRef: g,
        inputRef: w,
        confirmRef: b,
        doClose: k,
        handleClose: B,
        onCloseRequested: F,
        handleWrapperClick: O,
        handleInputEnter: P,
        handleAction: A,
        t: l
      };
    }
  }), Vee = ["aria-label", "aria-describedby"], Bee = ["aria-label"], Fee = ["id"];
  function Hee(e, t, n, o, r, s) {
    const l = Qe("el-icon"), a = Qe("close"), u = Qe("el-input"), c = Qe("el-button"), f = Qe("el-focus-trap"), d = Qe("el-overlay");
    return S(), ie(Qt, {
      name: "fade-in-linear",
      onAfterLeave: t[11] || (t[11] = (p) => e.$emit("vanish")),
      persisted: ""
    }, {
      default: X(() => [
        ot(K(d, {
          "z-index": e.zIndex,
          "overlay-class": [e.ns.is("message-box"), e.modalClass],
          mask: e.modal
        }, {
          default: X(() => [
            H("div", {
              role: "dialog",
              "aria-label": e.title,
              "aria-modal": "true",
              "aria-describedby": e.showInput ? void 0 : e.contentId,
              class: $(`${e.ns.namespace.value}-overlay-message-box`),
              onClick: t[8] || (t[8] = (...p) => e.overlayEvent.onClick && e.overlayEvent.onClick(...p)),
              onMousedown: t[9] || (t[9] = (...p) => e.overlayEvent.onMousedown && e.overlayEvent.onMousedown(...p)),
              onMouseup: t[10] || (t[10] = (...p) => e.overlayEvent.onMouseup && e.overlayEvent.onMouseup(...p))
            }, [
              K(f, {
                loop: "",
                trapped: e.visible,
                "focus-trap-el": e.rootRef,
                "focus-start-el": e.focusStartRef,
                onReleaseRequested: e.onCloseRequested
              }, {
                default: X(() => [
                  H("div", {
                    ref: "rootRef",
                    class: $([
                      e.ns.b(),
                      e.customClass,
                      e.ns.is("draggable", e.draggable),
                      { [e.ns.m("center")]: e.center }
                    ]),
                    style: Ke(e.customStyle),
                    tabindex: "-1",
                    onClick: t[7] || (t[7] = Ze(() => {
                    }, ["stop"]))
                  }, [
                    e.title !== null && e.title !== void 0 ? (S(), V("div", {
                      key: 0,
                      ref: "headerRef",
                      class: $(e.ns.e("header"))
                    }, [
                      H("div", {
                        class: $(e.ns.e("title"))
                      }, [
                        e.iconComponent && e.center ? (S(), ie(l, {
                          key: 0,
                          class: $([e.ns.e("status"), e.typeClass])
                        }, {
                          default: X(() => [
                            (S(), ie(vt(e.iconComponent)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : se("v-if", !0),
                        H("span", null, Ne(e.title), 1)
                      ], 2),
                      e.showClose ? (S(), V("button", {
                        key: 0,
                        type: "button",
                        class: $(e.ns.e("headerbtn")),
                        "aria-label": e.t("el.messagebox.close"),
                        onClick: t[0] || (t[0] = (p) => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel")),
                        onKeydown: t[1] || (t[1] = Et(Ze((p) => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                      }, [
                        K(l, {
                          class: $(e.ns.e("close"))
                        }, {
                          default: X(() => [
                            K(a)
                          ]),
                          _: 1
                        }, 8, ["class"])
                      ], 42, Bee)) : se("v-if", !0)
                    ], 2)) : se("v-if", !0),
                    H("div", {
                      id: e.contentId,
                      class: $(e.ns.e("content"))
                    }, [
                      H("div", {
                        class: $(e.ns.e("container"))
                      }, [
                        e.iconComponent && !e.center && e.hasMessage ? (S(), ie(l, {
                          key: 0,
                          class: $([e.ns.e("status"), e.typeClass])
                        }, {
                          default: X(() => [
                            (S(), ie(vt(e.iconComponent)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : se("v-if", !0),
                        e.hasMessage ? (S(), V("div", {
                          key: 1,
                          class: $(e.ns.e("message"))
                        }, [
                          he(e.$slots, "default", {}, () => [
                            e.dangerouslyUseHTMLString ? (S(), ie(vt(e.showInput ? "label" : "p"), {
                              key: 1,
                              for: e.showInput ? e.inputId : void 0,
                              innerHTML: e.message
                            }, null, 8, ["for", "innerHTML"])) : (S(), ie(vt(e.showInput ? "label" : "p"), {
                              key: 0,
                              for: e.showInput ? e.inputId : void 0
                            }, {
                              default: X(() => [
                                wt(Ne(e.dangerouslyUseHTMLString ? "" : e.message), 1)
                              ]),
                              _: 1
                            }, 8, ["for"]))
                          ])
                        ], 2)) : se("v-if", !0)
                      ], 2),
                      ot(H("div", {
                        class: $(e.ns.e("input"))
                      }, [
                        K(u, {
                          id: e.inputId,
                          ref: "inputRef",
                          modelValue: e.inputValue,
                          "onUpdate:modelValue": t[2] || (t[2] = (p) => e.inputValue = p),
                          type: e.inputType,
                          placeholder: e.inputPlaceholder,
                          "aria-invalid": e.validateError,
                          class: $({ invalid: e.validateError }),
                          onKeydown: Et(e.handleInputEnter, ["enter"])
                        }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                        H("div", {
                          class: $(e.ns.e("errormsg")),
                          style: Ke({
                            visibility: e.editorErrorMessage ? "visible" : "hidden"
                          })
                        }, Ne(e.editorErrorMessage), 7)
                      ], 2), [
                        [$t, e.showInput]
                      ])
                    ], 10, Fee),
                    H("div", {
                      class: $(e.ns.e("btns"))
                    }, [
                      e.showCancelButton ? (S(), ie(c, {
                        key: 0,
                        loading: e.cancelButtonLoading,
                        class: $([e.cancelButtonClass]),
                        round: e.roundButton,
                        size: e.btnSize,
                        onClick: t[3] || (t[3] = (p) => e.handleAction("cancel")),
                        onKeydown: t[4] || (t[4] = Et(Ze((p) => e.handleAction("cancel"), ["prevent"]), ["enter"]))
                      }, {
                        default: X(() => [
                          wt(Ne(e.cancelButtonText || e.t("el.messagebox.cancel")), 1)
                        ]),
                        _: 1
                      }, 8, ["loading", "class", "round", "size"])) : se("v-if", !0),
                      ot(K(c, {
                        ref: "confirmRef",
                        type: "primary",
                        loading: e.confirmButtonLoading,
                        class: $([e.confirmButtonClasses]),
                        round: e.roundButton,
                        disabled: e.confirmButtonDisabled,
                        size: e.btnSize,
                        onClick: t[5] || (t[5] = (p) => e.handleAction("confirm")),
                        onKeydown: t[6] || (t[6] = Et(Ze((p) => e.handleAction("confirm"), ["prevent"]), ["enter"]))
                      }, {
                        default: X(() => [
                          wt(Ne(e.confirmButtonText || e.t("el.messagebox.confirm")), 1)
                        ]),
                        _: 1
                      }, 8, ["loading", "class", "round", "disabled", "size"]), [
                        [$t, e.showConfirmButton]
                      ])
                    ], 2)
                  ], 6)
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
            ], 42, Vee)
          ]),
          _: 3
        }, 8, ["z-index", "overlay-class", "mask"]), [
          [$t, e.visible]
        ])
      ]),
      _: 3
    });
  }
  var zee = /* @__PURE__ */ Me(Lee, [["render", Hee], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/message-box/src/index.vue"]]);
  const si = /* @__PURE__ */ new Map(), Kee = (e) => {
    let t = document.body;
    return e.appendTo && (et(e.appendTo) && (t = document.querySelector(e.appendTo)), So(e.appendTo) && (t = e.appendTo), So(t) || (yt("ElMessageBox", "the appendTo option is not an HTMLElement. Falling back to document.body."), t = document.body)), t;
  }, jee = (e, t, n = null) => {
    const o = K(zee, e, Ge(e.message) || Bt(e.message) ? {
      default: Ge(e.message) ? e.message : () => e.message
    } : null);
    return o.appContext = n, El(o, t), Kee(e).appendChild(t.firstElementChild), o.component;
  }, Wee = () => document.createElement("div"), Uee = (e, t) => {
    const n = Wee();
    e.onVanish = () => {
      El(null, n), si.delete(r);
    }, e.onAction = (s) => {
      const l = si.get(r);
      let a;
      e.showInput ? a = { value: r.inputValue, action: s } : a = s, e.callback ? e.callback(a, o.proxy) : s === "cancel" || s === "close" ? e.distinguishCancelAndClose && s !== "cancel" ? l.reject("close") : l.reject("cancel") : l.resolve(a);
    };
    const o = jee(e, n, t), r = o.proxy;
    for (const s in e)
      ht(e, s) && !ht(r.$props, s) && (r[s] = e[s]);
    return r.visible = !0, r;
  };
  function Ul(e, t = null) {
    if (!bt)
      return Promise.reject();
    let n;
    return et(e) || Bt(e) ? e = {
      message: e
    } : n = e.callback, new Promise((o, r) => {
      const s = Uee(e, t != null ? t : Ul._context);
      si.set(s, {
        options: e,
        callback: n,
        resolve: o,
        reject: r
      });
    });
  }
  const qee = ["alert", "confirm", "prompt"], Yee = {
    alert: { closeOnPressEscape: !1, closeOnClickModal: !1 },
    confirm: { showCancelButton: !0 },
    prompt: { showCancelButton: !0, showInput: !0 }
  };
  qee.forEach((e) => {
    Ul[e] = Gee(e);
  });
  function Gee(e) {
    return (t, n, o, r) => {
      let s = "";
      return rt(n) ? (o = n, s = "") : pn(n) ? s = "" : s = n, Ul(Object.assign({
        title: s,
        message: t,
        type: "",
        ...Yee[e]
      }, o, {
        boxType: e
      }), r);
    };
  }
  Ul.close = () => {
    si.forEach((e, t) => {
      t.doClose();
    }), si.clear();
  };
  Ul._context = null;
  const Sr = Ul;
  Sr.install = (e) => {
    Sr._context = e._context, e.config.globalProperties.$msgbox = Sr, e.config.globalProperties.$messageBox = Sr, e.config.globalProperties.$alert = Sr.alert, e.config.globalProperties.$confirm = Sr.confirm, e.config.globalProperties.$prompt = Sr.prompt;
  };
  const Xee = Sr, QS = [
    "success",
    "info",
    "warning",
    "error"
  ], Jee = Ie({
    customClass: {
      type: String,
      default: ""
    },
    dangerouslyUseHTMLString: {
      type: Boolean,
      default: !1
    },
    duration: {
      type: Number,
      default: 4500
    },
    icon: {
      type: Vt
    },
    id: {
      type: String,
      default: ""
    },
    message: {
      type: le([String, Object]),
      default: ""
    },
    offset: {
      type: Number,
      default: 0
    },
    onClick: {
      type: le(Function),
      default: () => {
      }
    },
    onClose: {
      type: le(Function),
      required: !0
    },
    position: {
      type: String,
      values: ["top-right", "top-left", "bottom-right", "bottom-left"],
      default: "top-right"
    },
    showClose: {
      type: Boolean,
      default: !0
    },
    title: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      values: [...QS, ""],
      default: ""
    },
    zIndex: {
      type: Number,
      default: 0
    }
  }), Zee = {
    destroy: () => !0
  }, Qee = ["id"], ete = ["textContent"], tte = { key: 0 }, nte = ["innerHTML"], ote = G({
    name: "ElNotification"
  }), rte = /* @__PURE__ */ G({
    ...ote,
    props: Jee,
    emits: Zee,
    setup(e, { expose: t }) {
      const n = e, { ns: o, zIndex: r } = Xc("notification"), { nextZIndex: s, currentZIndex: l } = r, { Close: a } = nw, u = I(!1);
      let c;
      const f = E(() => {
        const b = n.type;
        return b && Fr[n.type] ? o.m(b) : "";
      }), d = E(() => n.type && Fr[n.type] || n.icon), p = E(() => n.position.endsWith("right") ? "right" : "left"), h = E(() => n.position.startsWith("top") ? "top" : "bottom"), m = E(() => ({
        [h.value]: `${n.offset}px`,
        zIndex: l.value
      }));
      function v() {
        n.duration > 0 && ({ stop: c } = Os(() => {
          u.value && y();
        }, n.duration));
      }
      function g() {
        c == null || c();
      }
      function y() {
        u.value = !1;
      }
      function w({ code: b }) {
        b === We.delete || b === We.backspace ? g() : b === We.esc ? u.value && y() : v();
      }
      return st(() => {
        v(), s(), u.value = !0;
      }), Wt(document, "keydown", w), t({
        visible: u,
        close: y
      }), (b, C) => (S(), ie(Qt, {
        name: i(o).b("fade"),
        onBeforeLeave: b.onClose,
        onAfterLeave: C[1] || (C[1] = (_) => b.$emit("destroy")),
        persisted: ""
      }, {
        default: X(() => [
          ot(H("div", {
            id: b.id,
            class: $([i(o).b(), b.customClass, i(p)]),
            style: Ke(i(m)),
            role: "alert",
            onMouseenter: g,
            onMouseleave: v,
            onClick: C[0] || (C[0] = (..._) => b.onClick && b.onClick(..._))
          }, [
            i(d) ? (S(), ie(i(He), {
              key: 0,
              class: $([i(o).e("icon"), i(f)])
            }, {
              default: X(() => [
                (S(), ie(vt(i(d))))
              ]),
              _: 1
            }, 8, ["class"])) : se("v-if", !0),
            H("div", {
              class: $(i(o).e("group"))
            }, [
              H("h2", {
                class: $(i(o).e("title")),
                textContent: Ne(b.title)
              }, null, 10, ete),
              ot(H("div", {
                class: $(i(o).e("content")),
                style: Ke(b.title ? void 0 : { margin: 0 })
              }, [
                he(b.$slots, "default", {}, () => [
                  b.dangerouslyUseHTMLString ? (S(), V(ze, { key: 1 }, [
                    se(" Caution here, message could've been compromised, never use user's input as message "),
                    H("p", { innerHTML: b.message }, null, 8, nte)
                  ], 2112)) : (S(), V("p", tte, Ne(b.message), 1))
                ])
              ], 6), [
                [$t, b.message]
              ]),
              b.showClose ? (S(), ie(i(He), {
                key: 0,
                class: $(i(o).e("closeBtn")),
                onClick: Ze(y, ["stop"])
              }, {
                default: X(() => [
                  K(i(a))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : se("v-if", !0)
            ], 2)
          ], 46, Qee), [
            [$t, u.value]
          ])
        ]),
        _: 3
      }, 8, ["name", "onBeforeLeave"]));
    }
  });
  var ste = /* @__PURE__ */ Me(rte, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/notification/src/notification.vue"]]);
  const fc = {
    "top-left": [],
    "top-right": [],
    "bottom-left": [],
    "bottom-right": []
  }, kp = 16;
  let lte = 1;
  const Ll = function(e = {}, t = null) {
    if (!bt)
      return { close: () => {
      } };
    (typeof e == "string" || Bt(e)) && (e = { message: e });
    const n = e.position || "top-right";
    let o = e.offset || 0;
    fc[n].forEach(({ vm: f }) => {
      var d;
      o += (((d = f.el) == null ? void 0 : d.offsetHeight) || 0) + kp;
    }), o += kp;
    const r = `notification_${lte++}`, s = e.onClose, l = {
      ...e,
      offset: o,
      id: r,
      onClose: () => {
        ate(r, n, s);
      }
    };
    let a = document.body;
    So(e.appendTo) ? a = e.appendTo : et(e.appendTo) && (a = document.querySelector(e.appendTo)), So(a) || (yt("ElNotification", "the appendTo option is not an HTMLElement. Falling back to document.body."), a = document.body);
    const u = document.createElement("div"), c = K(ste, l, Bt(l.message) ? {
      default: () => l.message
    } : null);
    return c.appContext = t != null ? t : Ll._context, c.props.onDestroy = () => {
      El(null, u);
    }, El(c, u), fc[n].push({ vm: c }), a.appendChild(u.firstElementChild), {
      close: () => {
        c.component.exposed.visible.value = !1;
      }
    };
  };
  QS.forEach((e) => {
    Ll[e] = (t = {}) => ((typeof t == "string" || Bt(t)) && (t = {
      message: t
    }), Ll({
      ...t,
      type: e
    }));
  });
  function ate(e, t, n) {
    const o = fc[t], r = o.findIndex(({ vm: c }) => {
      var f;
      return ((f = c.component) == null ? void 0 : f.props.id) === e;
    });
    if (r === -1)
      return;
    const { vm: s } = o[r];
    if (!s)
      return;
    n == null || n(s);
    const l = s.el.offsetHeight, a = t.split("-")[0];
    o.splice(r, 1);
    const u = o.length;
    if (!(u < 1))
      for (let c = r; c < u; c++) {
        const { el: f, component: d } = o[c].vm, p = Number.parseInt(f.style[a], 10) - l - kp;
        d.props.offset = p;
      }
  }
  function ite() {
    for (const e of Object.values(fc))
      e.forEach(({ vm: t }) => {
        t.component.exposed.visible.value = !1;
      });
  }
  Ll.closeAll = ite;
  Ll._context = null;
  const ute = rw(Ll, "$notify");
  var cte = [
    mee,
    Cee,
    Dee,
    Xee,
    ute,
    HE
  ], dte = kL([...uee, ...cte]);
  function fte() {
    return e_().__VUE_DEVTOOLS_GLOBAL_HOOK__;
  }
  function e_() {
    return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {};
  }
  const pte = typeof Proxy == "function", hte = "devtools-plugin:setup", vte = "plugin:settings:set";
  let Us, $p;
  function mte() {
    var e;
    return Us !== void 0 || (typeof window < "u" && window.performance ? (Us = !0, $p = window.performance) : typeof global < "u" && ((e = global.perf_hooks) === null || e === void 0 ? void 0 : e.performance) ? (Us = !0, $p = global.perf_hooks.performance) : Us = !1), Us;
  }
  function gte() {
    return mte() ? $p.now() : Date.now();
  }
  class yte {
    constructor(t, n) {
      this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = n;
      const o = {};
      if (t.settings)
        for (const l in t.settings) {
          const a = t.settings[l];
          o[l] = a.defaultValue;
        }
      const r = `__vue-devtools-plugin-settings__${t.id}`;
      let s = Object.assign({}, o);
      try {
        const l = localStorage.getItem(r), a = JSON.parse(l);
        Object.assign(s, a);
      } catch {
      }
      this.fallbacks = {
        getSettings() {
          return s;
        },
        setSettings(l) {
          try {
            localStorage.setItem(r, JSON.stringify(l));
          } catch {
          }
          s = l;
        },
        now() {
          return gte();
        }
      }, n && n.on(vte, (l, a) => {
        l === this.plugin.id && this.fallbacks.setSettings(a);
      }), this.proxiedOn = new Proxy({}, {
        get: (l, a) => this.target ? this.target.on[a] : (...u) => {
          this.onQueue.push({
            method: a,
            args: u
          });
        }
      }), this.proxiedTarget = new Proxy({}, {
        get: (l, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...u) => (this.targetQueue.push({
          method: a,
          args: u,
          resolve: () => {
          }
        }), this.fallbacks[a](...u)) : (...u) => new Promise((c) => {
          this.targetQueue.push({
            method: a,
            args: u,
            resolve: c
          });
        })
      });
    }
    async setRealTarget(t) {
      this.target = t;
      for (const n of this.onQueue)
        this.target.on[n.method](...n.args);
      for (const n of this.targetQueue)
        n.resolve(await this.target[n.method](...n.args));
    }
  }
  function bte(e, t) {
    const n = e, o = e_(), r = fte(), s = pte && n.enableEarlyProxy;
    if (r && (o.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !s))
      r.emit(hte, e, t);
    else {
      const l = s ? new yte(n, r) : null;
      (o.__VUE_DEVTOOLS_PLUGINS__ = o.__VUE_DEVTOOLS_PLUGINS__ || []).push({
        pluginDescriptor: n,
        setupFn: t,
        proxy: l
      }), l && t(l.proxiedTarget);
    }
  }
  /*!
    * vue-router v4.1.6
    * (c) 2022 Eduardo San Martin Morote
    * @license MIT
    */
  const Zo = typeof window < "u";
  function wte(e) {
    return e.__esModule || e[Symbol.toStringTag] === "Module";
  }
  const Dt = Object.assign;
  function Yd(e, t) {
    const n = {};
    for (const o in t) {
      const r = t[o];
      n[o] = Xn(r) ? r.map(e) : e(r);
    }
    return n;
  }
  const Ea = () => {
  }, Xn = Array.isArray;
  function At(e) {
    const t = Array.from(arguments).slice(1);
    console.warn.apply(console, ["[Vue Router warn]: " + e].concat(t));
  }
  const Cte = /\/$/, Ete = (e) => e.replace(Cte, "");
  function Gd(e, t, n = "/") {
    let o, r = {}, s = "", l = "";
    const a = t.indexOf("#");
    let u = t.indexOf("?");
    return a < u && a >= 0 && (u = -1), u > -1 && (o = t.slice(0, u), s = t.slice(u + 1, a > -1 ? a : t.length), r = e(s)), a > -1 && (o = o || t.slice(0, a), l = t.slice(a, t.length)), o = kte(o != null ? o : t, n), {
      fullPath: o + (s && "?") + s + l,
      path: o,
      query: r,
      hash: l
    };
  }
  function Ste(e, t) {
    const n = t.query ? e(t.query) : "";
    return t.path + (n && "?") + n + (t.hash || "");
  }
  function rb(e, t) {
    return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/";
  }
  function sb(e, t, n) {
    const o = t.matched.length - 1, r = n.matched.length - 1;
    return o > -1 && o === r && jr(t.matched[o], n.matched[r]) && t_(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash;
  }
  function jr(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t);
  }
  function t_(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
    for (const n in e)
      if (!_te(e[n], t[n]))
        return !1;
    return !0;
  }
  function _te(e, t) {
    return Xn(e) ? lb(e, t) : Xn(t) ? lb(t, e) : e === t;
  }
  function lb(e, t) {
    return Xn(t) ? e.length === t.length && e.every((n, o) => n === t[o]) : e.length === 1 && e[0] === t;
  }
  function kte(e, t) {
    if (e.startsWith("/"))
      return e;
    if (process.env.NODE_ENV !== "production" && !t.startsWith("/"))
      return At(`Cannot resolve a relative location without an absolute path. Trying to resolve "${e}" from "${t}". It should look like "/${t}".`), e;
    if (!e)
      return t;
    const n = t.split("/"), o = e.split("/");
    let r = n.length - 1, s, l;
    for (s = 0; s < o.length; s++)
      if (l = o[s], l !== ".")
        if (l === "..")
          r > 1 && r--;
        else
          break;
    return n.slice(0, r).join("/") + "/" + o.slice(s - (s === o.length ? 1 : 0)).join("/");
  }
  var li;
  (function(e) {
    e.pop = "pop", e.push = "push";
  })(li || (li = {}));
  var Sa;
  (function(e) {
    e.back = "back", e.forward = "forward", e.unknown = "";
  })(Sa || (Sa = {}));
  function $te(e) {
    if (!e)
      if (Zo) {
        const t = document.querySelector("base");
        e = t && t.getAttribute("href") || "/", e = e.replace(/^\w+:\/\/[^\/]+/, "");
      } else
        e = "/";
    return e[0] !== "/" && e[0] !== "#" && (e = "/" + e), Ete(e);
  }
  const Nte = /^[^#]+#/;
  function Tte(e, t) {
    return e.replace(Nte, "#") + t;
  }
  function Ote(e, t) {
    const n = document.documentElement.getBoundingClientRect(), o = e.getBoundingClientRect();
    return {
      behavior: t.behavior,
      left: o.left - n.left - (t.left || 0),
      top: o.top - n.top - (t.top || 0)
    };
  }
  const sd = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset
  });
  function Mte(e) {
    let t;
    if ("el" in e) {
      const n = e.el, o = typeof n == "string" && n.startsWith("#");
      if (process.env.NODE_ENV !== "production" && typeof e.el == "string" && (!o || !document.getElementById(e.el.slice(1))))
        try {
          const s = document.querySelector(e.el);
          if (o && s) {
            At(`The selector "${e.el}" should be passed as "el: document.querySelector('${e.el}')" because it starts with "#".`);
            return;
          }
        } catch {
          At(`The selector "${e.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
          return;
        }
      const r = typeof n == "string" ? o ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
      if (!r) {
        process.env.NODE_ENV !== "production" && At(`Couldn't find element using selector "${e.el}" returned by scrollBehavior.`);
        return;
      }
      t = Ote(r, e);
    } else
      t = e;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.pageXOffset, t.top != null ? t.top : window.pageYOffset);
  }
  function ab(e, t) {
    return (history.state ? history.state.position - t : -1) + e;
  }
  const Np = /* @__PURE__ */ new Map();
  function Ite(e, t) {
    Np.set(e, t);
  }
  function Pte(e) {
    const t = Np.get(e);
    return Np.delete(e), t;
  }
  let Ate = () => location.protocol + "//" + location.host;
  function n_(e, t) {
    const { pathname: n, search: o, hash: r } = t, s = e.indexOf("#");
    if (s > -1) {
      let a = r.includes(e.slice(s)) ? e.slice(s).length : 1, u = r.slice(a);
      return u[0] !== "/" && (u = "/" + u), rb(u, "");
    }
    return rb(n, e) + o + r;
  }
  function Rte(e, t, n, o) {
    let r = [], s = [], l = null;
    const a = ({ state: p }) => {
      const h = n_(e, location), m = n.value, v = t.value;
      let g = 0;
      if (p) {
        if (n.value = h, t.value = p, l && l === m) {
          l = null;
          return;
        }
        g = v ? p.position - v.position : 0;
      } else
        o(h);
      r.forEach((y) => {
        y(n.value, m, {
          delta: g,
          type: li.pop,
          direction: g ? g > 0 ? Sa.forward : Sa.back : Sa.unknown
        });
      });
    };
    function u() {
      l = n.value;
    }
    function c(p) {
      r.push(p);
      const h = () => {
        const m = r.indexOf(p);
        m > -1 && r.splice(m, 1);
      };
      return s.push(h), h;
    }
    function f() {
      const { history: p } = window;
      !p.state || p.replaceState(Dt({}, p.state, { scroll: sd() }), "");
    }
    function d() {
      for (const p of s)
        p();
      s = [], window.removeEventListener("popstate", a), window.removeEventListener("beforeunload", f);
    }
    return window.addEventListener("popstate", a), window.addEventListener("beforeunload", f), {
      pauseListeners: u,
      listen: c,
      destroy: d
    };
  }
  function ib(e, t, n, o = !1, r = !1) {
    return {
      back: e,
      current: t,
      forward: n,
      replaced: o,
      position: window.history.length,
      scroll: r ? sd() : null
    };
  }
  function xte(e) {
    const { history: t, location: n } = window, o = {
      value: n_(e, n)
    }, r = { value: t.state };
    r.value || s(o.value, {
      back: null,
      current: o.value,
      forward: null,
      position: t.length - 1,
      replaced: !0,
      scroll: null
    }, !0);
    function s(u, c, f) {
      const d = e.indexOf("#"), p = d > -1 ? (n.host && document.querySelector("base") ? e : e.slice(d)) + u : Ate() + e + u;
      try {
        t[f ? "replaceState" : "pushState"](c, "", p), r.value = c;
      } catch (h) {
        process.env.NODE_ENV !== "production" ? At("Error with push/replace State", h) : console.error(h), n[f ? "replace" : "assign"](p);
      }
    }
    function l(u, c) {
      const f = Dt({}, t.state, ib(
        r.value.back,
        u,
        r.value.forward,
        !0
      ), c, { position: r.value.position });
      s(u, f, !0), o.value = u;
    }
    function a(u, c) {
      const f = Dt(
        {},
        r.value,
        t.state,
        {
          forward: u,
          scroll: sd()
        }
      );
      process.env.NODE_ENV !== "production" && !t.state && At(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:

history.replaceState(history.state, '', url)

You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`), s(f.current, f, !0);
      const d = Dt({}, ib(o.value, u, null), { position: f.position + 1 }, c);
      s(u, d, !1), o.value = u;
    }
    return {
      location: o,
      state: r,
      push: a,
      replace: l
    };
  }
  function Dte(e) {
    e = $te(e);
    const t = xte(e), n = Rte(e, t.state, t.location, t.replace);
    function o(s, l = !0) {
      l || n.pauseListeners(), history.go(s);
    }
    const r = Dt({
      location: "",
      base: e,
      go: o,
      createHref: Tte.bind(null, e)
    }, t, n);
    return Object.defineProperty(r, "location", {
      enumerable: !0,
      get: () => t.location.value
    }), Object.defineProperty(r, "state", {
      enumerable: !0,
      get: () => t.state.value
    }), r;
  }
  function Lte(e) {
    return typeof e == "string" || e && typeof e == "object";
  }
  function o_(e) {
    return typeof e == "string" || typeof e == "symbol";
  }
  const yr = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
  }, Tp = Symbol(process.env.NODE_ENV !== "production" ? "navigation failure" : "");
  var ub;
  (function(e) {
    e[e.aborted = 4] = "aborted", e[e.cancelled = 8] = "cancelled", e[e.duplicated = 16] = "duplicated";
  })(ub || (ub = {}));
  const Vte = {
    [1]({ location: e, currentLocation: t }) {
      return `No match for
 ${JSON.stringify(e)}${t ? `
while being at
` + JSON.stringify(t) : ""}`;
    },
    [2]({ from: e, to: t }) {
      return `Redirected from "${e.fullPath}" to "${Fte(t)}" via a navigation guard.`;
    },
    [4]({ from: e, to: t }) {
      return `Navigation aborted from "${e.fullPath}" to "${t.fullPath}" via a navigation guard.`;
    },
    [8]({ from: e, to: t }) {
      return `Navigation cancelled from "${e.fullPath}" to "${t.fullPath}" with a new navigation.`;
    },
    [16]({ from: e, to: t }) {
      return `Avoided redundant navigation to current location: "${e.fullPath}".`;
    }
  };
  function Vl(e, t) {
    return process.env.NODE_ENV !== "production" ? Dt(new Error(Vte[e](t)), {
      type: e,
      [Tp]: !0
    }, t) : Dt(new Error(), {
      type: e,
      [Tp]: !0
    }, t);
  }
  function Uo(e, t) {
    return e instanceof Error && Tp in e && (t == null || !!(e.type & t));
  }
  const Bte = ["params", "query", "hash"];
  function Fte(e) {
    if (typeof e == "string")
      return e;
    if ("path" in e)
      return e.path;
    const t = {};
    for (const n of Bte)
      n in e && (t[n] = e[n]);
    return JSON.stringify(t, null, 2);
  }
  const cb = "[^/]+?", Hte = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
  }, zte = /[.+*?^${}()[\]/\\]/g;
  function Kte(e, t) {
    const n = Dt({}, Hte, t), o = [];
    let r = n.start ? "^" : "";
    const s = [];
    for (const c of e) {
      const f = c.length ? [] : [90];
      n.strict && !c.length && (r += "/");
      for (let d = 0; d < c.length; d++) {
        const p = c[d];
        let h = 40 + (n.sensitive ? 0.25 : 0);
        if (p.type === 0)
          d || (r += "/"), r += p.value.replace(zte, "\\$&"), h += 40;
        else if (p.type === 1) {
          const { value: m, repeatable: v, optional: g, regexp: y } = p;
          s.push({
            name: m,
            repeatable: v,
            optional: g
          });
          const w = y || cb;
          if (w !== cb) {
            h += 10;
            try {
              new RegExp(`(${w})`);
            } catch (C) {
              throw new Error(`Invalid custom RegExp for param "${m}" (${w}): ` + C.message);
            }
          }
          let b = v ? `((?:${w})(?:/(?:${w}))*)` : `(${w})`;
          d || (b = g && c.length < 2 ? `(?:/${b})` : "/" + b), g && (b += "?"), r += b, h += 20, g && (h += -8), v && (h += -20), w === ".*" && (h += -50);
        }
        f.push(h);
      }
      o.push(f);
    }
    if (n.strict && n.end) {
      const c = o.length - 1;
      o[c][o[c].length - 1] += 0.7000000000000001;
    }
    n.strict || (r += "/?"), n.end ? r += "$" : n.strict && (r += "(?:/|$)");
    const l = new RegExp(r, n.sensitive ? "" : "i");
    function a(c) {
      const f = c.match(l), d = {};
      if (!f)
        return null;
      for (let p = 1; p < f.length; p++) {
        const h = f[p] || "", m = s[p - 1];
        d[m.name] = h && m.repeatable ? h.split("/") : h;
      }
      return d;
    }
    function u(c) {
      let f = "", d = !1;
      for (const p of e) {
        (!d || !f.endsWith("/")) && (f += "/"), d = !1;
        for (const h of p)
          if (h.type === 0)
            f += h.value;
          else if (h.type === 1) {
            const { value: m, repeatable: v, optional: g } = h, y = m in c ? c[m] : "";
            if (Xn(y) && !v)
              throw new Error(`Provided param "${m}" is an array but it is not repeatable (* or + modifiers)`);
            const w = Xn(y) ? y.join("/") : y;
            if (!w)
              if (g)
                p.length < 2 && (f.endsWith("/") ? f = f.slice(0, -1) : d = !0);
              else
                throw new Error(`Missing required param "${m}"`);
            f += w;
          }
      }
      return f || "/";
    }
    return {
      re: l,
      score: o,
      keys: s,
      parse: a,
      stringify: u
    };
  }
  function jte(e, t) {
    let n = 0;
    for (; n < e.length && n < t.length; ) {
      const o = t[n] - e[n];
      if (o)
        return o;
      n++;
    }
    return e.length < t.length ? e.length === 1 && e[0] === 40 + 40 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 40 + 40 ? 1 : -1 : 0;
  }
  function Wte(e, t) {
    let n = 0;
    const o = e.score, r = t.score;
    for (; n < o.length && n < r.length; ) {
      const s = jte(o[n], r[n]);
      if (s)
        return s;
      n++;
    }
    if (Math.abs(r.length - o.length) === 1) {
      if (db(o))
        return 1;
      if (db(r))
        return -1;
    }
    return r.length - o.length;
  }
  function db(e) {
    const t = e[e.length - 1];
    return e.length > 0 && t[t.length - 1] < 0;
  }
  const Ute = {
    type: 0,
    value: ""
  }, qte = /[a-zA-Z0-9_]/;
  function Yte(e) {
    if (!e)
      return [[]];
    if (e === "/")
      return [[Ute]];
    if (!e.startsWith("/"))
      throw new Error(process.env.NODE_ENV !== "production" ? `Route paths should start with a "/": "${e}" should be "/${e}".` : `Invalid path "${e}"`);
    function t(h) {
      throw new Error(`ERR (${n})/"${c}": ${h}`);
    }
    let n = 0, o = n;
    const r = [];
    let s;
    function l() {
      s && r.push(s), s = [];
    }
    let a = 0, u, c = "", f = "";
    function d() {
      !c || (n === 0 ? s.push({
        type: 0,
        value: c
      }) : n === 1 || n === 2 || n === 3 ? (s.length > 1 && (u === "*" || u === "+") && t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), s.push({
        type: 1,
        value: c,
        regexp: f,
        repeatable: u === "*" || u === "+",
        optional: u === "*" || u === "?"
      })) : t("Invalid state to consume buffer"), c = "");
    }
    function p() {
      c += u;
    }
    for (; a < e.length; ) {
      if (u = e[a++], u === "\\" && n !== 2) {
        o = n, n = 4;
        continue;
      }
      switch (n) {
        case 0:
          u === "/" ? (c && d(), l()) : u === ":" ? (d(), n = 1) : p();
          break;
        case 4:
          p(), n = o;
          break;
        case 1:
          u === "(" ? n = 2 : qte.test(u) ? p() : (d(), n = 0, u !== "*" && u !== "?" && u !== "+" && a--);
          break;
        case 2:
          u === ")" ? f[f.length - 1] == "\\" ? f = f.slice(0, -1) + u : n = 3 : f += u;
          break;
        case 3:
          d(), n = 0, u !== "*" && u !== "?" && u !== "+" && a--, f = "";
          break;
        default:
          t("Unknown state");
          break;
      }
    }
    return n === 2 && t(`Unfinished custom RegExp for param "${c}"`), d(), l(), r;
  }
  function Gte(e, t, n) {
    const o = Kte(Yte(e.path), n);
    if (process.env.NODE_ENV !== "production") {
      const s = /* @__PURE__ */ new Set();
      for (const l of o.keys)
        s.has(l.name) && At(`Found duplicated params with name "${l.name}" for path "${e.path}". Only the last one will be available on "$route.params".`), s.add(l.name);
    }
    const r = Dt(o, {
      record: e,
      parent: t,
      children: [],
      alias: []
    });
    return t && !r.record.aliasOf == !t.record.aliasOf && t.children.push(r), r;
  }
  function Xte(e, t) {
    const n = [], o = /* @__PURE__ */ new Map();
    t = hb({ strict: !1, end: !0, sensitive: !1 }, t);
    function r(f) {
      return o.get(f);
    }
    function s(f, d, p) {
      const h = !p, m = Jte(f);
      process.env.NODE_ENV !== "production" && tne(m, d), m.aliasOf = p && p.record;
      const v = hb(t, f), g = [
        m
      ];
      if ("alias" in f) {
        const b = typeof f.alias == "string" ? [f.alias] : f.alias;
        for (const C of b)
          g.push(Dt({}, m, {
            components: p ? p.record.components : m.components,
            path: C,
            aliasOf: p ? p.record : m
          }));
      }
      let y, w;
      for (const b of g) {
        const { path: C } = b;
        if (d && C[0] !== "/") {
          const _ = d.record.path, k = _[_.length - 1] === "/" ? "" : "/";
          b.path = d.record.path + (C && k + C);
        }
        if (process.env.NODE_ENV !== "production" && b.path === "*")
          throw new Error(`Catch all routes ("*") must now be defined using a param with a custom regexp.
See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.`);
        if (y = Gte(b, d, v), process.env.NODE_ENV !== "production" && d && C[0] === "/" && nne(y, d), p ? (p.alias.push(y), process.env.NODE_ENV !== "production" && ene(p, y)) : (w = w || y, w !== y && w.alias.push(y), h && f.name && !pb(y) && l(f.name)), m.children) {
          const _ = m.children;
          for (let k = 0; k < _.length; k++)
            s(_[k], y, p && p.children[k]);
        }
        p = p || y, (y.record.components && Object.keys(y.record.components).length || y.record.name || y.record.redirect) && u(y);
      }
      return w ? () => {
        l(w);
      } : Ea;
    }
    function l(f) {
      if (o_(f)) {
        const d = o.get(f);
        d && (o.delete(f), n.splice(n.indexOf(d), 1), d.children.forEach(l), d.alias.forEach(l));
      } else {
        const d = n.indexOf(f);
        d > -1 && (n.splice(d, 1), f.record.name && o.delete(f.record.name), f.children.forEach(l), f.alias.forEach(l));
      }
    }
    function a() {
      return n;
    }
    function u(f) {
      let d = 0;
      for (; d < n.length && Wte(f, n[d]) >= 0 && (f.record.path !== n[d].record.path || !r_(f, n[d])); )
        d++;
      n.splice(d, 0, f), f.record.name && !pb(f) && o.set(f.record.name, f);
    }
    function c(f, d) {
      let p, h = {}, m, v;
      if ("name" in f && f.name) {
        if (p = o.get(f.name), !p)
          throw Vl(1, {
            location: f
          });
        if (process.env.NODE_ENV !== "production") {
          const w = Object.keys(f.params || {}).filter((b) => !p.keys.find((C) => C.name === b));
          w.length && At(`Discarded invalid param(s) "${w.join('", "')}" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);
        }
        v = p.record.name, h = Dt(
          fb(
            d.params,
            p.keys.filter((w) => !w.optional).map((w) => w.name)
          ),
          f.params && fb(f.params, p.keys.map((w) => w.name))
        ), m = p.stringify(h);
      } else if ("path" in f)
        m = f.path, process.env.NODE_ENV !== "production" && !m.startsWith("/") && At(`The Matcher cannot resolve relative paths but received "${m}". Unless you directly called \`matcher.resolve("${m}")\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`), p = n.find((w) => w.re.test(m)), p && (h = p.parse(m), v = p.record.name);
      else {
        if (p = d.name ? o.get(d.name) : n.find((w) => w.re.test(d.path)), !p)
          throw Vl(1, {
            location: f,
            currentLocation: d
          });
        v = p.record.name, h = Dt({}, d.params, f.params), m = p.stringify(h);
      }
      const g = [];
      let y = p;
      for (; y; )
        g.unshift(y.record), y = y.parent;
      return {
        name: v,
        path: m,
        params: h,
        matched: g,
        meta: Qte(g)
      };
    }
    return e.forEach((f) => s(f)), { addRoute: s, resolve: c, removeRoute: l, getRoutes: a, getRecordMatcher: r };
  }
  function fb(e, t) {
    const n = {};
    for (const o of t)
      o in e && (n[o] = e[o]);
    return n;
  }
  function Jte(e) {
    return {
      path: e.path,
      redirect: e.redirect,
      name: e.name,
      meta: e.meta || {},
      aliasOf: void 0,
      beforeEnter: e.beforeEnter,
      props: Zte(e),
      children: e.children || [],
      instances: {},
      leaveGuards: /* @__PURE__ */ new Set(),
      updateGuards: /* @__PURE__ */ new Set(),
      enterCallbacks: {},
      components: "components" in e ? e.components || null : e.component && { default: e.component }
    };
  }
  function Zte(e) {
    const t = {}, n = e.props || !1;
    if ("component" in e)
      t.default = n;
    else
      for (const o in e.components)
        t[o] = typeof n == "boolean" ? n : n[o];
    return t;
  }
  function pb(e) {
    for (; e; ) {
      if (e.record.aliasOf)
        return !0;
      e = e.parent;
    }
    return !1;
  }
  function Qte(e) {
    return e.reduce((t, n) => Dt(t, n.meta), {});
  }
  function hb(e, t) {
    const n = {};
    for (const o in e)
      n[o] = o in t ? t[o] : e[o];
    return n;
  }
  function Op(e, t) {
    return e.name === t.name && e.optional === t.optional && e.repeatable === t.repeatable;
  }
  function ene(e, t) {
    for (const n of e.keys)
      if (!n.optional && !t.keys.find(Op.bind(null, n)))
        return At(`Alias "${t.record.path}" and the original record: "${e.record.path}" must have the exact same param named "${n.name}"`);
    for (const n of t.keys)
      if (!n.optional && !e.keys.find(Op.bind(null, n)))
        return At(`Alias "${t.record.path}" and the original record: "${e.record.path}" must have the exact same param named "${n.name}"`);
  }
  function tne(e, t) {
    t && t.record.name && !e.name && !e.path && At(`The route named "${String(t.record.name)}" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);
  }
  function nne(e, t) {
    for (const n of t.keys)
      if (!e.keys.find(Op.bind(null, n)))
        return At(`Absolute path "${e.record.path}" must have the exact same param named "${n.name}" as its parent "${t.record.path}".`);
  }
  function r_(e, t) {
    return t.children.some((n) => n === e || r_(e, n));
  }
  const s_ = /#/g, one = /&/g, rne = /\//g, sne = /=/g, lne = /\?/g, l_ = /\+/g, ane = /%5B/g, ine = /%5D/g, a_ = /%5E/g, une = /%60/g, i_ = /%7B/g, cne = /%7C/g, u_ = /%7D/g, dne = /%20/g;
  function Nv(e) {
    return encodeURI("" + e).replace(cne, "|").replace(ane, "[").replace(ine, "]");
  }
  function fne(e) {
    return Nv(e).replace(i_, "{").replace(u_, "}").replace(a_, "^");
  }
  function Mp(e) {
    return Nv(e).replace(l_, "%2B").replace(dne, "+").replace(s_, "%23").replace(one, "%26").replace(une, "`").replace(i_, "{").replace(u_, "}").replace(a_, "^");
  }
  function pne(e) {
    return Mp(e).replace(sne, "%3D");
  }
  function hne(e) {
    return Nv(e).replace(s_, "%23").replace(lne, "%3F");
  }
  function vne(e) {
    return e == null ? "" : hne(e).replace(rne, "%2F");
  }
  function ai(e) {
    try {
      return decodeURIComponent("" + e);
    } catch {
      process.env.NODE_ENV !== "production" && At(`Error decoding "${e}". Using original value`);
    }
    return "" + e;
  }
  function mne(e) {
    const t = {};
    if (e === "" || e === "?")
      return t;
    const o = (e[0] === "?" ? e.slice(1) : e).split("&");
    for (let r = 0; r < o.length; ++r) {
      const s = o[r].replace(l_, " "), l = s.indexOf("="), a = ai(l < 0 ? s : s.slice(0, l)), u = l < 0 ? null : ai(s.slice(l + 1));
      if (a in t) {
        let c = t[a];
        Xn(c) || (c = t[a] = [c]), c.push(u);
      } else
        t[a] = u;
    }
    return t;
  }
  function vb(e) {
    let t = "";
    for (let n in e) {
      const o = e[n];
      if (n = pne(n), o == null) {
        o !== void 0 && (t += (t.length ? "&" : "") + n);
        continue;
      }
      (Xn(o) ? o.map((s) => s && Mp(s)) : [o && Mp(o)]).forEach((s) => {
        s !== void 0 && (t += (t.length ? "&" : "") + n, s != null && (t += "=" + s));
      });
    }
    return t;
  }
  function gne(e) {
    const t = {};
    for (const n in e) {
      const o = e[n];
      o !== void 0 && (t[n] = Xn(o) ? o.map((r) => r == null ? null : "" + r) : o == null ? o : "" + o);
    }
    return t;
  }
  const yne = Symbol(process.env.NODE_ENV !== "production" ? "router view location matched" : ""), mb = Symbol(process.env.NODE_ENV !== "production" ? "router view depth" : ""), ld = Symbol(process.env.NODE_ENV !== "production" ? "router" : ""), c_ = Symbol(process.env.NODE_ENV !== "production" ? "route location" : ""), Ip = Symbol(process.env.NODE_ENV !== "production" ? "router view location" : "");
  function oa() {
    let e = [];
    function t(o) {
      return e.push(o), () => {
        const r = e.indexOf(o);
        r > -1 && e.splice(r, 1);
      };
    }
    function n() {
      e = [];
    }
    return {
      add: t,
      list: () => e,
      reset: n
    };
  }
  function Nr(e, t, n, o, r) {
    const s = o && (o.enterCallbacks[r] = o.enterCallbacks[r] || []);
    return () => new Promise((l, a) => {
      const u = (d) => {
        d === !1 ? a(Vl(4, {
          from: n,
          to: t
        })) : d instanceof Error ? a(d) : Lte(d) ? a(Vl(2, {
          from: t,
          to: d
        })) : (s && o.enterCallbacks[r] === s && typeof d == "function" && s.push(d), l());
      }, c = e.call(o && o.instances[r], t, n, process.env.NODE_ENV !== "production" ? bne(u, t, n) : u);
      let f = Promise.resolve(c);
      if (e.length < 3 && (f = f.then(u)), process.env.NODE_ENV !== "production" && e.length > 2) {
        const d = `The "next" callback was never called inside of ${e.name ? '"' + e.name + '"' : ""}:
${e.toString()}
. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
        if (typeof c == "object" && "then" in c)
          f = f.then((p) => u._called ? p : (At(d), Promise.reject(new Error("Invalid navigation guard"))));
        else if (c !== void 0 && !u._called) {
          At(d), a(new Error("Invalid navigation guard"));
          return;
        }
      }
      f.catch((d) => a(d));
    });
  }
  function bne(e, t, n) {
    let o = 0;
    return function() {
      o++ === 1 && At(`The "next" callback was called more than once in one navigation guard when going from "${n.fullPath}" to "${t.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`), e._called = !0, o === 1 && e.apply(null, arguments);
    };
  }
  function Xd(e, t, n, o) {
    const r = [];
    for (const s of e) {
      process.env.NODE_ENV !== "production" && !s.components && !s.children.length && At(`Record with path "${s.path}" is either missing a "component(s)" or "children" property.`);
      for (const l in s.components) {
        let a = s.components[l];
        if (process.env.NODE_ENV !== "production") {
          if (!a || typeof a != "object" && typeof a != "function")
            throw At(`Component "${l}" in record with path "${s.path}" is not a valid component. Received "${String(a)}".`), new Error("Invalid route component");
          if ("then" in a) {
            At(`Component "${l}" in record with path "${s.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')" ? This will break in production if not fixed.`);
            const u = a;
            a = () => u;
          } else
            a.__asyncLoader && !a.__warnedDefineAsync && (a.__warnedDefineAsync = !0, At(`Component "${l}" in record with path "${s.path}" is defined using "defineAsyncComponent()". Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".`));
        }
        if (!(t !== "beforeRouteEnter" && !s.instances[l]))
          if (wne(a)) {
            const c = (a.__vccOpts || a)[t];
            c && r.push(Nr(c, n, o, s, l));
          } else {
            let u = a();
            process.env.NODE_ENV !== "production" && !("catch" in u) && (At(`Component "${l}" in record with path "${s.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`), u = Promise.resolve(u)), r.push(() => u.then((c) => {
              if (!c)
                return Promise.reject(new Error(`Couldn't resolve component "${l}" at "${s.path}"`));
              const f = wte(c) ? c.default : c;
              s.components[l] = f;
              const p = (f.__vccOpts || f)[t];
              return p && Nr(p, n, o, s, l)();
            }));
          }
      }
    }
    return r;
  }
  function wne(e) {
    return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e;
  }
  function gb(e) {
    const t = Be(ld), n = Be(c_), o = E(() => t.resolve(i(e.to))), r = E(() => {
      const { matched: u } = o.value, { length: c } = u, f = u[c - 1], d = n.matched;
      if (!f || !d.length)
        return -1;
      const p = d.findIndex(jr.bind(null, f));
      if (p > -1)
        return p;
      const h = yb(u[c - 2]);
      return c > 1 && yb(f) === h && d[d.length - 1].path !== h ? d.findIndex(jr.bind(null, u[c - 2])) : p;
    }), s = E(() => r.value > -1 && _ne(n.params, o.value.params)), l = E(() => r.value > -1 && r.value === n.matched.length - 1 && t_(n.params, o.value.params));
    function a(u = {}) {
      return Sne(u) ? t[i(e.replace) ? "replace" : "push"](
        i(e.to)
      ).catch(Ea) : Promise.resolve();
    }
    if ((process.env.NODE_ENV !== "production" || !1) && Zo) {
      const u = it();
      if (u) {
        const c = {
          route: o.value,
          isActive: s.value,
          isExactActive: l.value
        };
        u.__vrl_devtools = u.__vrl_devtools || [], u.__vrl_devtools.push(c), xn(() => {
          c.route = o.value, c.isActive = s.value, c.isExactActive = l.value;
        }, { flush: "post" });
      }
    }
    return {
      route: o,
      href: E(() => o.value.href),
      isActive: s,
      isExactActive: l,
      navigate: a
    };
  }
  const Cne = /* @__PURE__ */ G({
    name: "RouterLink",
    compatConfig: { MODE: 3 },
    props: {
      to: {
        type: [String, Object],
        required: !0
      },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: {
        type: String,
        default: "page"
      }
    },
    useLink: gb,
    setup(e, { slots: t }) {
      const n = Tt(gb(e)), { options: o } = Be(ld), r = E(() => ({
        [bb(e.activeClass, o.linkActiveClass, "router-link-active")]: n.isActive,
        [bb(e.exactActiveClass, o.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
      }));
      return () => {
        const s = t.default && t.default(n);
        return e.custom ? s : je("a", {
          "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
          href: n.href,
          onClick: n.navigate,
          class: r.value
        }, s);
      };
    }
  }), Ene = Cne;
  function Sne(e) {
    if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
      if (e.currentTarget && e.currentTarget.getAttribute) {
        const t = e.currentTarget.getAttribute("target");
        if (/\b_blank\b/i.test(t))
          return;
      }
      return e.preventDefault && e.preventDefault(), !0;
    }
  }
  function _ne(e, t) {
    for (const n in t) {
      const o = t[n], r = e[n];
      if (typeof o == "string") {
        if (o !== r)
          return !1;
      } else if (!Xn(r) || r.length !== o.length || o.some((s, l) => s !== r[l]))
        return !1;
    }
    return !0;
  }
  function yb(e) {
    return e ? e.aliasOf ? e.aliasOf.path : e.path : "";
  }
  const bb = (e, t, n) => e != null ? e : t != null ? t : n, kne = /* @__PURE__ */ G({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
      name: {
        type: String,
        default: "default"
      },
      route: Object
    },
    compatConfig: { MODE: 3 },
    setup(e, { attrs: t, slots: n }) {
      process.env.NODE_ENV !== "production" && Nne();
      const o = Be(Ip), r = E(() => e.route || o.value), s = Be(mb, 0), l = E(() => {
        let c = i(s);
        const { matched: f } = r.value;
        let d;
        for (; (d = f[c]) && !d.components; )
          c++;
        return c;
      }), a = E(() => r.value.matched[l.value]);
      pt(mb, E(() => l.value + 1)), pt(yne, a), pt(Ip, r);
      const u = I();
      return me(() => [u.value, a.value, e.name], ([c, f, d], [p, h, m]) => {
        f && (f.instances[d] = c, h && h !== f && c && c === p && (f.leaveGuards.size || (f.leaveGuards = h.leaveGuards), f.updateGuards.size || (f.updateGuards = h.updateGuards))), c && f && (!h || !jr(f, h) || !p) && (f.enterCallbacks[d] || []).forEach((v) => v(c));
      }, { flush: "post" }), () => {
        const c = r.value, f = e.name, d = a.value, p = d && d.components[f];
        if (!p)
          return wb(n.default, { Component: p, route: c });
        const h = d.props[f], m = h ? h === !0 ? c.params : typeof h == "function" ? h(c) : h : null, g = je(p, Dt({}, m, t, {
          onVnodeUnmounted: (y) => {
            y.component.isUnmounted && (d.instances[f] = null);
          },
          ref: u
        }));
        if ((process.env.NODE_ENV !== "production" || !1) && Zo && g.ref) {
          const y = {
            depth: l.value,
            name: d.name,
            path: d.path,
            meta: d.meta
          };
          (Xn(g.ref) ? g.ref.map((b) => b.i) : [g.ref.i]).forEach((b) => {
            b.__vrv_devtools = y;
          });
        }
        return wb(n.default, { Component: g, route: c }) || g;
      };
    }
  });
  function wb(e, t) {
    if (!e)
      return null;
    const n = e(t);
    return n.length === 1 ? n[0] : n;
  }
  const $ne = kne;
  function Nne() {
    const e = it(), t = e.parent && e.parent.type.name;
    if (t && (t === "KeepAlive" || t.includes("Transition"))) {
      const n = t === "KeepAlive" ? "keep-alive" : "transition";
      At(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${n}>
    <component :is="Component" />
  </${n}>
</router-view>`);
    }
  }
  function ra(e, t) {
    const n = Dt({}, e, {
      matched: e.matched.map((o) => Dne(o, ["instances", "children", "aliasOf"]))
    });
    return {
      _custom: {
        type: null,
        readOnly: !0,
        display: e.fullPath,
        tooltip: t,
        value: n
      }
    };
  }
  function eu(e) {
    return {
      _custom: {
        display: e
      }
    };
  }
  let Tne = 0;
  function One(e, t, n) {
    if (t.__hasDevtools)
      return;
    t.__hasDevtools = !0;
    const o = Tne++;
    bte({
      id: "org.vuejs.router" + (o ? "." + o : ""),
      label: "Vue Router",
      packageName: "vue-router",
      homepage: "https://router.vuejs.org",
      logo: "https://router.vuejs.org/logo.png",
      componentStateTypes: ["Routing"],
      app: e
    }, (r) => {
      typeof r.now != "function" && console.warn("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), r.on.inspectComponent((f, d) => {
        f.instanceData && f.instanceData.state.push({
          type: "Routing",
          key: "$route",
          editable: !1,
          value: ra(t.currentRoute.value, "Current Route")
        });
      }), r.on.visitComponentTree(({ treeNode: f, componentInstance: d }) => {
        if (d.__vrv_devtools) {
          const p = d.__vrv_devtools;
          f.tags.push({
            label: (p.name ? `${p.name.toString()}: ` : "") + p.path,
            textColor: 0,
            tooltip: "This component is rendered by &lt;router-view&gt;",
            backgroundColor: d_
          });
        }
        Xn(d.__vrl_devtools) && (d.__devtoolsApi = r, d.__vrl_devtools.forEach((p) => {
          let h = h_, m = "";
          p.isExactActive ? (h = p_, m = "This is exactly active") : p.isActive && (h = f_, m = "This link is active"), f.tags.push({
            label: p.route.path,
            textColor: 0,
            tooltip: m,
            backgroundColor: h
          });
        }));
      }), me(t.currentRoute, () => {
        u(), r.notifyComponentUpdate(), r.sendInspectorTree(a), r.sendInspectorState(a);
      });
      const s = "router:navigations:" + o;
      r.addTimelineLayer({
        id: s,
        label: `Router${o ? " " + o : ""} Navigations`,
        color: 4237508
      }), t.onError((f, d) => {
        r.addTimelineEvent({
          layerId: s,
          event: {
            title: "Error during Navigation",
            subtitle: d.fullPath,
            logType: "error",
            time: r.now(),
            data: { error: f },
            groupId: d.meta.__navigationId
          }
        });
      });
      let l = 0;
      t.beforeEach((f, d) => {
        const p = {
          guard: eu("beforeEach"),
          from: ra(d, "Current Location during this navigation"),
          to: ra(f, "Target location")
        };
        Object.defineProperty(f.meta, "__navigationId", {
          value: l++
        }), r.addTimelineEvent({
          layerId: s,
          event: {
            time: r.now(),
            title: "Start of navigation",
            subtitle: f.fullPath,
            data: p,
            groupId: f.meta.__navigationId
          }
        });
      }), t.afterEach((f, d, p) => {
        const h = {
          guard: eu("afterEach")
        };
        p ? (h.failure = {
          _custom: {
            type: Error,
            readOnly: !0,
            display: p ? p.message : "",
            tooltip: "Navigation Failure",
            value: p
          }
        }, h.status = eu("\u274C")) : h.status = eu("\u2705"), h.from = ra(d, "Current Location during this navigation"), h.to = ra(f, "Target location"), r.addTimelineEvent({
          layerId: s,
          event: {
            title: "End of navigation",
            subtitle: f.fullPath,
            time: r.now(),
            data: h,
            logType: p ? "warning" : "default",
            groupId: f.meta.__navigationId
          }
        });
      });
      const a = "router-inspector:" + o;
      r.addInspector({
        id: a,
        label: "Routes" + (o ? " " + o : ""),
        icon: "book",
        treeFilterPlaceholder: "Search routes"
      });
      function u() {
        if (!c)
          return;
        const f = c;
        let d = n.getRoutes().filter((p) => !p.parent);
        d.forEach(g_), f.filter && (d = d.filter((p) => Pp(p, f.filter.toLowerCase()))), d.forEach((p) => m_(p, t.currentRoute.value)), f.rootNodes = d.map(v_);
      }
      let c;
      r.on.getInspectorTree((f) => {
        c = f, f.app === e && f.inspectorId === a && u();
      }), r.on.getInspectorState((f) => {
        if (f.app === e && f.inspectorId === a) {
          const p = n.getRoutes().find((h) => h.record.__vd_id === f.nodeId);
          p && (f.state = {
            options: Ine(p)
          });
        }
      }), r.sendInspectorTree(a), r.sendInspectorState(a);
    });
  }
  function Mne(e) {
    return e.optional ? e.repeatable ? "*" : "?" : e.repeatable ? "+" : "";
  }
  function Ine(e) {
    const { record: t } = e, n = [
      { editable: !1, key: "path", value: t.path }
    ];
    return t.name != null && n.push({
      editable: !1,
      key: "name",
      value: t.name
    }), n.push({ editable: !1, key: "regexp", value: e.re }), e.keys.length && n.push({
      editable: !1,
      key: "keys",
      value: {
        _custom: {
          type: null,
          readOnly: !0,
          display: e.keys.map((o) => `${o.name}${Mne(o)}`).join(" "),
          tooltip: "Param keys",
          value: e.keys
        }
      }
    }), t.redirect != null && n.push({
      editable: !1,
      key: "redirect",
      value: t.redirect
    }), e.alias.length && n.push({
      editable: !1,
      key: "aliases",
      value: e.alias.map((o) => o.record.path)
    }), Object.keys(e.record.meta).length && n.push({
      editable: !1,
      key: "meta",
      value: e.record.meta
    }), n.push({
      key: "score",
      editable: !1,
      value: {
        _custom: {
          type: null,
          readOnly: !0,
          display: e.score.map((o) => o.join(", ")).join(" | "),
          tooltip: "Score used to sort routes",
          value: e.score
        }
      }
    }), n;
  }
  const d_ = 15485081, f_ = 2450411, p_ = 8702998, Pne = 2282478, h_ = 16486972, Ane = 6710886;
  function v_(e) {
    const t = [], { record: n } = e;
    n.name != null && t.push({
      label: String(n.name),
      textColor: 0,
      backgroundColor: Pne
    }), n.aliasOf && t.push({
      label: "alias",
      textColor: 0,
      backgroundColor: h_
    }), e.__vd_match && t.push({
      label: "matches",
      textColor: 0,
      backgroundColor: d_
    }), e.__vd_exactActive && t.push({
      label: "exact",
      textColor: 0,
      backgroundColor: p_
    }), e.__vd_active && t.push({
      label: "active",
      textColor: 0,
      backgroundColor: f_
    }), n.redirect && t.push({
      label: typeof n.redirect == "string" ? `redirect: ${n.redirect}` : "redirects",
      textColor: 16777215,
      backgroundColor: Ane
    });
    let o = n.__vd_id;
    return o == null && (o = String(Rne++), n.__vd_id = o), {
      id: o,
      label: n.path,
      tags: t,
      children: e.children.map(v_)
    };
  }
  let Rne = 0;
  const xne = /^\/(.*)\/([a-z]*)$/;
  function m_(e, t) {
    const n = t.matched.length && jr(t.matched[t.matched.length - 1], e.record);
    e.__vd_exactActive = e.__vd_active = n, n || (e.__vd_active = t.matched.some((o) => jr(o, e.record))), e.children.forEach((o) => m_(o, t));
  }
  function g_(e) {
    e.__vd_match = !1, e.children.forEach(g_);
  }
  function Pp(e, t) {
    const n = String(e.re).match(xne);
    if (e.__vd_match = !1, !n || n.length < 3)
      return !1;
    if (new RegExp(n[1].replace(/\$$/, ""), n[2]).test(t))
      return e.children.forEach((l) => Pp(l, t)), e.record.path !== "/" || t === "/" ? (e.__vd_match = e.re.test(t), !0) : !1;
    const r = e.record.path.toLowerCase(), s = ai(r);
    return !t.startsWith("/") && (s.includes(t) || r.includes(t)) || s.startsWith(t) || r.startsWith(t) || e.record.name && String(e.record.name).includes(t) ? !0 : e.children.some((l) => Pp(l, t));
  }
  function Dne(e, t) {
    const n = {};
    for (const o in e)
      t.includes(o) || (n[o] = e[o]);
    return n;
  }
  function Lne(e) {
    const t = Xte(e.routes, e), n = e.parseQuery || mne, o = e.stringifyQuery || vb, r = e.history;
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error('Provide the "history" option when calling "createRouter()": https://next.router.vuejs.org/api/#history.');
    const s = oa(), l = oa(), a = oa(), u = xt(yr);
    let c = yr;
    Zo && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const f = Yd.bind(null, (J) => "" + J), d = Yd.bind(null, vne), p = Yd.bind(null, ai);
    function h(J, ee) {
      let ne, Y;
      return o_(J) ? (ne = t.getRecordMatcher(J), Y = ee) : Y = J, t.addRoute(Y, ne);
    }
    function m(J) {
      const ee = t.getRecordMatcher(J);
      ee ? t.removeRoute(ee) : process.env.NODE_ENV !== "production" && At(`Cannot remove non-existent route "${String(J)}"`);
    }
    function v() {
      return t.getRoutes().map((J) => J.record);
    }
    function g(J) {
      return !!t.getRecordMatcher(J);
    }
    function y(J, ee) {
      if (ee = Dt({}, ee || u.value), typeof J == "string") {
        const Pe = Gd(n, J, ee.path), z = t.resolve({ path: Pe.path }, ee), Q = r.createHref(Pe.fullPath);
        return process.env.NODE_ENV !== "production" && (Q.startsWith("//") ? At(`Location "${J}" resolved to "${Q}". A resolved location cannot start with multiple slashes.`) : z.matched.length || At(`No match found for location with path "${J}"`)), Dt(Pe, z, {
          params: p(z.params),
          hash: ai(Pe.hash),
          redirectedFrom: void 0,
          href: Q
        });
      }
      let ne;
      if ("path" in J)
        process.env.NODE_ENV !== "production" && "params" in J && !("name" in J) && Object.keys(J.params).length && At(`Path "${J.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`), ne = Dt({}, J, {
          path: Gd(n, J.path, ee.path).path
        });
      else {
        const Pe = Dt({}, J.params);
        for (const z in Pe)
          Pe[z] == null && delete Pe[z];
        ne = Dt({}, J, {
          params: d(J.params)
        }), ee.params = d(ee.params);
      }
      const Y = t.resolve(ne, ee), re = J.hash || "";
      process.env.NODE_ENV !== "production" && re && !re.startsWith("#") && At(`A \`hash\` should always start with the character "#". Replace "${re}" with "#${re}".`), Y.params = f(p(Y.params));
      const ce = Ste(o, Dt({}, J, {
        hash: fne(re),
        path: Y.path
      })), Te = r.createHref(ce);
      return process.env.NODE_ENV !== "production" && (Te.startsWith("//") ? At(`Location "${J}" resolved to "${Te}". A resolved location cannot start with multiple slashes.`) : Y.matched.length || At(`No match found for location with path "${"path" in J ? J.path : J}"`)), Dt({
        fullPath: ce,
        hash: re,
        query: o === vb ? gne(J.query) : J.query || {}
      }, Y, {
        redirectedFrom: void 0,
        href: Te
      });
    }
    function w(J) {
      return typeof J == "string" ? Gd(n, J, u.value.path) : Dt({}, J);
    }
    function b(J, ee) {
      if (c !== J)
        return Vl(8, {
          from: ee,
          to: J
        });
    }
    function C(J) {
      return O(J);
    }
    function _(J) {
      return C(Dt(w(J), { replace: !0 }));
    }
    function k(J) {
      const ee = J.matched[J.matched.length - 1];
      if (ee && ee.redirect) {
        const { redirect: ne } = ee;
        let Y = typeof ne == "function" ? ne(J) : ne;
        if (typeof Y == "string" && (Y = Y.includes("?") || Y.includes("#") ? Y = w(Y) : { path: Y }, Y.params = {}), process.env.NODE_ENV !== "production" && !("path" in Y) && !("name" in Y))
          throw At(`Invalid redirect found:
${JSON.stringify(Y, null, 2)}
 when navigating to "${J.fullPath}". A redirect must contain a name or path. This will break in production.`), new Error("Invalid redirect");
        return Dt({
          query: J.query,
          hash: J.hash,
          params: "path" in Y ? {} : J.params
        }, Y);
      }
    }
    function O(J, ee) {
      const ne = c = y(J), Y = u.value, re = J.state, ce = J.force, Te = J.replace === !0, Pe = k(ne);
      if (Pe)
        return O(
          Dt(w(Pe), {
            state: typeof Pe == "object" ? Dt({}, re, Pe.state) : re,
            force: ce,
            replace: Te
          }),
          ee || ne
        );
      const z = ne;
      z.redirectedFrom = ee;
      let Q;
      return !ce && sb(o, Y, ne) && (Q = Vl(16, { to: z, from: Y }), j(
        Y,
        Y,
        !0,
        !1
      )), (Q ? Promise.resolve(Q) : P(z, Y)).catch((de) => Uo(de) ? Uo(de, 2) ? de : M(de) : N(de, z, Y)).then((de) => {
        if (de) {
          if (Uo(de, 2))
            return process.env.NODE_ENV !== "production" && sb(o, y(de.to), z) && ee && (ee._count = ee._count ? ee._count + 1 : 1) > 10 ? (At(`Detected an infinite redirection in a navigation guard when going from "${Y.fullPath}" to "${z.fullPath}". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`), Promise.reject(new Error("Infinite redirect in navigation guard"))) : O(
              Dt({
                replace: Te
              }, w(de.to), {
                state: typeof de.to == "object" ? Dt({}, re, de.to.state) : re,
                force: ce
              }),
              ee || z
            );
        } else
          de = L(z, Y, !0, Te, re);
        return A(z, Y, de), de;
      });
    }
    function T(J, ee) {
      const ne = b(J, ee);
      return ne ? Promise.reject(ne) : Promise.resolve();
    }
    function P(J, ee) {
      let ne;
      const [Y, re, ce] = Vne(J, ee);
      ne = Xd(Y.reverse(), "beforeRouteLeave", J, ee);
      for (const Pe of Y)
        Pe.leaveGuards.forEach((z) => {
          ne.push(Nr(z, J, ee));
        });
      const Te = T.bind(null, J, ee);
      return ne.push(Te), qs(ne).then(() => {
        ne = [];
        for (const Pe of s.list())
          ne.push(Nr(Pe, J, ee));
        return ne.push(Te), qs(ne);
      }).then(() => {
        ne = Xd(re, "beforeRouteUpdate", J, ee);
        for (const Pe of re)
          Pe.updateGuards.forEach((z) => {
            ne.push(Nr(z, J, ee));
          });
        return ne.push(Te), qs(ne);
      }).then(() => {
        ne = [];
        for (const Pe of J.matched)
          if (Pe.beforeEnter && !ee.matched.includes(Pe))
            if (Xn(Pe.beforeEnter))
              for (const z of Pe.beforeEnter)
                ne.push(Nr(z, J, ee));
            else
              ne.push(Nr(Pe.beforeEnter, J, ee));
        return ne.push(Te), qs(ne);
      }).then(() => (J.matched.forEach((Pe) => Pe.enterCallbacks = {}), ne = Xd(ce, "beforeRouteEnter", J, ee), ne.push(Te), qs(ne))).then(() => {
        ne = [];
        for (const Pe of l.list())
          ne.push(Nr(Pe, J, ee));
        return ne.push(Te), qs(ne);
      }).catch((Pe) => Uo(Pe, 8) ? Pe : Promise.reject(Pe));
    }
    function A(J, ee, ne) {
      for (const Y of a.list())
        Y(J, ee, ne);
    }
    function L(J, ee, ne, Y, re) {
      const ce = b(J, ee);
      if (ce)
        return ce;
      const Te = ee === yr, Pe = Zo ? history.state : {};
      ne && (Y || Te ? r.replace(J.fullPath, Dt({
        scroll: Te && Pe && Pe.scroll
      }, re)) : r.push(J.fullPath, re)), u.value = J, j(J, ee, ne, Te), M();
    }
    let D;
    function B() {
      D || (D = r.listen((J, ee, ne) => {
        const Y = y(J), re = k(Y);
        if (re) {
          O(Dt(re, { replace: !0 }), Y).catch(Ea);
          return;
        }
        c = Y;
        const ce = u.value;
        Zo && Ite(ab(ce.fullPath, ne.delta), sd()), P(Y, ce).catch((Te) => Uo(Te, 12) ? Te : Uo(Te, 2) ? (O(
          Te.to,
          Y
        ).then((Pe) => {
          Uo(Pe, 20) && !ne.delta && ne.type === li.pop && r.go(-1, !1);
        }).catch(Ea), Promise.reject()) : (ne.delta && r.go(-ne.delta, !1), N(Te, Y, ce))).then((Te) => {
          Te = Te || L(
            Y,
            ce,
            !1
          ), Te && (ne.delta && !Uo(Te, 8) ? r.go(-ne.delta, !1) : ne.type === li.pop && Uo(Te, 20) && r.go(-1, !1)), A(Y, ce, Te);
        }).catch(Ea);
      }));
    }
    let F = oa(), W = oa(), x;
    function N(J, ee, ne) {
      M(J);
      const Y = W.list();
      return Y.length ? Y.forEach((re) => re(J, ee, ne)) : (process.env.NODE_ENV !== "production" && At("uncaught error during route navigation:"), console.error(J)), Promise.reject(J);
    }
    function R() {
      return x && u.value !== yr ? Promise.resolve() : new Promise((J, ee) => {
        F.add([J, ee]);
      });
    }
    function M(J) {
      return x || (x = !J, B(), F.list().forEach(([ee, ne]) => J ? ne(J) : ee()), F.reset()), J;
    }
    function j(J, ee, ne, Y) {
      const { scrollBehavior: re } = e;
      if (!Zo || !re)
        return Promise.resolve();
      const ce = !ne && Pte(ab(J.fullPath, 0)) || (Y || !ne) && history.state && history.state.scroll || null;
      return Fe().then(() => re(J, ee, ce)).then((Te) => Te && Mte(Te)).catch((Te) => N(Te, J, ee));
    }
    const te = (J) => r.go(J);
    let U;
    const Z = /* @__PURE__ */ new Set();
    return {
      currentRoute: u,
      listening: !0,
      addRoute: h,
      removeRoute: m,
      hasRoute: g,
      getRoutes: v,
      resolve: y,
      options: e,
      push: C,
      replace: _,
      go: te,
      back: () => te(-1),
      forward: () => te(1),
      beforeEach: s.add,
      beforeResolve: l.add,
      afterEach: a.add,
      onError: W.add,
      isReady: R,
      install(J) {
        const ee = this;
        J.component("RouterLink", Ene), J.component("RouterView", $ne), J.config.globalProperties.$router = ee, Object.defineProperty(J.config.globalProperties, "$route", {
          enumerable: !0,
          get: () => i(u)
        }), Zo && !U && u.value === yr && (U = !0, C(r.location).catch((re) => {
          process.env.NODE_ENV !== "production" && At("Unexpected error when starting the router:", re);
        }));
        const ne = {};
        for (const re in yr)
          ne[re] = E(() => u.value[re]);
        J.provide(ld, ee), J.provide(c_, Tt(ne)), J.provide(Ip, u);
        const Y = J.unmount;
        Z.add(J), J.unmount = function() {
          Z.delete(J), Z.size < 1 && (c = yr, D && D(), D = null, u.value = yr, U = !1, x = !1), Y();
        }, (process.env.NODE_ENV !== "production" || !1) && Zo && One(J, ee, t);
      }
    };
  }
  function qs(e) {
    return e.reduce((t, n) => t.then(() => n()), Promise.resolve());
  }
  function Vne(e, t) {
    const n = [], o = [], r = [], s = Math.max(t.matched.length, e.matched.length);
    for (let l = 0; l < s; l++) {
      const a = t.matched[l];
      a && (e.matched.find((c) => jr(c, a)) ? o.push(a) : n.push(a));
      const u = e.matched[l];
      u && (t.matched.find((c) => jr(c, u)) || r.push(u));
    }
    return [n, o, r];
  }
  function Bne() {
    return Be(ld);
  }
  function y_(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  }
  const { toString: Fne } = Object.prototype, { getPrototypeOf: Tv } = Object, ad = ((e) => (t) => {
    const n = Fne.call(t);
    return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null)), jo = (e) => (e = e.toLowerCase(), (t) => ad(t) === e), id = (e) => (t) => typeof t === e, { isArray: ql } = Array, ii = id("undefined");
  function Hne(e) {
    return e !== null && !ii(e) && e.constructor !== null && !ii(e.constructor) && oo(e.constructor.isBuffer) && e.constructor.isBuffer(e);
  }
  const b_ = jo("ArrayBuffer");
  function zne(e) {
    let t;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && b_(e.buffer), t;
  }
  const Kne = id("string"), oo = id("function"), w_ = id("number"), ud = (e) => e !== null && typeof e == "object", jne = (e) => e === !0 || e === !1, Pu = (e) => {
    if (ad(e) !== "object")
      return !1;
    const t = Tv(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
  }, Wne = jo("Date"), Une = jo("File"), qne = jo("Blob"), Yne = jo("FileList"), Gne = (e) => ud(e) && oo(e.pipe), Xne = (e) => {
    let t;
    return e && (typeof FormData == "function" && e instanceof FormData || oo(e.append) && ((t = ad(e)) === "formdata" || t === "object" && oo(e.toString) && e.toString() === "[object FormData]"));
  }, Jne = jo("URLSearchParams"), Zne = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function Ti(e, t, { allOwnKeys: n = !1 } = {}) {
    if (e === null || typeof e > "u")
      return;
    let o, r;
    if (typeof e != "object" && (e = [e]), ql(e))
      for (o = 0, r = e.length; o < r; o++)
        t.call(null, e[o], o, e);
    else {
      const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e), l = s.length;
      let a;
      for (o = 0; o < l; o++)
        a = s[o], t.call(null, e[a], a, e);
    }
  }
  function C_(e, t) {
    t = t.toLowerCase();
    const n = Object.keys(e);
    let o = n.length, r;
    for (; o-- > 0; )
      if (r = n[o], t === r.toLowerCase())
        return r;
    return null;
  }
  const E_ = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), S_ = (e) => !ii(e) && e !== E_;
  function Ap() {
    const { caseless: e } = S_(this) && this || {}, t = {}, n = (o, r) => {
      const s = e && C_(t, r) || r;
      Pu(t[s]) && Pu(o) ? t[s] = Ap(t[s], o) : Pu(o) ? t[s] = Ap({}, o) : ql(o) ? t[s] = o.slice() : t[s] = o;
    };
    for (let o = 0, r = arguments.length; o < r; o++)
      arguments[o] && Ti(arguments[o], n);
    return t;
  }
  const Qne = (e, t, n, { allOwnKeys: o } = {}) => (Ti(t, (r, s) => {
    n && oo(r) ? e[s] = y_(r, n) : e[s] = r;
  }, { allOwnKeys: o }), e), eoe = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), toe = (e, t, n, o) => {
    e.prototype = Object.create(t.prototype, o), e.prototype.constructor = e, Object.defineProperty(e, "super", {
      value: t.prototype
    }), n && Object.assign(e.prototype, n);
  }, noe = (e, t, n, o) => {
    let r, s, l;
    const a = {};
    if (t = t || {}, e == null)
      return t;
    do {
      for (r = Object.getOwnPropertyNames(e), s = r.length; s-- > 0; )
        l = r[s], (!o || o(l, e, t)) && !a[l] && (t[l] = e[l], a[l] = !0);
      e = n !== !1 && Tv(e);
    } while (e && (!n || n(e, t)) && e !== Object.prototype);
    return t;
  }, ooe = (e, t, n) => {
    e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
    const o = e.indexOf(t, n);
    return o !== -1 && o === n;
  }, roe = (e) => {
    if (!e)
      return null;
    if (ql(e))
      return e;
    let t = e.length;
    if (!w_(t))
      return null;
    const n = new Array(t);
    for (; t-- > 0; )
      n[t] = e[t];
    return n;
  }, soe = ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Tv(Uint8Array)), loe = (e, t) => {
    const o = (e && e[Symbol.iterator]).call(e);
    let r;
    for (; (r = o.next()) && !r.done; ) {
      const s = r.value;
      t.call(e, s[0], s[1]);
    }
  }, aoe = (e, t) => {
    let n;
    const o = [];
    for (; (n = e.exec(t)) !== null; )
      o.push(n);
    return o;
  }, ioe = jo("HTMLFormElement"), uoe = (e) => e.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function(n, o, r) {
      return o.toUpperCase() + r;
    }
  ), Cb = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), coe = jo("RegExp"), __ = (e, t) => {
    const n = Object.getOwnPropertyDescriptors(e), o = {};
    Ti(n, (r, s) => {
      let l;
      (l = t(r, s, e)) !== !1 && (o[s] = l || r);
    }), Object.defineProperties(e, o);
  }, doe = (e) => {
    __(e, (t, n) => {
      if (oo(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
        return !1;
      const o = e[n];
      if (!!oo(o)) {
        if (t.enumerable = !1, "writable" in t) {
          t.writable = !1;
          return;
        }
        t.set || (t.set = () => {
          throw Error("Can not rewrite read-only method '" + n + "'");
        });
      }
    });
  }, foe = (e, t) => {
    const n = {}, o = (r) => {
      r.forEach((s) => {
        n[s] = !0;
      });
    };
    return ql(e) ? o(e) : o(String(e).split(t)), n;
  }, poe = () => {
  }, hoe = (e, t) => (e = +e, Number.isFinite(e) ? e : t), Jd = "abcdefghijklmnopqrstuvwxyz", Eb = "0123456789", k_ = {
    DIGIT: Eb,
    ALPHA: Jd,
    ALPHA_DIGIT: Jd + Jd.toUpperCase() + Eb
  }, voe = (e = 16, t = k_.ALPHA_DIGIT) => {
    let n = "";
    const { length: o } = t;
    for (; e--; )
      n += t[Math.random() * o | 0];
    return n;
  };
  function moe(e) {
    return !!(e && oo(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
  }
  const goe = (e) => {
    const t = new Array(10), n = (o, r) => {
      if (ud(o)) {
        if (t.indexOf(o) >= 0)
          return;
        if (!("toJSON" in o)) {
          t[r] = o;
          const s = ql(o) ? [] : {};
          return Ti(o, (l, a) => {
            const u = n(l, r + 1);
            !ii(u) && (s[a] = u);
          }), t[r] = void 0, s;
        }
      }
      return o;
    };
    return n(e, 0);
  }, yoe = jo("AsyncFunction"), boe = (e) => e && (ud(e) || oo(e)) && oo(e.then) && oo(e.catch), Ve = {
    isArray: ql,
    isArrayBuffer: b_,
    isBuffer: Hne,
    isFormData: Xne,
    isArrayBufferView: zne,
    isString: Kne,
    isNumber: w_,
    isBoolean: jne,
    isObject: ud,
    isPlainObject: Pu,
    isUndefined: ii,
    isDate: Wne,
    isFile: Une,
    isBlob: qne,
    isRegExp: coe,
    isFunction: oo,
    isStream: Gne,
    isURLSearchParams: Jne,
    isTypedArray: soe,
    isFileList: Yne,
    forEach: Ti,
    merge: Ap,
    extend: Qne,
    trim: Zne,
    stripBOM: eoe,
    inherits: toe,
    toFlatObject: noe,
    kindOf: ad,
    kindOfTest: jo,
    endsWith: ooe,
    toArray: roe,
    forEachEntry: loe,
    matchAll: aoe,
    isHTMLForm: ioe,
    hasOwnProperty: Cb,
    hasOwnProp: Cb,
    reduceDescriptors: __,
    freezeMethods: doe,
    toObjectSet: foe,
    toCamelCase: uoe,
    noop: poe,
    toFiniteNumber: hoe,
    findKey: C_,
    global: E_,
    isContextDefined: S_,
    ALPHABET: k_,
    generateString: voe,
    isSpecCompliantForm: moe,
    toJSONObject: goe,
    isAsyncFn: yoe,
    isThenable: boe
  };
  function Rt(e, t, n, o, r) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), o && (this.request = o), r && (this.response = r);
  }
  Ve.inherits(Rt, Error, {
    toJSON: function() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: Ve.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  const $_ = Rt.prototype, N_ = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
  ].forEach((e) => {
    N_[e] = { value: e };
  });
  Object.defineProperties(Rt, N_);
  Object.defineProperty($_, "isAxiosError", { value: !0 });
  Rt.from = (e, t, n, o, r, s) => {
    const l = Object.create($_);
    return Ve.toFlatObject(e, l, function(u) {
      return u !== Error.prototype;
    }, (a) => a !== "isAxiosError"), Rt.call(l, e.message, t, n, o, r), l.cause = e, l.name = e.name, s && Object.assign(l, s), l;
  };
  const woe = null;
  function Rp(e) {
    return Ve.isPlainObject(e) || Ve.isArray(e);
  }
  function T_(e) {
    return Ve.endsWith(e, "[]") ? e.slice(0, -2) : e;
  }
  function Sb(e, t, n) {
    return e ? e.concat(t).map(function(r, s) {
      return r = T_(r), !n && s ? "[" + r + "]" : r;
    }).join(n ? "." : "") : t;
  }
  function Coe(e) {
    return Ve.isArray(e) && !e.some(Rp);
  }
  const Eoe = Ve.toFlatObject(Ve, {}, null, function(t) {
    return /^is[A-Z]/.test(t);
  });
  function cd(e, t, n) {
    if (!Ve.isObject(e))
      throw new TypeError("target must be an object");
    t = t || new FormData(), n = Ve.toFlatObject(n, {
      metaTokens: !0,
      dots: !1,
      indexes: !1
    }, !1, function(v, g) {
      return !Ve.isUndefined(g[v]);
    });
    const o = n.metaTokens, r = n.visitor || f, s = n.dots, l = n.indexes, u = (n.Blob || typeof Blob < "u" && Blob) && Ve.isSpecCompliantForm(t);
    if (!Ve.isFunction(r))
      throw new TypeError("visitor must be a function");
    function c(m) {
      if (m === null)
        return "";
      if (Ve.isDate(m))
        return m.toISOString();
      if (!u && Ve.isBlob(m))
        throw new Rt("Blob is not supported. Use a Buffer instead.");
      return Ve.isArrayBuffer(m) || Ve.isTypedArray(m) ? u && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m;
    }
    function f(m, v, g) {
      let y = m;
      if (m && !g && typeof m == "object") {
        if (Ve.endsWith(v, "{}"))
          v = o ? v : v.slice(0, -2), m = JSON.stringify(m);
        else if (Ve.isArray(m) && Coe(m) || (Ve.isFileList(m) || Ve.endsWith(v, "[]")) && (y = Ve.toArray(m)))
          return v = T_(v), y.forEach(function(b, C) {
            !(Ve.isUndefined(b) || b === null) && t.append(
              l === !0 ? Sb([v], C, s) : l === null ? v : v + "[]",
              c(b)
            );
          }), !1;
      }
      return Rp(m) ? !0 : (t.append(Sb(g, v, s), c(m)), !1);
    }
    const d = [], p = Object.assign(Eoe, {
      defaultVisitor: f,
      convertValue: c,
      isVisitable: Rp
    });
    function h(m, v) {
      if (!Ve.isUndefined(m)) {
        if (d.indexOf(m) !== -1)
          throw Error("Circular reference detected in " + v.join("."));
        d.push(m), Ve.forEach(m, function(y, w) {
          (!(Ve.isUndefined(y) || y === null) && r.call(
            t,
            y,
            Ve.isString(w) ? w.trim() : w,
            v,
            p
          )) === !0 && h(y, v ? v.concat(w) : [w]);
        }), d.pop();
      }
    }
    if (!Ve.isObject(e))
      throw new TypeError("data must be an object");
    return h(e), t;
  }
  function _b(e) {
    const t = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(o) {
      return t[o];
    });
  }
  function Ov(e, t) {
    this._pairs = [], e && cd(e, this, t);
  }
  const O_ = Ov.prototype;
  O_.append = function(t, n) {
    this._pairs.push([t, n]);
  };
  O_.toString = function(t) {
    const n = t ? function(o) {
      return t.call(this, o, _b);
    } : _b;
    return this._pairs.map(function(r) {
      return n(r[0]) + "=" + n(r[1]);
    }, "").join("&");
  };
  function Soe(e) {
    return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function M_(e, t, n) {
    if (!t)
      return e;
    const o = n && n.encode || Soe, r = n && n.serialize;
    let s;
    if (r ? s = r(t, n) : s = Ve.isURLSearchParams(t) ? t.toString() : new Ov(t, n).toString(o), s) {
      const l = e.indexOf("#");
      l !== -1 && (e = e.slice(0, l)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
    }
    return e;
  }
  class _oe {
    constructor() {
      this.handlers = [];
    }
    use(t, n, o) {
      return this.handlers.push({
        fulfilled: t,
        rejected: n,
        synchronous: o ? o.synchronous : !1,
        runWhen: o ? o.runWhen : null
      }), this.handlers.length - 1;
    }
    eject(t) {
      this.handlers[t] && (this.handlers[t] = null);
    }
    clear() {
      this.handlers && (this.handlers = []);
    }
    forEach(t) {
      Ve.forEach(this.handlers, function(o) {
        o !== null && t(o);
      });
    }
  }
  const kb = _oe, I_ = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  }, koe = typeof URLSearchParams < "u" ? URLSearchParams : Ov, $oe = typeof FormData < "u" ? FormData : null, Noe = typeof Blob < "u" ? Blob : null, Toe = (() => {
    let e;
    return typeof navigator < "u" && ((e = navigator.product) === "ReactNative" || e === "NativeScript" || e === "NS") ? !1 : typeof window < "u" && typeof document < "u";
  })(), Ooe = (() => typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), bo = {
    isBrowser: !0,
    classes: {
      URLSearchParams: koe,
      FormData: $oe,
      Blob: Noe
    },
    isStandardBrowserEnv: Toe,
    isStandardBrowserWebWorkerEnv: Ooe,
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  function Moe(e, t) {
    return cd(e, new bo.classes.URLSearchParams(), Object.assign({
      visitor: function(n, o, r, s) {
        return bo.isNode && Ve.isBuffer(n) ? (this.append(o, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
      }
    }, t));
  }
  function Ioe(e) {
    return Ve.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
  }
  function Poe(e) {
    const t = {}, n = Object.keys(e);
    let o;
    const r = n.length;
    let s;
    for (o = 0; o < r; o++)
      s = n[o], t[s] = e[s];
    return t;
  }
  function P_(e) {
    function t(n, o, r, s) {
      let l = n[s++];
      const a = Number.isFinite(+l), u = s >= n.length;
      return l = !l && Ve.isArray(r) ? r.length : l, u ? (Ve.hasOwnProp(r, l) ? r[l] = [r[l], o] : r[l] = o, !a) : ((!r[l] || !Ve.isObject(r[l])) && (r[l] = []), t(n, o, r[l], s) && Ve.isArray(r[l]) && (r[l] = Poe(r[l])), !a);
    }
    if (Ve.isFormData(e) && Ve.isFunction(e.entries)) {
      const n = {};
      return Ve.forEachEntry(e, (o, r) => {
        t(Ioe(o), r, n, 0);
      }), n;
    }
    return null;
  }
  function Aoe(e, t, n) {
    if (Ve.isString(e))
      try {
        return (t || JSON.parse)(e), Ve.trim(e);
      } catch (o) {
        if (o.name !== "SyntaxError")
          throw o;
      }
    return (n || JSON.stringify)(e);
  }
  const Mv = {
    transitional: I_,
    adapter: bo.isNode ? "http" : "xhr",
    transformRequest: [function(t, n) {
      const o = n.getContentType() || "", r = o.indexOf("application/json") > -1, s = Ve.isObject(t);
      if (s && Ve.isHTMLForm(t) && (t = new FormData(t)), Ve.isFormData(t))
        return r && r ? JSON.stringify(P_(t)) : t;
      if (Ve.isArrayBuffer(t) || Ve.isBuffer(t) || Ve.isStream(t) || Ve.isFile(t) || Ve.isBlob(t))
        return t;
      if (Ve.isArrayBufferView(t))
        return t.buffer;
      if (Ve.isURLSearchParams(t))
        return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
      let a;
      if (s) {
        if (o.indexOf("application/x-www-form-urlencoded") > -1)
          return Moe(t, this.formSerializer).toString();
        if ((a = Ve.isFileList(t)) || o.indexOf("multipart/form-data") > -1) {
          const u = this.env && this.env.FormData;
          return cd(
            a ? { "files[]": t } : t,
            u && new u(),
            this.formSerializer
          );
        }
      }
      return s || r ? (n.setContentType("application/json", !1), Aoe(t)) : t;
    }],
    transformResponse: [function(t) {
      const n = this.transitional || Mv.transitional, o = n && n.forcedJSONParsing, r = this.responseType === "json";
      if (t && Ve.isString(t) && (o && !this.responseType || r)) {
        const l = !(n && n.silentJSONParsing) && r;
        try {
          return JSON.parse(t);
        } catch (a) {
          if (l)
            throw a.name === "SyntaxError" ? Rt.from(a, Rt.ERR_BAD_RESPONSE, this, null, this.response) : a;
        }
      }
      return t;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: bo.classes.FormData,
      Blob: bo.classes.Blob
    },
    validateStatus: function(t) {
      return t >= 200 && t < 300;
    },
    headers: {
      common: {
        Accept: "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  Ve.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
    Mv.headers[e] = {};
  });
  const Iv = Mv, Roe = Ve.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]), xoe = (e) => {
    const t = {};
    let n, o, r;
    return e && e.split(`
`).forEach(function(l) {
      r = l.indexOf(":"), n = l.substring(0, r).trim().toLowerCase(), o = l.substring(r + 1).trim(), !(!n || t[n] && Roe[n]) && (n === "set-cookie" ? t[n] ? t[n].push(o) : t[n] = [o] : t[n] = t[n] ? t[n] + ", " + o : o);
    }), t;
  }, $b = Symbol("internals");
  function sa(e) {
    return e && String(e).trim().toLowerCase();
  }
  function Au(e) {
    return e === !1 || e == null ? e : Ve.isArray(e) ? e.map(Au) : String(e);
  }
  function Doe(e) {
    const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let o;
    for (; o = n.exec(e); )
      t[o[1]] = o[2];
    return t;
  }
  const Loe = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
  function Zd(e, t, n, o, r) {
    if (Ve.isFunction(o))
      return o.call(this, t, n);
    if (r && (t = n), !!Ve.isString(t)) {
      if (Ve.isString(o))
        return t.indexOf(o) !== -1;
      if (Ve.isRegExp(o))
        return o.test(t);
    }
  }
  function Voe(e) {
    return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, o) => n.toUpperCase() + o);
  }
  function Boe(e, t) {
    const n = Ve.toCamelCase(" " + t);
    ["get", "set", "has"].forEach((o) => {
      Object.defineProperty(e, o + n, {
        value: function(r, s, l) {
          return this[o].call(this, t, r, s, l);
        },
        configurable: !0
      });
    });
  }
  class dd {
    constructor(t) {
      t && this.set(t);
    }
    set(t, n, o) {
      const r = this;
      function s(a, u, c) {
        const f = sa(u);
        if (!f)
          throw new Error("header name must be a non-empty string");
        const d = Ve.findKey(r, f);
        (!d || r[d] === void 0 || c === !0 || c === void 0 && r[d] !== !1) && (r[d || u] = Au(a));
      }
      const l = (a, u) => Ve.forEach(a, (c, f) => s(c, f, u));
      return Ve.isPlainObject(t) || t instanceof this.constructor ? l(t, n) : Ve.isString(t) && (t = t.trim()) && !Loe(t) ? l(xoe(t), n) : t != null && s(n, t, o), this;
    }
    get(t, n) {
      if (t = sa(t), t) {
        const o = Ve.findKey(this, t);
        if (o) {
          const r = this[o];
          if (!n)
            return r;
          if (n === !0)
            return Doe(r);
          if (Ve.isFunction(n))
            return n.call(this, r, o);
          if (Ve.isRegExp(n))
            return n.exec(r);
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(t, n) {
      if (t = sa(t), t) {
        const o = Ve.findKey(this, t);
        return !!(o && this[o] !== void 0 && (!n || Zd(this, this[o], o, n)));
      }
      return !1;
    }
    delete(t, n) {
      const o = this;
      let r = !1;
      function s(l) {
        if (l = sa(l), l) {
          const a = Ve.findKey(o, l);
          a && (!n || Zd(o, o[a], a, n)) && (delete o[a], r = !0);
        }
      }
      return Ve.isArray(t) ? t.forEach(s) : s(t), r;
    }
    clear(t) {
      const n = Object.keys(this);
      let o = n.length, r = !1;
      for (; o--; ) {
        const s = n[o];
        (!t || Zd(this, this[s], s, t, !0)) && (delete this[s], r = !0);
      }
      return r;
    }
    normalize(t) {
      const n = this, o = {};
      return Ve.forEach(this, (r, s) => {
        const l = Ve.findKey(o, s);
        if (l) {
          n[l] = Au(r), delete n[s];
          return;
        }
        const a = t ? Voe(s) : String(s).trim();
        a !== s && delete n[s], n[a] = Au(r), o[a] = !0;
      }), this;
    }
    concat(...t) {
      return this.constructor.concat(this, ...t);
    }
    toJSON(t) {
      const n = /* @__PURE__ */ Object.create(null);
      return Ve.forEach(this, (o, r) => {
        o != null && o !== !1 && (n[r] = t && Ve.isArray(o) ? o.join(", ") : o);
      }), n;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(t) {
      return t instanceof this ? t : new this(t);
    }
    static concat(t, ...n) {
      const o = new this(t);
      return n.forEach((r) => o.set(r)), o;
    }
    static accessor(t) {
      const o = (this[$b] = this[$b] = {
        accessors: {}
      }).accessors, r = this.prototype;
      function s(l) {
        const a = sa(l);
        o[a] || (Boe(r, l), o[a] = !0);
      }
      return Ve.isArray(t) ? t.forEach(s) : s(t), this;
    }
  }
  dd.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  Ve.reduceDescriptors(dd.prototype, ({ value: e }, t) => {
    let n = t[0].toUpperCase() + t.slice(1);
    return {
      get: () => e,
      set(o) {
        this[n] = o;
      }
    };
  });
  Ve.freezeMethods(dd);
  const rr = dd;
  function Qd(e, t) {
    const n = this || Iv, o = t || n, r = rr.from(o.headers);
    let s = o.data;
    return Ve.forEach(e, function(a) {
      s = a.call(n, s, r.normalize(), t ? t.status : void 0);
    }), r.normalize(), s;
  }
  function A_(e) {
    return !!(e && e.__CANCEL__);
  }
  function Oi(e, t, n) {
    Rt.call(this, e == null ? "canceled" : e, Rt.ERR_CANCELED, t, n), this.name = "CanceledError";
  }
  Ve.inherits(Oi, Rt, {
    __CANCEL__: !0
  });
  function Foe(e, t, n) {
    const o = n.config.validateStatus;
    !n.status || !o || o(n.status) ? e(n) : t(new Rt(
      "Request failed with status code " + n.status,
      [Rt.ERR_BAD_REQUEST, Rt.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
      n.config,
      n.request,
      n
    ));
  }
  const Hoe = bo.isStandardBrowserEnv ? function() {
    return {
      write: function(n, o, r, s, l, a) {
        const u = [];
        u.push(n + "=" + encodeURIComponent(o)), Ve.isNumber(r) && u.push("expires=" + new Date(r).toGMTString()), Ve.isString(s) && u.push("path=" + s), Ve.isString(l) && u.push("domain=" + l), a === !0 && u.push("secure"), document.cookie = u.join("; ");
      },
      read: function(n) {
        const o = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
        return o ? decodeURIComponent(o[3]) : null;
      },
      remove: function(n) {
        this.write(n, "", Date.now() - 864e5);
      }
    };
  }() : function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }();
  function zoe(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
  }
  function Koe(e, t) {
    return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
  }
  function R_(e, t) {
    return e && !zoe(t) ? Koe(e, t) : t;
  }
  const joe = bo.isStandardBrowserEnv ? function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a");
    let o;
    function r(s) {
      let l = s;
      return t && (n.setAttribute("href", l), l = n.href), n.setAttribute("href", l), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return o = r(window.location.href), function(l) {
      const a = Ve.isString(l) ? r(l) : l;
      return a.protocol === o.protocol && a.host === o.host;
    };
  }() : function() {
    return function() {
      return !0;
    };
  }();
  function Woe(e) {
    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
    return t && t[1] || "";
  }
  function Uoe(e, t) {
    e = e || 10;
    const n = new Array(e), o = new Array(e);
    let r = 0, s = 0, l;
    return t = t !== void 0 ? t : 1e3, function(u) {
      const c = Date.now(), f = o[s];
      l || (l = c), n[r] = u, o[r] = c;
      let d = s, p = 0;
      for (; d !== r; )
        p += n[d++], d = d % e;
      if (r = (r + 1) % e, r === s && (s = (s + 1) % e), c - l < t)
        return;
      const h = f && c - f;
      return h ? Math.round(p * 1e3 / h) : void 0;
    };
  }
  function Nb(e, t) {
    let n = 0;
    const o = Uoe(50, 250);
    return (r) => {
      const s = r.loaded, l = r.lengthComputable ? r.total : void 0, a = s - n, u = o(a), c = s <= l;
      n = s;
      const f = {
        loaded: s,
        total: l,
        progress: l ? s / l : void 0,
        bytes: a,
        rate: u || void 0,
        estimated: u && l && c ? (l - s) / u : void 0,
        event: r
      };
      f[t ? "download" : "upload"] = !0, e(f);
    };
  }
  const qoe = typeof XMLHttpRequest < "u", Yoe = qoe && function(e) {
    return new Promise(function(n, o) {
      let r = e.data;
      const s = rr.from(e.headers).normalize(), l = e.responseType;
      let a;
      function u() {
        e.cancelToken && e.cancelToken.unsubscribe(a), e.signal && e.signal.removeEventListener("abort", a);
      }
      Ve.isFormData(r) && (bo.isStandardBrowserEnv || bo.isStandardBrowserWebWorkerEnv ? s.setContentType(!1) : s.setContentType("multipart/form-data;", !1));
      let c = new XMLHttpRequest();
      if (e.auth) {
        const h = e.auth.username || "", m = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
        s.set("Authorization", "Basic " + btoa(h + ":" + m));
      }
      const f = R_(e.baseURL, e.url);
      c.open(e.method.toUpperCase(), M_(f, e.params, e.paramsSerializer), !0), c.timeout = e.timeout;
      function d() {
        if (!c)
          return;
        const h = rr.from(
          "getAllResponseHeaders" in c && c.getAllResponseHeaders()
        ), v = {
          data: !l || l === "text" || l === "json" ? c.responseText : c.response,
          status: c.status,
          statusText: c.statusText,
          headers: h,
          config: e,
          request: c
        };
        Foe(function(y) {
          n(y), u();
        }, function(y) {
          o(y), u();
        }, v), c = null;
      }
      if ("onloadend" in c ? c.onloadend = d : c.onreadystatechange = function() {
        !c || c.readyState !== 4 || c.status === 0 && !(c.responseURL && c.responseURL.indexOf("file:") === 0) || setTimeout(d);
      }, c.onabort = function() {
        !c || (o(new Rt("Request aborted", Rt.ECONNABORTED, e, c)), c = null);
      }, c.onerror = function() {
        o(new Rt("Network Error", Rt.ERR_NETWORK, e, c)), c = null;
      }, c.ontimeout = function() {
        let m = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
        const v = e.transitional || I_;
        e.timeoutErrorMessage && (m = e.timeoutErrorMessage), o(new Rt(
          m,
          v.clarifyTimeoutError ? Rt.ETIMEDOUT : Rt.ECONNABORTED,
          e,
          c
        )), c = null;
      }, bo.isStandardBrowserEnv) {
        const h = (e.withCredentials || joe(f)) && e.xsrfCookieName && Hoe.read(e.xsrfCookieName);
        h && s.set(e.xsrfHeaderName, h);
      }
      r === void 0 && s.setContentType(null), "setRequestHeader" in c && Ve.forEach(s.toJSON(), function(m, v) {
        c.setRequestHeader(v, m);
      }), Ve.isUndefined(e.withCredentials) || (c.withCredentials = !!e.withCredentials), l && l !== "json" && (c.responseType = e.responseType), typeof e.onDownloadProgress == "function" && c.addEventListener("progress", Nb(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && c.upload && c.upload.addEventListener("progress", Nb(e.onUploadProgress)), (e.cancelToken || e.signal) && (a = (h) => {
        !c || (o(!h || h.type ? new Oi(null, e, c) : h), c.abort(), c = null);
      }, e.cancelToken && e.cancelToken.subscribe(a), e.signal && (e.signal.aborted ? a() : e.signal.addEventListener("abort", a)));
      const p = Woe(f);
      if (p && bo.protocols.indexOf(p) === -1) {
        o(new Rt("Unsupported protocol " + p + ":", Rt.ERR_BAD_REQUEST, e));
        return;
      }
      c.send(r || null);
    });
  }, Ru = {
    http: woe,
    xhr: Yoe
  };
  Ve.forEach(Ru, (e, t) => {
    if (e) {
      try {
        Object.defineProperty(e, "name", { value: t });
      } catch {
      }
      Object.defineProperty(e, "adapterName", { value: t });
    }
  });
  const x_ = {
    getAdapter: (e) => {
      e = Ve.isArray(e) ? e : [e];
      const { length: t } = e;
      let n, o;
      for (let r = 0; r < t && (n = e[r], !(o = Ve.isString(n) ? Ru[n.toLowerCase()] : n)); r++)
        ;
      if (!o)
        throw o === !1 ? new Rt(
          `Adapter ${n} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        ) : new Error(
          Ve.hasOwnProp(Ru, n) ? `Adapter '${n}' is not available in the build` : `Unknown adapter '${n}'`
        );
      if (!Ve.isFunction(o))
        throw new TypeError("adapter is not a function");
      return o;
    },
    adapters: Ru
  };
  function ef(e) {
    if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
      throw new Oi(null, e);
  }
  function Tb(e) {
    return ef(e), e.headers = rr.from(e.headers), e.data = Qd.call(
      e,
      e.transformRequest
    ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), x_.getAdapter(e.adapter || Iv.adapter)(e).then(function(o) {
      return ef(e), o.data = Qd.call(
        e,
        e.transformResponse,
        o
      ), o.headers = rr.from(o.headers), o;
    }, function(o) {
      return A_(o) || (ef(e), o && o.response && (o.response.data = Qd.call(
        e,
        e.transformResponse,
        o.response
      ), o.response.headers = rr.from(o.response.headers))), Promise.reject(o);
    });
  }
  const Ob = (e) => e instanceof rr ? e.toJSON() : e;
  function Bl(e, t) {
    t = t || {};
    const n = {};
    function o(c, f, d) {
      return Ve.isPlainObject(c) && Ve.isPlainObject(f) ? Ve.merge.call({ caseless: d }, c, f) : Ve.isPlainObject(f) ? Ve.merge({}, f) : Ve.isArray(f) ? f.slice() : f;
    }
    function r(c, f, d) {
      if (Ve.isUndefined(f)) {
        if (!Ve.isUndefined(c))
          return o(void 0, c, d);
      } else
        return o(c, f, d);
    }
    function s(c, f) {
      if (!Ve.isUndefined(f))
        return o(void 0, f);
    }
    function l(c, f) {
      if (Ve.isUndefined(f)) {
        if (!Ve.isUndefined(c))
          return o(void 0, c);
      } else
        return o(void 0, f);
    }
    function a(c, f, d) {
      if (d in t)
        return o(c, f);
      if (d in e)
        return o(void 0, c);
    }
    const u = {
      url: s,
      method: s,
      data: s,
      baseURL: l,
      transformRequest: l,
      transformResponse: l,
      paramsSerializer: l,
      timeout: l,
      timeoutMessage: l,
      withCredentials: l,
      adapter: l,
      responseType: l,
      xsrfCookieName: l,
      xsrfHeaderName: l,
      onUploadProgress: l,
      onDownloadProgress: l,
      decompress: l,
      maxContentLength: l,
      maxBodyLength: l,
      beforeRedirect: l,
      transport: l,
      httpAgent: l,
      httpsAgent: l,
      cancelToken: l,
      socketPath: l,
      responseEncoding: l,
      validateStatus: a,
      headers: (c, f) => r(Ob(c), Ob(f), !0)
    };
    return Ve.forEach(Object.keys(Object.assign({}, e, t)), function(f) {
      const d = u[f] || r, p = d(e[f], t[f], f);
      Ve.isUndefined(p) && d !== a || (n[f] = p);
    }), n;
  }
  const D_ = "1.5.0", Pv = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
    Pv[e] = function(o) {
      return typeof o === e || "a" + (t < 1 ? "n " : " ") + e;
    };
  });
  const Mb = {};
  Pv.transitional = function(t, n, o) {
    function r(s, l) {
      return "[Axios v" + D_ + "] Transitional option '" + s + "'" + l + (o ? ". " + o : "");
    }
    return (s, l, a) => {
      if (t === !1)
        throw new Rt(
          r(l, " has been removed" + (n ? " in " + n : "")),
          Rt.ERR_DEPRECATED
        );
      return n && !Mb[l] && (Mb[l] = !0, console.warn(
        r(
          l,
          " has been deprecated since v" + n + " and will be removed in the near future"
        )
      )), t ? t(s, l, a) : !0;
    };
  };
  function Goe(e, t, n) {
    if (typeof e != "object")
      throw new Rt("options must be an object", Rt.ERR_BAD_OPTION_VALUE);
    const o = Object.keys(e);
    let r = o.length;
    for (; r-- > 0; ) {
      const s = o[r], l = t[s];
      if (l) {
        const a = e[s], u = a === void 0 || l(a, s, e);
        if (u !== !0)
          throw new Rt("option " + s + " must be " + u, Rt.ERR_BAD_OPTION_VALUE);
        continue;
      }
      if (n !== !0)
        throw new Rt("Unknown option " + s, Rt.ERR_BAD_OPTION);
    }
  }
  const xp = {
    assertOptions: Goe,
    validators: Pv
  }, br = xp.validators;
  class pc {
    constructor(t) {
      this.defaults = t, this.interceptors = {
        request: new kb(),
        response: new kb()
      };
    }
    request(t, n) {
      typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Bl(this.defaults, n);
      const { transitional: o, paramsSerializer: r, headers: s } = n;
      o !== void 0 && xp.assertOptions(o, {
        silentJSONParsing: br.transitional(br.boolean),
        forcedJSONParsing: br.transitional(br.boolean),
        clarifyTimeoutError: br.transitional(br.boolean)
      }, !1), r != null && (Ve.isFunction(r) ? n.paramsSerializer = {
        serialize: r
      } : xp.assertOptions(r, {
        encode: br.function,
        serialize: br.function
      }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
      let l = s && Ve.merge(
        s.common,
        s[n.method]
      );
      s && Ve.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (m) => {
          delete s[m];
        }
      ), n.headers = rr.concat(l, s);
      const a = [];
      let u = !0;
      this.interceptors.request.forEach(function(v) {
        typeof v.runWhen == "function" && v.runWhen(n) === !1 || (u = u && v.synchronous, a.unshift(v.fulfilled, v.rejected));
      });
      const c = [];
      this.interceptors.response.forEach(function(v) {
        c.push(v.fulfilled, v.rejected);
      });
      let f, d = 0, p;
      if (!u) {
        const m = [Tb.bind(this), void 0];
        for (m.unshift.apply(m, a), m.push.apply(m, c), p = m.length, f = Promise.resolve(n); d < p; )
          f = f.then(m[d++], m[d++]);
        return f;
      }
      p = a.length;
      let h = n;
      for (d = 0; d < p; ) {
        const m = a[d++], v = a[d++];
        try {
          h = m(h);
        } catch (g) {
          v.call(this, g);
          break;
        }
      }
      try {
        f = Tb.call(this, h);
      } catch (m) {
        return Promise.reject(m);
      }
      for (d = 0, p = c.length; d < p; )
        f = f.then(c[d++], c[d++]);
      return f;
    }
    getUri(t) {
      t = Bl(this.defaults, t);
      const n = R_(t.baseURL, t.url);
      return M_(n, t.params, t.paramsSerializer);
    }
  }
  Ve.forEach(["delete", "get", "head", "options"], function(t) {
    pc.prototype[t] = function(n, o) {
      return this.request(Bl(o || {}, {
        method: t,
        url: n,
        data: (o || {}).data
      }));
    };
  });
  Ve.forEach(["post", "put", "patch"], function(t) {
    function n(o) {
      return function(s, l, a) {
        return this.request(Bl(a || {}, {
          method: t,
          headers: o ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: s,
          data: l
        }));
      };
    }
    pc.prototype[t] = n(), pc.prototype[t + "Form"] = n(!0);
  });
  const xu = pc;
  class Av {
    constructor(t) {
      if (typeof t != "function")
        throw new TypeError("executor must be a function.");
      let n;
      this.promise = new Promise(function(s) {
        n = s;
      });
      const o = this;
      this.promise.then((r) => {
        if (!o._listeners)
          return;
        let s = o._listeners.length;
        for (; s-- > 0; )
          o._listeners[s](r);
        o._listeners = null;
      }), this.promise.then = (r) => {
        let s;
        const l = new Promise((a) => {
          o.subscribe(a), s = a;
        }).then(r);
        return l.cancel = function() {
          o.unsubscribe(s);
        }, l;
      }, t(function(s, l, a) {
        o.reason || (o.reason = new Oi(s, l, a), n(o.reason));
      });
    }
    throwIfRequested() {
      if (this.reason)
        throw this.reason;
    }
    subscribe(t) {
      if (this.reason) {
        t(this.reason);
        return;
      }
      this._listeners ? this._listeners.push(t) : this._listeners = [t];
    }
    unsubscribe(t) {
      if (!this._listeners)
        return;
      const n = this._listeners.indexOf(t);
      n !== -1 && this._listeners.splice(n, 1);
    }
    static source() {
      let t;
      return {
        token: new Av(function(r) {
          t = r;
        }),
        cancel: t
      };
    }
  }
  const Xoe = Av;
  function Joe(e) {
    return function(n) {
      return e.apply(null, n);
    };
  }
  function Zoe(e) {
    return Ve.isObject(e) && e.isAxiosError === !0;
  }
  const Dp = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(Dp).forEach(([e, t]) => {
    Dp[t] = e;
  });
  const Qoe = Dp;
  function L_(e) {
    const t = new xu(e), n = y_(xu.prototype.request, t);
    return Ve.extend(n, xu.prototype, t, { allOwnKeys: !0 }), Ve.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(r) {
      return L_(Bl(e, r));
    }, n;
  }
  const sn = L_(Iv);
  sn.Axios = xu;
  sn.CanceledError = Oi;
  sn.CancelToken = Xoe;
  sn.isCancel = A_;
  sn.VERSION = D_;
  sn.toFormData = cd;
  sn.AxiosError = Rt;
  sn.Cancel = sn.CanceledError;
  sn.all = function(t) {
    return Promise.all(t);
  };
  sn.spread = Joe;
  sn.isAxiosError = Zoe;
  sn.mergeConfig = Bl;
  sn.AxiosHeaders = rr;
  sn.formToJSON = (e) => P_(Ve.isHTMLForm(e) ? new FormData(e) : e);
  sn.getAdapter = x_.getAdapter;
  sn.HttpStatusCode = Qoe;
  sn.default = sn;
  const ere = sn, Ib = window.location.host, tre = Ib.startsWith("localhost") || Ib.startsWith("127.0.0.1:8080"), nre = tre ? "http://localhost:3000/api" : "/api", fd = ere.create({ baseURL: nre, timeout: 6e3 }), ore = async (e) => {
    try {
      return await fd.post("/wallet/setup", e);
    } catch (t) {
      throw t;
    }
  }, rre = async (e, t) => {
    try {
      return await fd.post(`/transact/${t}`, e);
    } catch (n) {
      throw n;
    }
  }, sre = async (e) => {
    try {
      return await fd.get(`/transactions?${e}`);
    } catch (t) {
      throw t;
    }
  }, lre = async (e) => {
    try {
      const t = await fd({
        url: `/transactions_export/${e}`,
        method: "GET",
        responseType: "arraybuffer"
      });
      if (t) {
        const n = window.URL.createObjectURL(new Blob([t], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" })), o = document.createElement("a");
        o.href = n, o.setAttribute("download", "transactions.xlsx"), document.body.appendChild(o), o.click(), o.remove();
      }
      return !0;
    } catch (t) {
      throw t;
    }
  }, _a = {
    setupWallet: ore,
    setupTransaction: rre,
    getTransaction: sre,
    exportTransaction: lre
  }, are = {
    name: "WalletSubmit",
    data() {
      return {
        walletForm: {
          name: "",
          balance: null
        },
        transactionForm: {
          amount: null,
          credit: !0,
          description: null
        },
        currentWallet: null
      };
    },
    created() {
      const e = JSON.parse(localStorage.getItem("wallet"));
      e.id && (this.currentWallet = e);
    },
    methods: {
      async onSumbit() {
        var n, o;
        const e = {
          balance: this.walletForm.balance ? this.walletForm.balance : 0,
          name: this.walletForm.name
        }, t = await _a.setupWallet(e);
        t.status === 200 && (this.$message({
          message: "Wallet created successfully",
          type: "success"
        }), (n = t == null ? void 0 : t.data) != null && n.data && (this.currentWallet = (o = t == null ? void 0 : t.data) == null ? void 0 : o.data, localStorage.setItem("wallet", JSON.stringify(this.currentWallet))), this.walletForm = {
          name: "",
          balance: null
        });
      },
      async onSumbitTransaction() {
        var n, o;
        const e = {
          amount: this.transactionForm.amount ? this.transactionForm.amount : null,
          description: this.transactionForm.description
        };
        this.transactionForm.credit || (e.amount = -e.amount);
        const t = await _a.setupTransaction(e, this.currentWallet.id);
        if (t.status === 200) {
          if (this.$message({
            message: "Transaction created successfully",
            type: "success"
          }), (n = t == null ? void 0 : t.data) != null && n.data) {
            const r = (o = t == null ? void 0 : t.data) == null ? void 0 : o.data.balance;
            this.currentWallet.balance = r, localStorage.setItem("wallet", JSON.stringify(this.currentWallet));
          }
          this.transactionForm = {
            amount: null,
            credit: !0,
            description: null
          };
        }
      },
      routeTransactions() {
        Bne().push({ name: "Transactions" });
      }
    }
  }, ire = { id: "app" }, ure = { key: 0 };
  function cre(e, t, n, o, r, s) {
    const l = Qe("el-input"), a = Qe("el-form-item"), u = Qe("el-form"), c = Qe("el-button"), f = Qe("el-switch"), d = Qe("router-link");
    return S(), V("div", null, [
      H("div", ire, [
        K(u, {
          ref: "walletForm",
          model: r.walletForm,
          "status-icon": "",
          rules: e.rules
        }, {
          default: X(() => [
            K(a, {
              label: "Wallet User Name",
              prop: "name"
            }, {
              default: X(() => [
                K(l, {
                  modelValue: r.walletForm.name,
                  "onUpdate:modelValue": t[0] || (t[0] = (p) => r.walletForm.name = p)
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }),
            K(a, {
              label: "Wallet balance",
              prop: "balance"
            }, {
              default: X(() => [
                K(l, {
                  modelValue: r.walletForm.balance,
                  "onUpdate:modelValue": t[1] || (t[1] = (p) => r.walletForm.balance = p)
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["model", "rules"]),
        K(c, { onClick: s.onSumbit }, {
          default: X(() => [
            wt(" Submit Wallet ")
          ]),
          _: 1
        }, 8, ["onClick"]),
        r.currentWallet && r.currentWallet.id ? (S(), V("div", ure, [
          H("p", null, " Current Wallet Name: " + Ne(r.currentWallet.name), 1),
          H("p", null, " Current Wallet Balance: " + Ne(r.currentWallet.balance), 1),
          K(f, {
            modelValue: r.transactionForm.credit,
            "onUpdate:modelValue": t[2] || (t[2] = (p) => r.transactionForm.credit = p),
            style: { "--el-switch-on-color": "#13ce66", "--el-switch-off-color": "#ff4949" },
            "active-text": "Credit",
            "inactive-text": "Debit"
          }, null, 8, ["modelValue"]),
          K(u, {
            ref: "transactionForm",
            model: r.walletForm,
            "status-icon": "",
            rules: e.rules
          }, {
            default: X(() => [
              K(a, {
                label: "Transaction Amount",
                prop: "name"
              }, {
                default: X(() => [
                  K(l, {
                    modelValue: r.transactionForm.amount,
                    "onUpdate:modelValue": t[3] || (t[3] = (p) => r.transactionForm.amount = p),
                    min: "0",
                    onkeypress: `return (event.charCode !=8 && event.charCode ==0 ||
            (event.charCode >= 48 && event.charCode <= 57))`
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              }),
              K(a, {
                label: "Transaction description",
                prop: "balance"
              }, {
                default: X(() => [
                  K(l, {
                    modelValue: r.transactionForm.description,
                    "onUpdate:modelValue": t[4] || (t[4] = (p) => r.transactionForm.description = p)
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["model", "rules"]),
          K(c, { onClick: s.onSumbitTransaction }, {
            default: X(() => [
              wt(" Submit Transaction ")
            ]),
            _: 1
          }, 8, ["onClick"]),
          H("div", null, [
            H("p", null, [
              K(d, { to: { name: "Transactions" } }, {
                default: X(() => [
                  wt(" View Transactions ")
                ]),
                _: 1
              })
            ])
          ])
        ])) : se("", !0)
      ])
    ]);
  }
  const Pb = /* @__PURE__ */ Mc(are, [["render", cre]]), dre = {
    name: "WalletTransactions",
    data() {
      return {
        currentWallet: null,
        transactionsData: [],
        limit: 10,
        page: 1
      };
    },
    computed: {
      totalTransactions() {
        var e, t;
        return (e = this.transactionsData) != null && e.length ? (t = this.transactionsData[0]) == null ? void 0 : t.totalCount : 0;
      }
    },
    async created() {
      var t, n;
      const e = JSON.parse(localStorage.getItem("wallet"));
      if (e.id) {
        this.currentWallet = e;
        const o = (this.page - 1) * this.limit, r = `walletId=${e.id}&skip=${o}&limit=${this.limit}`, s = await _a.getTransaction(r);
        (t = s == null ? void 0 : s.data) != null && t.data && (this.transactionsData = (n = s == null ? void 0 : s.data) == null ? void 0 : n.data);
      }
    },
    methods: {
      async setPage(e) {
        var t, n;
        if (this.currentWallet && e) {
          const o = (e - 1) * this.limit, r = `walletId=${this.currentWallet.id}&skip=${o}&limit=${this.limit}`, s = await _a.getTransaction(r);
          (t = s == null ? void 0 : s.data) != null && t.data && (this.transactionsData = (n = s == null ? void 0 : s.data) == null ? void 0 : n.data);
        }
      },
      async routeTransactions() {
        this.currentWallet && await _a.exportTransaction(this.currentWallet.id) && this.$message({
          message: "Export Transactions successfull",
          type: "success"
        });
      }
    }
  }, fre = /* @__PURE__ */ H("h2", null, "Transactions", -1), pre = { key: 0 };
  function hre(e, t, n, o, r, s) {
    const l = Qe("el-button"), a = Qe("el-table-column"), u = Qe("el-table"), c = Qe("el-pagination");
    return S(), V("div", null, [
      fre,
      r.currentWallet && r.currentWallet.id ? (S(), V("div", pre, [
        H("p", null, " Current Wallet Name: " + Ne(r.currentWallet.name), 1),
        H("p", null, " Current Wallet Balance: " + Ne(r.currentWallet.balance), 1),
        H("p", null, [
          K(l, {
            type: "info",
            onClick: s.routeTransactions
          }, {
            default: X(() => [
              wt(" Export Transactions ")
            ]),
            _: 1
          }, 8, ["onClick"])
        ])
      ])) : se("", !0),
      H("div", null, [
        K(u, {
          data: r.transactionsData,
          style: { width: "100%" }
        }, {
          default: X(() => [
            K(a, {
              prop: "date",
              label: "Date",
              sortable: "",
              width: "180"
            }),
            K(a, {
              prop: "type",
              label: "Type",
              width: "180"
            }),
            K(a, {
              prop: "description",
              label: "Description",
              width: "200"
            }),
            K(a, {
              prop: "amount",
              label: "Amount",
              sortable: "",
              width: "180"
            }),
            K(a, {
              prop: "balance",
              label: "Balance"
            })
          ]),
          _: 1
        }, 8, ["data"]),
        K(c, {
          layout: "prev, pager, next",
          total: s.totalTransactions,
          "page-size": r.limit,
          onCurrentChange: s.setPage
        }, null, 8, ["total", "page-size", "onCurrentChange"])
      ])
    ]);
  }
  const vre = /* @__PURE__ */ Mc(dre, [["render", hre]]), mre = [
    {
      path: "/",
      name: "Wallet",
      component: Pb,
      meta: {
        title: "Wallet"
      }
    },
    {
      path: "/wallet",
      name: "Wallet",
      component: Pb,
      meta: {
        title: "Wallet"
      }
    },
    {
      path: "/wallet/transactions",
      name: "Transactions",
      component: vre,
      meta: {
        title: "Transactions"
      }
    }
  ], gre = [...mre], yre = () => {
    const e = new Lne({
      history: Dte(),
      routes: gre,
      scrollBehavior() {
        return { x: 0, y: 0 };
      }
    });
    return e.beforeEach((t, n, o) => {
      t.path === "/" ? o({ name: "Wallet" }) : t.matched.length ? o() : o({ name: "Error", params: { type: "page-not-found" } });
    }), e;
  }, bre = r1(Y$);
  async function wre() {
    bre.use(dte).use(yre()).mount("#app");
  }
  wre();
});
export default Cre();
